
u-boot:     file format elf32-littlearm


Disassembly of section .text:

34800000 <__image_copy_start>:
#include <version.h>
#include <asm/system.h>
#include <linux/linkage.h>

.globl _start
_start: b	reset
34800000:	ea000014 	b	34800058 <reset>
	ldr	pc, _undefined_instruction
34800004:	e59ff014 	ldr	pc, [pc, #20]	; 34800020 <_undefined_instruction>
	ldr	pc, _software_interrupt
34800008:	e59ff014 	ldr	pc, [pc, #20]	; 34800024 <_software_interrupt>
	ldr	pc, _prefetch_abort
3480000c:	e59ff014 	ldr	pc, [pc, #20]	; 34800028 <_prefetch_abort>
	ldr	pc, _data_abort
34800010:	e59ff014 	ldr	pc, [pc, #20]	; 3480002c <_data_abort>
	ldr	pc, _not_used
34800014:	e59ff014 	ldr	pc, [pc, #20]	; 34800030 <_not_used>
	ldr	pc, _irq
34800018:	e59ff014 	ldr	pc, [pc, #20]	; 34800034 <_irq>
	ldr	pc, _fiq
3480001c:	e59ff014 	ldr	pc, [pc, #20]	; 34800038 <_fiq>

34800020 <_undefined_instruction>:
34800020:	34800220 	.word	0x34800220

34800024 <_software_interrupt>:
34800024:	34800280 	.word	0x34800280

34800028 <_prefetch_abort>:
34800028:	348002e0 	.word	0x348002e0

3480002c <_data_abort>:
3480002c:	34800340 	.word	0x34800340

34800030 <_not_used>:
34800030:	348003a0 	.word	0x348003a0

34800034 <_irq>:
34800034:	34800400 	.word	0x34800400

34800038 <_fiq>:
34800038:	34800460 	.word	0x34800460

3480003c <_pad>:
3480003c:	12345678 	.word	0x12345678

34800040 <_TEXT_BASE>:
34800040:	34800000 	.word	0x34800000

34800044 <_bss_start_ofs>:
34800044:	00029070 	.word	0x00029070

34800048 <_image_copy_end_ofs>:
34800048:	00029070 	.word	0x00029070

3480004c <_bss_end_ofs>:
3480004c:	0002e300 	.word	0x0002e300

34800050 <_end_ofs>:
34800050:	0002db20 	.word	0x0002db20

34800054 <IRQ_STACK_START_IN>:
34800054:	0badc0de 	.word	0x0badc0de

34800058 <reset>:
/*
 * the actual reset code
 */

reset:
	bl	save_boot_params
34800058:	eb00005c 	bl	348001d0 <save_boot_params>
	/*
	 * set the cpu to SVC32 mode
	 */
	mrs	r0, cpsr
3480005c:	e10f0000 	mrs	r0, CPSR
	bic	r0, r0, #0x1f
34800060:	e3c0001f 	bic	r0, r0, #31
	orr	r0, r0, #0xd3
34800064:	e38000d3 	orr	r0, r0, #211	; 0xd3
	msr	cpsr,r0
34800068:	e129f000 	msr	CPSR_fc, r0
 * (OMAP4 spl TEXT_BASE is not 32 byte aligned.
 * Continue to use ROM code vector only in OMAP4 spl)
 */
#if !(defined(CONFIG_OMAP44XX) && defined(CONFIG_SPL_BUILD))
	/* Set V=0 in CP15 SCTRL register - for VBAR to point to vector */
	mrc	p15, 0, r0, c1, c0, 0	@ Read CP15 SCTRL Register
3480006c:	ee110f10 	mrc	15, 0, r0, cr1, cr0, {0}
	bic	r0, #CR_V		@ V = 0
34800070:	e3c00a02 	bic	r0, r0, #8192	; 0x2000
	mcr	p15, 0, r0, c1, c0, 0	@ Write CP15 SCTRL Register
34800074:	ee010f10 	mcr	15, 0, r0, cr1, cr0, {0}

	/* Set vector address in CP15 VBAR register */
	ldr	r0, =_start
34800078:	e59f0458 	ldr	r0, [pc, #1112]	; 348004d8 <led1_on+0x14>
	mcr	p15, 0, r0, c12, c0, 0	@Set VBAR
3480007c:	ee0c0f10 	mcr	15, 0, r0, cr12, cr0, {0}
#endif

	bl gpio_out
34800080:	eb000108 	bl	348004a8 <gpio_out>
	bl led1_on
34800084:	eb00010e 	bl	348004c4 <led1_on>

	/* the mask ROM code should have PLL and others stable */
#ifndef CONFIG_SKIP_LOWLEVEL_INIT
	bl	cpu_init_cp15
34800088:	eb000051 	bl	348001d4 <cpu_init_cp15>
	bl	cpu_init_crit
3480008c:	eb00005e 	bl	3480020c <cpu_init_crit>

34800090 <call_board_init_f>:
#endif

/* Set stackpointer in internal RAM to call board_init_f */
call_board_init_f:
	ldr	sp, =(CONFIG_SYS_INIT_SP_ADDR)
34800090:	e3a0d423 	mov	sp, #587202560	; 0x23000000
	bic	sp, sp, #7 /* 8-byte alignment for ABI compliance */
34800094:	e3cdd007 	bic	sp, sp, #7
//	ldr	r0,=0x00000000
//	bl	board_init_f

	ldr r0, =_start
34800098:	e59f0438 	ldr	r0, [pc, #1080]	; 348004d8 <led1_on+0x14>
	ldr r1, _board_init_f_ofs
3480009c:	e59f1008 	ldr	r1, [pc, #8]	; 348000ac <_board_init_f_ofs>

	add lr, r0, r1
348000a0:	e080e001 	add	lr, r0, r1
	ldr	r0,=0x00000000
348000a4:	e3a00000 	mov	r0, #0
	mov pc, lr
348000a8:	e1a0f00e 	mov	pc, lr

348000ac <_board_init_f_ofs>:
348000ac:	00001b04 	.word	0x00001b04

348000b0 <relocate_code>:
 * This "function" does not return, instead it continues in RAM
 * after relocating the monitor code.
 *
 */
ENTRY(relocate_code)
	mov	r4, r0	/* save addr_sp */
348000b0:	e1a04000 	mov	r4, r0
	mov	r5, r1	/* save addr of gd */
348000b4:	e1a05001 	mov	r5, r1
	mov	r6, r2	/* save addr of destination  r6(addr(6)) */
348000b8:	e1a06002 	mov	r6, r2

348000bc <stack_setup>:

	/* Set up the stack						    */
stack_setup:
	mov	sp, r4
348000bc:	e1a0d004 	mov	sp, r4

	adr	r0, _start	/* 伪指令，将_start的运行时的地址放到r0  r0(1) */
348000c0:	e24f00c8 	sub	r0, pc, #200	; 0xc8
	cmp	r0, r6
348000c4:	e1500006 	cmp	r0, r6
	moveq	r9, #0		/* no relocation. relocation offset(r9) = 0 */
348000c8:	03a09000 	moveq	r9, #0
	beq	clear_bss		/* skip relocation */
348000cc:	0a000026 	beq	3480016c <clear_bss>
	mov	r1, r6			/* r1 <- scratch for copy_loop  r1(1) */
348000d0:	e1a01006 	mov	r1, r6
	ldr	r3, _image_copy_end_ofs /* r3 = _image_copy_end_ofs */
348000d4:	e51f3094 	ldr	r3, [pc, #-148]	; 34800048 <_image_copy_end_ofs>
	add	r2, r0, r3		/* r2 <- source end address	  r2(1)-copy  */
348000d8:	e0802003 	add	r2, r0, r3

348000dc <copy_loop>:

copy_loop:	/* uboot image部分 */
	ldmia	r0!, {r9-r10}		/* copy from source address [r0]    */
348000dc:	e8b00600 	ldm	r0!, {r9, sl}
	stmia	r1!, {r9-r10}		/* copy to   target address [r1]    */
348000e0:	e8a10600 	stmia	r1!, {r9, sl}
	cmp	r0, r2			/* until source end address [r2]  r0(1), r2(1)-copy */
348000e4:	e1500002 	cmp	r0, r2
	blo	copy_loop
348000e8:	3afffffb 	bcc	348000dc <copy_loop>

	/*
	 * fix .rel.dyn relocations
	 */
	ldr	r0, _TEXT_BASE		/* r0 <- Text base  r0(2) */
348000ec:	e51f00b4 	ldr	r0, [pc, #-180]	; 34800040 <_TEXT_BASE>
	sub	r9, r6, r0		/* r9 <- relocation offset  r9(1) */
348000f0:	e0469000 	sub	r9, r6, r0
	ldr	r10, _dynsym_start_ofs	/* r10 <- sym table ofs */
348000f4:	e59fa06c 	ldr	sl, [pc, #108]	; 34800168 <_dynsym_start_ofs>
	add	r10, r10, r0		/* r10 <- sym table in FLASH */
348000f8:	e08aa000 	add	sl, sl, r0
	ldr	r2, _rel_dyn_start_ofs	/* r2 <- rel dyn start ofs */
348000fc:	e59f205c 	ldr	r2, [pc, #92]	; 34800160 <_rel_dyn_start_ofs>
	add	r2, r2, r0		/* r2 <- rel dyn start in FLASH   r2(2)-fix */
34800100:	e0822000 	add	r2, r2, r0
	ldr	r3, _rel_dyn_end_ofs	/* r3 <- rel dyn end ofs */
34800104:	e59f3058 	ldr	r3, [pc, #88]	; 34800164 <_rel_dyn_end_ofs>
	add	r3, r3, r0		/* r3 <- rel dyn end in FLASH  r3(1) */
34800108:	e0833000 	add	r3, r3, r0

3480010c <fixloop>:
fixloop:
	ldr	r0, [r2]		/* r0 <- location to fix up, IN FLASH! 使用 arm-linux-readelf -r u-boot */
3480010c:	e5920000 	ldr	r0, [r2]
	add	r0, r0, r9		/* r0 <- location to fix up in RAM  r0(fix) offset */
34800110:	e0800009 	add	r0, r0, r9
	ldr	r1, [r2, #4]	/* info */
34800114:	e5921004 	ldr	r1, [r2, #4]
	and	r7, r1, #0xff
34800118:	e20170ff 	and	r7, r1, #255	; 0xff
	cmp	r7, #23			/* relative fixup? */
3480011c:	e3570017 	cmp	r7, #23
	beq	fixrel
34800120:	0a000007 	beq	34800144 <fixrel>
	cmp	r7, #2			/* absolute fixup? */
34800124:	e3570002 	cmp	r7, #2
	beq	fixabs
34800128:	0a000000 	beq	34800130 <fixabs>
	/* ignore unknown type of fixup */
	b	fixnext
3480012c:	ea000006 	b	3480014c <fixnext>

34800130 <fixabs>:
fixabs:
	/* absolute fix: set location to (offset) symbol value */
	mov	r1, r1, LSR #4		/* r1 <- symbol index in .dynsym */
34800130:	e1a01221 	lsr	r1, r1, #4
	add	r1, r10, r1		/* r1 <- address of symbol in table */
34800134:	e08a1001 	add	r1, sl, r1
	ldr	r1, [r1, #4]		/* r1 <- symbol value */
34800138:	e5911004 	ldr	r1, [r1, #4]
	add	r1, r1, r9		/* r1 <- relocated sym addr */
3480013c:	e0811009 	add	r1, r1, r9
	b	fixnext
34800140:	ea000001 	b	3480014c <fixnext>

34800144 <fixrel>:
fixrel:
	/* relative fix: increase location by offset */
	ldr	r1, [r0]	//r0的地址是0x34800020+r9, 取值赋给r1=0x34800220  objdump查看
34800144:	e5901000 	ldr	r1, [r0]
	add	r1, r1, r9
34800148:	e0811009 	add	r1, r1, r9

3480014c <fixnext>:
fixnext:
	str	r1, [r0]	//修改r0 0x34800020+r9 存的值。新的跳转地址
3480014c:	e5801000 	str	r1, [r0]
	add	r2, r2, #8		/* each rel.dyn entry is 8 bytes */
34800150:	e2822008 	add	r2, r2, #8
	cmp	r2, r3
34800154:	e1520003 	cmp	r2, r3
	blo	fixloop
34800158:	3affffeb 	bcc	3480010c <fixloop>
	b	clear_bss
3480015c:	ea000002 	b	3480016c <clear_bss>

34800160 <_rel_dyn_start_ofs>:
34800160:	00029070 	.word	0x00029070

34800164 <_rel_dyn_end_ofs>:
34800164:	0002da50 	.word	0x0002da50

34800168 <_dynsym_start_ofs>:
34800168:	0002da50 	.word	0x0002da50

3480016c <clear_bss>:
	.word __rel_dyn_end - _start
_dynsym_start_ofs:
	.word __dynsym_start - _start

clear_bss:
	ldr	r0, _bss_start_ofs
3480016c:	e51f0130 	ldr	r0, [pc, #-304]	; 34800044 <_bss_start_ofs>
	ldr	r1, _bss_end_ofs
34800170:	e51f112c 	ldr	r1, [pc, #-300]	; 3480004c <_bss_end_ofs>
	mov	r4, r6			/* reloc addr */
34800174:	e1a04006 	mov	r4, r6
	add	r0, r0, r4
34800178:	e0800004 	add	r0, r0, r4
	add	r1, r1, r4
3480017c:	e0811004 	add	r1, r1, r4
	mov	r2, #0x00000000		/* clear			    */
34800180:	e3a02000 	mov	r2, #0

34800184 <clbss_l>:

clbss_l:cmp	r0, r1			/* clear loop... */
34800184:	e1500001 	cmp	r0, r1
	bhs	clbss_e			/* if reached end of bss, exit */
34800188:	2a000002 	bcs	34800198 <clbss_e>
	str	r2, [r0]
3480018c:	e5802000 	str	r2, [r0]
	add	r0, r0, #4
34800190:	e2800004 	add	r0, r0, #4
	b	clbss_l
34800194:	eafffffa 	b	34800184 <clbss_l>

34800198 <clbss_e>:
jump_2_ram:
/*
 * If I-cache is enabled invalidate it
 */
#ifndef CONFIG_SYS_ICACHE_OFF
	mcr	p15, 0, r0, c7, c5, 0	@ invalidate icache
34800198:	ee070f15 	mcr	15, 0, r0, cr7, cr5, {0}
	mcr     p15, 0, r0, c7, c10, 4	@ DSB
3480019c:	ee070f9a 	mcr	15, 0, r0, cr7, cr10, {4}
	mcr     p15, 0, r0, c7, c5, 4	@ ISB
348001a0:	ee070f95 	mcr	15, 0, r0, cr7, cr5, {4}
/*
 * Move vector table
 */
#if !defined(CONFIG_TEGRA20)
	/* Set vector address in CP15 VBAR register */
	ldr     r0, =_start
348001a4:	e59f032c 	ldr	r0, [pc, #812]	; 348004d8 <led1_on+0x14>
	add     r0, r0, r9
348001a8:	e0800009 	add	r0, r0, r9
	mcr     p15, 0, r0, c12, c0, 0  @Set VBAR
348001ac:	ee0c0f10 	mcr	15, 0, r0, cr12, cr0, {0}
#endif /* !Tegra20 */

	ldr	r0, _board_init_r_ofs
348001b0:	e59f0014 	ldr	r0, [pc, #20]	; 348001cc <_board_init_r_ofs>
	adr	r1, _start
348001b4:	e24f1f6f 	sub	r1, pc, #444	; 0x1bc
	add	lr, r0, r1
348001b8:	e080e001 	add	lr, r0, r1
	add	lr, lr, r9
348001bc:	e08ee009 	add	lr, lr, r9
	/* setup parameters for board_init_r */
	mov	r0, r5		/* gd_t */
348001c0:	e1a00005 	mov	r0, r5
	mov	r1, r6		/* dest_addr */
348001c4:	e1a01006 	mov	r1, r6
	/* jump to it ... */
	mov	pc, lr
348001c8:	e1a0f00e 	mov	pc, lr

348001cc <_board_init_r_ofs>:
348001cc:	00001a40 	.word	0x00001a40

348001d0 <save_boot_params>:
 * Stack pointer is not yet initialized at this moment
 * Don't save anything to stack even if compiled with -O0
 *
 *************************************************************************/
ENTRY(save_boot_params)
	bx	lr			@ back to my caller
348001d0:	e12fff1e 	bx	lr

348001d4 <cpu_init_cp15>:
 *************************************************************************/
ENTRY(cpu_init_cp15)
	/*
	 * Invalidate L1 I/D
	 */
	mov	r0, #0			@ set up for MCR
348001d4:	e3a00000 	mov	r0, #0
	mcr	p15, 0, r0, c8, c7, 0	@ invalidate TLBs
348001d8:	ee080f17 	mcr	15, 0, r0, cr8, cr7, {0}
	mcr	p15, 0, r0, c7, c5, 0	@ invalidate icache
348001dc:	ee070f15 	mcr	15, 0, r0, cr7, cr5, {0}
	mcr	p15, 0, r0, c7, c5, 6	@ invalidate BP array
348001e0:	ee070fd5 	mcr	15, 0, r0, cr7, cr5, {6}
	mcr     p15, 0, r0, c7, c10, 4	@ DSB
348001e4:	ee070f9a 	mcr	15, 0, r0, cr7, cr10, {4}
	mcr     p15, 0, r0, c7, c5, 4	@ ISB
348001e8:	ee070f95 	mcr	15, 0, r0, cr7, cr5, {4}

	/*
	 * disable MMU stuff and caches
	 */
	mrc	p15, 0, r0, c1, c0, 0
348001ec:	ee110f10 	mrc	15, 0, r0, cr1, cr0, {0}
	bic	r0, r0, #0x00002000	@ clear bits 13 (--V-)
348001f0:	e3c00a02 	bic	r0, r0, #8192	; 0x2000
	bic	r0, r0, #0x00000007	@ clear bits 2:0 (-CAM)
348001f4:	e3c00007 	bic	r0, r0, #7
	orr	r0, r0, #0x00000002	@ set bit 1 (--A-) Align
348001f8:	e3800002 	orr	r0, r0, #2
	orr	r0, r0, #0x00000800	@ set bit 11 (Z---) BTB
348001fc:	e3800b02 	orr	r0, r0, #2048	; 0x800
#ifdef CONFIG_SYS_ICACHE_OFF
	bic	r0, r0, #0x00001000	@ clear bit 12 (I) I-cache
#else
	orr	r0, r0, #0x00001000	@ set bit 12 (I) I-cache
34800200:	e3800a01 	orr	r0, r0, #4096	; 0x1000
#endif
	mcr	p15, 0, r0, c1, c0, 0
34800204:	ee010f10 	mcr	15, 0, r0, cr1, cr0, {0}
	mov	pc, lr			@ back to my caller
34800208:	e1a0f00e 	mov	pc, lr

3480020c <cpu_init_crit>:
	 * Jump to board specific initialization...
	 * The Mask ROM will have already initialized
	 * basic memory. Go here to bump up clock rate and handle
	 * wake up conditions.
	 */
	b	lowlevel_init		@ go setup pll,mux,memory
3480020c:	ea0000bc 	b	34800504 <lowlevel_init>
34800210:	e320f000 	nop	{0}
34800214:	e320f000 	nop	{0}
34800218:	e320f000 	nop	{0}
3480021c:	e320f000 	nop	{0}

34800220 <undefined_instruction>:
/*
 * exception handlers
 */
	.align	5
undefined_instruction:
	get_bad_stack
34800220:	e51fd1d4 	ldr	sp, [pc, #-468]	; 34800054 <IRQ_STACK_START_IN>
34800224:	e58de000 	str	lr, [sp]
34800228:	e14fe000 	mrs	lr, SPSR
3480022c:	e58de004 	str	lr, [sp, #4]
34800230:	e3a0d013 	mov	sp, #19
34800234:	e169f00d 	msr	SPSR_fc, sp
34800238:	e1a0e00f 	mov	lr, pc
3480023c:	e1b0f00e 	movs	pc, lr
	bad_save_user_regs
34800240:	e24dd048 	sub	sp, sp, #72	; 0x48
34800244:	e88d1fff 	stm	sp, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
34800248:	e51f21fc 	ldr	r2, [pc, #-508]	; 34800054 <IRQ_STACK_START_IN>
3480024c:	e892000c 	ldm	r2, {r2, r3}
34800250:	e28d0048 	add	r0, sp, #72	; 0x48
34800254:	e28d5034 	add	r5, sp, #52	; 0x34
34800258:	e1a0100e 	mov	r1, lr
3480025c:	e885000f 	stm	r5, {r0, r1, r2, r3}
34800260:	e1a0000d 	mov	r0, sp
	bl	do_undefined_instruction
34800264:	eb00075c 	bl	34801fdc <do_undefined_instruction>
34800268:	e320f000 	nop	{0}
3480026c:	e320f000 	nop	{0}
34800270:	e320f000 	nop	{0}
34800274:	e320f000 	nop	{0}
34800278:	e320f000 	nop	{0}
3480027c:	e320f000 	nop	{0}

34800280 <software_interrupt>:

	.align	5
software_interrupt:
	get_bad_stack_swi
34800280:	e24dd004 	sub	sp, sp, #4
34800284:	e58d0000 	str	r0, [sp]
34800288:	e51f023c 	ldr	r0, [pc, #-572]	; 34800054 <IRQ_STACK_START_IN>
3480028c:	e580e000 	str	lr, [r0]
34800290:	e14f0000 	mrs	r0, SPSR
34800294:	e580e004 	str	lr, [r0, #4]
34800298:	e59d0000 	ldr	r0, [sp]
3480029c:	e28dd004 	add	sp, sp, #4
	bad_save_user_regs
348002a0:	e24dd048 	sub	sp, sp, #72	; 0x48
348002a4:	e88d1fff 	stm	sp, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
348002a8:	e51f225c 	ldr	r2, [pc, #-604]	; 34800054 <IRQ_STACK_START_IN>
348002ac:	e892000c 	ldm	r2, {r2, r3}
348002b0:	e28d0048 	add	r0, sp, #72	; 0x48
348002b4:	e28d5034 	add	r5, sp, #52	; 0x34
348002b8:	e1a0100e 	mov	r1, lr
348002bc:	e885000f 	stm	r5, {r0, r1, r2, r3}
348002c0:	e1a0000d 	mov	r0, sp
	bl	do_software_interrupt
348002c4:	eb00074d 	bl	34802000 <do_software_interrupt>
348002c8:	e320f000 	nop	{0}
348002cc:	e320f000 	nop	{0}
348002d0:	e320f000 	nop	{0}
348002d4:	e320f000 	nop	{0}
348002d8:	e320f000 	nop	{0}
348002dc:	e320f000 	nop	{0}

348002e0 <prefetch_abort>:

	.align	5
prefetch_abort:
	get_bad_stack
348002e0:	e51fd294 	ldr	sp, [pc, #-660]	; 34800054 <IRQ_STACK_START_IN>
348002e4:	e58de000 	str	lr, [sp]
348002e8:	e14fe000 	mrs	lr, SPSR
348002ec:	e58de004 	str	lr, [sp, #4]
348002f0:	e3a0d013 	mov	sp, #19
348002f4:	e169f00d 	msr	SPSR_fc, sp
348002f8:	e1a0e00f 	mov	lr, pc
348002fc:	e1b0f00e 	movs	pc, lr
	bad_save_user_regs
34800300:	e24dd048 	sub	sp, sp, #72	; 0x48
34800304:	e88d1fff 	stm	sp, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
34800308:	e51f22bc 	ldr	r2, [pc, #-700]	; 34800054 <IRQ_STACK_START_IN>
3480030c:	e892000c 	ldm	r2, {r2, r3}
34800310:	e28d0048 	add	r0, sp, #72	; 0x48
34800314:	e28d5034 	add	r5, sp, #52	; 0x34
34800318:	e1a0100e 	mov	r1, lr
3480031c:	e885000f 	stm	r5, {r0, r1, r2, r3}
34800320:	e1a0000d 	mov	r0, sp
	bl	do_prefetch_abort
34800324:	eb00073e 	bl	34802024 <do_prefetch_abort>
34800328:	e320f000 	nop	{0}
3480032c:	e320f000 	nop	{0}
34800330:	e320f000 	nop	{0}
34800334:	e320f000 	nop	{0}
34800338:	e320f000 	nop	{0}
3480033c:	e320f000 	nop	{0}

34800340 <data_abort>:

	.align	5
data_abort:
	get_bad_stack
34800340:	e51fd2f4 	ldr	sp, [pc, #-756]	; 34800054 <IRQ_STACK_START_IN>
34800344:	e58de000 	str	lr, [sp]
34800348:	e14fe000 	mrs	lr, SPSR
3480034c:	e58de004 	str	lr, [sp, #4]
34800350:	e3a0d013 	mov	sp, #19
34800354:	e169f00d 	msr	SPSR_fc, sp
34800358:	e1a0e00f 	mov	lr, pc
3480035c:	e1b0f00e 	movs	pc, lr
	bad_save_user_regs
34800360:	e24dd048 	sub	sp, sp, #72	; 0x48
34800364:	e88d1fff 	stm	sp, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
34800368:	e51f231c 	ldr	r2, [pc, #-796]	; 34800054 <IRQ_STACK_START_IN>
3480036c:	e892000c 	ldm	r2, {r2, r3}
34800370:	e28d0048 	add	r0, sp, #72	; 0x48
34800374:	e28d5034 	add	r5, sp, #52	; 0x34
34800378:	e1a0100e 	mov	r1, lr
3480037c:	e885000f 	stm	r5, {r0, r1, r2, r3}
34800380:	e1a0000d 	mov	r0, sp
	bl	do_data_abort
34800384:	eb00072f 	bl	34802048 <do_data_abort>
34800388:	e320f000 	nop	{0}
3480038c:	e320f000 	nop	{0}
34800390:	e320f000 	nop	{0}
34800394:	e320f000 	nop	{0}
34800398:	e320f000 	nop	{0}
3480039c:	e320f000 	nop	{0}

348003a0 <not_used>:

	.align	5
not_used:
	get_bad_stack
348003a0:	e51fd354 	ldr	sp, [pc, #-852]	; 34800054 <IRQ_STACK_START_IN>
348003a4:	e58de000 	str	lr, [sp]
348003a8:	e14fe000 	mrs	lr, SPSR
348003ac:	e58de004 	str	lr, [sp, #4]
348003b0:	e3a0d013 	mov	sp, #19
348003b4:	e169f00d 	msr	SPSR_fc, sp
348003b8:	e1a0e00f 	mov	lr, pc
348003bc:	e1b0f00e 	movs	pc, lr
	bad_save_user_regs
348003c0:	e24dd048 	sub	sp, sp, #72	; 0x48
348003c4:	e88d1fff 	stm	sp, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
348003c8:	e51f237c 	ldr	r2, [pc, #-892]	; 34800054 <IRQ_STACK_START_IN>
348003cc:	e892000c 	ldm	r2, {r2, r3}
348003d0:	e28d0048 	add	r0, sp, #72	; 0x48
348003d4:	e28d5034 	add	r5, sp, #52	; 0x34
348003d8:	e1a0100e 	mov	r1, lr
348003dc:	e885000f 	stm	r5, {r0, r1, r2, r3}
348003e0:	e1a0000d 	mov	r0, sp
	bl	do_not_used
348003e4:	eb000720 	bl	3480206c <do_not_used>
348003e8:	e320f000 	nop	{0}
348003ec:	e320f000 	nop	{0}
348003f0:	e320f000 	nop	{0}
348003f4:	e320f000 	nop	{0}
348003f8:	e320f000 	nop	{0}
348003fc:	e320f000 	nop	{0}

34800400 <irq>:

#else

	.align	5
irq:
	get_bad_stack
34800400:	e51fd3b4 	ldr	sp, [pc, #-948]	; 34800054 <IRQ_STACK_START_IN>
34800404:	e58de000 	str	lr, [sp]
34800408:	e14fe000 	mrs	lr, SPSR
3480040c:	e58de004 	str	lr, [sp, #4]
34800410:	e3a0d013 	mov	sp, #19
34800414:	e169f00d 	msr	SPSR_fc, sp
34800418:	e1a0e00f 	mov	lr, pc
3480041c:	e1b0f00e 	movs	pc, lr
	bad_save_user_regs
34800420:	e24dd048 	sub	sp, sp, #72	; 0x48
34800424:	e88d1fff 	stm	sp, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
34800428:	e51f23dc 	ldr	r2, [pc, #-988]	; 34800054 <IRQ_STACK_START_IN>
3480042c:	e892000c 	ldm	r2, {r2, r3}
34800430:	e28d0048 	add	r0, sp, #72	; 0x48
34800434:	e28d5034 	add	r5, sp, #52	; 0x34
34800438:	e1a0100e 	mov	r1, lr
3480043c:	e885000f 	stm	r5, {r0, r1, r2, r3}
34800440:	e1a0000d 	mov	r0, sp
	bl	do_irq
34800444:	eb00071a 	bl	348020b4 <do_irq>
34800448:	e320f000 	nop	{0}
3480044c:	e320f000 	nop	{0}
34800450:	e320f000 	nop	{0}
34800454:	e320f000 	nop	{0}
34800458:	e320f000 	nop	{0}
3480045c:	e320f000 	nop	{0}

34800460 <fiq>:

	.align	5
fiq:
	get_bad_stack
34800460:	e51fd414 	ldr	sp, [pc, #-1044]	; 34800054 <IRQ_STACK_START_IN>
34800464:	e58de000 	str	lr, [sp]
34800468:	e14fe000 	mrs	lr, SPSR
3480046c:	e58de004 	str	lr, [sp, #4]
34800470:	e3a0d013 	mov	sp, #19
34800474:	e169f00d 	msr	SPSR_fc, sp
34800478:	e1a0e00f 	mov	lr, pc
3480047c:	e1b0f00e 	movs	pc, lr
	bad_save_user_regs
34800480:	e24dd048 	sub	sp, sp, #72	; 0x48
34800484:	e88d1fff 	stm	sp, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
34800488:	e51f243c 	ldr	r2, [pc, #-1084]	; 34800054 <IRQ_STACK_START_IN>
3480048c:	e892000c 	ldm	r2, {r2, r3}
34800490:	e28d0048 	add	r0, sp, #72	; 0x48
34800494:	e28d5034 	add	r5, sp, #52	; 0x34
34800498:	e1a0100e 	mov	r1, lr
3480049c:	e885000f 	stm	r5, {r0, r1, r2, r3}
348004a0:	e1a0000d 	mov	r0, sp
	bl	do_fiq
348004a4:	eb0006f9 	bl	34802090 <do_fiq>

348004a8 <gpio_out>:

#endif /* CONFIG_USE_IRQ */
#endif /* CONFIG_SPL_BUILD */

gpio_out:
        ldr r11, =0xE0200280
348004a8:	e59fb02c 	ldr	fp, [pc, #44]	; 348004dc <led1_on+0x18>
        ldr r12, =0x1111
348004ac:	e59fc02c 	ldr	ip, [pc, #44]	; 348004e0 <led1_on+0x1c>
        str r12, [r11]
348004b0:	e58bc000 	str	ip, [fp]

        ldr r11, =0xE0200284
348004b4:	e59fb028 	ldr	fp, [pc, #40]	; 348004e4 <led1_on+0x20>
        ldr r12, =0xF
348004b8:	e3a0c00f 	mov	ip, #15
        str r12, [r11]
348004bc:	e58bc000 	str	ip, [fp]
        mov pc, lr
348004c0:	e1a0f00e 	mov	pc, lr

348004c4 <led1_on>:


.global led1_on
led1_on:
        ldr r11, =0xE0200284
348004c4:	e59fb018 	ldr	fp, [pc, #24]	; 348004e4 <led1_on+0x20>
        ldr r12, [r11]
348004c8:	e59bc000 	ldr	ip, [fp]
        bic r12, r12, #1
348004cc:	e3ccc001 	bic	ip, ip, #1
        str r12, [r11]
348004d0:	e58bc000 	str	ip, [fp]

348004d4:	e1a0f00e 	mov	pc, lr
348004d8:	34800000 	.word	0x34800000
348004dc:	e0200280 	.word	0xe0200280
348004e0:	00001111 	.word	0x00001111
348004e4:	e0200284 	.word	0xe0200284
348004e8:	e320f000 	nop	{0}
348004ec:	e320f000 	nop	{0}
348004f0:	e320f000 	nop	{0}
348004f4:	e320f000 	nop	{0}
348004f8:	e320f000 	nop	{0}
348004fc:	e320f000 	nop	{0}

34800500 <_TEXT_BASE>:
34800500:	34800000 	.word	0x34800000

34800504 <lowlevel_init>:
_TEXT_BASE:
	.word	CONFIG_SYS_TEXT_BASE

	.globl lowlevel_init
lowlevel_init:
	mov	r11, lr
34800504:	e1a0b00e 	mov	fp, lr

	/* set srom_bw */
	ldr r0, =0xE8000000
34800508:	e3a0033a 	mov	r0, #-402653184	; 0xe8000000
	ldr r1, =0x30
3480050c:	e3a01030 	mov	r1, #48	; 0x30
	str r1,[r0]
34800510:	e5801000 	str	r1, [r0]

	/* r5 has always zero */
	mov	r5, #0
34800514:	e3a05000 	mov	r5, #0

	ldr	r7, =S5PC100_GPIO_BASE
34800518:	e59f752c 	ldr	r7, [pc, #1324]	; 34800a4c <ddrmem_init+0x130>
	ldr	r8, =S5PC100_GPIO_BASE
3480051c:	e59f8528 	ldr	r8, [pc, #1320]	; 34800a4c <ddrmem_init+0x130>
	/* Read CPU ID */
	ldr	r2, =S5PC110_PRO_ID
34800520:	e3a0220e 	mov	r2, #-536870912	; 0xe0000000
	ldr	r0, [r2]
34800524:	e5920000 	ldr	r0, [r2]
	mov	r1, #0x00010000
34800528:	e3a01801 	mov	r1, #65536	; 0x10000
	and	r0, r0, r1
3480052c:	e0000001 	and	r0, r0, r1
	cmp	r0, r5
34800530:	e1500005 	cmp	r0, r5
	beq	100f
34800534:	0a000000 	beq	3480053c <lowlevel_init+0x38>
	ldr	r8, =S5PC110_GPIO_BASE
34800538:	e59f8510 	ldr	r8, [pc, #1296]	; 34800a50 <ddrmem_init+0x134>
100:
	/* Turn on KEY_LED_ON [GPJ4(1)] XMSMWEN */
	cmp	r7, r8
3480053c:	e1570008 	cmp	r7, r8
	beq	skip_check_didle			@ Support C110 only
34800540:	0a000005 	beq	3480055c <skip_check_didle>

	ldr	r0, =S5PC110_RST_STAT
34800544:	e59f0508 	ldr	r0, [pc, #1288]	; 34800a54 <ddrmem_init+0x138>
	ldr	r1, [r0]
34800548:	e5901000 	ldr	r1, [r0]
	and	r1, r1, #0x000D0000
3480054c:	e201180d 	and	r1, r1, #851968	; 0xd0000
	cmp	r1, #(0x1 << 19)			@ DEEPIDLE_WAKEUP
34800550:	e3510702 	cmp	r1, #524288	; 0x80000
	beq	didle_wakeup
34800554:	0a00006f 	beq	34800718 <didle_wakeup>
	cmp	r7, r8
34800558:	e1570008 	cmp	r7, r8

3480055c <skip_check_didle>:

skip_check_didle:
	addeq	r0, r8, #0x280				@ S5PC100_GPIO_J4
3480055c:	02880d0a 	addeq	r0, r8, #640	; 0x280
	addne	r0, r8, #0x2C0				@ S5PC110_GPIO_J4
34800560:	12880d0b 	addne	r0, r8, #704	; 0x2c0
	ldr	r1, [r0, #0x0]				@ GPIO_CON_OFFSET
34800564:	e5901000 	ldr	r1, [r0]
	bic	r1, r1, #(0xf << 4)			@ 1 * 4-bit
34800568:	e3c110f0 	bic	r1, r1, #240	; 0xf0
	orr	r1, r1, #(0x1 << 4)
3480056c:	e3811010 	orr	r1, r1, #16
	str	r1, [r0, #0x0]				@ GPIO_CON_OFFSET
34800570:	e5801000 	str	r1, [r0]

	ldr	r1, [r0, #0x4]				@ GPIO_DAT_OFFSET
34800574:	e5901004 	ldr	r1, [r0, #4]
	bic	r1, r1, #(1 << 1)
34800578:	e3c11002 	bic	r1, r1, #2
	str	r1, [r0, #0x4]				@ GPIO_DAT_OFFSET
3480057c:	e5801004 	str	r1, [r0, #4]

	/* Don't setup at s5pc100 */
	beq	100f
34800580:	0a00002e 	beq	34800640 <skip_check_didle+0xe4>
	 *	0xF1D0_0000
	 *	0xF1E0_0000
	 *	0xF1F0_0000
	 *	0xFAF0_0000
	 */
	ldr     r0, =0xe0f00000
34800584:	e59f04cc 	ldr	r0, [pc, #1228]	; 34800a58 <ddrmem_init+0x13c>
	ldr     r1, [r0]
34800588:	e5901000 	ldr	r1, [r0]
	bic     r1, r1, #0x1
3480058c:	e3c11001 	bic	r1, r1, #1
	str     r1, [r0]
34800590:	e5801000 	str	r1, [r0]

	ldr     r0, =0xe1f00000
34800594:	e59f04c0 	ldr	r0, [pc, #1216]	; 34800a5c <ddrmem_init+0x140>
	ldr     r1, [r0]
34800598:	e5901000 	ldr	r1, [r0]
	bic     r1, r1, #0x1
3480059c:	e3c11001 	bic	r1, r1, #1
	str     r1, [r0]
348005a0:	e5801000 	str	r1, [r0]

	ldr     r0, =0xf1800000
348005a4:	e59f04b4 	ldr	r0, [pc, #1204]	; 34800a60 <ddrmem_init+0x144>
	ldr     r1, [r0]
348005a8:	e5901000 	ldr	r1, [r0]
	bic     r1, r1, #0x1
348005ac:	e3c11001 	bic	r1, r1, #1
	str     r1, [r0]
348005b0:	e5801000 	str	r1, [r0]

	ldr     r0, =0xf1900000
348005b4:	e59f04a8 	ldr	r0, [pc, #1192]	; 34800a64 <ddrmem_init+0x148>
	ldr     r1, [r0]
348005b8:	e5901000 	ldr	r1, [r0]
	bic     r1, r1, #0x1
348005bc:	e3c11001 	bic	r1, r1, #1
	str     r1, [r0]
348005c0:	e5801000 	str	r1, [r0]

	ldr     r0, =0xf1a00000
348005c4:	e59f049c 	ldr	r0, [pc, #1180]	; 34800a68 <ddrmem_init+0x14c>
	ldr     r1, [r0]
348005c8:	e5901000 	ldr	r1, [r0]
	bic     r1, r1, #0x1
348005cc:	e3c11001 	bic	r1, r1, #1
	str     r1, [r0]
348005d0:	e5801000 	str	r1, [r0]

	ldr     r0, =0xf1b00000
348005d4:	e59f0490 	ldr	r0, [pc, #1168]	; 34800a6c <ddrmem_init+0x150>
	ldr     r1, [r0]
348005d8:	e5901000 	ldr	r1, [r0]
	bic     r1, r1, #0x1
348005dc:	e3c11001 	bic	r1, r1, #1
	str     r1, [r0]
348005e0:	e5801000 	str	r1, [r0]

	ldr     r0, =0xf1c00000
348005e4:	e59f0484 	ldr	r0, [pc, #1156]	; 34800a70 <ddrmem_init+0x154>
	ldr     r1, [r0]
348005e8:	e5901000 	ldr	r1, [r0]
	bic     r1, r1, #0x1
348005ec:	e3c11001 	bic	r1, r1, #1
	str     r1, [r0]
348005f0:	e5801000 	str	r1, [r0]

	ldr     r0, =0xf1d00000
348005f4:	e59f0478 	ldr	r0, [pc, #1144]	; 34800a74 <ddrmem_init+0x158>
	ldr     r1, [r0]
348005f8:	e5901000 	ldr	r1, [r0]
	bic     r1, r1, #0x1
348005fc:	e3c11001 	bic	r1, r1, #1
	str     r1, [r0]
34800600:	e5801000 	str	r1, [r0]

	ldr     r0, =0xf1e00000
34800604:	e59f046c 	ldr	r0, [pc, #1132]	; 34800a78 <ddrmem_init+0x15c>
	ldr     r1, [r0]
34800608:	e5901000 	ldr	r1, [r0]
	bic     r1, r1, #0x1
3480060c:	e3c11001 	bic	r1, r1, #1
	str     r1, [r0]
34800610:	e5801000 	str	r1, [r0]

	ldr     r0, =0xf1f00000
34800614:	e59f0460 	ldr	r0, [pc, #1120]	; 34800a7c <ddrmem_init+0x160>
	ldr     r1, [r0]
34800618:	e5901000 	ldr	r1, [r0]
	bic     r1, r1, #0x1
3480061c:	e3c11001 	bic	r1, r1, #1
	str     r1, [r0]
34800620:	e5801000 	str	r1, [r0]

	ldr     r0, =0xfaf00000
34800624:	e59f0454 	ldr	r0, [pc, #1108]	; 34800a80 <ddrmem_init+0x164>
	ldr     r1, [r0]
34800628:	e5901000 	ldr	r1, [r0]
	bic     r1, r1, #0x1
3480062c:	e3c11001 	bic	r1, r1, #1
	str     r1, [r0]
34800630:	e5801000 	str	r1, [r0]

	/*
	 * Diable ABB block to reduce sleep current at low temperature
	 * Note that it's hidden register setup don't modify it
	 */
	ldr	r0, =0xE010C300
34800634:	e59f0448 	ldr	r0, [pc, #1096]	; 34800a84 <ddrmem_init+0x168>
	ldr	r1, =0x00800000
34800638:	e3a01502 	mov	r1, #8388608	; 0x800000
	str	r1, [r0]
3480063c:	e5801000 	str	r1, [r0]

100:
	/* IO retension release */
	ldreq	r0, =S5PC100_OTHERS			@ 0xE0108200
34800640:	059f0440 	ldreq	r0, [pc, #1088]	; 34800a88 <ddrmem_init+0x16c>
	ldrne	r0, =S5PC110_OTHERS			@ 0xE010E000
34800644:	159f0440 	ldrne	r0, [pc, #1088]	; 34800a8c <ddrmem_init+0x170>
	ldr	r1, [r0]
34800648:	e5901000 	ldr	r1, [r0]
	ldreq	r2, =(1 << 31)				@ IO_RET_REL
3480064c:	03a02102 	moveq	r2, #-2147483648	; 0x80000000
	ldrne	r2, =((1 << 31) | (1 << 30) | (1 << 29) | (1 << 28))
34800650:	13a0220f 	movne	r2, #-268435456	; 0xf0000000
	orr	r1, r1, r2
34800654:	e1811002 	orr	r1, r1, r2
	/* Do not release retention here for S5PC110 */
	streq	r1, [r0]
34800658:	05801000 	streq	r1, [r0]

	/* Disable Watchdog */
	ldreq	r0, =S5PC100_WATCHDOG_BASE		@ 0xEA200000
3480065c:	059f042c 	ldreq	r0, [pc, #1068]	; 34800a90 <ddrmem_init+0x174>
	ldrne	r0, =S5PC110_WATCHDOG_BASE		@ 0xE2700000
34800660:	159f042c 	ldrne	r0, [pc, #1068]	; 34800a94 <ddrmem_init+0x178>
	str	r5, [r0]
34800664:	e5805000 	str	r5, [r0]

	/* setting SRAM */
	ldreq	r0, =S5PC100_SROMC_BASE
34800668:	03a004e7 	moveq	r0, #-419430400	; 0xe7000000
	ldrne	r0, =S5PC110_SROMC_BASE
3480066c:	13a0033a 	movne	r0, #-402653184	; 0xe8000000
	ldr	r1, =0x9
34800670:	e3a01009 	mov	r1, #9
	str	r1, [r0]
34800674:	e5801000 	str	r1, [r0]

	/* S5PC100 has 3 groups of interrupt sources */
	ldreq	r0, =S5PC100_VIC0_BASE			@ 0xE4000000
34800678:	03a00339 	moveq	r0, #-469762048	; 0xe4000000
	ldrne	r0, =S5PC110_VIC0_BASE			@ 0xF2000000
3480067c:	13a004f2 	movne	r0, #-234881024	; 0xf2000000
	add	r1, r0, #0x00100000
34800680:	e2801601 	add	r1, r0, #1048576	; 0x100000
	add	r2, r0, #0x00200000
34800684:	e2802602 	add	r2, r0, #2097152	; 0x200000

	/* Disable all interrupts (VIC0, VIC1 and VIC2) */
	mvn	r3, #0x0
34800688:	e3e03000 	mvn	r3, #0
	str	r3, [r0, #0x14]				@ INTENCLEAR
3480068c:	e5803014 	str	r3, [r0, #20]
	str	r3, [r1, #0x14]				@ INTENCLEAR
34800690:	e5813014 	str	r3, [r1, #20]
	str	r3, [r2, #0x14]				@ INTENCLEAR
34800694:	e5823014 	str	r3, [r2, #20]

	/* Set all interrupts as IRQ */
	str	r5, [r0, #0xc]				@ INTSELECT
34800698:	e580500c 	str	r5, [r0, #12]
	str	r5, [r1, #0xc]				@ INTSELECT
3480069c:	e581500c 	str	r5, [r1, #12]
	str	r5, [r2, #0xc]				@ INTSELECT
348006a0:	e582500c 	str	r5, [r2, #12]

	/* Pending Interrupt Clear */
	str	r5, [r0, #0xf00]			@ INTADDRESS
348006a4:	e5805f00 	str	r5, [r0, #3840]	; 0xf00
	str	r5, [r1, #0xf00]			@ INTADDRESS
348006a8:	e5815f00 	str	r5, [r1, #3840]	; 0xf00
	str	r5, [r2, #0xf00]			@ INTADDRESS
348006ac:	e5825f00 	str	r5, [r2, #3840]	; 0xf00
	
	bl  system_clock_init 
348006b0:	eb000027 	bl	34800754 <system_clock_init>
	
	/* for UART */
	bl	uart_asm_init
348006b4:	eb000042 	bl	348007c4 <uart_asm_init>

	/* display the value of 0xE00000000 */
	ldr r0, =0xE0000000
348006b8:	e3a0020e 	mov	r0, #-536870912	; 0xe0000000
	bl display_addr_dat
348006bc:	eb000081 	bl	348008c8 <display_addr_dat>

	/* for DDR */
	bl ddrmem_init
348006c0:	eb000095 	bl	3480091c <ddrmem_init>

	ldr r0, =0x30000000
348006c4:	e3a00203 	mov	r0, #805306368	; 0x30000000
	ldr r1, =0x12345678
348006c8:	e59f13c8 	ldr	r1, [pc, #968]	; 34800a98 <ddrmem_init+0x17c>
	str r1, [r0]
348006cc:	e5801000 	str	r1, [r0]
	bl display_addr_dat
348006d0:	eb00007c 	bl	348008c8 <display_addr_dat>

	bl	internal_ram_init
348006d4:	eb000035 	bl	348007b0 <internal_ram_init>

	/* for copy_code_to_ddr */
	bl copy_code_to_dram
348006d8:	eb00019f 	bl	34800d5c <copy_code_to_dram>
	ldr r0, =0x34800000
348006dc:	e3a005d2 	mov	r0, #880803840	; 0x34800000
	bl display_addr_dat
348006e0:	eb000078 	bl	348008c8 <display_addr_dat>

	cmp	r7, r8
348006e4:	e1570008 	cmp	r7, r8
	/* Clear wakeup status register */
	ldreq	r0, =S5PC100_WAKEUP_STAT
348006e8:	059f03ac 	ldreq	r0, [pc, #940]	; 34800a9c <ddrmem_init+0x180>
	ldrne	r0, =S5PC110_WAKEUP_STAT
348006ec:	159f03ac 	ldrne	r0, [pc, #940]	; 34800aa0 <ddrmem_init+0x184>
	ldr	r1, [r0]
348006f0:	e5901000 	ldr	r1, [r0]
	str	r1, [r0]
348006f4:	e5801000 	str	r1, [r0]

	/* IO retension release */
	ldreq	r0, =S5PC100_OTHERS			@ 0xE0108200
348006f8:	059f0388 	ldreq	r0, [pc, #904]	; 34800a88 <ddrmem_init+0x16c>
	ldrne	r0, =S5PC110_OTHERS			@ 0xE010E000
348006fc:	159f0388 	ldrne	r0, [pc, #904]	; 34800a8c <ddrmem_init+0x170>
	ldr	r1, [r0]
34800700:	e5901000 	ldr	r1, [r0]
	ldreq	r2, =(1 << 31)				@ IO_RET_REL
34800704:	03a02102 	moveq	r2, #-2147483648	; 0x80000000
	ldrne	r2, =((1 << 31) | (1 << 30) | (1 << 29) | (1 << 28))
34800708:	13a0220f 	movne	r2, #-268435456	; 0xf0000000
	orr	r1, r1, r2
3480070c:	e1811002 	orr	r1, r1, r2
	str	r1, [r0]
34800710:	e5801000 	str	r1, [r0]

	b	1f
34800714:	ea00000c 	b	3480074c <lockloop+0x30>

34800718 <didle_wakeup>:

didle_wakeup:
	/* Wait when APLL is locked */
	ldr	r0, =0xE0100100			@ S5PC110_APLL_CON
34800718:	e59f0384 	ldr	r0, [pc, #900]	; 34800aa4 <ddrmem_init+0x188>

3480071c <lockloop>:
lockloop:
	ldr	r1, [r0]
3480071c:	e5901000 	ldr	r1, [r0]
	and	r1, r1, #(1 << 29)
34800720:	e2011202 	and	r1, r1, #536870912	; 0x20000000
	cmp	r1, #(1 << 29)
34800724:	e3510202 	cmp	r1, #536870912	; 0x20000000
	bne	lockloop
34800728:	1afffffb 	bne	3480071c <lockloop>

	ldr	r0, =S5PC110_INFORM0
3480072c:	e59f0374 	ldr	r0, [pc, #884]	; 34800aa8 <ddrmem_init+0x18c>
	ldr	r1, [r0]
34800730:	e5901000 	ldr	r1, [r0]
	mov	pc, r1
34800734:	e1a0f001 	mov	pc, r1
	nop
34800738:	e320f000 	nop	{0}
	nop
3480073c:	e320f000 	nop	{0}
	nop
34800740:	e320f000 	nop	{0}
	nop
34800744:	e320f000 	nop	{0}
	nop
34800748:	e320f000 	nop	{0}

1:
	mov	lr, r11
3480074c:	e1a0e00b 	mov	lr, fp
	mov	pc, lr
34800750:	e1a0f00e 	mov	pc, lr

34800754 <system_clock_init>:
/*
 * system_clock_init: Initialize core clock and bus clock.
 * void system_clock_init(void)
 */
 system_clock_init:
        ldr     r0, =S5PC110_CLOCK_BASE         @ 0xE0100000
34800754:	e59f0350 	ldr	r0, [pc, #848]	; 34800aac <ddrmem_init+0x190>
 
        /* Set Clock divider */
        ldr     r1, =0x14131440                 @
34800758:	e59f1350 	ldr	r1, [pc, #848]	; 34800ab0 <ddrmem_init+0x194>
        str     r1, [r0, #0x300]
3480075c:	e5801300 	str	r1, [r0, #768]	; 0x300
 
        /* Set Lock Time */
        ldr     r1, =0x2D0                      @ Locktime : 30us
34800760:	e3a01e2d 	mov	r1, #720	; 0x2d0
        str     r1, [r0, #0x000]                @ S5PC110_APLL_LOCK
34800764:	e5801000 	str	r1, [r0]
        ldr     r1, =0xBB0                      @ Locktime : 0xBB8 = 3000
34800768:	e3a01ebb 	mov	r1, #2992	; 0xbb0
        str     r1, [r0, #0x008]                @ S5PC110_MPLL_LOCK
3480076c:	e5801008 	str	r1, [r0, #8]
        str     r1, [r0, #0x010]                @ S5PC110_EPLL_LOCK
34800770:	e5801010 	str	r1, [r0, #16]
        str     r1, [r0, #0x020]                @ S5PC110_VPLL_LOCK
34800774:	e5801020 	str	r1, [r0, #32]
 
        /* S5PC110_APLL_CON */
        ldr     r1, =0x807D0301                 @ 800MHz
34800778:	e59f1334 	ldr	r1, [pc, #820]	; 34800ab4 <ddrmem_init+0x198>
        str     r1, [r0, #0x100]
3480077c:	e5801100 	str	r1, [r0, #256]	; 0x100
        /* S5PC110_MPLL_CON */
        ldr     r1, =0x829B0C01                 @ 667MHz
34800780:	e59f1330 	ldr	r1, [pc, #816]	; 34800ab8 <ddrmem_init+0x19c>
        str     r1, [r0, #0x108]
34800784:	e5801108 	str	r1, [r0, #264]	; 0x108
        /* S5PC110_EPLL_CON */
        ldr     r1, =0x80600602                 @  96MHz VSEL 0 P 6 M 96 S 2
34800788:	e59f132c 	ldr	r1, [pc, #812]	; 34800abc <ddrmem_init+0x1a0>
        str     r1, [r0, #0x110]
3480078c:	e5801110 	str	r1, [r0, #272]	; 0x110
        /* S5PC110_VPLL_CON */
        ldr     r1, =0x806C0603                 @  54MHz
34800790:	e59f1328 	ldr	r1, [pc, #808]	; 34800ac0 <ddrmem_init+0x1a4>
        str     r1, [r0, #0x120]
34800794:	e5801120 	str	r1, [r0, #288]	; 0x120
 
        /* Set Source Clock */
        ldr     r1, =0x10001111                 @ A, M, E, VPLL Muxing
34800798:	e59f1324 	ldr	r1, [pc, #804]	; 34800ac4 <ddrmem_init+0x1a8>
        str     r1, [r0, #0x200]                @ S5PC1XX_CLK_SRC0
3480079c:	e5801200 	str	r1, [r0, #512]	; 0x200
 
        /* wait at least 200us to stablize all clock */
        mov     r2, #0x10000
348007a0:	e3a02801 	mov	r2, #65536	; 0x10000
1:      subs    r2, r2, #1
348007a4:	e2522001 	subs	r2, r2, #1
        bne     1b
348007a8:	1afffffd 	bne	348007a4 <system_clock_init+0x50>
 
        mov     pc, lr
348007ac:	e1a0f00e 	mov	pc, lr

348007b0 <internal_ram_init>:

internal_ram_init:
	ldreq	r0, =0xE3800000
348007b0:	059f0310 	ldreq	r0, [pc, #784]	; 34800ac8 <ddrmem_init+0x1ac>
	ldrne	r0, =0xF1500000
348007b4:	159f0310 	ldrne	r0, [pc, #784]	; 34800acc <ddrmem_init+0x1b0>
	ldr	r1, =0x0
348007b8:	e3a01000 	mov	r1, #0
	str	r1, [r0]
348007bc:	e5801000 	str	r1, [r0]

	mov	pc, lr
348007c0:	e1a0f00e 	mov	pc, lr

348007c4 <uart_asm_init>:
/*
 * uart_asm_init: Initialize UART's pins
 */
uart_asm_init:
	/* set GPIO to enable UART0-UART4 */
	mov	r0, r8
348007c4:	e1a00008 	mov	r0, r8
	ldr	r1, =0x22222222
348007c8:	e59f1300 	ldr	r1, [pc, #768]	; 34800ad0 <ddrmem_init+0x1b4>
	str	r1, [r0, #0x0]			@ S5PC100_GPIO_A0_OFFSET
348007cc:	e5801000 	str	r1, [r0]
	ldr	r1, =0x00002222
348007d0:	e59f12fc 	ldr	r1, [pc, #764]	; 34800ad4 <ddrmem_init+0x1b8>
	str	r1, [r0, #0x20]			@ S5PC100_GPIO_A1_OFFSET
348007d4:	e5801020 	str	r1, [r0, #32]

	/* Check S5PC100 */
	cmp	r7, r8
348007d8:	e1570008 	cmp	r7, r8
	bne	110f
348007dc:	1a00000c 	bne	34800814 <uart_asm_init+0x50>

	/* UART_SEL GPK0[5] at S5PC100 */
	add	r0, r8, #0x2A0			@ S5PC100_GPIO_K0_OFFSET
348007e0:	e2880e2a 	add	r0, r8, #672	; 0x2a0
	ldr	r1, [r0, #0x0]			@ S5PC1XX_GPIO_CON_OFFSET
348007e4:	e5901000 	ldr	r1, [r0]
	bic	r1, r1, #(0xf << 20)		@ 20 = 5 * 4-bit
348007e8:	e3c1160f 	bic	r1, r1, #15728640	; 0xf00000
	orr	r1, r1, #(0x1 << 20)		@ Output
348007ec:	e3811601 	orr	r1, r1, #1048576	; 0x100000
	str	r1, [r0, #0x0]			@ S5PC1XX_GPIO_CON_OFFSET
348007f0:	e5801000 	str	r1, [r0]

	ldr	r1, [r0, #0x8]			@ S5PC1XX_GPIO_PULL_OFFSET
348007f4:	e5901008 	ldr	r1, [r0, #8]
	bic	r1, r1, #(0x3 << 10)		@ 10 = 5 * 2-bit
348007f8:	e3c11b03 	bic	r1, r1, #3072	; 0xc00
	orr	r1, r1, #(0x2 << 10)		@ Pull-up enabled
348007fc:	e3811b02 	orr	r1, r1, #2048	; 0x800
	str	r1, [r0, #0x8]			@ S5PC1XX_GPIO_PULL_OFFSET
34800800:	e5801008 	str	r1, [r0, #8]

	ldr	r1, [r0, #0x4]			@ S5PC1XX_GPIO_DAT_OFFSET
34800804:	e5901004 	ldr	r1, [r0, #4]
	orr	r1, r1, #(1 << 5)		@ 5 = 5 * 1-bit
34800808:	e3811020 	orr	r1, r1, #32
	str	r1, [r0, #0x4]			@ S5PC1XX_GPIO_DAT_OFFSET
3480080c:	e5801004 	str	r1, [r0, #4]

	b	200f
34800810:	ea00002b 	b	348008c4 <uart_asm_init+0x100>
	/*
	 * Note that the following address
	 * 0xE020'0360 is reserved address at S5PC100
	 */
	/* UART_SEL MP0_5[7] at S5PC110 */
	add	r0, r8, #0x360			@ S5PC110_GPIO_MP0_5_OFFSET
34800814:	e2880e36 	add	r0, r8, #864	; 0x360
	ldr	r1, [r0, #0x0]			@ S5PC1XX_GPIO_CON_OFFSET
34800818:	e5901000 	ldr	r1, [r0]
	bic	r1, r1, #(0xf << 28)		@ 28 = 7 * 4-bit
3480081c:	e3c1120f 	bic	r1, r1, #-268435456	; 0xf0000000
	orr	r1, r1, #(0x1 << 28)		@ Output
34800820:	e3811201 	orr	r1, r1, #268435456	; 0x10000000
	str	r1, [r0, #0x0]			@ S5PC1XX_GPIO_CON_OFFSET
34800824:	e5801000 	str	r1, [r0]

	ldr	r1, [r0, #0x8]			@ S5PC1XX_GPIO_PULL_OFFSET
34800828:	e5901008 	ldr	r1, [r0, #8]
	bic	r1, r1, #(0x3 << 14)		@ 14 = 7 * 2-bit
3480082c:	e3c11903 	bic	r1, r1, #49152	; 0xc000
	orr	r1, r1, #(0x2 << 14)		@ Pull-up enabled
34800830:	e3811902 	orr	r1, r1, #32768	; 0x8000
	str	r1, [r0, #0x8]			@ S5PC1XX_GPIO_PULL_OFFSET
34800834:	e5801008 	str	r1, [r0, #8]

	ldr	r1, [r0, #0x4]			@ S5PC1XX_GPIO_DAT_OFFSET
34800838:	e5901004 	ldr	r1, [r0, #4]
	orr	r1, r1, #(1 << 7)		@ 7 = 7 * 1-bit
3480083c:	e3811080 	orr	r1, r1, #128	; 0x80
	str	r1, [r0, #0x4]			@ S5PC1XX_GPIO_DAT_OFFSET
34800840:	e5801004 	str	r1, [r0, #4]

	ldr r0, =0xE2900000
34800844:	e59f028c 	ldr	r0, [pc, #652]	; 34800ad8 <ddrmem_init+0x1bc>
	ldr r1, =0x3
34800848:	e3a01003 	mov	r1, #3
	str r1, [r0]				@ULCON0=3
3480084c:	e5801000 	str	r1, [r0]

	ldr r1, =0x305
34800850:	e59f1284 	ldr	r1, [pc, #644]	; 34800adc <ddrmem_init+0x1c0>
	str r1, [r0, #0x4]			@UCON0=0x305
34800854:	e5801004 	str	r1, [r0, #4]

	ldr r1, =1
34800858:	e3a01001 	mov	r1, #1
	str r1, [r0, #0x8]			@UFCON0=1
3480085c:	e5801008 	str	r1, [r0, #8]

	ldr r1, =0
34800860:	e3a01000 	mov	r1, #0
	str r1, [r0, #0xc]			@UMCON0=0
34800864:	e580100c 	str	r1, [r0, #12]

	ldr r1, =34
34800868:	e3a01022 	mov	r1, #34	; 0x22
	str r1, [r0, #0x28]			@UBRDIV0=34
3480086c:	e5801028 	str	r1, [r0, #40]	; 0x28

	ldr r1, =0xDFDD
34800870:	e59f1268 	ldr	r1, [pc, #616]	; 34800ae0 <ddrmem_init+0x1c4>
	str r1, [r0, #0x2c]			@UDIVSLOT0=13'1
34800874:	e580102c 	str	r1, [r0, #44]	; 0x2c

	ldr r0, =0xE2900020
34800878:	e59f0264 	ldr	r0, [pc, #612]	; 34800ae4 <ddrmem_init+0x1c8>
	ldr r1, =0x55
3480087c:	e3a01055 	mov	r1, #85	; 0x55
	str r1, [r0]				@UTH0='U'
34800880:	e5801000 	str	r1, [r0]

	ldr r1, =0x61
34800884:	e3a01061 	mov	r1, #97	; 0x61
	str r1, [r0]				@UTH0='a'
34800888:	e5801000 	str	r1, [r0]

	ldr r1, =0x72
3480088c:	e3a01072 	mov	r1, #114	; 0x72
	str r1, [r0]				@UTH0='r'
34800890:	e5801000 	str	r1, [r0]

	ldr r1, =0x74
34800894:	e3a01074 	mov	r1, #116	; 0x74
	str r1, [r0]				@UTH0='t'
34800898:	e5801000 	str	r1, [r0]

	ldr r1, =0x5f
3480089c:	e3a0105f 	mov	r1, #95	; 0x5f
	str r1, [r0]				@UTH0='-'
348008a0:	e5801000 	str	r1, [r0]

	ldr r1, =0x4f
348008a4:	e3a0104f 	mov	r1, #79	; 0x4f
	str r1, [r0]				@UTH0='O'
348008a8:	e5801000 	str	r1, [r0]

	ldr r1, =0x6b
348008ac:	e3a0106b 	mov	r1, #107	; 0x6b
	str r1, [r0]				@UTH0='k'
348008b0:	e5801000 	str	r1, [r0]

	ldr r1, =0xa
348008b4:	e3a0100a 	mov	r1, #10
	str r1, [r0]				@UTH0='\r'
348008b8:	e5801000 	str	r1, [r0]

	ldr r1, =0xd
348008bc:	e3a0100d 	mov	r1, #13
	str r1, [r0]				@UTH0='\n'
348008c0:	e5801000 	str	r1, [r0]
200:
	mov	pc, lr
348008c4:	e1a0f00e 	mov	pc, lr

348008c8 <display_addr_dat>:



display_addr_dat:
	ldr r0, [r0]
348008c8:	e5900000 	ldr	r0, [r0]

	ldr r1, =0xE2900020
348008cc:	e59f1210 	ldr	r1, [pc, #528]	; 34800ae4 <ddrmem_init+0x1c8>

	ldr r2, =0x30
348008d0:	e3a02030 	mov	r2, #48	; 0x30
	str r2, [r1]				@UTH0='0'
348008d4:	e5812000 	str	r2, [r1]

	ldr r2, =0x78
348008d8:	e3a02078 	mov	r2, #120	; 0x78
	str r2, [r1]				@UTH0='x'
348008dc:	e5812000 	str	r2, [r1]

	ldr r3, =28
348008e0:	e3a0301c 	mov	r3, #28

348008e4 <disphex_loop_cnt>:

disphex_loop_cnt:
	lsr r2, r0, r3
348008e4:	e1a02330 	lsr	r2, r0, r3
	and r2, r2, #0xf
348008e8:	e202200f 	and	r2, r2, #15
	cmp r2, #10
348008ec:	e352000a 	cmp	r2, #10
	addmi r2, r2, #0x30
348008f0:	42822030 	addmi	r2, r2, #48	; 0x30
	addpl r2, r2, #0x37
348008f4:	52822037 	addpl	r2, r2, #55	; 0x37
	str r2, [r1]
348008f8:	e5812000 	str	r2, [r1]

	sub r3, r3, #4
348008fc:	e2433004 	sub	r3, r3, #4
	cmp r3, #0
34800900:	e3530000 	cmp	r3, #0
	bpl disphex_loop_cnt
34800904:	5afffff6 	bpl	348008e4 <disphex_loop_cnt>

	ldr r2, =0xA
34800908:	e3a0200a 	mov	r2, #10
	str r2, [r1]				@UTH0='\r'
3480090c:	e5812000 	str	r2, [r1]

	ldr r2, =0xD
34800910:	e3a0200d 	mov	r2, #13
	str r2, [r1]				@UTH0='\n'
34800914:	e5812000 	str	r2, [r1]

	mov pc, lr
34800918:	e1a0f00e 	mov	pc, lr

3480091c <ddrmem_init>:


.global ddrmem_init
ddrmem_init:
	//2.设置PhyControl0.ctrl_start_pointandPhyControl0.ctrl_inc
	ldr r0, =0xF0000000
3480091c:	e3a0020f 	mov	r0, #-268435456	; 0xf0000000
	ldr r1, =0x00101002
34800920:	e59f11c0 	ldr	r1, [pc, #448]	; 34800ae8 <ddrmem_init+0x1cc>
	str r1,[r0,#0x18]
34800924:	e5801018 	str	r1, [r0, #24]
	
	//3.设置PhyControl1.ctrl_shiftcandPhyControl1.ctrl_offsetc
	ldr r1, =0x2046
34800928:	e59f11bc 	ldr	r1, [pc, #444]	; 34800aec <ddrmem_init+0x1d0>
	str r1,[r0,#0x1C]
3480092c:	e580101c 	str	r1, [r0, #28]
	
	//4.设置PhyControl0.ctrl_start为1
	ldr r1, =0x00101003
34800930:	e59f11b8 	ldr	r1, [pc, #440]	; 34800af0 <ddrmem_init+0x1d4>
	str r1,[r0,#0x18]
34800934:	e5801018 	str	r1, [r0, #24]
	
	//5.设置ConControl关闭自动刷新
	ldr r1, =0x0FFF13A8
34800938:	e59f11b4 	ldr	r1, [pc, #436]	; 34800af4 <ddrmem_init+0x1d8>
	str r1,[r0,#0x0]
3480093c:	e5801000 	str	r1, [r0]
	
	//6.设置MemControl关闭所有的掉电模式
	ldr r1, =0x00212400
34800940:	e59f11b0 	ldr	r1, [pc, #432]	; 34800af8 <ddrmem_init+0x1dc>
	str r1,[r0,#0x4]
34800944:	e5801004 	str	r1, [r0, #4]
	
	//7.设置MemConfig0
	ldr r1, =0x20E00323
34800948:	e59f11ac 	ldr	r1, [pc, #428]	; 34800afc <ddrmem_init+0x1e0>
	str r1,[r0,#0x8]
3480094c:	e5801008 	str	r1, [r0, #8]
	
	//8.设置PrechConfigandPwrdnConfig
	ldr r1, =0xFF000000
34800950:	e3a014ff 	mov	r1, #-16777216	; 0xff000000
	ldr r1,[r0,#0x14]
34800954:	e5901014 	ldr	r1, [r0, #20]
	
	ldr r1, =0xFFFF00FF
34800958:	e3e01cff 	mvn	r1, #65280	; 0xff00
	str r1,[r0,#0x28]
3480095c:	e5801028 	str	r1, [r0, #40]	; 0x28
	
	//9.设置TimingAref,TimingRow,TimingDataandTimingPower
	ldr r1, =0x618
34800960:	e59f1198 	ldr	r1, [pc, #408]	; 34800b00 <ddrmem_init+0x1e4>
	str r1,[r0,#0x30]
34800964:	e5801030 	str	r1, [r0, #48]	; 0x30
	
	ldr r1, =0x1C24434A
34800968:	e59f1194 	ldr	r1, [pc, #404]	; 34800b04 <ddrmem_init+0x1e8>
	str r1,[r0,#0x34]
3480096c:	e5801034 	str	r1, [r0, #52]	; 0x34
	
	ldr r1, =0x24240000
34800970:	e59f1190 	ldr	r1, [pc, #400]	; 34800b08 <ddrmem_init+0x1ec>
	str r1,[r0,#0x38]
34800974:	e5801038 	str	r1, [r0, #56]	; 0x38
	
	ldr r1, =0x08C90343
34800978:	e59f118c 	ldr	r1, [pc, #396]	; 34800b0c <ddrmem_init+0x1f0>
	str r1,[r0,#0x3C]
3480097c:	e580103c 	str	r1, [r0, #60]	; 0x3c
	
	//10.QoS没用到，这一步跳过
	
	//11.通过读PhyStatus0.ctrl_locked 是否为1检测PHY DLL是否锁定
1:
	ldr r1,[r0,#0x40]
34800980:	e5901040 	ldr	r1, [r0, #64]	; 0x40
	and r2,r1,#0x2
34800984:	e2012002 	and	r2, r1, #2
	cmp r2,#0
34800988:	e3520000 	cmp	r2, #0
	beq 1b
3480098c:	0afffffb 	beq	34800980 <ddrmem_init+0x64>
	
	//12.强制延时
	and r1,r1,#0x3fc0
34800990:	e2011dff 	and	r1, r1, #16320	; 0x3fc0
	mov r2,r1,LSL #18
34800994:	e1a02901 	lsl	r2, r1, #18
	orr r2,r2,#0x100000
34800998:	e3822601 	orr	r2, r2, #1048576	; 0x100000
	orr r2,r2,#0x1000
3480099c:	e3822a01 	orr	r2, r2, #4096	; 0x1000
	orr r2,r2,#0x3
348009a0:	e3822003 	orr	r2, r2, #3
	str r2,[r0,#0x18]
348009a4:	e5802018 	str	r2, [r0, #24]
	
	//13.开机等待200us是时钟平稳，这一步不用开机到内存初始化肯定时钟平稳了
	//14.使用DirectCmd发送NOP命令，确保CKE保持为高电平
	ldr r1, =0x07000000
348009a8:	e3a01407 	mov	r1, #117440512	; 0x7000000
	str r1,[r0,#0x10]
348009ac:	e5801010 	str	r1, [r0, #16]
	
	//15.等待最少400ns
	//16.使用DirectCmd发送PALL命令
	ldr r1, =0x01000000
348009b0:	e3a01401 	mov	r1, #16777216	; 0x1000000
	str r1,[r0,#0x10]
348009b4:	e5801010 	str	r1, [r0, #16]
	
	//17.使用DirectCmd发送EMRS2命令去写入运行参数
	ldr r1, =0x00020000
348009b8:	e3a01802 	mov	r1, #131072	; 0x20000
	str r1,[r0,#0x10]
348009bc:	e5801010 	str	r1, [r0, #16]
	
	//18.使用DirectCmd发送EMRS3命令去写入运行参数
	ldr r1, =0x00030000
348009c0:	e3a01803 	mov	r1, #196608	; 0x30000
	str r1,[r0,#0x10]
348009c4:	e5801010 	str	r1, [r0, #16]
	
	//19. 使用DirectCmd发送EMRS命令，使能内存DLLs
	ldr r1, =0x00010000
348009c8:	e3a01801 	mov	r1, #65536	; 0x10000
	str r1,[r0,#0x10]
348009cc:	e5801010 	str	r1, [r0, #16]
	
	//20.使用DirectCmd发送MRS命令，复位内存DLLs
	ldr r1, =0x542
348009d0:	e59f1138 	ldr	r1, [pc, #312]	; 34800b10 <ddrmem_init+0x1f4>
	str r1,[r0,#0x10]
348009d4:	e5801010 	str	r1, [r0, #16]
	
	//21.使用DirectCmd发送PALL命令
	ldr r1, =0x01000000
348009d8:	e3a01401 	mov	r1, #16777216	; 0x1000000
	str r1,[r0,#0x10]
348009dc:	e5801010 	str	r1, [r0, #16]
	
	//22.使用DirectCmd发送两次auto refresh命令
	ldr r1, =0x05000000
348009e0:	e3a01405 	mov	r1, #83886080	; 0x5000000
	str r1,[r0,#0x10]
348009e4:	e5801010 	str	r1, [r0, #16]
	str r1,[r0,#0x10]
348009e8:	e5801010 	str	r1, [r0, #16]
	
	//23.使用DirectCmd发送MRS命令，运行无复位的内存DLL
	ldr r1, =0x442
348009ec:	e59f1120 	ldr	r1, [pc, #288]	; 34800b14 <ddrmem_init+0x1f8>
	str r1,[r0,#0x10]
348009f0:	e5801010 	str	r1, [r0, #16]
	
	//24.最少等200个时钟周期
	//25.使用DirectCmd发送EMRS命令，设置OCD校正
	ldr r1, =0x00010780
348009f4:	e59f111c 	ldr	r1, [pc, #284]	; 34800b18 <ddrmem_init+0x1fc>
	str r1,[r0,#0x10]
348009f8:	e5801010 	str	r1, [r0, #16]
	
	//26.不用设置
	//27.设置ConControl启动自动刷新计数器
	ldr r1, =0x0FFF13B8
348009fc:	e59f1118 	ldr	r1, [pc, #280]	; 34800b1c <ddrmem_init+0x200>
	str r1,[r0,#0x0]
34800a00:	e5801000 	str	r1, [r0]
	
	//28如果有必要的话设置MemControl开启掉电模式

	ldr r0, =0xE2900020
34800a04:	e59f00d8 	ldr	r0, [pc, #216]	; 34800ae4 <ddrmem_init+0x1c8>
	ldr r1, =0x44
34800a08:	e3a01044 	mov	r1, #68	; 0x44
	str r1, [r0]				@UTH0='D'
34800a0c:	e5801000 	str	r1, [r0]

	ldr r1, =0x44
34800a10:	e3a01044 	mov	r1, #68	; 0x44
	str r1, [r0]				@UTH0='D'
34800a14:	e5801000 	str	r1, [r0]

	ldr r1, =0x52
34800a18:	e3a01052 	mov	r1, #82	; 0x52
	str r1, [r0]				@UTH0='R'
34800a1c:	e5801000 	str	r1, [r0]

	ldr r1, =0x5f
34800a20:	e3a0105f 	mov	r1, #95	; 0x5f
	str r1, [r0]				@UTH0='-'
34800a24:	e5801000 	str	r1, [r0]

	ldr r1, =0x4f
34800a28:	e3a0104f 	mov	r1, #79	; 0x4f
	str r1, [r0]				@UTH0='O'
34800a2c:	e5801000 	str	r1, [r0]

	ldr r1, =0x6b
34800a30:	e3a0106b 	mov	r1, #107	; 0x6b
	str r1, [r0]				@UTH0='k'
34800a34:	e5801000 	str	r1, [r0]

	ldr r1, =0xa
34800a38:	e3a0100a 	mov	r1, #10
	str r1, [r0]				@UTH0='\r'
34800a3c:	e5801000 	str	r1, [r0]

	ldr r1, =0xd
34800a40:	e3a0100d 	mov	r1, #13
	str r1, [r0]				@UTH0='\n'
34800a44:	e5801000 	str	r1, [r0]

	mov	pc, lr
34800a48:	e1a0f00e 	mov	pc, lr
34800a4c:	e0300000 	.word	0xe0300000
34800a50:	e0200000 	.word	0xe0200000
34800a54:	e010a000 	.word	0xe010a000
34800a58:	e0f00000 	.word	0xe0f00000
34800a5c:	e1f00000 	.word	0xe1f00000
34800a60:	f1800000 	.word	0xf1800000
34800a64:	f1900000 	.word	0xf1900000
34800a68:	f1a00000 	.word	0xf1a00000
34800a6c:	f1b00000 	.word	0xf1b00000
34800a70:	f1c00000 	.word	0xf1c00000
34800a74:	f1d00000 	.word	0xf1d00000
34800a78:	f1e00000 	.word	0xf1e00000
34800a7c:	f1f00000 	.word	0xf1f00000
34800a80:	faf00000 	.word	0xfaf00000
34800a84:	e010c300 	.word	0xe010c300
34800a88:	e0108200 	.word	0xe0108200
34800a8c:	e010e000 	.word	0xe010e000
34800a90:	ea200000 	.word	0xea200000
34800a94:	e2700000 	.word	0xe2700000
34800a98:	12345678 	.word	0x12345678
34800a9c:	e0108304 	.word	0xe0108304
34800aa0:	e010c200 	.word	0xe010c200
34800aa4:	e0100100 	.word	0xe0100100
34800aa8:	e010f000 	.word	0xe010f000
34800aac:	e0100000 	.word	0xe0100000
34800ab0:	14131440 	.word	0x14131440
34800ab4:	807d0301 	.word	0x807d0301
34800ab8:	829b0c01 	.word	0x829b0c01
34800abc:	80600602 	.word	0x80600602
34800ac0:	806c0603 	.word	0x806c0603
34800ac4:	10001111 	.word	0x10001111
34800ac8:	e3800000 	.word	0xe3800000
34800acc:	f1500000 	.word	0xf1500000
34800ad0:	22222222 	.word	0x22222222
34800ad4:	00002222 	.word	0x00002222
34800ad8:	e2900000 	.word	0xe2900000
34800adc:	00000305 	.word	0x00000305
34800ae0:	0000dfdd 	.word	0x0000dfdd
34800ae4:	e2900020 	.word	0xe2900020
34800ae8:	00101002 	.word	0x00101002
34800aec:	00002046 	.word	0x00002046
34800af0:	00101003 	.word	0x00101003
34800af4:	0fff13a8 	.word	0x0fff13a8
34800af8:	00212400 	.word	0x00212400
34800afc:	20e00323 	.word	0x20e00323
34800b00:	00000618 	.word	0x00000618
34800b04:	1c24434a 	.word	0x1c24434a
34800b08:	24240000 	.word	0x24240000
34800b0c:	08c90343 	.word	0x08c90343
34800b10:	00000542 	.word	0x00000542
34800b14:	00000442 	.word	0x00000442
34800b18:	00010780 	.word	0x00010780
34800b1c:	0fff13b8 	.word	0x0fff13b8

34800b20 <s5pc1xx_phy_control>:
}
#endif

#ifdef CONFIG_USB_GADGET
static int s5pc1xx_phy_control(int on)
{
34800b20:	e92d4070 	push	{r4, r5, r6, lr}
34800b24:	e1a06000 	mov	r6, r0
	int ret;
	static int status;
	struct pmic *p = get_pmic();
34800b28:	eb003f1f 	bl	348107ac <get_pmic>
34800b2c:	e1a05000 	mov	r5, r0

	if (pmic_probe(p))
34800b30:	eb003f7a 	bl	34810920 <pmic_probe>
34800b34:	e3500000 	cmp	r0, #0
34800b38:	1a00002c 	bne	34800bf0 <s5pc1xx_phy_control+0xd0>
		return -1;

	if (on && !status) {
34800b3c:	e3560000 	cmp	r6, #0
34800b40:	e59f40b0 	ldr	r4, [pc, #176]	; 34800bf8 <s5pc1xx_phy_control+0xd8>
34800b44:	0a000011 	beq	34800b90 <s5pc1xx_phy_control+0x70>
34800b48:	e5943000 	ldr	r3, [r4]
34800b4c:	e3530000 	cmp	r3, #0
34800b50:	1a000022 	bne	34800be0 <s5pc1xx_phy_control+0xc0>
		ret = pmic_set_output(p, MAX8998_REG_ONOFF1,
34800b54:	e3a01011 	mov	r1, #17
34800b58:	e3a02004 	mov	r2, #4
34800b5c:	e2833001 	add	r3, r3, #1
34800b60:	e1a00005 	mov	r0, r5
34800b64:	eb003efa 	bl	34810754 <pmic_set_output>
				      MAX8998_LDO3, LDO_ON);
		ret = pmic_set_output(p, MAX8998_REG_ONOFF2,
34800b68:	e3a03001 	mov	r3, #1
34800b6c:	e1a00005 	mov	r0, r5
34800b70:	e3a01012 	mov	r1, #18
34800b74:	e3a02020 	mov	r2, #32
34800b78:	eb003ef5 	bl	34810754 <pmic_set_output>
				      MAX8998_LDO8, LDO_ON);
		if (ret) {
34800b7c:	e3500000 	cmp	r0, #0
			puts("MAX8998 LDO setting error!\n");
			return -1;
		}
		status = 1;
34800b80:	03a03001 	moveq	r3, #1
34800b84:	05843000 	streq	r3, [r4]
	if (on && !status) {
		ret = pmic_set_output(p, MAX8998_REG_ONOFF1,
				      MAX8998_LDO3, LDO_ON);
		ret = pmic_set_output(p, MAX8998_REG_ONOFF2,
				      MAX8998_LDO8, LDO_ON);
		if (ret) {
34800b88:	0a000014 	beq	34800be0 <s5pc1xx_phy_control+0xc0>
34800b8c:	ea00000f 	b	34800bd0 <s5pc1xx_phy_control+0xb0>
			puts("MAX8998 LDO setting error!\n");
			return -1;
		}
		status = 1;
	} else if (!on && status) {
34800b90:	e5943000 	ldr	r3, [r4]
34800b94:	e3530000 	cmp	r3, #0
34800b98:	0a000010 	beq	34800be0 <s5pc1xx_phy_control+0xc0>
		ret = pmic_set_output(p, MAX8998_REG_ONOFF1,
34800b9c:	e3a01011 	mov	r1, #17
34800ba0:	e3a02004 	mov	r2, #4
34800ba4:	e1a03006 	mov	r3, r6
34800ba8:	e1a00005 	mov	r0, r5
34800bac:	eb003ee8 	bl	34810754 <pmic_set_output>
				      MAX8998_LDO3, LDO_OFF);
		ret = pmic_set_output(p, MAX8998_REG_ONOFF2,
34800bb0:	e1a00005 	mov	r0, r5
34800bb4:	e3a01012 	mov	r1, #18
34800bb8:	e3a02020 	mov	r2, #32
34800bbc:	e1a03006 	mov	r3, r6
34800bc0:	eb003ee3 	bl	34810754 <pmic_set_output>
				      MAX8998_LDO8, LDO_OFF);
		if (ret) {
34800bc4:	e3500000 	cmp	r0, #0
			puts("MAX8998 LDO setting error!\n");
			return -1;
		}
		status = 0;
34800bc8:	05840000 	streq	r0, [r4]
	} else if (!on && status) {
		ret = pmic_set_output(p, MAX8998_REG_ONOFF1,
				      MAX8998_LDO3, LDO_OFF);
		ret = pmic_set_output(p, MAX8998_REG_ONOFF2,
				      MAX8998_LDO8, LDO_OFF);
		if (ret) {
34800bcc:	0a000003 	beq	34800be0 <s5pc1xx_phy_control+0xc0>
			puts("MAX8998 LDO setting error!\n");
34800bd0:	e59f0024 	ldr	r0, [pc, #36]	; 34800bfc <s5pc1xx_phy_control+0xdc>
34800bd4:	eb0020d2 	bl	34808f24 <puts>
			return -1;
34800bd8:	e3e00000 	mvn	r0, #0
34800bdc:	e8bd8070 	pop	{r4, r5, r6, pc}
		}
		status = 0;
	}
	udelay(10000);
34800be0:	e3020710 	movw	r0, #10000	; 0x2710
34800be4:	eb006134 	bl	348190bc <udelay>

	return 0;
34800be8:	e3a00000 	mov	r0, #0
34800bec:	e8bd8070 	pop	{r4, r5, r6, pc}
	int ret;
	static int status;
	struct pmic *p = get_pmic();

	if (pmic_probe(p))
		return -1;
34800bf0:	e3e00000 	mvn	r0, #0
		status = 0;
	}
	udelay(10000);

	return 0;
}
34800bf4:	e8bd8070 	pop	{r4, r5, r6, pc}
34800bf8:	34829070 	.word	0x34829070
34800bfc:	34822af3 	.word	0x34822af3

34800c00 <board_init>:
DECLARE_GLOBAL_DATA_PTR;

static struct s5pc110_gpio *s5pc110_gpio;

int board_init(void)
{
34800c00:	e92d4008 	push	{r3, lr}
	/* Set Initial global variables */
	s5pc110_gpio = (struct s5pc110_gpio *)S5PC110_GPIO_BASE;
34800c04:	e59f2028 	ldr	r2, [pc, #40]	; 34800c34 <board_init+0x34>
34800c08:	e59f3028 	ldr	r3, [pc, #40]	; 34800c38 <board_init+0x38>

	gd->bd->bi_arch_number = MACH_TYPE_GONI;
34800c0c:	e3001b2e 	movw	r1, #2862	; 0xb2e
static struct s5pc110_gpio *s5pc110_gpio;

int board_init(void)
{
	/* Set Initial global variables */
	s5pc110_gpio = (struct s5pc110_gpio *)S5PC110_GPIO_BASE;
34800c10:	e5832004 	str	r2, [r3, #4]

	gd->bd->bi_arch_number = MACH_TYPE_GONI;
34800c14:	e5982000 	ldr	r2, [r8]
	gd->bd->bi_boot_params = PHYS_SDRAM_1 + 0x100;
34800c18:	e5983000 	ldr	r3, [r8]
int board_init(void)
{
	/* Set Initial global variables */
	s5pc110_gpio = (struct s5pc110_gpio *)S5PC110_GPIO_BASE;

	gd->bd->bi_arch_number = MACH_TYPE_GONI;
34800c1c:	e5821004 	str	r1, [r2, #4]
	gd->bd->bi_boot_params = PHYS_SDRAM_1 + 0x100;
34800c20:	e59f2014 	ldr	r2, [pc, #20]	; 34800c3c <board_init+0x3c>
34800c24:	e5832008 	str	r2, [r3, #8]

#if defined(CONFIG_PMIC)
	pmic_init();
34800c28:	eb003f4a 	bl	34810958 <pmic_init>
#endif
	return 0;
}
34800c2c:	e3a00000 	mov	r0, #0
34800c30:	e8bd8008 	pop	{r3, pc}
34800c34:	e0200000 	.word	0xe0200000
34800c38:	34829070 	.word	0x34829070
34800c3c:	20000100 	.word	0x20000100

34800c40 <dram_init>:

int dram_init(void)
{
	gd->ram_size = PHYS_SDRAM_1_SIZE;
34800c40:	e3a02202 	mov	r2, #536870912	; 0x20000000
34800c44:	e5882038 	str	r2, [r8, #56]	; 0x38
	//gd->ram_size = PHYS_SDRAM_1_SIZE + PHYS_SDRAM_2_SIZE +
	//		PHYS_SDRAM_3_SIZE;

	return 0;
}
34800c48:	e3a00000 	mov	r0, #0
34800c4c:	e12fff1e 	bx	lr

34800c50 <dram_init_banksize>:

void dram_init_banksize(void)
{
	gd->bd->bi_dram[0].start = PHYS_SDRAM_1;
34800c50:	e5981000 	ldr	r1, [r8]
	gd->bd->bi_dram[0].size = PHYS_SDRAM_1_SIZE;
34800c54:	e5982000 	ldr	r2, [r8]
	return 0;
}

void dram_init_banksize(void)
{
	gd->bd->bi_dram[0].start = PHYS_SDRAM_1;
34800c58:	e3a03202 	mov	r3, #536870912	; 0x20000000
34800c5c:	e5813018 	str	r3, [r1, #24]
	gd->bd->bi_dram[0].size = PHYS_SDRAM_1_SIZE;
34800c60:	e582301c 	str	r3, [r2, #28]
	//gd->bd->bi_dram[1].start = PHYS_SDRAM_2;
	//gd->bd->bi_dram[1].size = PHYS_SDRAM_2_SIZE;
	//gd->bd->bi_dram[2].start = PHYS_SDRAM_3;
	//gd->bd->bi_dram[2].size = PHYS_SDRAM_3_SIZE;
}
34800c64:	e12fff1e 	bx	lr

34800c68 <checkboard>:

#ifdef CONFIG_DISPLAY_BOARDINFO
int checkboard(void)
{
34800c68:	e92d4008 	push	{r3, lr}
	puts("Board:\tGoni\n");
34800c6c:	e59f0008 	ldr	r0, [pc, #8]	; 34800c7c <checkboard+0x14>
34800c70:	eb0020ab 	bl	34808f24 <puts>
	return 0;
}
34800c74:	e3a00000 	mov	r0, #0
34800c78:	e8bd8008 	pop	{r3, pc}
34800c7c:	34822b0f 	.word	0x34822b0f

34800c80 <board_mmc_init>:
#endif

#ifdef CONFIG_GENERIC_MMC
int board_mmc_init(bd_t *bis)
{
34800c80:	e92d4070 	push	{r4, r5, r6, lr}
	int i;

	/* MASSMEMORY_EN: XMSMDATA7: GPJ2[7] output high */
	s5p_gpio_direction_output(&s5pc110_gpio->j2, 7, 1);
34800c84:	e59f5098 	ldr	r5, [pc, #152]	; 34800d24 <board_mmc_init+0xa4>
34800c88:	e3a01007 	mov	r1, #7
34800c8c:	e5950004 	ldr	r0, [r5, #4]
34800c90:	e3a02001 	mov	r2, #1
34800c94:	e2800d0a 	add	r0, r0, #640	; 0x280
34800c98:	eb003b4a 	bl	3480f9c8 <s5p_gpio_direction_output>
	 * GPG0[0]	SD_0_CLK
	 * GPG0[1]	SD_0_CMD
	 * GPG0[2]	SD_0_CDn	-> Not used
	 * GPG0[3:6]	SD_0_DATA[0:3]
	 */
	for (i = 0; i < 7; i++) {
34800c9c:	e3a04000 	mov	r4, #0
		if (i == 2)
34800ca0:	e3540002 	cmp	r4, #2
34800ca4:	0a00000e 	beq	34800ce4 <board_mmc_init+0x64>
			continue;
		/* GPG0[0:6] special function 2 */
		s5p_gpio_cfg_pin(&s5pc110_gpio->g0, i, 0x2);
34800ca8:	e5950004 	ldr	r0, [r5, #4]
34800cac:	e1a01004 	mov	r1, r4
34800cb0:	e2800e1a 	add	r0, r0, #416	; 0x1a0
34800cb4:	e3a02002 	mov	r2, #2
34800cb8:	eb003b3b 	bl	3480f9ac <s5p_gpio_cfg_pin>
		/* GPG0[0:6] pull disable */
		s5p_gpio_set_pull(&s5pc110_gpio->g0, i, GPIO_PULL_NONE);
34800cbc:	e5950004 	ldr	r0, [r5, #4]
34800cc0:	e1a01004 	mov	r1, r4
34800cc4:	e2800e1a 	add	r0, r0, #416	; 0x1a0
34800cc8:	e3a02000 	mov	r2, #0
34800ccc:	eb003b5b 	bl	3480fa40 <s5p_gpio_set_pull>
		/* GPG0[0:6] drv 4x */
		s5p_gpio_set_drv(&s5pc110_gpio->g0, i, GPIO_DRV_4X);
34800cd0:	e5950004 	ldr	r0, [r5, #4]
34800cd4:	e1a01004 	mov	r1, r4
34800cd8:	e2800e1a 	add	r0, r0, #416	; 0x1a0
34800cdc:	e3a02003 	mov	r2, #3
34800ce0:	eb003b5f 	bl	3480fa64 <s5p_gpio_set_drv>
	 * GPG0[0]	SD_0_CLK
	 * GPG0[1]	SD_0_CMD
	 * GPG0[2]	SD_0_CDn	-> Not used
	 * GPG0[3:6]	SD_0_DATA[0:3]
	 */
	for (i = 0; i < 7; i++) {
34800ce4:	e2844001 	add	r4, r4, #1
34800ce8:	e3540007 	cmp	r4, #7
34800cec:	1affffeb 	bne	34800ca0 <board_mmc_init+0x20>
static inline int cpu_is_##type(void)			\
{							\
	return s5p_cpu_id == id ? 1 : 0;		\
}

IS_SAMSUNG_TYPE(s5pc100, 0xc100)
34800cf0:	e59f3030 	ldr	r3, [pc, #48]	; 34800d28 <board_mmc_init+0xa8>
34800cf4:	e5933000 	ldr	r3, [r3]
}

SAMSUNG_BASE(clock, CLOCK_BASE)
SAMSUNG_BASE(gpio, GPIO_BASE)
SAMSUNG_BASE(pro_id, PRO_ID)
SAMSUNG_BASE(mmc, MMC_BASE)
34800cf8:	e3530cc1 	cmp	r3, #49408	; 0xc100
34800cfc:	059f0028 	ldreq	r0, [pc, #40]	; 34800d2c <board_mmc_init+0xac>
34800d00:	0a000003 	beq	34800d14 <board_mmc_init+0x94>
34800d04:	e30c0110 	movw	r0, #49424	; 0xc110
34800d08:	e1530000 	cmp	r3, r0
34800d0c:	03a004eb 	moveq	r0, #-352321536	; 0xeb000000
34800d10:	13a00000 	movne	r0, #0
int s5p_sdhci_init(u32 regbase, int index, int bus_width);

static inline unsigned int s5p_mmc_init(int index, int bus_width)
{
	unsigned int base = samsung_get_base_mmc() + (0x10000 * index);
	return s5p_sdhci_init(base, index, bus_width);
34800d14:	e3a01000 	mov	r1, #0
34800d18:	e3a02004 	mov	r2, #4
		/* GPG0[0:6] drv 4x */
		s5p_gpio_set_drv(&s5pc110_gpio->g0, i, GPIO_DRV_4X);
	}

	return s5p_mmc_init(0, 4);
}
34800d1c:	e8bd4070 	pop	{r4, r5, r6, lr}
34800d20:	ea0046ed 	b	348128dc <s5p_sdhci_init>
34800d24:	34829070 	.word	0x34829070
34800d28:	34828214 	.word	0x34828214
34800d2c:	ed800000 	.word	0xed800000

34800d30 <board_eth_init>:
};
#endif

int board_eth_init(bd_t *bis)
{
     return dm9000_initialize(bis);
34800d30:	ea004fd0 	b	34814c78 <dm9000_initialize>

34800d34 <onenand_board_init>:
#include <linux/mtd/samsung_onenand.h>
#include <onenand_uboot.h>

void onenand_board_init(struct mtd_info *mtd)
{
	struct onenand_chip *this = mtd->priv;
34800d34:	e5903094 	ldr	r3, [r0, #148]	; 0x94

	this->base = (void *)CONFIG_SYS_ONENAND_BASE;
34800d38:	e3a0220b 	mov	r2, #-1342177280	; 0xb0000000
34800d3c:	e5832000 	str	r2, [r3]
	this->options |= ONENAND_RUNTIME_BADBLOCK_CHECK;
34800d40:	e593202c 	ldr	r2, [r3, #44]	; 0x2c
34800d44:	e3822c02 	orr	r2, r2, #512	; 0x200
34800d48:	e583202c 	str	r2, [r3, #44]	; 0x2c
	this->chip_probe = s5pc110_chip_probe;
34800d4c:	e59f2004 	ldr	r2, [pc, #4]	; 34800d58 <onenand_board_init+0x24>
34800d50:	e5832070 	str	r2, [r3, #112]	; 0x70
}
34800d54:	e12fff1e 	bx	lr
34800d58:	3481420c 	.word	0x3481420c

34800d5c <copy_code_to_dram>:
	unsigned long ch;
    unsigned long dest=0x34800000;
    unsigned int sec_no = 49;
    unsigned int ret;

	ch = *(volatile unsigned int *)(0xD0037488);
34800d5c:	e59f3060 	ldr	r3, [pc, #96]	; 34800dc4 <copy_code_to_dram+0x68>
typedef unsigned int (*copy_sd_mmc_to_mem) (unsigned int  channel, unsigned int  start_block, unsigned char block_size, unsigned int  *trg, unsigned int  init);


void copy_code_to_dram(void)
{
34800d60:	e92d4037 	push	{r0, r1, r2, r4, r5, lr}
	unsigned long ch;
    unsigned long dest=0x34800000;
    unsigned int sec_no = 49;
    unsigned int ret;

	ch = *(volatile unsigned int *)(0xD0037488);
34800d64:	e5932488 	ldr	r2, [r3, #1160]	; 0x488

	// 函数指针
	copy_sd_mmc_to_mem copy_bl2 = (copy_sd_mmc_to_mem) (*(unsigned int *) (0xD0037F98));
34800d68:	e5935f98 	ldr	r5, [r3, #3992]	; 0xf98
	
	// 通道0
	if (ch == 0xEB000000)
34800d6c:	e35204eb 	cmp	r2, #-352321536	; 0xeb000000
34800d70:	1a000012 	bne	34800dc0 <copy_code_to_dram+0x64>
	{
		// 0:channel 0
		// 49:源,代码位于扇区49,1 sector = 512 bytes
		ret = copy_bl2(0, sec_no,   128,(unsigned int *)(dest), 0);
34800d74:	e3a04000 	mov	r4, #0
34800d78:	e3a01031 	mov	r1, #49	; 0x31
34800d7c:	e3a02080 	mov	r2, #128	; 0x80
34800d80:	e3a035d2 	mov	r3, #880803840	; 0x34800000
34800d84:	e58d4000 	str	r4, [sp]
34800d88:	e1a00004 	mov	r0, r4
34800d8c:	e12fff35 	blx	r5
        ret = copy_bl2(0, sec_no+128, 128,(unsigned int *)(dest+0x10000), 0);
34800d90:	e3a010b1 	mov	r1, #177	; 0xb1
34800d94:	e3a02080 	mov	r2, #128	; 0x80
34800d98:	e59f3028 	ldr	r3, [pc, #40]	; 34800dc8 <copy_code_to_dram+0x6c>
34800d9c:	e58d4000 	str	r4, [sp]
34800da0:	e1a00004 	mov	r0, r4
34800da4:	e12fff35 	blx	r5
        ret = copy_bl2(0, sec_no+256, 128,(unsigned int *)(dest+0x20000), 0);
34800da8:	e58d4000 	str	r4, [sp]
34800dac:	e1a00004 	mov	r0, r4
34800db0:	e3001131 	movw	r1, #305	; 0x131
34800db4:	e3a02080 	mov	r2, #128	; 0x80
34800db8:	e59f300c 	ldr	r3, [pc, #12]	; 34800dcc <copy_code_to_dram+0x70>
34800dbc:	e12fff35 	blx	r5
	}
}
34800dc0:	e8bd803e 	pop	{r1, r2, r3, r4, r5, pc}
34800dc4:	d0037000 	.word	0xd0037000
34800dc8:	34810000 	.word	0x34810000
34800dcc:	34820000 	.word	0x34820000

34800dd0 <v7_maint_dcache_all>:
						   way_shift, log2_line_len);
	}
}

static void v7_maint_dcache_all(u32 operation)
{
34800dd0:	e92d4ef3 	push	{r0, r1, r4, r5, r6, r7, r9, sl, fp, lr}
static u32 get_clidr(void)
{
	u32 clidr;

	/* Read current CP15 Cache Level ID Register */
	asm volatile ("mrc p15,1,%0,c0,c0,1" : "=r" (clidr));
34800dd4:	ee301f30 	mrc	15, 1, r1, cr0, cr0, {1}
	}
}

static void v7_maint_dcache_all(u32 operation)
{
	u32 level, cache_type, level_start_bit = 0;
34800dd8:	e3a03000 	mov	r3, #0
static u32 get_clidr(void)
{
	u32 clidr;

	/* Read current CP15 Cache Level ID Register */
	asm volatile ("mrc p15,1,%0,c0,c0,1" : "=r" (clidr));
34800ddc:	e58d1004 	str	r1, [sp, #4]
{
	u32 level, cache_type, level_start_bit = 0;

	u32 clidr = get_clidr();

	for (level = 0; level < 7; level++) {
34800de0:	e1a0c003 	mov	ip, r3
			asm volatile ("	mcr p15, 0, %0, c7, c14, 2"
					: : "r" (setway));
		}
	}
	/* DSB to make sure the operation is complete */
	CP15DSB;
34800de4:	e1a05003 	mov	r5, r3
	u32 level, cache_type, level_start_bit = 0;

	u32 clidr = get_clidr();

	for (level = 0; level < 7; level++) {
		cache_type = (clidr >> level_start_bit) & 0x7;
34800de8:	e59d1004 	ldr	r1, [sp, #4]
34800dec:	e1a02331 	lsr	r2, r1, r3
34800df0:	e2022007 	and	r2, r2, #7
		if ((cache_type == ARMV7_CLIDR_CTYPE_DATA_ONLY) ||
		    (cache_type == ARMV7_CLIDR_CTYPE_INSTRUCTION_DATA) ||
34800df4:	e2422002 	sub	r2, r2, #2

	u32 clidr = get_clidr();

	for (level = 0; level < 7; level++) {
		cache_type = (clidr >> level_start_bit) & 0x7;
		if ((cache_type == ARMV7_CLIDR_CTYPE_DATA_ONLY) ||
34800df8:	e3520002 	cmp	r2, #2
34800dfc:	8a00002a 	bhi	34800eac <v7_maint_dcache_all+0xdc>
/*
 * Write the level and type you want to Cache Size Selection Register(CSSELR)
 * to get size details from Current Cache Size ID Register(CCSIDR)
 */
static void set_csselr(u32 level, u32 type)
{	u32 csselr = level << 1 | type;
34800e00:	e1a0408c 	lsl	r4, ip, #1

	/* Write to Cache Size Selection Register(CSSELR) */
	asm volatile ("mcr p15, 2, %0, c0, c0, 0" : : "r" (csselr));
34800e04:	ee404f10 	mcr	15, 2, r4, cr0, cr0, {0}
static u32 get_ccsidr(void)
{
	u32 ccsidr;

	/* Read current CP15 Cache Size ID Register */
	asm volatile ("mrc p15, 1, %0, c0, c0, 0" : "=r" (ccsidr));
34800e08:	ee307f10 	mrc	15, 1, r7, cr0, cr0, {0}
	log2_line_len = ((ccsidr & CCSIDR_LINE_SIZE_MASK) >>
				CCSIDR_LINE_SIZE_OFFSET) + 2;
	/* Converting from words to bytes */
	log2_line_len += 2;

	num_ways  = ((ccsidr & CCSIDR_ASSOCIATIVITY_MASK) >>
34800e0c:	e7e921d7 	ubfx	r2, r7, #3, #10

	set_csselr(level, ARMV7_CSSELR_IND_DATA_UNIFIED);

	ccsidr = get_ccsidr();

	log2_line_len = ((ccsidr & CCSIDR_LINE_SIZE_MASK) >>
34800e10:	e2076007 	and	r6, r7, #7
				CCSIDR_LINE_SIZE_OFFSET) + 2;
	/* Converting from words to bytes */
	log2_line_len += 2;

	num_ways  = ((ccsidr & CCSIDR_ASSOCIATIVITY_MASK) >>
34800e14:	e2829001 	add	r9, r2, #1
	ccsidr = get_ccsidr();

	log2_line_len = ((ccsidr & CCSIDR_LINE_SIZE_MASK) >>
				CCSIDR_LINE_SIZE_OFFSET) + 2;
	/* Converting from words to bytes */
	log2_line_len += 2;
34800e18:	e2866004 	add	r6, r6, #4

	num_ways  = ((ccsidr & CCSIDR_ASSOCIATIVITY_MASK) >>
			CCSIDR_ASSOCIATIVITY_OFFSET) + 1;
	num_sets  = ((ccsidr & CCSIDR_NUM_SETS_MASK) >>
34800e1c:	e7ee76d7 	ubfx	r7, r7, #13, #15
	log2_line_len = ((ccsidr & CCSIDR_LINE_SIZE_MASK) >>
				CCSIDR_LINE_SIZE_OFFSET) + 2;
	/* Converting from words to bytes */
	log2_line_len += 2;

	num_ways  = ((ccsidr & CCSIDR_ASSOCIATIVITY_MASK) >>
34800e20:	e1a01009 	mov	r1, r9
#ifndef _UTILS_H_
#define _UTILS_H_

static inline s32 log_2_n_round_up(u32 n)
{
	s32 log2n = -1;
34800e24:	e3e0a000 	mvn	sl, #0
	u32 temp = n;

	while (temp) {
34800e28:	e1b010a1 	lsrs	r1, r1, #1
		log2n++;
34800e2c:	e28aa001 	add	sl, sl, #1
static inline s32 log_2_n_round_up(u32 n)
{
	s32 log2n = -1;
	u32 temp = n;

	while (temp) {
34800e30:	1afffffc 	bne	34800e28 <v7_maint_dcache_all+0x58>
		log2n++;
		temp >>= 1;
	}

	if (n & (n - 1))
34800e34:	e1190002 	tst	r9, r2
		return log2n + 1; /* not power of 2 - round up */
34800e38:	128aa001 	addne	sl, sl, #1
	 * not be a power of 2
	 */
	log2_num_ways = log_2_n_round_up(num_ways);

	way_shift = (32 - log2_num_ways);
	if (operation == ARMV7_DCACHE_INVAL_ALL) {
34800e3c:	e3500001 	cmp	r0, #1
	 * According to ARMv7 ARM number of sets and number of ways need
	 * not be a power of 2
	 */
	log2_num_ways = log_2_n_round_up(num_ways);

	way_shift = (32 - log2_num_ways);
34800e40:	e26aa020 	rsb	sl, sl, #32
	if (operation == ARMV7_DCACHE_INVAL_ALL) {
34800e44:	1a00000b 	bne	34800e78 <v7_maint_dcache_all+0xa8>
	 *	a. count down
	 *	b. have bigger loop inside
	 */
	for (way = num_ways - 1; way >= 0 ; way--) {
		for (set = num_sets - 1; set >= 0; set--) {
			setway = (level << 1) | (set << log2_line_len) |
34800e48:	e184ba12 	orr	fp, r4, r2, lsl sl
	 * For optimal assembly code:
	 *	a. count down
	 *	b. have bigger loop inside
	 */
	for (way = num_ways - 1; way >= 0 ; way--) {
		for (set = num_sets - 1; set >= 0; set--) {
34800e4c:	e1a01007 	mov	r1, r7
			setway = (level << 1) | (set << log2_line_len) |
34800e50:	e1a09004 	mov	r9, r4
34800e54:	e18b4611 	orr	r4, fp, r1, lsl r6
				 (way << way_shift);
			/* Invalidate data/unified cache line by set/way */
			asm volatile ("	mcr p15, 0, %0, c7, c6, 2"
34800e58:	ee074f56 	mcr	15, 0, r4, cr7, cr6, {2}
	 * For optimal assembly code:
	 *	a. count down
	 *	b. have bigger loop inside
	 */
	for (way = num_ways - 1; way >= 0 ; way--) {
		for (set = num_sets - 1; set >= 0; set--) {
34800e5c:	e2511001 	subs	r1, r1, #1
34800e60:	2afffffb 	bcs	34800e54 <v7_maint_dcache_all+0x84>
	/*
	 * For optimal assembly code:
	 *	a. count down
	 *	b. have bigger loop inside
	 */
	for (way = num_ways - 1; way >= 0 ; way--) {
34800e64:	e2522001 	subs	r2, r2, #1
34800e68:	e1a04009 	mov	r4, r9
34800e6c:	2afffff5 	bcs	34800e48 <v7_maint_dcache_all+0x78>
			asm volatile ("	mcr p15, 0, %0, c7, c6, 2"
					: : "r" (setway));
		}
	}
	/* DSB to make sure the operation is complete */
	CP15DSB;
34800e70:	ee075f9a 	mcr	15, 0, r5, cr7, cr10, {4}
34800e74:	ea00000c 	b	34800eac <v7_maint_dcache_all+0xdc>

	way_shift = (32 - log2_num_ways);
	if (operation == ARMV7_DCACHE_INVAL_ALL) {
		v7_inval_dcache_level_setway(level, num_sets, num_ways,
				      way_shift, log2_line_len);
	} else if (operation == ARMV7_DCACHE_CLEAN_INVAL_ALL) {
34800e78:	e3500002 	cmp	r0, #2
34800e7c:	1a00000a 	bne	34800eac <v7_maint_dcache_all+0xdc>
	 *	a. count down
	 *	b. have bigger loop inside
	 */
	for (way = num_ways - 1; way >= 0 ; way--) {
		for (set = num_sets - 1; set >= 0; set--) {
			setway = (level << 1) | (set << log2_line_len) |
34800e80:	e184ba12 	orr	fp, r4, r2, lsl sl
	 * For optimal assembly code:
	 *	a. count down
	 *	b. have bigger loop inside
	 */
	for (way = num_ways - 1; way >= 0 ; way--) {
		for (set = num_sets - 1; set >= 0; set--) {
34800e84:	e1a01007 	mov	r1, r7
			setway = (level << 1) | (set << log2_line_len) |
34800e88:	e1a09004 	mov	r9, r4
34800e8c:	e18b4611 	orr	r4, fp, r1, lsl r6
				 (way << way_shift);
			/*
			 * Clean & Invalidate data/unified
			 * cache line by set/way
			 */
			asm volatile ("	mcr p15, 0, %0, c7, c14, 2"
34800e90:	ee074f5e 	mcr	15, 0, r4, cr7, cr14, {2}
	 * For optimal assembly code:
	 *	a. count down
	 *	b. have bigger loop inside
	 */
	for (way = num_ways - 1; way >= 0 ; way--) {
		for (set = num_sets - 1; set >= 0; set--) {
34800e94:	e2511001 	subs	r1, r1, #1
34800e98:	2afffffb 	bcs	34800e8c <v7_maint_dcache_all+0xbc>
	/*
	 * For optimal assembly code:
	 *	a. count down
	 *	b. have bigger loop inside
	 */
	for (way = num_ways - 1; way >= 0 ; way--) {
34800e9c:	e2522001 	subs	r2, r2, #1
34800ea0:	e1a04009 	mov	r4, r9
34800ea4:	2afffff5 	bcs	34800e80 <v7_maint_dcache_all+0xb0>
			asm volatile ("	mcr p15, 0, %0, c7, c14, 2"
					: : "r" (setway));
		}
	}
	/* DSB to make sure the operation is complete */
	CP15DSB;
34800ea8:	ee075f9a 	mcr	15, 0, r5, cr7, cr10, {4}
{
	u32 level, cache_type, level_start_bit = 0;

	u32 clidr = get_clidr();

	for (level = 0; level < 7; level++) {
34800eac:	e3530012 	cmp	r3, #18
34800eb0:	e28cc001 	add	ip, ip, #1
		cache_type = (clidr >> level_start_bit) & 0x7;
		if ((cache_type == ARMV7_CLIDR_CTYPE_DATA_ONLY) ||
		    (cache_type == ARMV7_CLIDR_CTYPE_INSTRUCTION_DATA) ||
		    (cache_type == ARMV7_CLIDR_CTYPE_UNIFIED))
			v7_maint_dcache_level_setway(level, operation);
		level_start_bit += 3;
34800eb4:	12833003 	addne	r3, r3, #3
34800eb8:	1affffca 	bne	34800de8 <v7_maint_dcache_all+0x18>
	}
}
34800ebc:	e8bd8efc 	pop	{r2, r3, r4, r5, r6, r7, r9, sl, fp, pc}

34800ec0 <v7_dcache_maint_range>:
		asm volatile ("mcr p15, 0, %0, c7, c6, 1" : : "r" (mva));
	}
}

static void v7_dcache_maint_range(u32 start, u32 stop, u32 range_op)
{
34800ec0:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
34800ec4:	e1a04000 	mov	r4, r0
34800ec8:	e1a06001 	mov	r6, r1
static u32 get_ccsidr(void)
{
	u32 ccsidr;

	/* Read current CP15 Cache Size ID Register */
	asm volatile ("mrc p15, 1, %0, c0, c0, 0" : "=r" (ccsidr));
34800ecc:	ee305f10 	mrc	15, 1, r5, cr0, cr0, {0}
static void v7_dcache_maint_range(u32 start, u32 stop, u32 range_op)
{
	u32 line_len, ccsidr;

	ccsidr = get_ccsidr();
	line_len = ((ccsidr & CCSIDR_LINE_SIZE_MASK) >>
34800ed0:	e2055007 	and	r5, r5, #7
			CCSIDR_LINE_SIZE_OFFSET) + 2;
	/* Converting from words to bytes */
	line_len += 2;
34800ed4:	e2855004 	add	r5, r5, #4
	/* converting from log2(linelen) to linelen */
	line_len = 1 << line_len;
34800ed8:	e3a03001 	mov	r3, #1

	switch (range_op) {
34800edc:	e3520003 	cmp	r2, #3
	line_len = ((ccsidr & CCSIDR_LINE_SIZE_MASK) >>
			CCSIDR_LINE_SIZE_OFFSET) + 2;
	/* Converting from words to bytes */
	line_len += 2;
	/* converting from log2(linelen) to linelen */
	line_len = 1 << line_len;
34800ee0:	e1a05513 	lsl	r5, r3, r5

	switch (range_op) {
34800ee4:	0a000009 	beq	34800f10 <v7_dcache_maint_range+0x50>
34800ee8:	e3520004 	cmp	r2, #4
					u32 stop, u32 line_len)
{
	u32 mva;

	/* Align start to cache line boundary */
	start &= ~(line_len - 1);
34800eec:	02653000 	rsbeq	r3, r5, #0
34800ef0:	00034000 	andeq	r4, r3, r0
	/* Converting from words to bytes */
	line_len += 2;
	/* converting from log2(linelen) to linelen */
	line_len = 1 << line_len;

	switch (range_op) {
34800ef4:	1a00001d 	bne	34800f70 <v7_dcache_maint_range+0xb0>
34800ef8:	ea000001 	b	34800f04 <v7_dcache_maint_range+0x44>

	/* Align start to cache line boundary */
	start &= ~(line_len - 1);
	for (mva = start; mva < stop; mva = mva + line_len) {
		/* DCCIMVAC - Clean & Invalidate data cache by MVA to PoC */
		asm volatile ("mcr p15, 0, %0, c7, c14, 1" : : "r" (mva));
34800efc:	ee074f3e 	mcr	15, 0, r4, cr7, cr14, {1}
{
	u32 mva;

	/* Align start to cache line boundary */
	start &= ~(line_len - 1);
	for (mva = start; mva < stop; mva = mva + line_len) {
34800f00:	e0844005 	add	r4, r4, r5
34800f04:	e1540006 	cmp	r4, r6
34800f08:	3afffffb 	bcc	34800efc <v7_dcache_maint_range+0x3c>
34800f0c:	ea000017 	b	34800f70 <v7_dcache_maint_range+0xb0>

	/*
	 * If start address is not aligned to cache-line do not
	 * invalidate the first cache-line
	 */
	if (start & (line_len - 1)) {
34800f10:	e2457001 	sub	r7, r5, #1
34800f14:	e1170000 	tst	r7, r0
34800f18:	0a000007 	beq	34800f3c <v7_dcache_maint_range+0x7c>
		printf("ERROR: %s - start address is not aligned - 0x%08x\n",
34800f1c:	e1a02004 	mov	r2, r4
34800f20:	e59f0054 	ldr	r0, [pc, #84]	; 34800f7c <v7_dcache_maint_range+0xbc>
34800f24:	e59f1054 	ldr	r1, [pc, #84]	; 34800f80 <v7_dcache_maint_range+0xc0>
			__func__, start);
		/* move to next cache line */
		start = (start + line_len - 1) & ~(line_len - 1);
34800f28:	e2444001 	sub	r4, r4, #1
	/*
	 * If start address is not aligned to cache-line do not
	 * invalidate the first cache-line
	 */
	if (start & (line_len - 1)) {
		printf("ERROR: %s - start address is not aligned - 0x%08x\n",
34800f2c:	eb002006 	bl	34808f4c <printf>
			__func__, start);
		/* move to next cache line */
		start = (start + line_len - 1) & ~(line_len - 1);
34800f30:	e0844005 	add	r4, r4, r5
34800f34:	e2653000 	rsb	r3, r5, #0
34800f38:	e0034004 	and	r4, r3, r4

	/*
	 * If stop address is not aligned to cache-line do not
	 * invalidate the last cache-line
	 */
	if (stop & (line_len - 1)) {
34800f3c:	e1170006 	tst	r7, r6
34800f40:	0a000008 	beq	34800f68 <v7_dcache_maint_range+0xa8>
		printf("ERROR: %s - stop address is not aligned - 0x%08x\n",
34800f44:	e1a02006 	mov	r2, r6
34800f48:	e59f0034 	ldr	r0, [pc, #52]	; 34800f84 <v7_dcache_maint_range+0xc4>
34800f4c:	e59f102c 	ldr	r1, [pc, #44]	; 34800f80 <v7_dcache_maint_range+0xc0>
34800f50:	eb001ffd 	bl	34808f4c <printf>
			__func__, stop);
		/* align to the beginning of this cache line */
		stop &= ~(line_len - 1);
34800f54:	e2653000 	rsb	r3, r5, #0
34800f58:	e0066003 	and	r6, r6, r3
34800f5c:	ea000001 	b	34800f68 <v7_dcache_maint_range+0xa8>
	}

	for (mva = start; mva < stop; mva = mva + line_len) {
		/* DCIMVAC - Invalidate data cache by MVA to PoC */
		asm volatile ("mcr p15, 0, %0, c7, c6, 1" : : "r" (mva));
34800f60:	ee074f36 	mcr	15, 0, r4, cr7, cr6, {1}
			__func__, stop);
		/* align to the beginning of this cache line */
		stop &= ~(line_len - 1);
	}

	for (mva = start; mva < stop; mva = mva + line_len) {
34800f64:	e0844005 	add	r4, r4, r5
34800f68:	e1540006 	cmp	r4, r6
34800f6c:	3afffffb 	bcc	34800f60 <v7_dcache_maint_range+0xa0>
		v7_dcache_inval_range(start, stop, line_len);
		break;
	}

	/* DSB to make sure the operation is complete */
	CP15DSB;
34800f70:	e3a03000 	mov	r3, #0
34800f74:	ee073f9a 	mcr	15, 0, r3, cr7, cr10, {4}
}
34800f78:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
34800f7c:	34822b1c 	.word	0x34822b1c
34800f80:	34820354 	.word	0x34820354
34800f84:	34822b4f 	.word	0x34822b4f

34800f88 <invalidate_dcache_all>:
	/* Full system ISB - make sure the instruction stream sees it */
	CP15ISB;
}

void invalidate_dcache_all(void)
{
34800f88:	e92d4010 	push	{r4, lr}
	v7_maint_dcache_all(ARMV7_DCACHE_INVAL_ALL);
34800f8c:	e3a00001 	mov	r0, #1
34800f90:	ebffff8e 	bl	34800dd0 <v7_maint_dcache_all>

	v7_outer_cache_inval_all();
}
34800f94:	e8bd4010 	pop	{r4, lr}

void invalidate_dcache_all(void)
{
	v7_maint_dcache_all(ARMV7_DCACHE_INVAL_ALL);

	v7_outer_cache_inval_all();
34800f98:	ea00002b 	b	3480104c <__v7_outer_cache_inval_all>

34800f9c <flush_dcache_all>:
/*
 * Performs a clean & invalidation of the entire data cache
 * at all levels
 */
void flush_dcache_all(void)
{
34800f9c:	e92d4010 	push	{r4, lr}
	v7_maint_dcache_all(ARMV7_DCACHE_CLEAN_INVAL_ALL);
34800fa0:	e3a00002 	mov	r0, #2
34800fa4:	ebffff89 	bl	34800dd0 <v7_maint_dcache_all>

	v7_outer_cache_flush_all();
}
34800fa8:	e8bd4010 	pop	{r4, lr}
 */
void flush_dcache_all(void)
{
	v7_maint_dcache_all(ARMV7_DCACHE_CLEAN_INVAL_ALL);

	v7_outer_cache_flush_all();
34800fac:	ea000025 	b	34801048 <__v7_outer_cache_flush_all>

34800fb0 <invalidate_dcache_range>:
/*
 * Invalidates range in all levels of D-cache/unified cache used:
 * Affects the range [start, stop - 1]
 */
void invalidate_dcache_range(unsigned long start, unsigned long stop)
{
34800fb0:	e92d4070 	push	{r4, r5, r6, lr}

	v7_dcache_maint_range(start, stop, ARMV7_DCACHE_INVAL_RANGE);
34800fb4:	e3a02003 	mov	r2, #3
/*
 * Invalidates range in all levels of D-cache/unified cache used:
 * Affects the range [start, stop - 1]
 */
void invalidate_dcache_range(unsigned long start, unsigned long stop)
{
34800fb8:	e1a05000 	mov	r5, r0
34800fbc:	e1a04001 	mov	r4, r1

	v7_dcache_maint_range(start, stop, ARMV7_DCACHE_INVAL_RANGE);
34800fc0:	ebffffbe 	bl	34800ec0 <v7_dcache_maint_range>

	v7_outer_cache_inval_range(start, stop);
34800fc4:	e1a00005 	mov	r0, r5
34800fc8:	e1a01004 	mov	r1, r4
}
34800fcc:	e8bd4070 	pop	{r4, r5, r6, lr}
void invalidate_dcache_range(unsigned long start, unsigned long stop)
{

	v7_dcache_maint_range(start, stop, ARMV7_DCACHE_INVAL_RANGE);

	v7_outer_cache_inval_range(start, stop);
34800fd0:	ea00001f 	b	34801054 <__v7_outer_cache_inval_range>

34800fd4 <flush_dcache_range>:
 * Flush range(clean & invalidate) from all levels of D-cache/unified
 * cache used:
 * Affects the range [start, stop - 1]
 */
void flush_dcache_range(unsigned long start, unsigned long stop)
{
34800fd4:	e92d4070 	push	{r4, r5, r6, lr}
	v7_dcache_maint_range(start, stop, ARMV7_DCACHE_CLEAN_INVAL_RANGE);
34800fd8:	e3a02004 	mov	r2, #4
 * Flush range(clean & invalidate) from all levels of D-cache/unified
 * cache used:
 * Affects the range [start, stop - 1]
 */
void flush_dcache_range(unsigned long start, unsigned long stop)
{
34800fdc:	e1a05000 	mov	r5, r0
34800fe0:	e1a04001 	mov	r4, r1
	v7_dcache_maint_range(start, stop, ARMV7_DCACHE_CLEAN_INVAL_RANGE);
34800fe4:	ebffffb5 	bl	34800ec0 <v7_dcache_maint_range>

	v7_outer_cache_flush_range(start, stop);
34800fe8:	e1a00005 	mov	r0, r5
34800fec:	e1a01004 	mov	r1, r4
}
34800ff0:	e8bd4070 	pop	{r4, r5, r6, lr}
 */
void flush_dcache_range(unsigned long start, unsigned long stop)
{
	v7_dcache_maint_range(start, stop, ARMV7_DCACHE_CLEAN_INVAL_RANGE);

	v7_outer_cache_flush_range(start, stop);
34800ff4:	ea000015 	b	34801050 <__v7_outer_cache_flush_range>

34800ff8 <arm_init_before_mmu>:
}

void arm_init_before_mmu(void)
{
34800ff8:	e92d4008 	push	{r3, lr}
	v7_outer_cache_enable();
34800ffc:	eb00023f 	bl	34801900 <v7_outer_cache_enable>
	invalidate_dcache_all();
34801000:	ebffffe0 	bl	34800f88 <invalidate_dcache_all>

/* Invalidate TLB */
static void v7_inval_tlb(void)
{
	/* Invalidate entire unified TLB */
	asm volatile ("mcr p15, 0, %0, c8, c7, 0" : : "r" (0));
34801004:	e3a03000 	mov	r3, #0
34801008:	ee083f17 	mcr	15, 0, r3, cr8, cr7, {0}
	/* Invalidate entire data TLB */
	asm volatile ("mcr p15, 0, %0, c8, c6, 0" : : "r" (0));
3480100c:	ee083f16 	mcr	15, 0, r3, cr8, cr6, {0}
	/* Invalidate entire instruction TLB */
	asm volatile ("mcr p15, 0, %0, c8, c5, 0" : : "r" (0));
34801010:	ee083f15 	mcr	15, 0, r3, cr8, cr5, {0}
	/* Full system DSB - make sure that the invalidation is complete */
	CP15DSB;
34801014:	ee073f9a 	mcr	15, 0, r3, cr7, cr10, {4}
	/* Full system ISB - make sure the instruction stream sees it */
	CP15ISB;
34801018:	ee073f95 	mcr	15, 0, r3, cr7, cr5, {4}
void arm_init_before_mmu(void)
{
	v7_outer_cache_enable();
	invalidate_dcache_all();
	v7_inval_tlb();
}
3480101c:	e8bd8008 	pop	{r3, pc}

34801020 <flush_cache>:
 * Flush range from all levels of d-cache/unified-cache used:
 * Affects the range [start, start + size - 1]
 */
void  flush_cache(unsigned long start, unsigned long size)
{
	flush_dcache_range(start, start + size);
34801020:	e0811000 	add	r1, r1, r0
34801024:	eaffffea 	b	34800fd4 <flush_dcache_range>

34801028 <invalidate_icache_all>:
{
	/*
	 * Invalidate all instruction caches to PoU.
	 * Also flushes branch target cache.
	 */
	asm volatile ("mcr p15, 0, %0, c7, c5, 0" : : "r" (0));
34801028:	e3a03000 	mov	r3, #0
3480102c:	ee073f15 	mcr	15, 0, r3, cr7, cr5, {0}

	/* Invalidate entire branch predictor array */
	asm volatile ("mcr p15, 0, %0, c7, c5, 6" : : "r" (0));
34801030:	ee073fd5 	mcr	15, 0, r3, cr7, cr5, {6}

	/* Full system DSB - make sure that the invalidation is complete */
	CP15DSB;
34801034:	ee073f9a 	mcr	15, 0, r3, cr7, cr10, {4}

	/* ISB - make sure the instruction stream sees it */
	CP15ISB;
34801038:	ee073f95 	mcr	15, 0, r3, cr7, cr5, {4}
}
3480103c:	e12fff1e 	bx	lr

34801040 <__v7_outer_cache_enable>:
/*
 * Stub implementations for outer cache operations
 */
void __v7_outer_cache_enable(void)
{
}
34801040:	e12fff1e 	bx	lr

34801044 <__v7_outer_cache_disable>:
void v7_outer_cache_enable(void)
	__attribute__((weak, alias("__v7_outer_cache_enable")));

void __v7_outer_cache_disable(void)
{
}
34801044:	e12fff1e 	bx	lr

34801048 <__v7_outer_cache_flush_all>:
void v7_outer_cache_disable(void)
	__attribute__((weak, alias("__v7_outer_cache_disable")));

void __v7_outer_cache_flush_all(void)
{
}
34801048:	e12fff1e 	bx	lr

3480104c <__v7_outer_cache_inval_all>:
void v7_outer_cache_flush_all(void)
	__attribute__((weak, alias("__v7_outer_cache_flush_all")));

void __v7_outer_cache_inval_all(void)
{
}
3480104c:	e12fff1e 	bx	lr

34801050 <__v7_outer_cache_flush_range>:
void v7_outer_cache_inval_all(void)
	__attribute__((weak, alias("__v7_outer_cache_inval_all")));

void __v7_outer_cache_flush_range(u32 start, u32 end)
{
}
34801050:	e12fff1e 	bx	lr

34801054 <__v7_outer_cache_inval_range>:
void v7_outer_cache_flush_range(u32 start, u32 end)
	__attribute__((weak, alias("__v7_outer_cache_flush_range")));

void __v7_outer_cache_inval_range(u32 start, u32 end)
{
}
34801054:	e12fff1e 	bx	lr

34801058 <cpu_cache_initialization>:
#include <asm/system.h>
#include <asm/cache.h>
#include <asm/armv7.h>
#include <linux/compiler.h>

void __weak cpu_cache_initialization(void){}
34801058:	e12fff1e 	bx	lr

3480105c <cleanup_before_linux>:

int cleanup_before_linux(void)
{
3480105c:	e92d4008 	push	{r3, lr}
	 * it prepares the processor for linux
	 *
	 * we turn off caches etc ...
	 */
#ifndef CONFIG_SPL_BUILD
	disable_interrupts();
34801060:	eb000387 	bl	34801e84 <disable_interrupts>
#endif

	/*
	 * Turn off I-cache and invalidate it
	 */
	icache_disable();
34801064:	eb000477 	bl	34802248 <icache_disable>
	invalidate_icache_all();
34801068:	ebffffee 	bl	34801028 <invalidate_icache_all>

	/*
	 * turn off D-cache
	 * dcache_disable() in turn flushes the d-cache and disables MMU
	 */
	dcache_disable();
3480106c:	eb00047c 	bl	34802264 <dcache_disable>
	v7_outer_cache_disable();
34801070:	eb000227 	bl	34801914 <v7_outer_cache_disable>
	 * is all we did during this. We have not pushed anything on to the
	 * stack. Neither have we affected any static data)
	 * So just invalidate the entire d-cache again to avoid coherency
	 * problems for kernel
	 */
	invalidate_dcache_all();
34801074:	ebffffc3 	bl	34800f88 <invalidate_dcache_all>

	/*
	 * Some CPU need more cache attention before starting the kernel.
	 */
	cpu_cache_initialization();
34801078:	ebfffff6 	bl	34801058 <cpu_cache_initialization>

	return 0;
}
3480107c:	e3a00000 	mov	r0, #0
34801080:	e8bd8008 	pop	{r3, pc}

34801084 <sdelay>:
 *
 *  not inline to increase chances its in cache when called
 *************************************************************/
void sdelay(unsigned long loops)
{
	__asm__ volatile ("1:\n" "subs %0, %1, #1\n"
34801084:	e2500001 	subs	r0, r0, #1
34801088:	1afffffd 	bne	34801084 <sdelay>
			  "bne 1b":"=r" (loops):"0"(loops));
}
3480108c:	e12fff1e 	bx	lr

34801090 <sr32>:
 * sr32 - clear & set a value in a bit range for a 32 bit address
 *****************************************************************/
void sr32(void *addr, u32 start_bit, u32 num_bits, u32 value)
{
	u32 tmp, msk = 0;
	msk = 1 << num_bits;
34801090:	e3a0c001 	mov	ip, #1

/*****************************************************************
 * sr32 - clear & set a value in a bit range for a 32 bit address
 *****************************************************************/
void sr32(void *addr, u32 start_bit, u32 num_bits, u32 value)
{
34801094:	e92d4010 	push	{r4, lr}
	u32 tmp, msk = 0;
	msk = 1 << num_bits;
34801098:	e1a0c21c 	lsl	ip, ip, r2
	--msk;
	tmp = readl((u32)addr) & ~(msk << start_bit);
3480109c:	e5904000 	ldr	r4, [r0]
 *****************************************************************/
void sr32(void *addr, u32 start_bit, u32 num_bits, u32 value)
{
	u32 tmp, msk = 0;
	msk = 1 << num_bits;
	--msk;
348010a0:	e24cc001 	sub	ip, ip, #1
	tmp = readl((u32)addr) & ~(msk << start_bit);
348010a4:	e1c4c11c 	bic	ip, r4, ip, lsl r1
	tmp |= value << start_bit;
348010a8:	e18c1113 	orr	r1, ip, r3, lsl r1
	writel(tmp, (u32)addr);
348010ac:	e5801000 	str	r1, [r0]
}
348010b0:	e8bd8010 	pop	{r4, pc}

348010b4 <wait_on_value>:
 * wait_on_value() - common routine to allow waiting for changes in
 *   volatile regs.
 *********************************************************************/
u32 wait_on_value(u32 read_bit_mask, u32 match_value, void *read_addr,
		  u32 bound)
{
348010b4:	e92d4010 	push	{r4, lr}
	u32 i = 0, val;
348010b8:	e3a0c000 	mov	ip, #0
	do {
		++i;
		val = readl((u32)read_addr) & read_bit_mask;
348010bc:	e5924000 	ldr	r4, [r2]
348010c0:	e0044000 	and	r4, r4, r0
		if (val == match_value)
348010c4:	e1540001 	cmp	r4, r1
348010c8:	0a000004 	beq	348010e0 <wait_on_value+0x2c>
u32 wait_on_value(u32 read_bit_mask, u32 match_value, void *read_addr,
		  u32 bound)
{
	u32 i = 0, val;
	do {
		++i;
348010cc:	e28cc001 	add	ip, ip, #1
		val = readl((u32)read_addr) & read_bit_mask;
		if (val == match_value)
			return 1;
		if (i == bound)
348010d0:	e15c0003 	cmp	ip, r3
348010d4:	1afffff8 	bne	348010bc <wait_on_value+0x8>
			return 0;
348010d8:	e3a00000 	mov	r0, #0
348010dc:	e8bd8010 	pop	{r4, pc}
	u32 i = 0, val;
	do {
		++i;
		val = readl((u32)read_addr) & read_bit_mask;
		if (val == match_value)
			return 1;
348010e0:	e3a00001 	mov	r0, #1
		if (i == bound)
			return 0;
	} while (1);
}
348010e4:	e8bd8010 	pop	{r4, pc}

348010e8 <arch_cpu_init>:
/* CPU detection macros */
extern unsigned int s5p_cpu_id;

static inline void s5p_set_cpu_id(void)
{
	s5p_cpu_id = readl(S5PC100_PRO_ID);	/* readl io.h涓142琛 */
348010e8:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
348010ec:	e5932000 	ldr	r2, [r3]
	s5p_cpu_id = 0xC000 | ((s5p_cpu_id & 0x00FFF000) >> 12);
348010f0:	e59f3010 	ldr	r3, [pc, #16]	; 34801108 <arch_cpu_init+0x20>
348010f4:	e7eb2652 	ubfx	r2, r2, #12, #12
348010f8:	e3822903 	orr	r2, r2, #49152	; 0xc000
348010fc:	e5832000 	str	r2, [r3]
int arch_cpu_init(void)
{
	s5p_set_cpu_id();

	return 0;
}
34801100:	e3a00000 	mov	r0, #0
34801104:	e12fff1e 	bx	lr
34801108:	34828214 	.word	0x34828214

3480110c <get_device_type>:
#endif

u32 get_device_type(void)
{
	return s5p_cpu_id;
}
3480110c:	e59f3004 	ldr	r3, [pc, #4]	; 34801118 <get_device_type+0xc>
34801110:	e5930000 	ldr	r0, [r3]
34801114:	e12fff1e 	bx	lr
34801118:	34828214 	.word	0x34828214

3480111c <print_cpuinfo>:

#ifdef CONFIG_DISPLAY_CPUINFO
int print_cpuinfo(void)
{
3480111c:	e92d4010 	push	{r4, lr}
	char buf[32];

	printf("CPU:\t%s%X@%sMHz\n",
34801120:	e59f3034 	ldr	r3, [pc, #52]	; 3480115c <print_cpuinfo+0x40>
	return s5p_cpu_id;
}

#ifdef CONFIG_DISPLAY_CPUINFO
int print_cpuinfo(void)
{
34801124:	e24dd020 	sub	sp, sp, #32
	char buf[32];

	printf("CPU:\t%s%X@%sMHz\n",
34801128:	e5934000 	ldr	r4, [r3]
3480112c:	eb0001c7 	bl	34801850 <get_arm_clk>
34801130:	e1a01000 	mov	r1, r0
34801134:	e1a0000d 	mov	r0, sp
34801138:	eb005fc4 	bl	34819050 <strmhz>
3480113c:	e59f101c 	ldr	r1, [pc, #28]	; 34801160 <print_cpuinfo+0x44>
34801140:	e1a03000 	mov	r3, r0
34801144:	e1a02004 	mov	r2, r4
34801148:	e59f0014 	ldr	r0, [pc, #20]	; 34801164 <print_cpuinfo+0x48>
3480114c:	eb001f7e 	bl	34808f4c <printf>
			s5p_get_cpu_name(), s5p_cpu_id,
			strmhz(buf, get_arm_clk()));

	return 0;
}
34801150:	e3a00000 	mov	r0, #0
34801154:	e28dd020 	add	sp, sp, #32
34801158:	e8bd8010 	pop	{r4, pc}
3480115c:	34828214 	.word	0x34828214
34801160:	34822b92 	.word	0x34822b92
34801164:	34822b81 	.word	0x34822b81

34801168 <s5p_get_base_timer>:
static inline int cpu_is_##type(void)			\
{							\
	return s5p_cpu_id == id ? 1 : 0;		\
}

IS_SAMSUNG_TYPE(s5pc100, 0xc100)
34801168:	e59f3028 	ldr	r3, [pc, #40]	; 34801198 <s5p_get_base_timer+0x30>
3480116c:	e5933000 	ldr	r3, [r3]
SAMSUNG_BASE(clock, CLOCK_BASE)
SAMSUNG_BASE(gpio, GPIO_BASE)
SAMSUNG_BASE(pro_id, PRO_ID)
SAMSUNG_BASE(mmc, MMC_BASE)
SAMSUNG_BASE(sromc, SROMC_BASE)
SAMSUNG_BASE(timer, PWMTIMER_BASE)
34801170:	e3530cc1 	cmp	r3, #49408	; 0xc100
34801174:	0a000005 	beq	34801190 <s5p_get_base_timer+0x28>
34801178:	e30c0110 	movw	r0, #49424	; 0xc110
3480117c:	e59f2018 	ldr	r2, [pc, #24]	; 3480119c <s5p_get_base_timer+0x34>
34801180:	e1530000 	cmp	r3, r0
34801184:	01a00002 	moveq	r0, r2
34801188:	13a00000 	movne	r0, #0
3480118c:	e12fff1e 	bx	lr
34801190:	e3a004ea 	mov	r0, #-369098752	; 0xea000000

/* macro to read the 16 bit timer */
static inline struct s5p_timer *s5p_get_base_timer(void)
{
	return (struct s5p_timer *)samsung_get_base_timer();
}
34801194:	e12fff1e 	bx	lr
34801198:	34828214 	.word	0x34828214
3480119c:	e2500000 	.word	0xe2500000

348011a0 <reset_timer_masked>:
	while (get_current_tick() < tmo)
		;	/* nop */
}

void reset_timer_masked(void)
{
348011a0:	e92d4008 	push	{r3, lr}
	struct s5p_timer *const timer = s5p_get_base_timer();
348011a4:	ebffffef 	bl	34801168 <s5p_get_base_timer>

	/* reset time */
	gd->lastinc = readl(&timer->tcnto4);
348011a8:	e5902040 	ldr	r2, [r0, #64]	; 0x40
348011ac:	e5882030 	str	r2, [r8, #48]	; 0x30
	gd->tbl = 0;
348011b0:	e3a02000 	mov	r2, #0
348011b4:	e5882020 	str	r2, [r8, #32]
}
348011b8:	e8bd8008 	pop	{r3, pc}

348011bc <timer_init>:
{
	return (struct s5p_timer *)samsung_get_base_timer();
}

int timer_init(void)
{
348011bc:	e92d4008 	push	{r3, lr}
	/* PWM Timer 4 */
	pwm_init(4, MUX_DIV_2, 0);
348011c0:	e3a01001 	mov	r1, #1
348011c4:	e3a02000 	mov	r2, #0
348011c8:	e3a00004 	mov	r0, #4
348011cc:	eb0000f2 	bl	3480159c <pwm_init>
	pwm_config(4, 0, 0);
348011d0:	e3a01000 	mov	r1, #0
348011d4:	e1a02001 	mov	r2, r1
348011d8:	e3a00004 	mov	r0, #4
348011dc:	eb0000a3 	bl	34801470 <pwm_config>
	pwm_enable(4);
348011e0:	e3a00004 	mov	r0, #4
348011e4:	eb000088 	bl	3480140c <pwm_enable>

	reset_timer_masked();
348011e8:	ebffffec 	bl	348011a0 <reset_timer_masked>

	return 0;
}
348011ec:	e3a00000 	mov	r0, #0
348011f0:	e8bd8008 	pop	{r3, pc}

348011f4 <get_current_tick>:

	return get_current_tick() / count_value;
}

unsigned long get_current_tick(void)
{
348011f4:	e92d4008 	push	{r3, lr}
	struct s5p_timer *const timer = s5p_get_base_timer();
348011f8:	ebffffda 	bl	34801168 <s5p_get_base_timer>
	unsigned long now = readl(&timer->tcnto4);
348011fc:	e5902040 	ldr	r2, [r0, #64]	; 0x40
	unsigned long count_value = readl(&timer->tcntb4);
34801200:	e590103c 	ldr	r1, [r0, #60]	; 0x3c

	if (gd->lastinc >= now)
34801204:	e5980030 	ldr	r0, [r8, #48]	; 0x30
34801208:	e1500002 	cmp	r0, r2
		gd->tbl += gd->lastinc - now;
	else
		gd->tbl += gd->lastinc + count_value - now;
3480120c:	3598c020 	ldrcc	ip, [r8, #32]
	struct s5p_timer *const timer = s5p_get_base_timer();
	unsigned long now = readl(&timer->tcnto4);
	unsigned long count_value = readl(&timer->tcntb4);

	if (gd->lastinc >= now)
		gd->tbl += gd->lastinc - now;
34801210:	25981020 	ldrcs	r1, [r8, #32]
	else
		gd->tbl += gd->lastinc + count_value - now;
34801214:	35980030 	ldrcc	r0, [r8, #48]	; 0x30
	struct s5p_timer *const timer = s5p_get_base_timer();
	unsigned long now = readl(&timer->tcnto4);
	unsigned long count_value = readl(&timer->tcntb4);

	if (gd->lastinc >= now)
		gd->tbl += gd->lastinc - now;
34801218:	25980030 	ldrcs	r0, [r8, #48]	; 0x30
	else
		gd->tbl += gd->lastinc + count_value - now;
3480121c:	308c1001 	addcc	r1, ip, r1
34801220:	e0811000 	add	r1, r1, r0
34801224:	e0621001 	rsb	r1, r2, r1
34801228:	e5881020 	str	r1, [r8, #32]

	gd->lastinc = now;
3480122c:	e5882030 	str	r2, [r8, #48]	; 0x30

	return gd->tbl;
34801230:	e5980020 	ldr	r0, [r8, #32]
}
34801234:	e8bd8008 	pop	{r3, pc}

34801238 <get_timer_masked>:
	gd->lastinc = readl(&timer->tcnto4);
	gd->tbl = 0;
}

unsigned long get_timer_masked(void)
{
34801238:	e92d4010 	push	{r4, lr}
	struct s5p_timer *const timer = s5p_get_base_timer();
3480123c:	ebffffc9 	bl	34801168 <s5p_get_base_timer>
	unsigned long count_value = readl(&timer->tcntb4);
34801240:	e590403c 	ldr	r4, [r0, #60]	; 0x3c

	return get_current_tick() / count_value;
34801244:	ebffffea 	bl	348011f4 <get_current_tick>
34801248:	e1a01004 	mov	r1, r4
3480124c:	eb007b14 	bl	3481fea4 <__udivsi3>
}
34801250:	e8bd8010 	pop	{r4, pc}

34801254 <get_timer>:

/*
 * timer without interrupts
 */
unsigned long get_timer(unsigned long base)
{
34801254:	e92d4010 	push	{r4, lr}
34801258:	e1a04000 	mov	r4, r0
	return get_timer_masked() - base;
3480125c:	ebfffff5 	bl	34801238 <get_timer_masked>
}
34801260:	e0640000 	rsb	r0, r4, r0
34801264:	e8bd8010 	pop	{r4, pc}

34801268 <__udelay>:

/* delay x useconds */
void __udelay(unsigned long usec)
{
34801268:	e92d4038 	push	{r3, r4, r5, lr}
3480126c:	e1a05000 	mov	r5, r0
	struct s5p_timer *const timer = s5p_get_base_timer();
34801270:	ebffffbc 	bl	34801168 <s5p_get_base_timer>
	unsigned long tmo, tmp, count_value;

	count_value = readl(&timer->tcntb4);
34801274:	e590403c 	ldr	r4, [r0, #60]	; 0x3c

	if (usec >= 1000) {
34801278:	e3550ffa 	cmp	r5, #1000	; 0x3e8
3480127c:	3a000006 	bcc	3480129c <__udelay+0x34>
		 * to seconds
		 * 1. start to normalize for usec to ticks per sec
		 * 2. find number of "ticks" to wait to achieve target
		 * 3. finish normalize.
		 */
		tmo = usec / 1000;
34801280:	e3a01ffa 	mov	r1, #1000	; 0x3e8
34801284:	e1a00005 	mov	r0, r5
34801288:	eb007b05 	bl	3481fea4 <__udivsi3>
		tmo *= (CONFIG_SYS_HZ * count_value);
3480128c:	e3a01ffa 	mov	r1, #1000	; 0x3e8
34801290:	e0040491 	mul	r4, r1, r4
		tmo /= 1000;
34801294:	e0000490 	mul	r0, r0, r4
34801298:	ea000003 	b	348012ac <__udelay+0x44>
	} else {
		/* else small number, don't kill it prior to HZ multiply */
		tmo = usec * CONFIG_SYS_HZ * count_value;
3480129c:	e3a03ffa 	mov	r3, #1000	; 0x3e8
348012a0:	e0040493 	mul	r4, r3, r4
		tmo /= (1000 * 1000);
348012a4:	e0000495 	mul	r0, r5, r4
348012a8:	e59f1030 	ldr	r1, [pc, #48]	; 348012e0 <__udelay+0x78>
348012ac:	eb007afc 	bl	3481fea4 <__udivsi3>
348012b0:	e1a05000 	mov	r5, r0
	}

	/* get current timestamp */
	tmp = get_current_tick();
348012b4:	ebffffce 	bl	348011f4 <get_current_tick>

	/* if setting this fordward will roll time stamp */
	/* reset "advancing" timestamp to 0, set lastinc value */
	/* else, set advancing stamp wake up time */
	if ((tmo + tmp + 1) < tmp)
348012b8:	e0804005 	add	r4, r0, r5
348012bc:	e2843001 	add	r3, r4, #1
348012c0:	e1530000 	cmp	r3, r0
348012c4:	2a000001 	bcs	348012d0 <__udelay+0x68>
		reset_timer_masked();
348012c8:	ebffffb4 	bl	348011a0 <reset_timer_masked>
348012cc:	e1a04005 	mov	r4, r5
	else
		tmo += tmp;

	/* loop till event */
	while (get_current_tick() < tmo)
348012d0:	ebffffc7 	bl	348011f4 <get_current_tick>
348012d4:	e1500004 	cmp	r0, r4
348012d8:	3afffffc 	bcc	348012d0 <__udelay+0x68>
		;	/* nop */
}
348012dc:	e8bd8038 	pop	{r3, r4, r5, pc}
348012e0:	000f4240 	.word	0x000f4240

348012e4 <get_ticks>:
/*
 * This function is derived from PowerPC code (read timebase as long long).
 * On ARM it just returns the timer value.
 */
unsigned long long get_ticks(void)
{
348012e4:	e92d4008 	push	{r3, lr}
/*
 * timer without interrupts
 */
unsigned long get_timer(unsigned long base)
{
	return get_timer_masked() - base;
348012e8:	ebffffd2 	bl	34801238 <get_timer_masked>
 * On ARM it just returns the timer value.
 */
unsigned long long get_ticks(void)
{
	return get_timer(0);
}
348012ec:	e3a01000 	mov	r1, #0
348012f0:	e8bd8008 	pop	{r3, pc}

348012f4 <get_tbclk>:
 * On ARM it returns the number of timer ticks per second.
 */
unsigned long get_tbclk(void)
{
	return CONFIG_SYS_HZ;
}
348012f4:	e3a00ffa 	mov	r0, #1000	; 0x3e8
348012f8:	e12fff1e 	bx	lr

348012fc <s5p_config_sromc>:
static inline int cpu_is_##type(void)			\
{							\
	return s5p_cpu_id == id ? 1 : 0;		\
}

IS_SAMSUNG_TYPE(s5pc100, 0xc100)
348012fc:	e59f3040 	ldr	r3, [pc, #64]	; 34801344 <s5p_config_sromc+0x48>
 * srom_bank	- SROM
 * srom_bw_conf  - SMC Band witdh reg configuration value
 * srom_bc_conf  - SMC Bank Control reg configuration value
 */
void s5p_config_sromc(u32 srom_bank, u32 srom_bw_conf, u32 srom_bc_conf)
{
34801300:	e92d4010 	push	{r4, lr}
34801304:	e5933000 	ldr	r3, [r3]

SAMSUNG_BASE(clock, CLOCK_BASE)
SAMSUNG_BASE(gpio, GPIO_BASE)
SAMSUNG_BASE(pro_id, PRO_ID)
SAMSUNG_BASE(mmc, MMC_BASE)
SAMSUNG_BASE(sromc, SROMC_BASE)
34801308:	e3530cc1 	cmp	r3, #49408	; 0xc100
3480130c:	03a034e7 	moveq	r3, #-419430400	; 0xe7000000
34801310:	0a000003 	beq	34801324 <s5p_config_sromc+0x28>
34801314:	e30cc110 	movw	ip, #49424	; 0xc110
34801318:	e153000c 	cmp	r3, ip
3480131c:	03a0333a 	moveq	r3, #-402653184	; 0xe8000000
34801320:	13a03000 	movne	r3, #0
	u32 tmp;
	struct s5p_sromc *srom =
		(struct s5p_sromc *)samsung_get_base_sromc();

	/* Configure SMC_BW register to handle proper SROMC bank */
	tmp = srom->bw;
34801324:	e593c000 	ldr	ip, [r3]
	tmp &= ~(0xF << (srom_bank * 4));
34801328:	e1a00100 	lsl	r0, r0, #2
3480132c:	e3a0400f 	mov	r4, #15
34801330:	e1ccc014 	bic	ip, ip, r4, lsl r0
	tmp |= srom_bw_conf;
34801334:	e18c1001 	orr	r1, ip, r1
	srom->bw = tmp;
34801338:	e6831000 	str	r1, [r3], r0

	/* Configure SMC_BC register */
	srom->bc[srom_bank] = srom_bc_conf;
3480133c:	e5832004 	str	r2, [r3, #4]
}
34801340:	e8bd8010 	pop	{r4, pc}
34801344:	34828214 	.word	0x34828214

34801348 <samsung_get_base_watchdog>:
static inline int cpu_is_##type(void)			\
{							\
	return s5p_cpu_id == id ? 1 : 0;		\
}

IS_SAMSUNG_TYPE(s5pc100, 0xc100)
34801348:	e59f3028 	ldr	r3, [pc, #40]	; 34801378 <samsung_get_base_watchdog+0x30>
3480134c:	e5933000 	ldr	r3, [r3]
SAMSUNG_BASE(pro_id, PRO_ID)
SAMSUNG_BASE(mmc, MMC_BASE)
SAMSUNG_BASE(sromc, SROMC_BASE)
SAMSUNG_BASE(timer, PWMTIMER_BASE)
SAMSUNG_BASE(uart, UART_BASE)
SAMSUNG_BASE(watchdog, WATCHDOG_BASE)
34801350:	e3530cc1 	cmp	r3, #49408	; 0xc100
34801354:	0a000005 	beq	34801370 <samsung_get_base_watchdog+0x28>
34801358:	e30c0110 	movw	r0, #49424	; 0xc110
3480135c:	e59f2018 	ldr	r2, [pc, #24]	; 3480137c <samsung_get_base_watchdog+0x34>
34801360:	e1530000 	cmp	r3, r0
34801364:	01a00002 	moveq	r0, r2
34801368:	13a00000 	movne	r0, #0
3480136c:	e12fff1e 	bx	lr
34801370:	e59f0008 	ldr	r0, [pc, #8]	; 34801380 <samsung_get_base_watchdog+0x38>
34801374:	e12fff1e 	bx	lr
34801378:	34828214 	.word	0x34828214
3480137c:	e2700000 	.word	0xe2700000
34801380:	ea200000 	.word	0xea200000

34801384 <wdt_stop>:
#include <asm/arch/watchdog.h>

#define PRESCALER_VAL 255

void wdt_stop(void)
{
34801384:	e92d4008 	push	{r3, lr}
	struct s5p_watchdog *wdt =
		(struct s5p_watchdog *)samsung_get_base_watchdog();
34801388:	ebffffee 	bl	34801348 <samsung_get_base_watchdog>
	unsigned int wtcon;

	wtcon = readl(&wdt->wtcon);
3480138c:	e5903000 	ldr	r3, [r0]
	wtcon &= ~(WTCON_EN | WTCON_INT | WTCON_RESET);
34801390:	e3c33025 	bic	r3, r3, #37	; 0x25

	writel(wtcon, &wdt->wtcon);
34801394:	e5803000 	str	r3, [r0]
}
34801398:	e8bd8008 	pop	{r3, pc}

3480139c <wdt_start>:

void wdt_start(unsigned int timeout)
{
3480139c:	e92d4038 	push	{r3, r4, r5, lr}
348013a0:	e1a04000 	mov	r4, r0
	struct s5p_watchdog *wdt =
		(struct s5p_watchdog *)samsung_get_base_watchdog();
348013a4:	ebffffe7 	bl	34801348 <samsung_get_base_watchdog>
348013a8:	e1a05000 	mov	r5, r0
	unsigned int wtcon;

	wdt_stop();
348013ac:	ebfffff4 	bl	34801384 <wdt_stop>

	wtcon = readl(&wdt->wtcon);
348013b0:	e5953000 	ldr	r3, [r5]
	wtcon |= (WTCON_EN | WTCON_CLK(WTCON_CLK_128));
348013b4:	e3833038 	orr	r3, r3, #56	; 0x38
	wtcon &= ~WTCON_INT;
348013b8:	e3c33004 	bic	r3, r3, #4
	wtcon |= WTCON_RESET;
	wtcon |= WTCON_PRESCALER(PRESCALER_VAL);
348013bc:	e3833cff 	orr	r3, r3, #65280	; 0xff00
348013c0:	e3833001 	orr	r3, r3, #1

	writel(timeout, &wdt->wtdat);
348013c4:	e5854004 	str	r4, [r5, #4]
	writel(timeout, &wdt->wtcnt);
348013c8:	e5854008 	str	r4, [r5, #8]
	writel(wtcon, &wdt->wtcon);
348013cc:	e5853000 	str	r3, [r5]
}
348013d0:	e8bd8038 	pop	{r3, r4, r5, pc}

348013d4 <samsung_get_base_timer>:
static inline int cpu_is_##type(void)			\
{							\
	return s5p_cpu_id == id ? 1 : 0;		\
}

IS_SAMSUNG_TYPE(s5pc100, 0xc100)
348013d4:	e59f3028 	ldr	r3, [pc, #40]	; 34801404 <samsung_get_base_timer+0x30>
348013d8:	e5933000 	ldr	r3, [r3]
SAMSUNG_BASE(clock, CLOCK_BASE)
SAMSUNG_BASE(gpio, GPIO_BASE)
SAMSUNG_BASE(pro_id, PRO_ID)
SAMSUNG_BASE(mmc, MMC_BASE)
SAMSUNG_BASE(sromc, SROMC_BASE)
SAMSUNG_BASE(timer, PWMTIMER_BASE)
348013dc:	e3530cc1 	cmp	r3, #49408	; 0xc100
348013e0:	0a000005 	beq	348013fc <samsung_get_base_timer+0x28>
348013e4:	e30c0110 	movw	r0, #49424	; 0xc110
348013e8:	e59f2018 	ldr	r2, [pc, #24]	; 34801408 <samsung_get_base_timer+0x34>
348013ec:	e1530000 	cmp	r3, r0
348013f0:	01a00002 	moveq	r0, r2
348013f4:	13a00000 	movne	r0, #0
348013f8:	e12fff1e 	bx	lr
348013fc:	e3a004ea 	mov	r0, #-369098752	; 0xea000000
34801400:	e12fff1e 	bx	lr
34801404:	34828214 	.word	0x34828214
34801408:	e2500000 	.word	0xe2500000

3480140c <pwm_enable>:
#include <asm/io.h>
#include <asm/arch/pwm.h>
#include <asm/arch/clk.h>

int pwm_enable(int pwm_id)
{
3480140c:	e92d4010 	push	{r4, lr}
34801410:	e1a04000 	mov	r4, r0
	const struct s5p_timer *pwm =
			(struct s5p_timer *)samsung_get_base_timer();
34801414:	ebffffee 	bl	348013d4 <samsung_get_base_timer>
	unsigned long tcon;

	tcon = readl(&pwm->tcon);
34801418:	e5903008 	ldr	r3, [r0, #8]
	tcon |= TCON_START(pwm_id);
3480141c:	e3540000 	cmp	r4, #0
34801420:	12844001 	addne	r4, r4, #1
34801424:	03a04000 	moveq	r4, #0
34801428:	e3a02001 	mov	r2, #1
3480142c:	e1a04104 	lsl	r4, r4, #2
34801430:	e1834412 	orr	r4, r3, r2, lsl r4

	writel(tcon, &pwm->tcon);
34801434:	e5804008 	str	r4, [r0, #8]

	return 0;
}
34801438:	e3a00000 	mov	r0, #0
3480143c:	e8bd8010 	pop	{r4, pc}

34801440 <pwm_disable>:

void pwm_disable(int pwm_id)
{
34801440:	e92d4010 	push	{r4, lr}
34801444:	e1a04000 	mov	r4, r0
	const struct s5p_timer *pwm =
			(struct s5p_timer *)samsung_get_base_timer();
34801448:	ebffffe1 	bl	348013d4 <samsung_get_base_timer>
	unsigned long tcon;

	tcon = readl(&pwm->tcon);
3480144c:	e5903008 	ldr	r3, [r0, #8]
	tcon &= ~TCON_START(pwm_id);
34801450:	e3540000 	cmp	r4, #0
34801454:	12844001 	addne	r4, r4, #1
34801458:	03a04000 	moveq	r4, #0
3480145c:	e3a02001 	mov	r2, #1
34801460:	e1a04104 	lsl	r4, r4, #2
34801464:	e1c34412 	bic	r4, r3, r2, lsl r4

	writel(tcon, &pwm->tcon);
34801468:	e5804008 	str	r4, [r0, #8]
}
3480146c:	e8bd8010 	pop	{r4, pc}

34801470 <pwm_config>:
}

#define NS_IN_HZ (1000000000UL)

int pwm_config(int pwm_id, int duty_ns, int period_ns)
{
34801470:	e92d4ef3 	push	{r0, r1, r4, r5, r6, r7, r9, sl, fp, lr}
34801474:	e1a05001 	mov	r5, r1
34801478:	e1a07002 	mov	r7, r2
3480147c:	e1a04000 	mov	r4, r0
	const struct s5p_timer *pwm =
			(struct s5p_timer *)samsung_get_base_timer();
34801480:	ebffffd3 	bl	348013d4 <samsung_get_base_timer>
34801484:	e1a06000 	mov	r6, r0
	/*
	 * We currently avoid using 64bit arithmetic by using the
	 * fact that anything faster than 1GHz is easily representable
	 * by 32bits.
	 */
	if (period_ns > NS_IN_HZ || duty_ns > NS_IN_HZ)
34801488:	e59f0108 	ldr	r0, [pc, #264]	; 34801598 <pwm_config+0x128>
3480148c:	e1550000 	cmp	r5, r0
34801490:	91570000 	cmpls	r7, r0
		return -ERANGE;
34801494:	83e00021 	mvnhi	r0, #33	; 0x21
	/*
	 * We currently avoid using 64bit arithmetic by using the
	 * fact that anything faster than 1GHz is easily representable
	 * by 32bits.
	 */
	if (period_ns > NS_IN_HZ || duty_ns > NS_IN_HZ)
34801498:	8a00003d 	bhi	34801594 <pwm_config+0x124>
		return -ERANGE;

	if (duty_ns > period_ns)
3480149c:	e1550007 	cmp	r5, r7
		return -EINVAL;
348014a0:	c3e00015 	mvngt	r0, #21
	 * by 32bits.
	 */
	if (period_ns > NS_IN_HZ || duty_ns > NS_IN_HZ)
		return -ERANGE;

	if (duty_ns > period_ns)
348014a4:	ca00003a 	bgt	34801594 <pwm_config+0x124>
		return -EINVAL;

	period = NS_IN_HZ / period_ns;
348014a8:	e1a01007 	mov	r1, r7
348014ac:	eb007a7c 	bl	3481fea4 <__udivsi3>
348014b0:	e58d0004 	str	r0, [sp, #4]
static unsigned long pwm_calc_tin(int pwm_id, unsigned long freq)
{
	unsigned long tin_parent_rate;
	unsigned int div;

	tin_parent_rate = get_pwm_clk();
348014b4:	eb0000ff 	bl	348018b8 <get_pwm_clk>
348014b8:	e3a0b004 	mov	fp, #4
348014bc:	e1a09000 	mov	r9, r0

	for (div = 2; div <= 16; div *= 2) {
348014c0:	e3a0a002 	mov	sl, #2
		if ((tin_parent_rate / (div << 16)) < freq)
348014c4:	e1a00009 	mov	r0, r9
348014c8:	e1a0180a 	lsl	r1, sl, #16
348014cc:	eb007a74 	bl	3481fea4 <__udivsi3>
348014d0:	e59d3004 	ldr	r3, [sp, #4]
348014d4:	e1500003 	cmp	r0, r3
348014d8:	2a000004 	bcs	348014f0 <pwm_config+0x80>
			return tin_parent_rate / div;
348014dc:	e1a0100a 	mov	r1, sl
348014e0:	e1a00009 	mov	r0, r9
348014e4:	eb007a6e 	bl	3481fea4 <__udivsi3>
348014e8:	e1a01000 	mov	r1, r0
348014ec:	ea000003 	b	34801500 <pwm_config+0x90>
	unsigned long tin_parent_rate;
	unsigned int div;

	tin_parent_rate = get_pwm_clk();

	for (div = 2; div <= 16; div *= 2) {
348014f0:	e25bb001 	subs	fp, fp, #1
348014f4:	e1a0a08a 	lsl	sl, sl, #1
348014f8:	1afffff1 	bne	348014c4 <pwm_config+0x54>
		if ((tin_parent_rate / (div << 16)) < freq)
			return tin_parent_rate / div;
	}

	return tin_parent_rate / 16;
348014fc:	e1a01229 	lsr	r1, r9, #4
	period = NS_IN_HZ / period_ns;

	/* Check to see if we are changing the clock rate of the PWM */
	tin_rate = pwm_calc_tin(pwm_id, period);

	tin_ns = NS_IN_HZ / tin_rate;
34801500:	e59f0090 	ldr	r0, [pc, #144]	; 34801598 <pwm_config+0x128>
34801504:	eb007a66 	bl	3481fea4 <__udivsi3>
34801508:	e1a0a000 	mov	sl, r0
	tcnt = period_ns / tin_ns;
3480150c:	e1a0100a 	mov	r1, sl
34801510:	e1a00007 	mov	r0, r7
34801514:	eb007a62 	bl	3481fea4 <__udivsi3>

	/* Note, counters count down */
	tcmp = duty_ns / tin_ns;
34801518:	e1a0100a 	mov	r1, sl

	/* Check to see if we are changing the clock rate of the PWM */
	tin_rate = pwm_calc_tin(pwm_id, period);

	tin_ns = NS_IN_HZ / tin_rate;
	tcnt = period_ns / tin_ns;
3480151c:	e1a07000 	mov	r7, r0

	/* Note, counters count down */
	tcmp = duty_ns / tin_ns;
34801520:	e1a00005 	mov	r0, r5
34801524:	eb007a5e 	bl	3481fea4 <__udivsi3>
	tcmp = tcnt - tcmp;
34801528:	e0600007 	rsb	r0, r0, r7

	/*
	 * the pwm hw only checks the compare register after a decrement,
	 * so the pin never toggles if tcmp = tcnt
	 */
	if (tcmp == tcnt)
3480152c:	e1500007 	cmp	r0, r7
		tcmp--;
34801530:	02400001 	subeq	r0, r0, #1
	if (tcmp < 0)
		tcmp = 0;

	/* Update the PWM register block. */
	offset = pwm_id * 3;
	if (pwm_id < 4) {
34801534:	e3540003 	cmp	r4, #3
34801538:	ca000004 	bgt	34801550 <pwm_config+0xe0>

	if (tcmp < 0)
		tcmp = 0;

	/* Update the PWM register block. */
	offset = pwm_id * 3;
3480153c:	e0843084 	add	r3, r4, r4, lsl #1
	if (pwm_id < 4) {
		writel(tcnt, &pwm->tcntb0 + offset);
34801540:	e286200c 	add	r2, r6, #12
34801544:	e7827103 	str	r7, [r2, r3, lsl #2]
		writel(tcmp, &pwm->tcmpb0 + offset);
34801548:	e2862010 	add	r2, r6, #16
3480154c:	e7820103 	str	r0, [r2, r3, lsl #2]
	}

	tcon = readl(&pwm->tcon);
34801550:	e5961008 	ldr	r1, [r6, #8]
	tcon |= TCON_UPDATE(pwm_id);
34801554:	e3540000 	cmp	r4, #0
34801558:	1284c001 	addne	ip, r4, #1
3480155c:	03a0c000 	moveq	ip, #0
34801560:	e1a0c10c 	lsl	ip, ip, #2
34801564:	e3a00001 	mov	r0, #1
34801568:	e28c2001 	add	r2, ip, #1
3480156c:	e1a02210 	lsl	r2, r0, r2
	if (pwm_id < 4)
34801570:	e3540003 	cmp	r4, #3
		writel(tcnt, &pwm->tcntb0 + offset);
		writel(tcmp, &pwm->tcmpb0 + offset);
	}

	tcon = readl(&pwm->tcon);
	tcon |= TCON_UPDATE(pwm_id);
34801574:	e1821001 	orr	r1, r2, r1
	if (pwm_id < 4)
		tcon |= TCON_AUTO_RELOAD(pwm_id);
34801578:	d28c3003 	addle	r3, ip, #3
3480157c:	d1813310 	orrle	r3, r1, r0, lsl r3
	else
		tcon |= TCON4_AUTO_RELOAD;
34801580:	c3813501 	orrgt	r3, r1, #4194304	; 0x400000
	writel(tcon, &pwm->tcon);
34801584:	e5863008 	str	r3, [r6, #8]

	tcon &= ~TCON_UPDATE(pwm_id);
34801588:	e1c33002 	bic	r3, r3, r2
	writel(tcon, &pwm->tcon);

	return 0;
3480158c:	e3a00000 	mov	r0, #0
	else
		tcon |= TCON4_AUTO_RELOAD;
	writel(tcon, &pwm->tcon);

	tcon &= ~TCON_UPDATE(pwm_id);
	writel(tcon, &pwm->tcon);
34801590:	e5863008 	str	r3, [r6, #8]

	return 0;
}
34801594:	e8bd8efc 	pop	{r2, r3, r4, r5, r6, r7, r9, sl, fp, pc}
34801598:	3b9aca00 	.word	0x3b9aca00

3480159c <pwm_init>:

int pwm_init(int pwm_id, int div, int invert)
{
3480159c:	e92d46f8 	push	{r3, r4, r5, r6, r7, r9, sl, lr}
348015a0:	e1a04000 	mov	r4, r0
348015a4:	e1a07001 	mov	r7, r1
348015a8:	e1a0a002 	mov	sl, r2
	u32 val;
	const struct s5p_timer *pwm =
			(struct s5p_timer *)samsung_get_base_timer();
348015ac:	ebffff88 	bl	348013d4 <samsung_get_base_timer>
	/*
	 * Timer Freq(HZ) =
	 *	PWM_CLK / { (prescaler_value + 1) * (divider_value) }
	 */

	val = readl(&pwm->tcfg0);
348015b0:	e5903000 	ldr	r3, [r0]

int pwm_init(int pwm_id, int div, int invert)
{
	u32 val;
	const struct s5p_timer *pwm =
			(struct s5p_timer *)samsung_get_base_timer();
348015b4:	e1a05000 	mov	r5, r0
	 * Timer Freq(HZ) =
	 *	PWM_CLK / { (prescaler_value + 1) * (divider_value) }
	 */

	val = readl(&pwm->tcfg0);
	if (pwm_id < 2) {
348015b8:	e3540001 	cmp	r4, #1
		prescaler = PRESCALER_0;
		val &= ~0xff;
348015bc:	d3c330ff 	bicle	r3, r3, #255	; 0xff
		val |= (prescaler & 0xff);
	} else {
		prescaler = PRESCALER_1;
		val &= ~(0xff << 8);
348015c0:	c3c33cff 	bicgt	r3, r3, #65280	; 0xff00

	val = readl(&pwm->tcfg0);
	if (pwm_id < 2) {
		prescaler = PRESCALER_0;
		val &= ~0xff;
		val |= (prescaler & 0xff);
348015c4:	d3833007 	orrle	r3, r3, #7
	 *	PWM_CLK / { (prescaler_value + 1) * (divider_value) }
	 */

	val = readl(&pwm->tcfg0);
	if (pwm_id < 2) {
		prescaler = PRESCALER_0;
348015c8:	d3a09007 	movle	r9, #7
		val &= ~0xff;
		val |= (prescaler & 0xff);
	} else {
		prescaler = PRESCALER_1;
		val &= ~(0xff << 8);
		val |= (prescaler & 0xff) << 8;
348015cc:	c3833c0f 	orrgt	r3, r3, #3840	; 0xf00
	if (pwm_id < 2) {
		prescaler = PRESCALER_0;
		val &= ~0xff;
		val |= (prescaler & 0xff);
	} else {
		prescaler = PRESCALER_1;
348015d0:	c3a0900f 	movgt	r9, #15
		val &= ~(0xff << 8);
		val |= (prescaler & 0xff) << 8;
	}
	writel(val, &pwm->tcfg0);
348015d4:	e5803000 	str	r3, [r0]
	val = readl(&pwm->tcfg1);
348015d8:	e5902004 	ldr	r2, [r0, #4]
	val &= ~(0xf << MUX_DIV_SHIFT(pwm_id));
348015dc:	e3a0600f 	mov	r6, #15
348015e0:	e1a03104 	lsl	r3, r4, #2
348015e4:	e1c22316 	bic	r2, r2, r6, lsl r3
	val |= (div & 0xf) << MUX_DIV_SHIFT(pwm_id);
348015e8:	e0071006 	and	r1, r7, r6
348015ec:	e1823311 	orr	r3, r2, r1, lsl r3
	writel(val, &pwm->tcfg1);
348015f0:	e5803004 	str	r3, [r0, #4]

	timer_rate_hz = get_pwm_clk() / ((prescaler + 1) *
348015f4:	eb0000af 	bl	348018b8 <get_pwm_clk>
348015f8:	e2899001 	add	r9, r9, #1
			(div + 1));
348015fc:	e2871001 	add	r1, r7, #1
	val = readl(&pwm->tcfg1);
	val &= ~(0xf << MUX_DIV_SHIFT(pwm_id));
	val |= (div & 0xf) << MUX_DIV_SHIFT(pwm_id);
	writel(val, &pwm->tcfg1);

	timer_rate_hz = get_pwm_clk() / ((prescaler + 1) *
34801600:	e0010991 	mul	r1, r1, r9
34801604:	eb007a26 	bl	3481fea4 <__udivsi3>
			(div + 1));

	timer_rate_hz = timer_rate_hz / CONFIG_SYS_HZ;
34801608:	e3a01ffa 	mov	r1, #1000	; 0x3e8
3480160c:	eb007a24 	bl	3481fea4 <__udivsi3>

	/* set count value */
	offset = pwm_id * 3;
34801610:	e0842084 	add	r2, r4, r4, lsl #1
	writel(timer_rate_hz, &pwm->tcntb0 + offset);
34801614:	e285300c 	add	r3, r5, #12
34801618:	e7830102 	str	r0, [r3, r2, lsl #2]

	val = readl(&pwm->tcon) & ~(0xf << TCON_OFFSET(pwm_id));
3480161c:	e5952008 	ldr	r2, [r5, #8]
34801620:	e3540000 	cmp	r4, #0
34801624:	12843001 	addne	r3, r4, #1
34801628:	03a03000 	moveq	r3, #0
3480162c:	e1a03103 	lsl	r3, r3, #2
34801630:	e1c26316 	bic	r6, r2, r6, lsl r3
	if (invert && (pwm_id < 4))
34801634:	e25aa000 	subs	sl, sl, #0
34801638:	13a0a001 	movne	sl, #1
3480163c:	e3540003 	cmp	r4, #3
34801640:	c3a0a000 	movgt	sl, #0
34801644:	e35a0000 	cmp	sl, #0
		val |= TCON_INVERTER(pwm_id);
34801648:	12833002 	addne	r3, r3, #2
3480164c:	13a02001 	movne	r2, #1
34801650:	11866312 	orrne	r6, r6, r2, lsl r3
	writel(val, &pwm->tcon);
34801654:	e5856008 	str	r6, [r5, #8]

	pwm_enable(pwm_id);
34801658:	e1a00004 	mov	r0, r4
3480165c:	ebffff6a 	bl	3480140c <pwm_enable>

	return 0;
}
34801660:	e3a00000 	mov	r0, #0
34801664:	e8bd86f8 	pop	{r3, r4, r5, r6, r7, r9, sl, pc}
	...

34801680 <samsung_get_base_clock>:
static inline int cpu_is_##type(void)			\
{							\
	return s5p_cpu_id == id ? 1 : 0;		\
}

IS_SAMSUNG_TYPE(s5pc100, 0xc100)
34801680:	e59f3028 	ldr	r3, [pc, #40]	; 348016b0 <samsung_get_base_clock+0x30>
34801684:	e5933000 	ldr	r3, [r3]
		return S5PC110_##base;				\
	else							\
		return 0;					\
}

SAMSUNG_BASE(clock, CLOCK_BASE)
34801688:	e3530cc1 	cmp	r3, #49408	; 0xc100
3480168c:	0a000005 	beq	348016a8 <samsung_get_base_clock+0x28>
34801690:	e30c0110 	movw	r0, #49424	; 0xc110
34801694:	e59f2018 	ldr	r2, [pc, #24]	; 348016b4 <samsung_get_base_clock+0x34>
34801698:	e1530000 	cmp	r3, r0
3480169c:	01a00002 	moveq	r0, r2
348016a0:	13a00000 	movne	r0, #0
348016a4:	e12fff1e 	bx	lr
348016a8:	e59f0004 	ldr	r0, [pc, #4]	; 348016b4 <samsung_get_base_clock+0x34>
348016ac:	e12fff1e 	bx	lr
348016b0:	34828214 	.word	0x34828214
348016b4:	e0100000 	.word	0xe0100000

348016b8 <get_pll_clk>:
	else
		return s5pc100_get_pclk();
}

unsigned long get_pll_clk(int pllreg)
{
348016b8:	e92d4038 	push	{r3, r4, r5, lr}
	if (cpu_is_s5pc110())
348016bc:	e59f3114 	ldr	r3, [pc, #276]	; 348017d8 <get_pll_clk+0x120>
	else
		return s5pc100_get_pclk();
}

unsigned long get_pll_clk(int pllreg)
{
348016c0:	e1a05000 	mov	r5, r0
	if (cpu_is_s5pc110())
348016c4:	e5932000 	ldr	r2, [r3]
348016c8:	e30c3110 	movw	r3, #49424	; 0xc110
348016cc:	e1520003 	cmp	r2, r3
348016d0:	1a000020 	bne	34801758 <get_pll_clk+0xa0>

/* s5pc100: return pll clock frequency */
static unsigned long s5pc110_get_pll_clk(int pllreg)
{
	struct s5pc110_clock *clk =
		(struct s5pc110_clock *)samsung_get_base_clock();
348016d4:	ebffffe9 	bl	34801680 <samsung_get_base_clock>
	unsigned long r, m, p, s, mask, fout;
	unsigned int freq;

	switch (pllreg) {
348016d8:	e3550004 	cmp	r5, #4
348016dc:	979ff105 	ldrls	pc, [pc, r5, lsl #2]
348016e0:	ea00002d 	b	3480179c <get_pll_clk+0xe4>
348016e4:	348016f8 	.word	0x348016f8
348016e8:	34801700 	.word	0x34801700
348016ec:	34801708 	.word	0x34801708
348016f0:	3480179c 	.word	0x3480179c
348016f4:	34801710 	.word	0x34801710
	case APLL:
		r = readl(&clk->apll_con);
348016f8:	e5903100 	ldr	r3, [r0, #256]	; 0x100
348016fc:	ea000004 	b	34801714 <get_pll_clk+0x5c>
		break;
	case MPLL:
		r = readl(&clk->mpll_con);
34801700:	e5903108 	ldr	r3, [r0, #264]	; 0x108
34801704:	ea000002 	b	34801714 <get_pll_clk+0x5c>
		break;
	case EPLL:
		r = readl(&clk->epll_con);
34801708:	e5903110 	ldr	r3, [r0, #272]	; 0x110
3480170c:	ea000000 	b	34801714 <get_pll_clk+0x5c>
		break;
	case VPLL:
		r = readl(&clk->vpll_con);
34801710:	e5903120 	ldr	r3, [r0, #288]	; 0x120
	 * MPLL_CON: MIDV [25:16]
	 * EPLL_CON: MIDV [24:16]
	 * VPLL_CON: MIDV [24:16]
	 */
	if (pllreg == APLL || pllreg == MPLL)
		mask = 0x3ff;
34801714:	e3550001 	cmp	r5, #1
34801718:	e30023ff 	movw	r2, #1023	; 0x3ff
3480171c:	e30041ff 	movw	r4, #511	; 0x1ff
34801720:	91a04002 	movls	r4, r2
	p = (r >> 8) & 0x3f;
	/* SDIV [2:0] */
	s = r & 0x7;

	freq = CONFIG_SYS_CLK_FREQ_C110;
	if (pllreg == APLL) {
34801724:	e3550000 	cmp	r5, #0
	if (pllreg == APLL || pllreg == MPLL)
		mask = 0x3ff;
	else
		mask = 0x1ff;

	m = (r >> 16) & mask;
34801728:	e0044823 	and	r4, r4, r3, lsr #16

	/* PDIV [13:8] */
	p = (r >> 8) & 0x3f;
3480172c:	e7e51453 	ubfx	r1, r3, #8, #6
	/* SDIV [2:0] */
	s = r & 0x7;
34801730:	e2033007 	and	r3, r3, #7

	freq = CONFIG_SYS_CLK_FREQ_C110;
	if (pllreg == APLL) {
34801734:	1a000002 	bne	34801744 <get_pll_clk+0x8c>
		if (s < 1)
			s = 1;
34801738:	e3530000 	cmp	r3, #0
3480173c:	03a03001 	moveq	r3, #1
		/* FOUT = MDIV * FIN / (PDIV * 2^(SDIV - 1)) */
		fout = m * (freq / (p * (1 << (s - 1))));
34801740:	e2433001 	sub	r3, r3, #1
	} else
		/* FOUT = MDIV * FIN / (PDIV * 2^SDIV) */
		fout = m * (freq / (p * (1 << s)));
34801744:	e59f0090 	ldr	r0, [pc, #144]	; 348017dc <get_pll_clk+0x124>
34801748:	e1a01311 	lsl	r1, r1, r3
3480174c:	eb0079d4 	bl	3481fea4 <__udivsi3>
34801750:	e0000490 	mul	r0, r0, r4
34801754:	e8bd8038 	pop	{r3, r4, r5, pc}

/* s5pc110: return pll clock frequency */
static unsigned long s5pc100_get_pll_clk(int pllreg)
{
	struct s5pc100_clock *clk =
		(struct s5pc100_clock *)samsung_get_base_clock();
34801758:	ebffffc8 	bl	34801680 <samsung_get_base_clock>
	unsigned long r, m, p, s, mask, fout;
	unsigned int freq;

	switch (pllreg) {
3480175c:	e3550003 	cmp	r5, #3
34801760:	979ff105 	ldrls	pc, [pc, r5, lsl #2]
34801764:	ea00000c 	b	3480179c <get_pll_clk+0xe4>
34801768:	34801778 	.word	0x34801778
3480176c:	34801784 	.word	0x34801784
34801770:	3480178c 	.word	0x3480178c
34801774:	34801794 	.word	0x34801794
	case APLL:
		r = readl(&clk->apll_con);
34801778:	e5904100 	ldr	r4, [r0, #256]	; 0x100
	 * MPLL_CON: MIDV [23:16]
	 * EPLL_CON: MIDV [23:16]
	 * HPLL_CON: MIDV [23:16]
	 */
	if (pllreg == APLL)
		mask = 0x3ff;
3480177c:	e30053ff 	movw	r5, #1023	; 0x3ff
34801780:	ea00000a 	b	348017b0 <get_pll_clk+0xf8>
	switch (pllreg) {
	case APLL:
		r = readl(&clk->apll_con);
		break;
	case MPLL:
		r = readl(&clk->mpll_con);
34801784:	e5904104 	ldr	r4, [r0, #260]	; 0x104
34801788:	ea000010 	b	348017d0 <get_pll_clk+0x118>
		break;
	case EPLL:
		r = readl(&clk->epll_con);
3480178c:	e5904108 	ldr	r4, [r0, #264]	; 0x108
34801790:	ea00000e 	b	348017d0 <get_pll_clk+0x118>
		break;
	case HPLL:
		r = readl(&clk->hpll_con);
34801794:	e590410c 	ldr	r4, [r0, #268]	; 0x10c
34801798:	ea00000c 	b	348017d0 <get_pll_clk+0x118>
		break;
	default:
		printf("Unsupported PLL (%d)\n", pllreg);
3480179c:	e59f003c 	ldr	r0, [pc, #60]	; 348017e0 <get_pll_clk+0x128>
348017a0:	e1a01005 	mov	r1, r5
348017a4:	eb001de8 	bl	34808f4c <printf>
		return 0;
348017a8:	e3a00000 	mov	r0, #0
348017ac:	e8bd8038 	pop	{r3, r4, r5, pc}
	m = (r >> 16) & mask;

	/* PDIV [13:8] */
	p = (r >> 8) & 0x3f;
	/* SDIV [2:0] */
	s = r & 0x7;
348017b0:	e2043007 	and	r3, r4, #7
		mask = 0x0ff;

	m = (r >> 16) & mask;

	/* PDIV [13:8] */
	p = (r >> 8) & 0x3f;
348017b4:	e7e51454 	ubfx	r1, r4, #8, #6
	/* SDIV [2:0] */
	s = r & 0x7;

	/* FOUT = MDIV * FIN / (PDIV * 2^SDIV) */
	freq = CONFIG_SYS_CLK_FREQ_C100;
	fout = m * (freq / (p * (1 << s)));
348017b8:	e1a01311 	lsl	r1, r1, r3
348017bc:	e59f0020 	ldr	r0, [pc, #32]	; 348017e4 <get_pll_clk+0x12c>
348017c0:	eb0079b7 	bl	3481fea4 <__udivsi3>
	if (pllreg == APLL)
		mask = 0x3ff;
	else
		mask = 0x0ff;

	m = (r >> 16) & mask;
348017c4:	e0054824 	and	r4, r5, r4, lsr #16
	/* SDIV [2:0] */
	s = r & 0x7;

	/* FOUT = MDIV * FIN / (PDIV * 2^SDIV) */
	freq = CONFIG_SYS_CLK_FREQ_C100;
	fout = m * (freq / (p * (1 << s)));
348017c8:	e0000094 	mul	r0, r4, r0
{
	if (cpu_is_s5pc110())
		return s5pc110_get_pll_clk(pllreg);
	else
		return s5pc100_get_pll_clk(pllreg);
}
348017cc:	e8bd8038 	pop	{r3, r4, r5, pc}
	 * HPLL_CON: MIDV [23:16]
	 */
	if (pllreg == APLL)
		mask = 0x3ff;
	else
		mask = 0x0ff;
348017d0:	e3a050ff 	mov	r5, #255	; 0xff
348017d4:	eafffff5 	b	348017b0 <get_pll_clk+0xf8>
348017d8:	34828214 	.word	0x34828214
348017dc:	016e3600 	.word	0x016e3600
348017e0:	34822b96 	.word	0x34822b96
348017e4:	00b71b00 	.word	0x00b71b00

348017e8 <s5pc100_get_pclk>:
	return get_pclk_sys(CLK_P);
}

/* s5pc100: return peripheral clock frequency */
static unsigned long s5pc100_get_pclk(void)
{
348017e8:	e92d4010 	push	{r4, lr}

/* s5pc100: return PCLKD1 frequency */
static unsigned long get_pclkd1(void)
{
	struct s5pc100_clock *clk =
		(struct s5pc100_clock *)samsung_get_base_clock();
348017ec:	ebffffa3 	bl	34801680 <samsung_get_base_clock>
	unsigned long d1_bus, pclkd1;
	uint div, d1_bus_ratio, pclkd1_ratio;

	div = readl(&clk->div0);
348017f0:	e5904300 	ldr	r4, [r0, #768]	; 0x300
	d1_bus_ratio = (div >> 12) & 0x7;
	/* PCLKD1_RATIO: [18:16] */
	pclkd1_ratio = (div >> 16) & 0x7;

	/* ASYNC Mode */
	d1_bus = get_pll_clk(MPLL) / (d1_bus_ratio + 1);
348017f4:	e3a00001 	mov	r0, #1
348017f8:	ebffffae 	bl	348016b8 <get_pll_clk>
	unsigned long d1_bus, pclkd1;
	uint div, d1_bus_ratio, pclkd1_ratio;

	div = readl(&clk->div0);
	/* D1_BUS_RATIO: [14:12] */
	d1_bus_ratio = (div >> 12) & 0x7;
348017fc:	e7e21654 	ubfx	r1, r4, #12, #3
	/* PCLKD1_RATIO: [18:16] */
	pclkd1_ratio = (div >> 16) & 0x7;

	/* ASYNC Mode */
	d1_bus = get_pll_clk(MPLL) / (d1_bus_ratio + 1);
34801800:	e2811001 	add	r1, r1, #1
34801804:	eb0079a6 	bl	3481fea4 <__udivsi3>

	div = readl(&clk->div0);
	/* D1_BUS_RATIO: [14:12] */
	d1_bus_ratio = (div >> 12) & 0x7;
	/* PCLKD1_RATIO: [18:16] */
	pclkd1_ratio = (div >> 16) & 0x7;
34801808:	e7e21854 	ubfx	r1, r4, #16, #3

	/* ASYNC Mode */
	d1_bus = get_pll_clk(MPLL) / (d1_bus_ratio + 1);
	pclkd1 = d1_bus / (pclkd1_ratio + 1);
3480180c:	e2811001 	add	r1, r1, #1
34801810:	eb0079a3 	bl	3481fea4 <__udivsi3>

/* s5pc100: return peripheral clock frequency */
static unsigned long s5pc100_get_pclk(void)
{
	return get_pclkd1();
}
34801814:	e8bd8010 	pop	{r4, pc}

34801818 <s5pc110_get_pclk>:
	return pclk;
}

/* s5pc110: return peripheral clock frequency */
static unsigned long s5pc110_get_pclk(void)
{
34801818:	e92d4038 	push	{r3, r4, r5, lr}

/* s5pc110: return PCLKs frequency */
static unsigned long get_pclk_sys(int dom)
{
	struct s5pc110_clock *clk =
		(struct s5pc110_clock *)samsung_get_base_clock();
3480181c:	ebffff97 	bl	34801680 <samsung_get_base_clock>
	unsigned long pclk;
	unsigned int div;
	unsigned int offset;
	unsigned int pclk_sys_ratio;

	div = readl(&clk->div0);
34801820:	e5904300 	ldr	r4, [r0, #768]	; 0x300

/* s5pc110: return HCLKs frequency */
static unsigned long get_hclk_sys(int dom)
{
	struct s5pc110_clock *clk =
		(struct s5pc110_clock *)samsung_get_base_clock();
34801824:	ebffff95 	bl	34801680 <samsung_get_base_clock>
	unsigned int hclk_sys_ratio;

	if (dom == CLK_M)
		return get_hclk();

	div = readl(&clk->div0);
34801828:	e5905300 	ldr	r5, [r0, #768]	; 0x300
	 */
	offset = 8 + (dom << 0x3);

	hclk_sys_ratio = (div >> offset) & 0xf;

	hclk = get_pll_clk(MPLL) / (hclk_sys_ratio + 1);
3480182c:	e3a00001 	mov	r0, #1
34801830:	ebffffa0 	bl	348016b8 <get_pll_clk>
	 * HCLK_DSYS_RATIO: [19:16]
	 * HCLK_PSYS_RATIO: [27:24]
	 */
	offset = 8 + (dom << 0x3);

	hclk_sys_ratio = (div >> offset) & 0xf;
34801834:	e7e31c55 	ubfx	r1, r5, #24, #4

	hclk = get_pll_clk(MPLL) / (hclk_sys_ratio + 1);
34801838:	e2811001 	add	r1, r1, #1
3480183c:	eb007998 	bl	3481fea4 <__udivsi3>
	 * PCLK_DSYS_RATIO: [22:20]
	 * PCLK_PSYS_RATIO: [30:28]
	 */
	offset = 12 + (dom << 0x3);

	pclk_sys_ratio = (div >> offset) & 0x7;
34801840:	e7e21e54 	ubfx	r1, r4, #28, #3

	pclk = get_hclk_sys(dom) / (pclk_sys_ratio + 1);
34801844:	e2811001 	add	r1, r1, #1
34801848:	eb007995 	bl	3481fea4 <__udivsi3>

/* s5pc110: return peripheral clock frequency */
static unsigned long s5pc110_get_pclk(void)
{
	return get_pclk_sys(CLK_P);
}
3480184c:	e8bd8038 	pop	{r3, r4, r5, pc}

34801850 <get_arm_clk>:
		return s5pc100_get_pll_clk(pllreg);
}

unsigned long get_arm_clk(void)
{
	if (cpu_is_s5pc110())
34801850:	e59f305c 	ldr	r3, [pc, #92]	; 348018b4 <get_arm_clk+0x64>
	else
		return s5pc100_get_pll_clk(pllreg);
}

unsigned long get_arm_clk(void)
{
34801854:	e92d4010 	push	{r4, lr}
	if (cpu_is_s5pc110())
34801858:	e5932000 	ldr	r2, [r3]
3480185c:	e30c3110 	movw	r3, #49424	; 0xc110
34801860:	e1520003 	cmp	r2, r3
34801864:	1a000007 	bne	34801888 <get_arm_clk+0x38>

/* s5pc110: return ARM clock frequency */
static unsigned long s5pc110_get_arm_clk(void)
{
	struct s5pc110_clock *clk =
		(struct s5pc110_clock *)samsung_get_base_clock();
34801868:	ebffff84 	bl	34801680 <samsung_get_base_clock>
	unsigned long div;
	unsigned long dout_apll, armclk;
	unsigned int apll_ratio;

	div = readl(&clk->div0);
3480186c:	e5904300 	ldr	r4, [r0, #768]	; 0x300

	/* APLL_RATIO: [2:0] */
	apll_ratio = div & 0x7;

	dout_apll = get_pll_clk(APLL) / (apll_ratio + 1);
34801870:	e3a00000 	mov	r0, #0
34801874:	ebffff8f 	bl	348016b8 <get_pll_clk>
	unsigned int apll_ratio;

	div = readl(&clk->div0);

	/* APLL_RATIO: [2:0] */
	apll_ratio = div & 0x7;
34801878:	e2041007 	and	r1, r4, #7

	dout_apll = get_pll_clk(APLL) / (apll_ratio + 1);
3480187c:	e2811001 	add	r1, r1, #1
34801880:	eb007987 	bl	3481fea4 <__udivsi3>
}

unsigned long get_arm_clk(void)
{
	if (cpu_is_s5pc110())
		return s5pc110_get_arm_clk();
34801884:	e8bd8010 	pop	{r4, pc}

/* s5pc100: return ARM clock frequency */
static unsigned long s5pc100_get_arm_clk(void)
{
	struct s5pc100_clock *clk =
		(struct s5pc100_clock *)samsung_get_base_clock();
34801888:	ebffff7c 	bl	34801680 <samsung_get_base_clock>
	unsigned long div;
	unsigned long dout_apll, armclk;
	unsigned int apll_ratio, arm_ratio;

	div = readl(&clk->div0);
3480188c:	e5904300 	ldr	r4, [r0, #768]	; 0x300
	/* ARM_RATIO: [6:4] */
	arm_ratio = (div >> 4) & 0x7;
	/* APLL_RATIO: [0] */
	apll_ratio = div & 0x1;

	dout_apll = get_pll_clk(APLL) / (apll_ratio + 1);
34801890:	e3a00000 	mov	r0, #0
34801894:	ebffff87 	bl	348016b8 <get_pll_clk>
	div = readl(&clk->div0);

	/* ARM_RATIO: [6:4] */
	arm_ratio = (div >> 4) & 0x7;
	/* APLL_RATIO: [0] */
	apll_ratio = div & 0x1;
34801898:	e2041001 	and	r1, r4, #1

	dout_apll = get_pll_clk(APLL) / (apll_ratio + 1);
3480189c:	e2811001 	add	r1, r1, #1
348018a0:	eb00797f 	bl	3481fea4 <__udivsi3>
	unsigned int apll_ratio, arm_ratio;

	div = readl(&clk->div0);

	/* ARM_RATIO: [6:4] */
	arm_ratio = (div >> 4) & 0x7;
348018a4:	e7e21254 	ubfx	r1, r4, #4, #3
	/* APLL_RATIO: [0] */
	apll_ratio = div & 0x1;

	dout_apll = get_pll_clk(APLL) / (apll_ratio + 1);
	armclk = dout_apll / (arm_ratio + 1);
348018a8:	e2811001 	add	r1, r1, #1
348018ac:	eb00797c 	bl	3481fea4 <__udivsi3>
{
	if (cpu_is_s5pc110())
		return s5pc110_get_arm_clk();
	else
		return s5pc100_get_arm_clk();
}
348018b0:	e8bd8010 	pop	{r4, pc}
348018b4:	34828214 	.word	0x34828214

348018b8 <get_pwm_clk>:
}

/* s5pc1xx: return pwm clock frequency */
static unsigned long s5pc1xx_get_pwm_clk(void)
{
	if (cpu_is_s5pc110())
348018b8:	e59f3014 	ldr	r3, [pc, #20]	; 348018d4 <get_pwm_clk+0x1c>
348018bc:	e5932000 	ldr	r2, [r3]
348018c0:	e30c3110 	movw	r3, #49424	; 0xc110
348018c4:	e1520003 	cmp	r2, r3
348018c8:	1a000000 	bne	348018d0 <get_pwm_clk+0x18>
		return s5pc110_get_pclk();
348018cc:	eaffffd1 	b	34801818 <s5pc110_get_pclk>
	else
		return s5pc100_get_pclk();
348018d0:	eaffffc4 	b	348017e8 <s5pc100_get_pclk>
348018d4:	34828214 	.word	0x34828214

348018d8 <get_uart_clk>:
}

/* s5pc1xx: return uart clock frequency */
static unsigned long s5pc1xx_get_uart_clk(int dev_index)
{
	if (cpu_is_s5pc110())
348018d8:	e59f3014 	ldr	r3, [pc, #20]	; 348018f4 <get_uart_clk+0x1c>
348018dc:	e5932000 	ldr	r2, [r3]
348018e0:	e30c3110 	movw	r3, #49424	; 0xc110
348018e4:	e1520003 	cmp	r2, r3
348018e8:	1a000000 	bne	348018f0 <get_uart_clk+0x18>
		return s5pc110_get_pclk();
348018ec:	eaffffc9 	b	34801818 <s5pc110_get_pclk>
	else
		return s5pc100_get_pclk();
348018f0:	eaffffbc 	b	348017e8 <s5pc100_get_pclk>
348018f4:	34828214 	.word	0x34828214

348018f8 <set_mmc_clk>:
}

void set_mmc_clk(int dev_index, unsigned int div)
{
	/* Do NOTHING */
}
348018f8:	e12fff1e 	bx	lr
348018fc:	00000000 	andeq	r0, r0, r0

34801900 <v7_outer_cache_enable>:

#include <linux/linkage.h>

#ifndef CONFIG_SYS_L2CACHE_OFF
ENTRY(v7_outer_cache_enable)
	push	{r0, r1, r2, lr}
34801900:	e92d4007 	push	{r0, r1, r2, lr}
	mrc	15, 0, r3, cr1, cr0, 1
34801904:	ee113f30 	mrc	15, 0, r3, cr1, cr0, {1}
	orr	r3, r3, #2
34801908:	e3833002 	orr	r3, r3, #2
	mcr	15, 0, r3, cr1, cr0, 1
3480190c:	ee013f30 	mcr	15, 0, r3, cr1, cr0, {1}
	pop	{r1, r2, r3, pc}
34801910:	e8bd800e 	pop	{r1, r2, r3, pc}

34801914 <v7_outer_cache_disable>:
ENDPROC(v7_outer_cache_enable)

ENTRY(v7_outer_cache_disable)
	push	{r0, r1, r2, lr}
34801914:	e92d4007 	push	{r0, r1, r2, lr}
	mrc	15, 0, r3, cr1, cr0, 1
34801918:	ee113f30 	mrc	15, 0, r3, cr1, cr0, {1}
	bic	r3, r3, #2
3480191c:	e3c33002 	bic	r3, r3, #2
	mcr	15, 0, r3, cr1, cr0, 1
34801920:	ee013f30 	mcr	15, 0, r3, cr1, cr0, {1}
	pop	{r1, r2, r3, pc}
34801924:	e8bd800e 	pop	{r1, r2, r3, pc}
34801928:	e320f000 	nop	{0}
3480192c:	e320f000 	nop	{0}
34801930:	e320f000 	nop	{0}
34801934:	e320f000 	nop	{0}
34801938:	e320f000 	nop	{0}
3480193c:	e320f000 	nop	{0}

34801940 <reset_cpu>:

#define S5PC100_SWRESET			0xE0200000
#define S5PC110_SWRESET			0xE0102000

ENTRY(reset_cpu)
	ldr	r1, =S5PC100_PRO_ID
34801940:	e3a0120e 	mov	r1, #-536870912	; 0xe0000000
	ldr	r2, [r1]
34801944:	e5912000 	ldr	r2, [r1]
	ldr	r4, =0x00010000
34801948:	e3a04801 	mov	r4, #65536	; 0x10000
	and	r4, r2, r4
3480194c:	e0024004 	and	r4, r2, r4
	cmp	r4, #0
34801950:	e3540000 	cmp	r4, #0
	bne	110f
34801954:	1a000002 	bne	34801964 <reset_cpu+0x24>
	/* S5PC100 */
	ldr	r1, =S5PC100_SWRESET
34801958:	e59f1014 	ldr	r1, [pc, #20]	; 34801974 <_loop_forever+0x4>
	ldr	r2, =0xC100
3480195c:	e3a02cc1 	mov	r2, #49408	; 0xc100
	b	200f
34801960:	ea000001 	b	3480196c <reset_cpu+0x2c>
110:	/* S5PC110 */
	ldr	r1, =S5PC110_SWRESET
34801964:	e59f100c 	ldr	r1, [pc, #12]	; 34801978 <_loop_forever+0x8>
	mov	r2, #1
34801968:	e3a02001 	mov	r2, #1
200:
	str	r2, [r1]
3480196c:	e5812000 	str	r2, [r1]

34801970 <_loop_forever>:
_loop_forever:
	b	_loop_forever
34801970:	eafffffe 	b	34801970 <_loop_forever>
34801974:	e0200000 	.word	0xe0200000
34801978:	e0102000 	.word	0xe0102000

3480197c <init_func_i2c>:

	return (0);
}

#if defined(CONFIG_HARD_I2C) || defined(CONFIG_SOFT_I2C)
static int init_func_i2c(void)
3480197c:	e92d4008 	push	{r3, lr}
{
34801980:	e59f001c 	ldr	r0, [pc, #28]	; 348019a4 <init_func_i2c+0x28>
34801984:	eb001d66 	bl	34808f24 <puts>
	puts("I2C:   ");
34801988:	e3a010fe 	mov	r1, #254	; 0xfe
3480198c:	e30c0350 	movw	r0, #50000	; 0xc350
34801990:	eb0038e5 	bl	3480fd2c <i2c_init>
	i2c_init(CONFIG_SYS_I2C_SPEED, CONFIG_SYS_I2C_SLAVE);
34801994:	e59f000c 	ldr	r0, [pc, #12]	; 348019a8 <init_func_i2c+0x2c>
34801998:	eb001d61 	bl	34808f24 <puts>
	puts("ready\n");
	return (0);
3480199c:	e3a00000 	mov	r0, #0
348019a0:	e8bd8008 	pop	{r3, pc}
348019a4:	34822bac 	.word	0x34822bac
348019a8:	34826e8c 	.word	0x34826e8c

348019ac <display_banner>:
	gd->baudrate = getenv_ulong("baudrate", 10, CONFIG_BAUDRATE);
	return 0;
}

static int display_banner(void)
{
348019ac:	e92d4008 	push	{r3, lr}
	printf("\n\n%s\n\n", version_string);
348019b0:	e59f100c 	ldr	r1, [pc, #12]	; 348019c4 <display_banner+0x18>
348019b4:	e59f000c 	ldr	r0, [pc, #12]	; 348019c8 <display_banner+0x1c>
348019b8:	eb001d63 	bl	34808f4c <printf>
	debug("IRQ Stack: %08lx\n", IRQ_STACK_START);
	debug("FIQ Stack: %08lx\n", FIQ_STACK_START);
#endif

	return (0);
}
348019bc:	e3a00000 	mov	r0, #0
348019c0:	e8bd8008 	pop	{r3, pc}
348019c4:	3482053c 	.word	0x3482053c
348019c8:	34822bb4 	.word	0x34822bb4

348019cc <init_baudrate>:
#if defined(CONFIG_ARM_DCC) && !defined(CONFIG_BAUDRATE)
#define CONFIG_BAUDRATE 115200
#endif

static int init_baudrate(void)
{
348019cc:	e92d4010 	push	{r4, lr}
	/* 浠澧 default_environment 涓"baudrate", 濡涓板杩 CONFIG_BAUDRATE s5p_goni.h */
	gd->baudrate = getenv_ulong("baudrate", 10, CONFIG_BAUDRATE);
348019d0:	e3a0100a 	mov	r1, #10
348019d4:	e59f2014 	ldr	r2, [pc, #20]	; 348019f0 <init_baudrate+0x24>
348019d8:	e59f0014 	ldr	r0, [pc, #20]	; 348019f4 <init_baudrate+0x28>
348019dc:	e1a04008 	mov	r4, r8
348019e0:	eb001a30 	bl	348082a8 <getenv_ulong>
348019e4:	e5840008 	str	r0, [r4, #8]
	return 0;
}
348019e8:	e3a00000 	mov	r0, #0
348019ec:	e8bd8010 	pop	{r4, pc}
348019f0:	0001c200 	.word	0x0001c200
348019f4:	34822bbb 	.word	0x34822bbb

348019f8 <__coloured_LED_init>:
/************************************************************************
 * Coloured LED functionality
 ************************************************************************
 * May be supplied by boards if desired
 */
inline void __coloured_LED_init(void) {}
348019f8:	e12fff1e 	bx	lr

348019fc <__red_led_on>:
void coloured_LED_init(void)
	__attribute__((weak, alias("__coloured_LED_init")));
inline void __red_led_on(void) {}
348019fc:	e12fff1e 	bx	lr

34801a00 <__red_led_off>:
void red_led_on(void) __attribute__((weak, alias("__red_led_on")));
inline void __red_led_off(void) {}
34801a00:	e12fff1e 	bx	lr

34801a04 <__green_led_on>:
void red_led_off(void) __attribute__((weak, alias("__red_led_off")));
inline void __green_led_on(void) {}
34801a04:	e12fff1e 	bx	lr

34801a08 <__green_led_off>:
void green_led_on(void) __attribute__((weak, alias("__green_led_on")));
inline void __green_led_off(void) {}
34801a08:	e12fff1e 	bx	lr

34801a0c <__yellow_led_on>:
void green_led_off(void) __attribute__((weak, alias("__green_led_off")));
inline void __yellow_led_on(void) {}
34801a0c:	e12fff1e 	bx	lr

34801a10 <__yellow_led_off>:
void yellow_led_on(void) __attribute__((weak, alias("__yellow_led_on")));
inline void __yellow_led_off(void) {}
34801a10:	e12fff1e 	bx	lr

34801a14 <__blue_led_on>:
void yellow_led_off(void) __attribute__((weak, alias("__yellow_led_off")));
inline void __blue_led_on(void) {}
34801a14:	e12fff1e 	bx	lr

34801a18 <__blue_led_off>:
void blue_led_on(void) __attribute__((weak, alias("__blue_led_on")));
inline void __blue_led_off(void) {}
34801a18:	e12fff1e 	bx	lr

34801a1c <__dram_init_banksize>:
typedef int(init_fnc_t)(void);

int print_cpuinfo(void);

void __dram_init_banksize(void)
{
34801a1c:	e5982000 	ldr	r2, [r8]
34801a20:	e3a01202 	mov	r1, #536870912	; 0x20000000
34801a24:	e5821018 	str	r1, [r2, #24]
	gd->bd->bi_dram[0].start = CONFIG_SYS_SDRAM_BASE;
34801a28:	e5982000 	ldr	r2, [r8]
34801a2c:	e5983038 	ldr	r3, [r8, #56]	; 0x38
34801a30:	e582301c 	str	r3, [r2, #28]
	gd->bd->bi_dram[0].size = gd->ram_size;
34801a34:	e12fff1e 	bx	lr

34801a38 <__arch_cpu_init>:
void dram_init_banksize(void)
	__attribute__((weak, alias("__dram_init_banksize")));

int __arch_cpu_init(void)
{
	return 0;
34801a38:	e3a00000 	mov	r0, #0
34801a3c:	e12fff1e 	bx	lr

34801a40 <board_init_r>:
 * that critical any more, etc.
 *
 ************************************************************************
 */

void board_init_r(gd_t *id, ulong dest_addr)
34801a40:	e1a08000 	mov	r8, r0
/*
 ************************************************************************
 *
 * This is the next part if the initialization sequence: we are now
 * running from RAM and have a "normal" C environment, i. e. global
 * data can be written, BSS has been cleared, the stack size in not
34801a44:	e92d4008 	push	{r3, lr}
 ************************************************************************
 */

void board_init_r(gd_t *id, ulong dest_addr)
{
	ulong malloc_start;
34801a48:	e5983004 	ldr	r3, [r8, #4]
/*
 ************************************************************************
 *
 * This is the next part if the initialization sequence: we are now
 * running from RAM and have a "normal" C environment, i. e. global
 * data can be written, BSS has been cleared, the stack size in not
34801a4c:	e1a04001 	mov	r4, r1
 ************************************************************************
 */

void board_init_r(gd_t *id, ulong dest_addr)
{
	ulong malloc_start;
34801a50:	e3833001 	orr	r3, r3, #1
34801a54:	e5883004 	str	r3, [r8, #4]
#if !defined(CONFIG_SYS_NO_FLASH)
	ulong flash_size;
#endif
34801a58:	e59f3078 	ldr	r3, [pc, #120]	; 34801ad8 <board_init_r+0x98>
34801a5c:	e5932000 	ldr	r2, [r3]
34801a60:	e59f3074 	ldr	r3, [pc, #116]	; 34801adc <board_init_r+0x9c>
34801a64:	e5832000 	str	r2, [r3]

	gd = id;

34801a68:	eb0001a9 	bl	34802114 <__enable_caches>
	gd->flags |= GD_FLG_RELOC; /* tell others: relocation done */
	bootstage_mark_name(BOOTSTAGE_ID_START_UBOOT_R, "board_init_r");

34801a6c:	ebfffc63 	bl	34800c00 <board_init>
	debug("monitor flash len: %08lX\n", monitor_flash_len);
	board_init(); /* Setup chipselects */
				  /*
	 * TODO: printing of the clock inforamtion of the board is now
	 * implemented as part of bdinfo command. Currently only support for
	 * davinci SOC's is added. Remove this check once all the board
34801a70:	eb0031d2 	bl	3480e1c0 <serial_initialize>

	debug("Now running in RAM - U-Boot at: %08lx\n", dest_addr);

#ifdef CONFIG_LOGBUFFER
	logbuff_init_ptrs();
#endif
34801a74:	e3a01706 	mov	r1, #1572864	; 0x180000
34801a78:	e2440706 	sub	r0, r4, #1572864	; 0x180000
34801a7c:	eb001e34 	bl	34809354 <mem_malloc_init>
	{
		puts(failed);
		hang();
	}
#endif

34801a80:	e59f0058 	ldr	r0, [pc, #88]	; 34801ae0 <board_init_r+0xa0>
34801a84:	eb001d26 	bl	34808f24 <puts>
#if defined(CONFIG_CMD_NAND)
34801a88:	e5980000 	ldr	r0, [r8]
34801a8c:	eb004157 	bl	34811ff0 <mmc_initialize>

#if defined(CONFIG_CMD_ONENAND)
	onenand_init();
#endif

#ifdef CONFIG_GENERIC_MMC
34801a90:	eb0022b8 	bl	3480a578 <env_relocate>
	puts("MMC:   ");
	mmc_initialize(gd->bd);
#endif

#ifdef CONFIG_HAS_DATAFLASH
	AT91F_DataflashInit();
34801a94:	eb003245 	bl	3480e3b0 <stdio_init>
	dataflash_print_info();
#endif
34801a98:	eb0022c5 	bl	3480a5b4 <jumptable_init>
	/* initialize environment */
	env_relocate();

#if defined(CONFIG_CMD_PCI) || defined(CONFIG_PCI)
	arm_pci_init();
#endif
34801a9c:	eb001dc0 	bl	348091a4 <console_init_r>
	/* set up exceptions */
	interrupt_init();
	/* enable exceptions */
	enable_interrupts();

	/* Perform network card initialisation if necessary */
34801aa0:	e59f403c 	ldr	r4, [pc, #60]	; 34801ae4 <board_init_r+0xa4>
	/* Initialize API */
	api_init();
#endif

	console_init_r(); /* fully init console as a device */

34801aa4:	eb0000ee 	bl	34801e64 <interrupt_init>
#if defined(CONFIG_ARCH_MISC_INIT)
	/* miscellaneous arch dependent initialisations */
34801aa8:	eb0000f4 	bl	34801e80 <enable_interrupts>
	/* set up exceptions */
	interrupt_init();
	/* enable exceptions */
	enable_interrupts();

	/* Perform network card initialisation if necessary */
34801aac:	e3a01010 	mov	r1, #16
34801ab0:	e5942000 	ldr	r2, [r4]
34801ab4:	e59f002c 	ldr	r0, [pc, #44]	; 34801ae8 <board_init_r+0xa8>
34801ab8:	eb0019fa 	bl	348082a8 <getenv_ulong>
34801abc:	e5840000 	str	r0, [r4]
		uchar enetaddr[6];
		eth_getenv_enetaddr("ethaddr", enetaddr);
		smc_set_mac_addr(enetaddr);
	}
#endif /* CONFIG_DRIVER_SMC91111 || CONFIG_DRIVER_LAN91C96 */

34801ac0:	e59f0024 	ldr	r0, [pc, #36]	; 34801aec <board_init_r+0xac>
34801ac4:	eb001d16 	bl	34808f24 <puts>
	/* Initialize from environment */
34801ac8:	e5980000 	ldr	r0, [r8]
34801acc:	eb006e61 	bl	3481d458 <eth_initialize>

#ifdef CONFIG_PRAM
		pram = getenv_ulong("pram", 10, CONFIG_PRAM);
#endif
#ifdef CONFIG_LOGBUFFER
#ifndef CONFIG_ALT_LB_ADDR
34801ad0:	eb003013 	bl	3480db24 <main_loop>
34801ad4:	eafffffd 	b	34801ad0 <board_init_r+0x90>
34801ad8:	34800050 	.word	0x34800050
34801adc:	34829078 	.word	0x34829078
34801ae0:	34822bc4 	.word	0x34822bc4
34801ae4:	348283c4 	.word	0x348283c4
34801ae8:	34822bcc 	.word	0x34822bcc
34801aec:	34822bd5 	.word	0x34822bd5

34801af0 <hang>:
		pram += (LOGBUFF_LEN + LOGBUFF_OVERHEAD) / 1024;
#endif
#endif
		sprintf((char *)memsz, "%ldk", (gd->ram_size / 1024) - pram);
		setenv("mem", (char *)memsz);
	}
34801af0:	e92d4008 	push	{r3, lr}
#endif
34801af4:	e59f0004 	ldr	r0, [pc, #4]	; 34801b00 <hang+0x10>
34801af8:	eb001d09 	bl	34808f24 <puts>
34801afc:	eafffffe 	b	34801afc <hang+0xc>
34801b00:	34822bdd 	.word	0x34822bdd

34801b04 <board_init_f>:
#endif
	dram_init, /* configure available RAM banks */
	NULL,
};

void board_init_f(ulong bootflag)
34801b04:	e92d4080 	push	{r7, lr}
	ulong reg;
#endif

	bootstage_mark_name(BOOTSTAGE_ID_START_UBOOT_F, "board_init_f");

	/* Pointer is writable since we allocated a register for it */
34801b08:	e3a08423 	mov	r8, #587202560	; 0x23000000
	__asm__ __volatile__(""
						 :
						 :
						 : "memory");

	/* u-boot.16K杩琛SRAM涓锛褰稿硅烦杞讹浼璺冲SRAM澶㈠艰磋椋缁瀵硅烦杞0x348c8c4 DRAM涓锛DRAM娌℃濮涔浼瀵艰寸搴璺椋
34801b0c:	e3a01000 	mov	r1, #0
34801b10:	e3a02078 	mov	r2, #120	; 0x78
34801b14:	e1a00008 	mov	r0, r8
34801b18:	eb005cb8 	bl	34818e00 <memset>
	 * 浠ュㄨ琛 board_init_f 芥颁瑕灏瀹寸uboot浠flash涓杩DRAM涓伙跺璺宠浆DRAM涓杩琛 board_init_f
	 * flash杩浠ｇ浠ヨ宸卞拌诲flash浠ｇ锛涔浠ラs5pv210涓ROM涓哄杩浠ｇ
34801b1c:	e59f30e8 	ldr	r3, [pc, #232]	; 34801c0c <board_init_f+0x108>
	gd->mon_len = _bss_end_ofs;
#ifdef CONFIG_OF_EMBED /* s5p_goni.h */
	/* Get a pointer to the FDT */
	gd->fdt_blob = _binary_dt_dtb_start;
#elif defined CONFIG_OF_SEPARATE
	/* FDT is at end of image */
34801b20:	e59f00e8 	ldr	r0, [pc, #232]	; 34801c10 <board_init_f+0x10c>
						 :
						 : "memory");

	/* u-boot.16K杩琛SRAM涓锛褰稿硅烦杞讹浼璺冲SRAM澶㈠艰磋椋缁瀵硅烦杞0x348c8c4 DRAM涓锛DRAM娌℃濮涔浼瀵艰寸搴璺椋
	 * 浠ュㄨ琛 board_init_f 芥颁瑕灏瀹寸uboot浠flash涓杩DRAM涓伙跺璺宠浆DRAM涓杩琛 board_init_f
	 * flash杩浠ｇ浠ヨ宸卞拌诲flash浠ｇ锛涔浠ラs5pv210涓ROM涓哄杩浠ｇ
34801b24:	e5933000 	ldr	r3, [r3]
	gd->mon_len = _bss_end_ofs;
#ifdef CONFIG_OF_EMBED /* s5p_goni.h */
	/* Get a pointer to the FDT */
	gd->fdt_blob = _binary_dt_dtb_start;
#elif defined CONFIG_OF_SEPARATE
	/* FDT is at end of image */
34801b28:	e3a01010 	mov	r1, #16
						 :
						 : "memory");

	/* u-boot.16K杩琛SRAM涓锛褰稿硅烦杞讹浼璺冲SRAM澶㈠艰磋椋缁瀵硅烦杞0x348c8c4 DRAM涓锛DRAM娌℃濮涔浼瀵艰寸搴璺椋
	 * 浠ュㄨ琛 board_init_f 芥颁瑕灏瀹寸uboot浠flash涓杩DRAM涓伙跺璺宠浆DRAM涓杩琛 board_init_f
	 * flash杩浠ｇ浠ヨ宸卞拌诲flash浠ｇ锛涔浠ラs5pv210涓ROM涓哄杩浠ｇ
34801b2c:	e588303c 	str	r3, [r8, #60]	; 0x3c
#ifdef CONFIG_OF_EMBED /* s5p_goni.h */
	/* Get a pointer to the FDT */
	gd->fdt_blob = _binary_dt_dtb_start;
#elif defined CONFIG_OF_SEPARATE
	/* FDT is at end of image */
	gd->fdt_blob = (void *)(_end_ofs + _TEXT_BASE);
34801b30:	e5982050 	ldr	r2, [r8, #80]	; 0x50
						 :
						 : "memory");

	/* u-boot.16K杩琛SRAM涓锛褰稿硅烦杞讹浼璺冲SRAM澶㈠艰磋椋缁瀵硅烦杞0x348c8c4 DRAM涓锛DRAM娌℃濮涔浼瀵艰寸搴璺椋
	 * 浠ュㄨ琛 board_init_f 芥颁瑕灏瀹寸uboot浠flash涓杩DRAM涓伙跺璺宠浆DRAM涓杩琛 board_init_f
	 * flash杩浠ｇ浠ヨ宸卞拌诲flash浠ｇ锛涔浠ラs5pv210涓ROM涓哄杩浠ｇ
34801b34:	e1a04008 	mov	r4, r8
	gd->mon_len = _bss_end_ofs;
#ifdef CONFIG_OF_EMBED /* s5p_goni.h */
	/* Get a pointer to the FDT */
	gd->fdt_blob = _binary_dt_dtb_start;
#elif defined CONFIG_OF_SEPARATE
	/* FDT is at end of image */
34801b38:	eb0019da 	bl	348082a8 <getenv_ulong>
34801b3c:	e5840050 	str	r0, [r4, #80]	; 0x50
34801b40:	e59f40cc 	ldr	r4, [pc, #204]	; 34801c14 <board_init_f+0x110>
	gd->fdt_blob = (void *)(_end_ofs + _TEXT_BASE);
#endif
	/* Allow the early environment to override the fdt address */
34801b44:	ea000003 	b	34801b58 <board_init_f+0x54>
	gd->fdt_blob = (void *)getenv_ulong("fdtcontroladdr", 16,
34801b48:	e12fff37 	blx	r7
34801b4c:	e3500000 	cmp	r0, #0
34801b50:	0a000000 	beq	34801b58 <board_init_f+0x54>
										(uintptr_t)gd->fdt_blob);
34801b54:	ebffffe5 	bl	34801af0 <hang>
	gd->fdt_blob = _binary_dt_dtb_start;
#elif defined CONFIG_OF_SEPARATE
	/* FDT is at end of image */
	gd->fdt_blob = (void *)(_end_ofs + _TEXT_BASE);
#endif
	/* Allow the early environment to override the fdt address */
34801b58:	e5b47004 	ldr	r7, [r4, #4]!
34801b5c:	e3570000 	cmp	r7, #0
34801b60:	1afffff8 	bne	34801b48 <board_init_f+0x44>
	 * Subtract specified amount of memory to hide so that it won't
	 * get "touched" at all by U-Boot. By fixing up gd->ram_size
	 * the Linux kernel should now get passed the now "corrected"
	 * memory size and won't touch it either. This should work
	 * for arch/ppc and arch/powerpc. Only Linux board ports in
	 * arch/powerpc with bootwrapper support, that recalculate the
34801b64:	e5984038 	ldr	r4, [r8, #56]	; 0x38

#ifdef CONFIG_PRAM
	/*
	 * reserve protected RAM
	 */
	reg = getenv_ulong("pram", 10, CONFIG_PRAM);
34801b68:	e284457f 	add	r4, r4, #532676608	; 0x1fc00000
34801b6c:	e28449ff 	add	r4, r4, #4177920	; 0x3fc000
	addr -= (reg << 10); /* size is in kB */
	debug("Reserving %ldk for protected RAM at %08lx\n", reg, addr);
#endif /* CONFIG_PRAM */
34801b70:	e1a04824 	lsr	r4, r4, #16
34801b74:	e1a04804 	lsl	r4, r4, #16

#if !(defined(CONFIG_SYS_ICACHE_OFF) && defined(CONFIG_SYS_DCACHE_OFF))
34801b78:	e588404c 	str	r4, [r8, #76]	; 0x4c
	gd->fb_base = CONFIG_FB_ADDR;
#else
	/* reserve memory for LCD display (always full pages) */
	addr = lcd_setmem(addr);
	gd->fb_base = addr;
#endif /* CONFIG_FB_ADDR */
34801b7c:	e598203c 	ldr	r2, [r8, #60]	; 0x3c
34801b80:	e0624004 	rsb	r4, r2, r4
#endif /* CONFIG_LCD */
34801b84:	e3c44eff 	bic	r4, r4, #4080	; 0xff0
34801b88:	e3c4400f 	bic	r4, r4, #15

#ifndef CONFIG_SPL_BUILD
	/*
	 * reserve memory for malloc() arena
	 */
	addr_sp = addr - TOTAL_MALLOC_LEN;	// TOTAL_MALLOC_LEN = 1.5M
34801b8c:	e2446706 	sub	r6, r4, #1572864	; 0x180000
	 * and a permanent copy of the "global" data
	 */
	addr_sp -= sizeof(bd_t);
	bd = (bd_t *)addr_sp;
	gd->bd = bd;
	debug("Reserving %zu Bytes for Board Info at: %08lx\n",
34801b90:	e2465098 	sub	r5, r6, #152	; 0x98

#ifndef CONFIG_SPL_BUILD
	/*
	 * reserve memory for malloc() arena
	 */
	addr_sp = addr - TOTAL_MALLOC_LEN;	// TOTAL_MALLOC_LEN = 1.5M
34801b94:	e2462020 	sub	r2, r6, #32
	debug("Reserving %dk for malloc() at: %08lx\n",
		  TOTAL_MALLOC_LEN >> 10, addr_sp);
34801b98:	e5882000 	str	r2, [r8]
		  sizeof(bd_t), addr_sp);

#ifdef CONFIG_MACH_TYPE
	gd->bd->bi_arch_number = CONFIG_MACH_TYPE; /* board id for Linux */
#endif

34801b9c:	e5885040 	str	r5, [r8, #64]	; 0x40
#else
	addr_sp += 128; /* leave 32 words for abort-stack   */
	gd->irq_sp = addr_sp;
#endif

	debug("New Stack Pointer is: %08lx\n", addr_sp);
34801ba0:	e5982000 	ldr	r2, [r8]
34801ba4:	e5983008 	ldr	r3, [r8, #8]

	/* setup stackpointer for exeptions */
	gd->irq_sp = addr_sp;
#ifdef CONFIG_USE_IRQ
	addr_sp -= (CONFIG_STACKSIZE_IRQ + CONFIG_STACKSIZE_FIQ);
	debug("Reserving %zu Bytes for IRQ stack at: %08lx\n",
34801ba8:	e24660a8 	sub	r6, r6, #168	; 0xa8
#else
	addr_sp += 128; /* leave 32 words for abort-stack   */
	gd->irq_sp = addr_sp;
#endif

	debug("New Stack Pointer is: %08lx\n", addr_sp);
34801bac:	e5823000 	str	r3, [r2]

#ifdef CONFIG_POST
34801bb0:	ebfffc26 	bl	34800c50 <dram_init_banksize>
		print_size(gd->bd->bi_dram[i].size, "\n");
	}
#else
	ulong size = 0;

	for (i = 0; i < CONFIG_NR_DRAM_BANKS; i++)
34801bb4:	e5983000 	ldr	r3, [r8]
		size += gd->bd->bi_dram[i].size;

34801bb8:	e59f0058 	ldr	r0, [pc, #88]	; 34801c18 <board_init_f+0x114>
		print_size(gd->bd->bi_dram[i].size, "\n");
	}
#else
	ulong size = 0;

	for (i = 0; i < CONFIG_NR_DRAM_BANKS; i++)
34801bbc:	e593a01c 	ldr	sl, [r3, #28]
		size += gd->bd->bi_dram[i].size;

34801bc0:	eb001cd7 	bl	34808f24 <puts>
	puts("DRAM:  ");
34801bc4:	e1a0000a 	mov	r0, sl
34801bc8:	e1a01007 	mov	r1, r7
34801bcc:	e59f2048 	ldr	r2, [pc, #72]	; 34801c1c <board_init_f+0x118>
34801bd0:	eb005544 	bl	348170e8 <print_size>
#ifdef CONFIG_POST
	post_bootmode_init();
	post_run(NULL, POST_ROM | post_bootmode_get(0));
#endif

	gd->bd->bi_baudrate = gd->baudrate;
34801bd4:	e59f3044 	ldr	r3, [pc, #68]	; 34801c20 <board_init_f+0x11c>
	debug("New Stack Pointer is: %08lx\n", addr_sp);

#ifdef CONFIG_POST
	post_bootmode_init();
	post_run(NULL, POST_ROM | post_bootmode_get(0));
#endif
34801bd8:	e5884034 	str	r4, [r8, #52]	; 0x34

	gd->bd->bi_baudrate = gd->baudrate;
34801bdc:	e5933000 	ldr	r3, [r3]
	debug("New Stack Pointer is: %08lx\n", addr_sp);

#ifdef CONFIG_POST
	post_bootmode_init();
	post_run(NULL, POST_ROM | post_bootmode_get(0));
#endif
34801be0:	e1a01008 	mov	r1, r8

	gd->bd->bi_baudrate = gd->baudrate;
34801be4:	e0633004 	rsb	r3, r3, r4

#ifdef CONFIG_POST
	post_bootmode_init();
	post_run(NULL, POST_ROM | post_bootmode_get(0));
#endif

34801be8:	e5886044 	str	r6, [r8, #68]	; 0x44
	gd->bd->bi_baudrate = gd->baudrate;
	/* Ram ist board specific, so move it to board code ... */
	dram_init_banksize();
34801bec:	e3a02078 	mov	r2, #120	; 0x78
#ifdef CONFIG_POST
	post_bootmode_init();
	post_run(NULL, POST_ROM | post_bootmode_get(0));
#endif

	gd->bd->bi_baudrate = gd->baudrate;
34801bf0:	e5883048 	str	r3, [r8, #72]	; 0x48
	/* Ram ist board specific, so move it to board code ... */
	dram_init_banksize();
34801bf4:	e1a00005 	mov	r0, r5
34801bf8:	eb005ca4 	bl	34818e90 <memcpy>
	display_dram_config(); /* and display it */

34801bfc:	e1a00006 	mov	r0, r6
34801c00:	e1a01005 	mov	r1, r5
34801c04:	e1a02004 	mov	r2, r4
34801c08:	ebfff928 	bl	348000b0 <relocate_code>
34801c0c:	3480004c 	.word	0x3480004c
34801c10:	34822c07 	.word	0x34822c07
34801c14:	34828218 	.word	0x34828218
34801c18:	34822c16 	.word	0x34822c16
34801c1c:	348260f7 	.word	0x348260f7
34801c20:	34800040 	.word	0x34800040

34801c24 <boot_prep_linux>:
}
#endif

/* Subcommand: PREP */
static void boot_prep_linux(bootm_headers_t *images)
{
34801c24:	e92d4070 	push	{r4, r5, r6, lr}
34801c28:	e1a05000 	mov	r5, r0
#ifdef CONFIG_CMDLINE_TAG
	char *commandline = getenv("bootargs");
34801c2c:	e59f0128 	ldr	r0, [pc, #296]	; 34801d5c <boot_prep_linux+0x138>
34801c30:	eb001981 	bl	3480823c <getenv>
	defined(CONFIG_CMDLINE_TAG) || \
	defined(CONFIG_INITRD_TAG) || \
	defined(CONFIG_SERIAL_TAG) || \
	defined(CONFIG_REVISION_TAG)
		debug("using: ATAGS\n");
		setup_start_tag(gd->bd);
34801c34:	e5983000 	ldr	r3, [r8]

	params->u.core.flags = 0;
	params->u.core.pagesize = 0;
	params->u.core.rootdev = 0;

	params = tag_next (params);
34801c38:	e59f1120 	ldr	r1, [pc, #288]	; 34801d60 <boot_prep_linux+0x13c>
	defined(CONFIG_INITRD_TAG) || \
	defined(CONFIG_SERIAL_TAG) || \
	defined(CONFIG_REVISION_TAG)
static void setup_start_tag (bd_t *bd)
{
	params = (struct tag *)bd->bi_boot_params;
34801c3c:	e5934008 	ldr	r4, [r3, #8]

	params->hdr.tag = ATAG_CORE;
34801c40:	e59f311c 	ldr	r3, [pc, #284]	; 34801d64 <boot_prep_linux+0x140>
#ifdef CONFIG_CMDLINE_TAG
static void setup_commandline_tag(bd_t *bd, char *commandline)
{
	char *p;

	if (!commandline)
34801c44:	e3500000 	cmp	r0, #0
	defined(CONFIG_REVISION_TAG)
static void setup_start_tag (bd_t *bd)
{
	params = (struct tag *)bd->bi_boot_params;

	params->hdr.tag = ATAG_CORE;
34801c48:	e5843004 	str	r3, [r4, #4]
	params->hdr.size = tag_size (tag_core);
34801c4c:	e3a03005 	mov	r3, #5
34801c50:	e5843000 	str	r3, [r4]

	params->u.core.flags = 0;
34801c54:	e3a03000 	mov	r3, #0
34801c58:	e5843008 	str	r3, [r4, #8]
	params->u.core.pagesize = 0;
34801c5c:	e584300c 	str	r3, [r4, #12]
	params->u.core.rootdev = 0;
34801c60:	e5843010 	str	r3, [r4, #16]

	params = tag_next (params);
34801c64:	e2843014 	add	r3, r4, #20
34801c68:	e5813000 	str	r3, [r1]
		setup_start_tag(gd->bd);
#ifdef CONFIG_SERIAL_TAG
		setup_serial_tag(&params);
#endif
#ifdef CONFIG_CMDLINE_TAG
		setup_commandline_tag(gd->bd, commandline);
34801c6c:	e5982000 	ldr	r2, [r8]
#ifdef CONFIG_CMDLINE_TAG
static void setup_commandline_tag(bd_t *bd, char *commandline)
{
	char *p;

	if (!commandline)
34801c70:	0a000015 	beq	34801ccc <boot_prep_linux+0xa8>
34801c74:	e1a06000 	mov	r6, r0
		return;

	/* eat leading white space */
	for (p = commandline; *p == ' '; p++);
34801c78:	e4d02001 	ldrb	r2, [r0], #1
34801c7c:	e3520020 	cmp	r2, #32
34801c80:	0afffffb 	beq	34801c74 <boot_prep_linux+0x50>

	/* skip non-existent command lines so the kernel will still
	 * use its default command line.
	 */
	if (*p == '\0')
34801c84:	e3520000 	cmp	r2, #0
34801c88:	0a00000f 	beq	34801ccc <boot_prep_linux+0xa8>
		return;

	params->hdr.tag = ATAG_CMDLINE;
34801c8c:	e59f20d4 	ldr	r2, [pc, #212]	; 34801d68 <boot_prep_linux+0x144>
	params->hdr.size =
		(sizeof (struct tag_header) + strlen (p) + 1 + 4) >> 2;
34801c90:	e1a00006 	mov	r0, r6
	 * use its default command line.
	 */
	if (*p == '\0')
		return;

	params->hdr.tag = ATAG_CMDLINE;
34801c94:	e5832004 	str	r2, [r3, #4]
	params->hdr.size =
		(sizeof (struct tag_header) + strlen (p) + 1 + 4) >> 2;
34801c98:	eb005bb8 	bl	34818b80 <strlen>
34801c9c:	e280000d 	add	r0, r0, #13
34801ca0:	e1a00120 	lsr	r0, r0, #2
	 */
	if (*p == '\0')
		return;

	params->hdr.tag = ATAG_CMDLINE;
	params->hdr.size =
34801ca4:	e5840014 	str	r0, [r4, #20]
		(sizeof (struct tag_header) + strlen (p) + 1 + 4) >> 2;

	strcpy (params->u.cmdline.cmdline, p);
34801ca8:	e59f40b0 	ldr	r4, [pc, #176]	; 34801d60 <boot_prep_linux+0x13c>
34801cac:	e1a01006 	mov	r1, r6
34801cb0:	e5940000 	ldr	r0, [r4]
34801cb4:	e2800008 	add	r0, r0, #8
34801cb8:	eb005b4b 	bl	348189ec <strcpy>

	params = tag_next (params);
34801cbc:	e5943000 	ldr	r3, [r4]
34801cc0:	e5932000 	ldr	r2, [r3]
34801cc4:	e0833102 	add	r3, r3, r2, lsl #2
34801cc8:	e5843000 	str	r3, [r4]
static void setup_memory_tags(bd_t *bd)
{
	int i;

	for (i = 0; i < CONFIG_NR_DRAM_BANKS; i++) {
		params->hdr.tag = ATAG_MEM;
34801ccc:	e59f008c 	ldr	r0, [pc, #140]	; 34801d60 <boot_prep_linux+0x13c>
#endif
#ifdef CONFIG_REVISION_TAG
		setup_revision_tag(&params);
#endif
#ifdef CONFIG_SETUP_MEMORY_TAGS
		setup_memory_tags(gd->bd);
34801cd0:	e5982000 	ldr	r2, [r8]
static void setup_memory_tags(bd_t *bd)
{
	int i;

	for (i = 0; i < CONFIG_NR_DRAM_BANKS; i++) {
		params->hdr.tag = ATAG_MEM;
34801cd4:	e5903000 	ldr	r3, [r0]
34801cd8:	e59fc08c 	ldr	ip, [pc, #140]	; 34801d6c <boot_prep_linux+0x148>
		params->hdr.size = tag_size (tag_mem32);
34801cdc:	e3a06004 	mov	r6, #4
static void setup_memory_tags(bd_t *bd)
{
	int i;

	for (i = 0; i < CONFIG_NR_DRAM_BANKS; i++) {
		params->hdr.tag = ATAG_MEM;
34801ce0:	e583c004 	str	ip, [r3, #4]
		params->hdr.size = tag_size (tag_mem32);

		params->u.mem.start = bd->bi_dram[i].start;
34801ce4:	e592c018 	ldr	ip, [r2, #24]
#endif
#ifdef CONFIG_REVISION_TAG
		setup_revision_tag(&params);
#endif
#ifdef CONFIG_SETUP_MEMORY_TAGS
		setup_memory_tags(gd->bd);
34801ce8:	e1a01008 	mov	r1, r8

	for (i = 0; i < CONFIG_NR_DRAM_BANKS; i++) {
		params->hdr.tag = ATAG_MEM;
		params->hdr.size = tag_size (tag_mem32);

		params->u.mem.start = bd->bi_dram[i].start;
34801cec:	e583c00c 	str	ip, [r3, #12]
		params->u.mem.size = bd->bi_dram[i].size;
34801cf0:	e592201c 	ldr	r2, [r2, #28]
{
	int i;

	for (i = 0; i < CONFIG_NR_DRAM_BANKS; i++) {
		params->hdr.tag = ATAG_MEM;
		params->hdr.size = tag_size (tag_mem32);
34801cf4:	e5836000 	str	r6, [r3]

		params->u.mem.start = bd->bi_dram[i].start;
		params->u.mem.size = bd->bi_dram[i].size;
34801cf8:	e5832008 	str	r2, [r3, #8]
#endif
#ifdef CONFIG_SETUP_MEMORY_TAGS
		setup_memory_tags(gd->bd);
#endif
#ifdef CONFIG_INITRD_TAG
		if (images->rd_start && images->rd_end)
34801cfc:	e595c064 	ldr	ip, [r5, #100]	; 0x64
		params->hdr.size = tag_size (tag_mem32);

		params->u.mem.start = bd->bi_dram[i].start;
		params->u.mem.size = bd->bi_dram[i].size;

		params = tag_next (params);
34801d00:	e2832010 	add	r2, r3, #16
#endif
#ifdef CONFIG_SETUP_MEMORY_TAGS
		setup_memory_tags(gd->bd);
#endif
#ifdef CONFIG_INITRD_TAG
		if (images->rd_start && images->rd_end)
34801d04:	e35c0000 	cmp	ip, #0
		params->hdr.size = tag_size (tag_mem32);

		params->u.mem.start = bd->bi_dram[i].start;
		params->u.mem.size = bd->bi_dram[i].size;

		params = tag_next (params);
34801d08:	e5802000 	str	r2, [r0]
#endif
#ifdef CONFIG_SETUP_MEMORY_TAGS
		setup_memory_tags(gd->bd);
#endif
#ifdef CONFIG_INITRD_TAG
		if (images->rd_start && images->rd_end)
34801d0c:	0a00000b 	beq	34801d40 <boot_prep_linux+0x11c>
34801d10:	e5954068 	ldr	r4, [r5, #104]	; 0x68
34801d14:	e3540000 	cmp	r4, #0
34801d18:	0a000008 	beq	34801d40 <boot_prep_linux+0x11c>
			setup_initrd_tag(gd->bd, images->rd_start,
34801d1c:	e5985000 	ldr	r5, [r8]
static void setup_initrd_tag(bd_t *bd, ulong initrd_start, ulong initrd_end)
{
	/* an ATAG_INITRD node tells the kernel where the compressed
	 * ramdisk can be found. ATAG_RDIMG is a better name, actually.
	 */
	params->hdr.tag = ATAG_INITRD2;
34801d20:	e59f5048 	ldr	r5, [pc, #72]	; 34801d70 <boot_prep_linux+0x14c>
	params->hdr.size = tag_size (tag_initrd);

	params->u.initrd.start = initrd_start;
34801d24:	e582c008 	str	ip, [r2, #8]
	params->u.initrd.size = initrd_end - initrd_start;
34801d28:	e06cc004 	rsb	ip, ip, r4
static void setup_initrd_tag(bd_t *bd, ulong initrd_start, ulong initrd_end)
{
	/* an ATAG_INITRD node tells the kernel where the compressed
	 * ramdisk can be found. ATAG_RDIMG is a better name, actually.
	 */
	params->hdr.tag = ATAG_INITRD2;
34801d2c:	e5825004 	str	r5, [r2, #4]
	params->hdr.size = tag_size (tag_initrd);

	params->u.initrd.start = initrd_start;
	params->u.initrd.size = initrd_end - initrd_start;
34801d30:	e582c00c 	str	ip, [r2, #12]

	params = tag_next (params);
34801d34:	e2822010 	add	r2, r2, #16
{
	/* an ATAG_INITRD node tells the kernel where the compressed
	 * ramdisk can be found. ATAG_RDIMG is a better name, actually.
	 */
	params->hdr.tag = ATAG_INITRD2;
	params->hdr.size = tag_size (tag_initrd);
34801d38:	e5836010 	str	r6, [r3, #16]

	params->u.initrd.start = initrd_start;
	params->u.initrd.size = initrd_end - initrd_start;

	params = tag_next (params);
34801d3c:	e5802000 	str	r2, [r0]
#ifdef CONFIG_INITRD_TAG
		if (images->rd_start && images->rd_end)
			setup_initrd_tag(gd->bd, images->rd_start,
			images->rd_end);
#endif
		setup_end_tag(gd->bd);
34801d40:	e5913000 	ldr	r3, [r1]
	defined(CONFIG_INITRD_TAG) || \
	defined(CONFIG_SERIAL_TAG) || \
	defined(CONFIG_REVISION_TAG)
static void setup_end_tag(bd_t *bd)
{
	params->hdr.tag = ATAG_NONE;
34801d44:	e59f3014 	ldr	r3, [pc, #20]	; 34801d60 <boot_prep_linux+0x13c>
34801d48:	e3a02000 	mov	r2, #0
34801d4c:	e5933000 	ldr	r3, [r3]
34801d50:	e5832004 	str	r2, [r3, #4]
	params->hdr.size = 0;
34801d54:	e5832000 	str	r2, [r3]
#else /* all tags */
		printf("FDT and ATAGS support not compiled in - hanging\n");
		hang();
#endif /* all tags */
	}
}
34801d58:	e8bd8070 	pop	{r4, r5, r6, pc}
34801d5c:	34822c1e 	.word	0x34822c1e
34801d60:	3482907c 	.word	0x3482907c
34801d64:	54410001 	.word	0x54410001
34801d68:	54410009 	.word	0x54410009
34801d6c:	54410002 	.word	0x54410002
34801d70:	54420005 	.word	0x54420005

34801d74 <boot_jump_linux.clone.5>:

/* Subcommand: GO */
static void boot_jump_linux(bootm_headers_t *images)
34801d74:	e92d4013 	push	{r0, r1, r4, lr}
{
	unsigned long machid = gd->bd->bi_arch_number;
34801d78:	e5983000 	ldr	r3, [r8]
#endif /* all tags */
	}
}

/* Subcommand: GO */
static void boot_jump_linux(bootm_headers_t *images)
34801d7c:	e1a04000 	mov	r4, r0
{
	unsigned long machid = gd->bd->bi_arch_number;
34801d80:	e5933004 	ldr	r3, [r3, #4]
	void (*kernel_entry)(int zero, int arch, uint params);
	unsigned long r2;

	kernel_entry = (void (*)(int, int, uint))images->ep;

	s = getenv("machid");
34801d84:	e59f0050 	ldr	r0, [pc, #80]	; 34801ddc <boot_jump_linux.clone.5+0x68>
}

/* Subcommand: GO */
static void boot_jump_linux(bootm_headers_t *images)
{
	unsigned long machid = gd->bd->bi_arch_number;
34801d88:	e58d3004 	str	r3, [sp, #4]
	void (*kernel_entry)(int zero, int arch, uint params);
	unsigned long r2;

	kernel_entry = (void (*)(int, int, uint))images->ep;

	s = getenv("machid");
34801d8c:	eb00192a 	bl	3480823c <getenv>
	if (s) {
34801d90:	e3500000 	cmp	r0, #0
34801d94:	0a000005 	beq	34801db0 <boot_jump_linux.clone.5+0x3c>
		strict_strtoul(s, 16, &machid);
34801d98:	e3a01010 	mov	r1, #16
34801d9c:	e28d2004 	add	r2, sp, #4
34801da0:	eb005fbf 	bl	34819ca4 <strict_strtoul>
		printf("Using machid 0x%lx from environment\n", machid);
34801da4:	e59f0034 	ldr	r0, [pc, #52]	; 34801de0 <boot_jump_linux.clone.5+0x6c>
34801da8:	e59d1004 	ldr	r1, [sp, #4]
34801dac:	eb001c66 	bl	34808f4c <printf>
 * and won't even do that unless CONFIG_SHOW_BOOT_PROGRESS is defined
 */

static inline ulong bootstage_mark(enum bootstage_id id)
{
	show_boot_progress(id);
34801db0:	e3a0000f 	mov	r0, #15
34801db4:	eb002cdb 	bl	3480d128 <__show_boot_progress>
}
#endif

static void announce_and_cleanup(void)
{
	printf("\nStarting kernel ...\n\n");
34801db8:	e59f0024 	ldr	r0, [pc, #36]	; 34801de4 <boot_jump_linux.clone.5+0x70>
34801dbc:	eb001c62 	bl	34808f4c <printf>
#endif

#ifdef CONFIG_USB_DEVICE
	udc_disconnect();
#endif
	cleanup_before_linux();
34801dc0:	ebfffca5 	bl	3480105c <cleanup_before_linux>
#ifdef CONFIG_OF_LIBFDT
	if (images->ft_len)
		r2 = (unsigned long)images->ft_addr;
	else
#endif
		r2 = gd->bd->bi_boot_params;
34801dc4:	e5983000 	ldr	r3, [r8]

	kernel_entry(0, machid, r2);
34801dc8:	e3a00000 	mov	r0, #0
34801dcc:	e59d1004 	ldr	r1, [sp, #4]
34801dd0:	e5932008 	ldr	r2, [r3, #8]
34801dd4:	e12fff34 	blx	r4
}
34801dd8:	e8bd801c 	pop	{r2, r3, r4, pc}
34801ddc:	34822c27 	.word	0x34822c27
34801de0:	34822c2e 	.word	0x34822c2e
34801de4:	34822c53 	.word	0x34822c53

34801de8 <arch_lmb_reserve>:
	debug("## Current stack ends at 0x%08lx ", sp);

	/* adjust sp by 4K to be safe */
	sp -= 4096;
	lmb_reserve(lmb, sp,
		    gd->bd->bi_dram[0].start + gd->bd->bi_dram[0].size - sp);
34801de8:	e598c000 	ldr	ip, [r8]
34801dec:	e5983000 	ldr	r3, [r8]

static ulong get_sp(void)
{
	ulong ret;

	asm("mov %0, sp" : "=r"(ret) : );
34801df0:	e1a0100d 	mov	r1, sp
	debug("## Current stack ends at 0x%08lx ", sp);

	/* adjust sp by 4K to be safe */
	sp -= 4096;
	lmb_reserve(lmb, sp,
		    gd->bd->bi_dram[0].start + gd->bd->bi_dram[0].size - sp);
34801df4:	e593201c 	ldr	r2, [r3, #28]
34801df8:	e59c3018 	ldr	r3, [ip, #24]
	 */
	sp = get_sp();
	debug("## Current stack ends at 0x%08lx ", sp);

	/* adjust sp by 4K to be safe */
	sp -= 4096;
34801dfc:	e2411a01 	sub	r1, r1, #4096	; 0x1000
	lmb_reserve(lmb, sp,
		    gd->bd->bi_dram[0].start + gd->bd->bi_dram[0].size - sp);
34801e00:	e0822003 	add	r2, r2, r3
	sp = get_sp();
	debug("## Current stack ends at 0x%08lx ", sp);

	/* adjust sp by 4K to be safe */
	sp -= 4096;
	lmb_reserve(lmb, sp,
34801e04:	e0612002 	rsb	r2, r1, r2
34801e08:	ea005a13 	b	3481865c <lmb_reserve>

34801e0c <do_bootm_linux>:
 * Modeled after the powerpc implementation
 * DIFFERENCE: Instead of calling prep and go at the end
 * they are called if subcommand is equal 0.
 */
int do_bootm_linux(int flag, int argc, char *argv[], bootm_headers_t *images)
{
34801e0c:	e92d4070 	push	{r4, r5, r6, lr}
	/* No need for those on ARM */
	if (flag & BOOTM_STATE_OS_BD_T || flag & BOOTM_STATE_OS_CMDLINE)
34801e10:	e2105030 	ands	r5, r0, #48	; 0x30
 * Modeled after the powerpc implementation
 * DIFFERENCE: Instead of calling prep and go at the end
 * they are called if subcommand is equal 0.
 */
int do_bootm_linux(int flag, int argc, char *argv[], bootm_headers_t *images)
{
34801e14:	e1a04003 	mov	r4, r3
	/* No need for those on ARM */
	if (flag & BOOTM_STATE_OS_BD_T || flag & BOOTM_STATE_OS_CMDLINE)
		return -1;
34801e18:	13e05000 	mvnne	r5, #0
 * they are called if subcommand is equal 0.
 */
int do_bootm_linux(int flag, int argc, char *argv[], bootm_headers_t *images)
{
	/* No need for those on ARM */
	if (flag & BOOTM_STATE_OS_BD_T || flag & BOOTM_STATE_OS_CMDLINE)
34801e1c:	1a00000e 	bne	34801e5c <do_bootm_linux+0x50>
		return -1;

	if (flag & BOOTM_STATE_OS_PREP) {
34801e20:	e2106040 	ands	r6, r0, #64	; 0x40
34801e24:	0a000002 	beq	34801e34 <do_bootm_linux+0x28>
		boot_prep_linux(images);
34801e28:	e1a00003 	mov	r0, r3
34801e2c:	ebffff7c 	bl	34801c24 <boot_prep_linux>
		return 0;
34801e30:	ea000009 	b	34801e5c <do_bootm_linux+0x50>
	}

	if (flag & BOOTM_STATE_OS_GO) {
34801e34:	e2105080 	ands	r5, r0, #128	; 0x80
34801e38:	0a000003 	beq	34801e4c <do_bootm_linux+0x40>
		boot_jump_linux(images);
34801e3c:	e5930060 	ldr	r0, [r3, #96]	; 0x60
34801e40:	ebffffcb 	bl	34801d74 <boot_jump_linux.clone.5>
		return 0;
34801e44:	e1a05006 	mov	r5, r6
34801e48:	ea000003 	b	34801e5c <do_bootm_linux+0x50>
	}

	boot_prep_linux(images);
34801e4c:	e1a00003 	mov	r0, r3
34801e50:	ebffff73 	bl	34801c24 <boot_prep_linux>
	boot_jump_linux(images);
34801e54:	e5940060 	ldr	r0, [r4, #96]	; 0x60
34801e58:	ebffffc5 	bl	34801d74 <boot_jump_linux.clone.5>
	return 0;
}
34801e5c:	e1a00005 	mov	r0, r5
34801e60:	e8bd8070 	pop	{r4, r5, r6, pc}

34801e64 <interrupt_init>:
int interrupt_init (void)
{
	/*
	 * setup up stacks if necessary
	 */
	IRQ_STACK_START_IN = gd->irq_sp + 8;
34801e64:	e5982040 	ldr	r2, [r8, #64]	; 0x40
34801e68:	e59f300c 	ldr	r3, [pc, #12]	; 34801e7c <interrupt_init+0x18>
34801e6c:	e2822008 	add	r2, r2, #8
34801e70:	e5832000 	str	r2, [r3]

	return 0;
}
34801e74:	e3a00000 	mov	r0, #0
34801e78:	e12fff1e 	bx	lr
34801e7c:	34800054 	.word	0x34800054

34801e80 <enable_interrupts>:

void enable_interrupts (void)
{
	return;
}
34801e80:	e12fff1e 	bx	lr

34801e84 <disable_interrupts>:
int disable_interrupts (void)
{
	return 0;
}
34801e84:	e3a00000 	mov	r0, #0
34801e88:	e12fff1e 	bx	lr

34801e8c <bad_mode>:
#endif


void bad_mode (void)
{
34801e8c:	e92d4008 	push	{r3, lr}
	panic ("Resetting CPU ...\n");
34801e90:	e59f0000 	ldr	r0, [pc, #0]	; 34801e98 <bad_mode+0xc>
34801e94:	eb006006 	bl	34819eb4 <panic>
34801e98:	34822c6a 	.word	0x34822c6a

34801e9c <show_regs>:
	reset_cpu (0);
}

void show_regs (struct pt_regs *regs)
{
34801e9c:	e92d4070 	push	{r4, r5, r6, lr}
34801ea0:	e24dd088 	sub	sp, sp, #136	; 0x88
34801ea4:	e1a04000 	mov	r4, r0
	unsigned long flags;
	const char *processor_modes[] = {
34801ea8:	e59f1104 	ldr	r1, [pc, #260]	; 34801fb4 <show_regs+0x118>
34801eac:	e28d0008 	add	r0, sp, #8
34801eb0:	e3a02080 	mov	r2, #128	; 0x80
34801eb4:	eb005bf5 	bl	34818e90 <memcpy>
	"UK12_32",	"UK13_32",	"UK14_32",	"SYS_32",
	};

	flags = condition_codes (regs);

	printf ("pc : [<%08lx>]	   lr : [<%08lx>]\n"
34801eb8:	e5943030 	ldr	r3, [r4, #48]	; 0x30
34801ebc:	e594103c 	ldr	r1, [r4, #60]	; 0x3c
34801ec0:	e58d3000 	str	r3, [sp]
34801ec4:	e594302c 	ldr	r3, [r4, #44]	; 0x2c
34801ec8:	e5942038 	ldr	r2, [r4, #56]	; 0x38
34801ecc:	e58d3004 	str	r3, [sp, #4]
34801ed0:	e59f00e0 	ldr	r0, [pc, #224]	; 34801fb8 <show_regs+0x11c>
34801ed4:	e5943034 	ldr	r3, [r4, #52]	; 0x34
	"UK4_32",	"UK5_32",	"UK6_32",	"ABT_32",
	"UK8_32",	"UK9_32",	"UK10_32",	"UND_32",
	"UK12_32",	"UK13_32",	"UK14_32",	"SYS_32",
	};

	flags = condition_codes (regs);
34801ed8:	e5945040 	ldr	r5, [r4, #64]	; 0x40

	printf ("pc : [<%08lx>]	   lr : [<%08lx>]\n"
34801edc:	eb001c1a 	bl	34808f4c <printf>
		"sp : %08lx  ip : %08lx	 fp : %08lx\n",
		instruction_pointer (regs),
		regs->ARM_lr, regs->ARM_sp, regs->ARM_ip, regs->ARM_fp);
	printf ("r10: %08lx  r9 : %08lx	 r8 : %08lx\n",
34801ee0:	e5941028 	ldr	r1, [r4, #40]	; 0x28
34801ee4:	e5942024 	ldr	r2, [r4, #36]	; 0x24
34801ee8:	e5943020 	ldr	r3, [r4, #32]
34801eec:	e59f00c8 	ldr	r0, [pc, #200]	; 34801fbc <show_regs+0x120>
34801ef0:	eb001c15 	bl	34808f4c <printf>
		regs->ARM_r10, regs->ARM_r9, regs->ARM_r8);
	printf ("r7 : %08lx  r6 : %08lx	 r5 : %08lx  r4 : %08lx\n",
34801ef4:	e5943010 	ldr	r3, [r4, #16]
34801ef8:	e594101c 	ldr	r1, [r4, #28]
34801efc:	e58d3000 	str	r3, [sp]
34801f00:	e5942018 	ldr	r2, [r4, #24]
34801f04:	e5943014 	ldr	r3, [r4, #20]
34801f08:	e59f00b0 	ldr	r0, [pc, #176]	; 34801fc0 <show_regs+0x124>
34801f0c:	eb001c0e 	bl	34808f4c <printf>
		regs->ARM_r7, regs->ARM_r6, regs->ARM_r5, regs->ARM_r4);
	printf ("r3 : %08lx  r2 : %08lx	 r1 : %08lx  r0 : %08lx\n",
34801f10:	e5943000 	ldr	r3, [r4]
34801f14:	e594100c 	ldr	r1, [r4, #12]
34801f18:	e58d3000 	str	r3, [sp]
34801f1c:	e5942008 	ldr	r2, [r4, #8]
34801f20:	e5943004 	ldr	r3, [r4, #4]
34801f24:	e59f0098 	ldr	r0, [pc, #152]	; 34801fc4 <show_regs+0x128>
34801f28:	eb001c07 	bl	34808f4c <printf>
		regs->ARM_r3, regs->ARM_r2, regs->ARM_r1, regs->ARM_r0);
	printf ("Flags: %c%c%c%c",
34801f2c:	e3150101 	tst	r5, #1073741824	; 0x40000000
34801f30:	03a0207a 	moveq	r2, #122	; 0x7a
34801f34:	13a0205a 	movne	r2, #90	; 0x5a
34801f38:	e3150202 	tst	r5, #536870912	; 0x20000000
34801f3c:	03a03063 	moveq	r3, #99	; 0x63
34801f40:	13a03043 	movne	r3, #67	; 0x43
	"UK4_32",	"UK5_32",	"UK6_32",	"ABT_32",
	"UK8_32",	"UK9_32",	"UK10_32",	"UND_32",
	"UK12_32",	"UK13_32",	"UK14_32",	"SYS_32",
	};

	flags = condition_codes (regs);
34801f44:	e205620f 	and	r6, r5, #-268435456	; 0xf0000000
		regs->ARM_r10, regs->ARM_r9, regs->ARM_r8);
	printf ("r7 : %08lx  r6 : %08lx	 r5 : %08lx  r4 : %08lx\n",
		regs->ARM_r7, regs->ARM_r6, regs->ARM_r5, regs->ARM_r4);
	printf ("r3 : %08lx  r2 : %08lx	 r1 : %08lx  r0 : %08lx\n",
		regs->ARM_r3, regs->ARM_r2, regs->ARM_r1, regs->ARM_r0);
	printf ("Flags: %c%c%c%c",
34801f48:	e3150201 	tst	r5, #268435456	; 0x10000000
34801f4c:	03a01076 	moveq	r1, #118	; 0x76
34801f50:	13a01056 	movne	r1, #86	; 0x56
34801f54:	e3560000 	cmp	r6, #0
34801f58:	e58d1000 	str	r1, [sp]
34801f5c:	e59f0064 	ldr	r0, [pc, #100]	; 34801fc8 <show_regs+0x12c>
34801f60:	a3a0106e 	movge	r1, #110	; 0x6e
34801f64:	b3a0104e 	movlt	r1, #78	; 0x4e
34801f68:	eb001bf7 	bl	34808f4c <printf>
		flags & CC_N_BIT ? 'N' : 'n',
		flags & CC_Z_BIT ? 'Z' : 'z',
		flags & CC_C_BIT ? 'C' : 'c', flags & CC_V_BIT ? 'V' : 'v');
	printf ("  IRQs %s  FIQs %s  Mode %s%s\n",
		interrupts_enabled (regs) ? "on" : "off",
34801f6c:	e5943040 	ldr	r3, [r4, #64]	; 0x40
		regs->ARM_r3, regs->ARM_r2, regs->ARM_r1, regs->ARM_r0);
	printf ("Flags: %c%c%c%c",
		flags & CC_N_BIT ? 'N' : 'n',
		flags & CC_Z_BIT ? 'Z' : 'z',
		flags & CC_C_BIT ? 'C' : 'c', flags & CC_V_BIT ? 'V' : 'v');
	printf ("  IRQs %s  FIQs %s  Mode %s%s\n",
34801f70:	e59fc054 	ldr	ip, [pc, #84]	; 34801fcc <show_regs+0x130>
34801f74:	e59f2054 	ldr	r2, [pc, #84]	; 34801fd0 <show_regs+0x134>
34801f78:	e3130080 	tst	r3, #128	; 0x80
34801f7c:	01a0100c 	moveq	r1, ip
34801f80:	11a01002 	movne	r1, r2
34801f84:	e28d0088 	add	r0, sp, #136	; 0x88
34801f88:	e3130040 	tst	r3, #64	; 0x40
		interrupts_enabled (regs) ? "on" : "off",
		fast_interrupts_enabled (regs) ? "on" : "off",
		processor_modes[processor_mode (regs)],
34801f8c:	e203301f 	and	r3, r3, #31
		regs->ARM_r3, regs->ARM_r2, regs->ARM_r1, regs->ARM_r0);
	printf ("Flags: %c%c%c%c",
		flags & CC_N_BIT ? 'N' : 'n',
		flags & CC_Z_BIT ? 'Z' : 'z',
		flags & CC_C_BIT ? 'C' : 'c', flags & CC_V_BIT ? 'V' : 'v');
	printf ("  IRQs %s  FIQs %s  Mode %s%s\n",
34801f90:	e0803103 	add	r3, r0, r3, lsl #2
34801f94:	e59f0038 	ldr	r0, [pc, #56]	; 34801fd4 <show_regs+0x138>
34801f98:	01a0200c 	moveq	r2, ip
34801f9c:	e58d0000 	str	r0, [sp]
34801fa0:	e5133080 	ldr	r3, [r3, #-128]	; 0x80
34801fa4:	e59f002c 	ldr	r0, [pc, #44]	; 34801fd8 <show_regs+0x13c>
34801fa8:	eb001be7 	bl	34808f4c <printf>
		interrupts_enabled (regs) ? "on" : "off",
		fast_interrupts_enabled (regs) ? "on" : "off",
		processor_modes[processor_mode (regs)],
		thumb_mode (regs) ? " (T)" : "");
}
34801fac:	e28dd088 	add	sp, sp, #136	; 0x88
34801fb0:	e8bd8070 	pop	{r4, r5, r6, pc}
34801fb4:	3482036c 	.word	0x3482036c
34801fb8:	34822c7d 	.word	0x34822c7d
34801fbc:	34822cc2 	.word	0x34822cc2
34801fc0:	34822ce6 	.word	0x34822ce6
34801fc4:	34822d16 	.word	0x34822d16
34801fc8:	34822d46 	.word	0x34822d46
34801fcc:	34827ac6 	.word	0x34827ac6
34801fd0:	34822f9e 	.word	0x34822f9e
34801fd4:	34824054 	.word	0x34824054
34801fd8:	34822d56 	.word	0x34822d56

34801fdc <do_undefined_instruction>:

void do_undefined_instruction (struct pt_regs *pt_regs)
{
34801fdc:	e92d4010 	push	{r4, lr}
34801fe0:	e1a04000 	mov	r4, r0
	printf ("undefined instruction\n");
34801fe4:	e59f0010 	ldr	r0, [pc, #16]	; 34801ffc <do_undefined_instruction+0x20>
34801fe8:	eb001bd7 	bl	34808f4c <printf>
	show_regs (pt_regs);
34801fec:	e1a00004 	mov	r0, r4
34801ff0:	ebffffa9 	bl	34801e9c <show_regs>
	bad_mode ();
}
34801ff4:	e8bd4010 	pop	{r4, lr}

void do_undefined_instruction (struct pt_regs *pt_regs)
{
	printf ("undefined instruction\n");
	show_regs (pt_regs);
	bad_mode ();
34801ff8:	eaffffa3 	b	34801e8c <bad_mode>
34801ffc:	34822d75 	.word	0x34822d75

34802000 <do_software_interrupt>:
}

void do_software_interrupt (struct pt_regs *pt_regs)
{
34802000:	e92d4010 	push	{r4, lr}
34802004:	e1a04000 	mov	r4, r0
	printf ("software interrupt\n");
34802008:	e59f0010 	ldr	r0, [pc, #16]	; 34802020 <do_software_interrupt+0x20>
3480200c:	eb001bce 	bl	34808f4c <printf>
	show_regs (pt_regs);
34802010:	e1a00004 	mov	r0, r4
34802014:	ebffffa0 	bl	34801e9c <show_regs>
	bad_mode ();
}
34802018:	e8bd4010 	pop	{r4, lr}

void do_software_interrupt (struct pt_regs *pt_regs)
{
	printf ("software interrupt\n");
	show_regs (pt_regs);
	bad_mode ();
3480201c:	eaffff9a 	b	34801e8c <bad_mode>
34802020:	34822d8c 	.word	0x34822d8c

34802024 <do_prefetch_abort>:
}

void do_prefetch_abort (struct pt_regs *pt_regs)
{
34802024:	e92d4010 	push	{r4, lr}
34802028:	e1a04000 	mov	r4, r0
	printf ("prefetch abort\n");
3480202c:	e59f0010 	ldr	r0, [pc, #16]	; 34802044 <do_prefetch_abort+0x20>
34802030:	eb001bc5 	bl	34808f4c <printf>
	show_regs (pt_regs);
34802034:	e1a00004 	mov	r0, r4
34802038:	ebffff97 	bl	34801e9c <show_regs>
	bad_mode ();
}
3480203c:	e8bd4010 	pop	{r4, lr}

void do_prefetch_abort (struct pt_regs *pt_regs)
{
	printf ("prefetch abort\n");
	show_regs (pt_regs);
	bad_mode ();
34802040:	eaffff91 	b	34801e8c <bad_mode>
34802044:	34822da0 	.word	0x34822da0

34802048 <do_data_abort>:
}

void do_data_abort (struct pt_regs *pt_regs)
{
34802048:	e92d4010 	push	{r4, lr}
3480204c:	e1a04000 	mov	r4, r0
	printf ("data abort\n");
34802050:	e59f0010 	ldr	r0, [pc, #16]	; 34802068 <do_data_abort+0x20>
34802054:	eb001bbc 	bl	34808f4c <printf>
	show_regs (pt_regs);
34802058:	e1a00004 	mov	r0, r4
3480205c:	ebffff8e 	bl	34801e9c <show_regs>
	bad_mode ();
}
34802060:	e8bd4010 	pop	{r4, lr}

void do_data_abort (struct pt_regs *pt_regs)
{
	printf ("data abort\n");
	show_regs (pt_regs);
	bad_mode ();
34802064:	eaffff88 	b	34801e8c <bad_mode>
34802068:	34822db0 	.word	0x34822db0

3480206c <do_not_used>:
}

void do_not_used (struct pt_regs *pt_regs)
{
3480206c:	e92d4010 	push	{r4, lr}
34802070:	e1a04000 	mov	r4, r0
	printf ("not used\n");
34802074:	e59f0010 	ldr	r0, [pc, #16]	; 3480208c <do_not_used+0x20>
34802078:	eb001bb3 	bl	34808f4c <printf>
	show_regs (pt_regs);
3480207c:	e1a00004 	mov	r0, r4
34802080:	ebffff85 	bl	34801e9c <show_regs>
	bad_mode ();
}
34802084:	e8bd4010 	pop	{r4, lr}

void do_not_used (struct pt_regs *pt_regs)
{
	printf ("not used\n");
	show_regs (pt_regs);
	bad_mode ();
34802088:	eaffff7f 	b	34801e8c <bad_mode>
3480208c:	34822dbc 	.word	0x34822dbc

34802090 <do_fiq>:
}

void do_fiq (struct pt_regs *pt_regs)
{
34802090:	e92d4010 	push	{r4, lr}
34802094:	e1a04000 	mov	r4, r0
	printf ("fast interrupt request\n");
34802098:	e59f0010 	ldr	r0, [pc, #16]	; 348020b0 <do_fiq+0x20>
3480209c:	eb001baa 	bl	34808f4c <printf>
	show_regs (pt_regs);
348020a0:	e1a00004 	mov	r0, r4
348020a4:	ebffff7c 	bl	34801e9c <show_regs>
	bad_mode ();
}
348020a8:	e8bd4010 	pop	{r4, lr}

void do_fiq (struct pt_regs *pt_regs)
{
	printf ("fast interrupt request\n");
	show_regs (pt_regs);
	bad_mode ();
348020ac:	eaffff76 	b	34801e8c <bad_mode>
348020b0:	34822dc6 	.word	0x34822dc6

348020b4 <do_irq>:
}

#ifndef CONFIG_USE_IRQ
void do_irq (struct pt_regs *pt_regs)
{
348020b4:	e92d4010 	push	{r4, lr}
348020b8:	e1a04000 	mov	r4, r0
	printf ("interrupt request\n");
348020bc:	e59f0010 	ldr	r0, [pc, #16]	; 348020d4 <do_irq+0x20>
348020c0:	eb001ba1 	bl	34808f4c <printf>
	show_regs (pt_regs);
348020c4:	e1a00004 	mov	r0, r4
348020c8:	ebffff73 	bl	34801e9c <show_regs>
	bad_mode ();
}
348020cc:	e8bd4010 	pop	{r4, lr}
#ifndef CONFIG_USE_IRQ
void do_irq (struct pt_regs *pt_regs)
{
	printf ("interrupt request\n");
	show_regs (pt_regs);
	bad_mode ();
348020d0:	eaffff6d 	b	34801e8c <bad_mode>
348020d4:	34822dcb 	.word	0x34822dcb

348020d8 <do_reset>:
 */

#include <common.h>

int do_reset(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
348020d8:	e92d4008 	push	{r3, lr}
	puts ("resetting ...\n");
348020dc:	e59f001c 	ldr	r0, [pc, #28]	; 34802100 <do_reset+0x28>
348020e0:	eb001b8f 	bl	34808f24 <puts>

	udelay (50000);				/* wait 50 ms */
348020e4:	e30c0350 	movw	r0, #50000	; 0xc350
348020e8:	eb005bf3 	bl	348190bc <udelay>

	disable_interrupts();
348020ec:	ebffff64 	bl	34801e84 <disable_interrupts>
	reset_cpu(0);
348020f0:	e3a00000 	mov	r0, #0
348020f4:	ebfffe11 	bl	34801940 <reset_cpu>

	/*NOTREACHED*/
	return 0;
}
348020f8:	e3a00000 	mov	r0, #0
348020fc:	e8bd8008 	pop	{r3, pc}
34802100:	34822eca 	.word	0x34822eca

34802104 <__flush_cache>:
	asm("0: mrc p15, 0, r15, c7, c10, 3\n\t" "bne 0b\n" : : : "memory");
	/* disable write buffer as well (page 2-22) */
	asm("mcr p15, 0, %0, c7, c10, 4" : : "r" (0));
#endif
	return;
}
34802104:	e12fff1e 	bx	lr

34802108 <__flush_dcache_all>:
 * Default implementation:
 * do a range flush for the entire range
 */
void	__flush_dcache_all(void)
{
	flush_cache(0, ~0);
34802108:	e3a00000 	mov	r0, #0
3480210c:	e3e01000 	mvn	r1, #0
34802110:	eafffbc2 	b	34801020 <flush_cache>

34802114 <__enable_caches>:
 * Default implementation of enable_caches()
 * Real implementation should be in platform code
 */
void __enable_caches(void)
{
	puts("WARNING: Caches not enabled\n");
34802114:	e59f0000 	ldr	r0, [pc, #0]	; 3480211c <__enable_caches+0x8>
34802118:	ea001b81 	b	34808f24 <puts>
3480211c:	34822ed9 	.word	0x34822ed9

34802120 <cp_delay>:
}
void arm_init_before_mmu(void)
	__attribute__((weak, alias("__arm_init_before_mmu")));

static void cp_delay (void)
{
34802120:	e24dd008 	sub	sp, sp, #8
	volatile int i;

	/* copro seems to need some delay between reading and writing */
	for (i = 0; i < 100; i++)
34802124:	e3a03000 	mov	r3, #0
34802128:	ea000002 	b	34802138 <cp_delay+0x18>
		nop();
3480212c:	e1a00000 	nop			; (mov r0, r0)
static void cp_delay (void)
{
	volatile int i;

	/* copro seems to need some delay between reading and writing */
	for (i = 0; i < 100; i++)
34802130:	e59d3004 	ldr	r3, [sp, #4]
34802134:	e2833001 	add	r3, r3, #1
34802138:	e58d3004 	str	r3, [sp, #4]
3480213c:	e59d3004 	ldr	r3, [sp, #4]
34802140:	e3530063 	cmp	r3, #99	; 0x63
34802144:	dafffff8 	ble	3480212c <cp_delay+0xc>
		nop();
	asm volatile("" : : : "memory");
}
34802148:	e28dd008 	add	sp, sp, #8
3480214c:	e12fff1e 	bx	lr

34802150 <cache_enable>:
static void cache_enable(uint32_t cache_bit)
{
	uint32_t reg;

	/* The data cache is not active unless the mmu is enabled too */
	if ((cache_bit == CR_C) && !mmu_enabled())
34802150:	e3500004 	cmp	r0, #4
	return get_cr() & CR_M;
}

/* cache_bit must be either CR_I or CR_C */
static void cache_enable(uint32_t cache_bit)
{
34802154:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
34802158:	e1a05000 	mov	r5, r0
	uint32_t reg;

	/* The data cache is not active unless the mmu is enabled too */
	if ((cache_bit == CR_C) && !mmu_enabled())
3480215c:	1a000024 	bne	348021f4 <cache_enable+0xa4>
#define nop() __asm__ __volatile__("mov\tr0,r0\t@ nop\n\t");

static inline unsigned int get_cr(void)
{
	unsigned int val;
	asm("mrc p15, 0, %0, c1, c0, 0	@ get CR" : "=r" (val) : : "cc");
34802160:	ee117f10 	mrc	15, 0, r7, cr1, cr0, {0}
34802164:	e2177001 	ands	r7, r7, #1
34802168:	1a000021 	bne	348021f4 <cache_enable+0xa4>
}

/* to activate the MMU we need to set up virtual memory: use 1M areas */
static inline void mmu_setup(void)
{
	u32 *page_table = (u32 *)gd->tlb_addr;
3480216c:	e598404c 	ldr	r4, [r8, #76]	; 0x4c
34802170:	e1a06004 	mov	r6, r4
	int i;
	u32 reg;

	arm_init_before_mmu();
34802174:	ebfffb9f 	bl	34800ff8 <arm_init_before_mmu>
	/* Set up an identity-mapping for all 4GB, rw for everyone */
	for (i = 0; i < 4096; i++)
		page_table[i] = i << 20 | (3 << 10) | 0x12;
34802178:	e1a03a07 	lsl	r3, r7, #20
3480217c:	e3833ec1 	orr	r3, r3, #3088	; 0xc10
	int i;
	u32 reg;

	arm_init_before_mmu();
	/* Set up an identity-mapping for all 4GB, rw for everyone */
	for (i = 0; i < 4096; i++)
34802180:	e2877001 	add	r7, r7, #1
		page_table[i] = i << 20 | (3 << 10) | 0x12;
34802184:	e3833002 	orr	r3, r3, #2
	int i;
	u32 reg;

	arm_init_before_mmu();
	/* Set up an identity-mapping for all 4GB, rw for everyone */
	for (i = 0; i < 4096; i++)
34802188:	e3570a01 	cmp	r7, #4096	; 0x1000
		page_table[i] = i << 20 | (3 << 10) | 0x12;
3480218c:	e4843004 	str	r3, [r4], #4
	int i;
	u32 reg;

	arm_init_before_mmu();
	/* Set up an identity-mapping for all 4GB, rw for everyone */
	for (i = 0; i < 4096; i++)
34802190:	1afffff8 	bne	34802178 <cache_enable+0x28>
	asm volatile("" : : : "memory");
}

static inline void dram_bank_mmu_setup(int bank)
{
	u32 *page_table = (u32 *)gd->tlb_addr;
34802194:	e598204c 	ldr	r2, [r8, #76]	; 0x4c
	bd_t *bd = gd->bd;
34802198:	e5980000 	ldr	r0, [r8]
{
	return get_cr() & CR_M;
}

/* cache_bit must be either CR_I or CR_C */
static void cache_enable(uint32_t cache_bit)
3480219c:	e2422004 	sub	r2, r2, #4
	u32 *page_table = (u32 *)gd->tlb_addr;
	bd_t *bd = gd->bd;
	int	i;

	debug("%s: bank: %d\n", __func__, bank);
	for (i = bd->bi_dram[bank].start >> 20;
348021a0:	e5901018 	ldr	r1, [r0, #24]
	     i < (bd->bi_dram[bank].start + bd->bi_dram[bank].size) >> 20;
348021a4:	e590001c 	ldr	r0, [r0, #28]
	u32 *page_table = (u32 *)gd->tlb_addr;
	bd_t *bd = gd->bd;
	int	i;

	debug("%s: bank: %d\n", __func__, bank);
	for (i = bd->bi_dram[bank].start >> 20;
348021a8:	e1a03a21 	lsr	r3, r1, #20
	     i < (bd->bi_dram[bank].start + bd->bi_dram[bank].size) >> 20;
348021ac:	e0811000 	add	r1, r1, r0
348021b0:	e1a01a21 	lsr	r1, r1, #20
348021b4:	e0822103 	add	r2, r2, r3, lsl #2
348021b8:	ea000004 	b	348021d0 <cache_enable+0x80>
	     i++) {
		page_table[i] = i << 20 | (3 << 10) | CACHE_SETUP;
348021bc:	e1a00a03 	lsl	r0, r3, #20
348021c0:	e3800ec1 	orr	r0, r0, #3088	; 0xc10
348021c4:	e380000e 	orr	r0, r0, #14
348021c8:	e5a20004 	str	r0, [r2, #4]!
	int	i;

	debug("%s: bank: %d\n", __func__, bank);
	for (i = bd->bi_dram[bank].start >> 20;
	     i < (bd->bi_dram[bank].start + bd->bi_dram[bank].size) >> 20;
	     i++) {
348021cc:	e2833001 	add	r3, r3, #1
	u32 *page_table = (u32 *)gd->tlb_addr;
	bd_t *bd = gd->bd;
	int	i;

	debug("%s: bank: %d\n", __func__, bank);
	for (i = bd->bi_dram[bank].start >> 20;
348021d0:	e1530001 	cmp	r3, r1
348021d4:	3afffff8 	bcc	348021bc <cache_enable+0x6c>
	for (i = 0; i < CONFIG_NR_DRAM_BANKS; i++) {
		dram_bank_mmu_setup(i);
	}

	/* Copy the page table address to cp15 */
	asm volatile("mcr p15, 0, %0, c2, c0, 0"
348021d8:	ee026f10 	mcr	15, 0, r6, cr2, cr0, {0}
		     : : "r" (page_table) : "memory");
	/* Set the access control to all-supervisor */
	asm volatile("mcr p15, 0, %0, c3, c0, 0"
348021dc:	e3e03000 	mvn	r3, #0
348021e0:	ee033f10 	mcr	15, 0, r3, cr3, cr0, {0}
		     : : "r" (~0));
	/* and enable the mmu */
	reg = get_cr();	/* get control reg. */
	cp_delay();
348021e4:	ebffffcd 	bl	34802120 <cp_delay>
348021e8:	ee114f10 	mrc	15, 0, r4, cr1, cr0, {0}
	set_cr(reg | CR_M);
348021ec:	e3844001 	orr	r4, r4, #1
	return val;
}

static inline void set_cr(unsigned int val)
{
	asm volatile("mcr p15, 0, %0, c1, c0, 0	@ set CR"
348021f0:	ee014f10 	mcr	15, 0, r4, cr1, cr0, {0}
#define nop() __asm__ __volatile__("mov\tr0,r0\t@ nop\n\t");

static inline unsigned int get_cr(void)
{
	unsigned int val;
	asm("mrc p15, 0, %0, c1, c0, 0	@ get CR" : "=r" (val) : : "cc");
348021f4:	ee114f10 	mrc	15, 0, r4, cr1, cr0, {0}

	/* The data cache is not active unless the mmu is enabled too */
	if ((cache_bit == CR_C) && !mmu_enabled())
		mmu_setup();
	reg = get_cr();	/* get control reg. */
	cp_delay();
348021f8:	ebffffc8 	bl	34802120 <cp_delay>
	set_cr(reg | cache_bit);
348021fc:	e1845005 	orr	r5, r4, r5
	return val;
}

static inline void set_cr(unsigned int val)
{
	asm volatile("mcr p15, 0, %0, c1, c0, 0	@ set CR"
34802200:	ee015f10 	mcr	15, 0, r5, cr1, cr0, {0}
}
34802204:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}

34802208 <cache_disable>:

/* cache_bit must be either CR_I or CR_C */
static void cache_disable(uint32_t cache_bit)
{
34802208:	e92d4038 	push	{r3, r4, r5, lr}
#define nop() __asm__ __volatile__("mov\tr0,r0\t@ nop\n\t");

static inline unsigned int get_cr(void)
{
	unsigned int val;
	asm("mrc p15, 0, %0, c1, c0, 0	@ get CR" : "=r" (val) : : "cc");
3480220c:	ee115f10 	mrc	15, 0, r5, cr1, cr0, {0}
34802210:	e1a04000 	mov	r4, r0
	uint32_t reg;

	reg = get_cr();
	cp_delay();
34802214:	ebffffc1 	bl	34802120 <cp_delay>

	if (cache_bit == CR_C) {
34802218:	e3540004 	cmp	r4, #4
3480221c:	1a000003 	bne	34802230 <cache_disable+0x28>
		/* if cache isn;t enabled no need to disable */
		if ((reg & CR_C) != CR_C)
34802220:	e3150004 	tst	r5, #4
34802224:	08bd8038 	popeq	{r3, r4, r5, pc}
			return;
		/* if disabling data cache, disable mmu too */
		cache_bit |= CR_M;
		flush_dcache_all();
34802228:	ebfffb5b 	bl	34800f9c <flush_dcache_all>
	if (cache_bit == CR_C) {
		/* if cache isn;t enabled no need to disable */
		if ((reg & CR_C) != CR_C)
			return;
		/* if disabling data cache, disable mmu too */
		cache_bit |= CR_M;
3480222c:	e2844001 	add	r4, r4, #1
		flush_dcache_all();
	}
	set_cr(reg & ~cache_bit);
34802230:	e1c54004 	bic	r4, r5, r4
	return val;
}

static inline void set_cr(unsigned int val)
{
	asm volatile("mcr p15, 0, %0, c1, c0, 0	@ set CR"
34802234:	ee014f10 	mcr	15, 0, r4, cr1, cr0, {0}
	  : : "r" (val) : "cc");
	isb();
34802238:	e8bd8038 	pop	{r3, r4, r5, pc}

3480223c <__arm_init_before_mmu>:

DECLARE_GLOBAL_DATA_PTR;

void __arm_init_before_mmu(void)
{
}
3480223c:	e12fff1e 	bx	lr

34802240 <icache_enable>:
	return 0;					/* always off */
}
#else
void icache_enable(void)
{
	cache_enable(CR_I);
34802240:	e3a00a01 	mov	r0, #4096	; 0x1000
34802244:	eaffffc1 	b	34802150 <cache_enable>

34802248 <icache_disable>:
}

void icache_disable(void)
{
	cache_disable(CR_I);
34802248:	e3a00a01 	mov	r0, #4096	; 0x1000
3480224c:	eaffffed 	b	34802208 <cache_disable>

34802250 <icache_status>:
#define nop() __asm__ __volatile__("mov\tr0,r0\t@ nop\n\t");

static inline unsigned int get_cr(void)
{
	unsigned int val;
	asm("mrc p15, 0, %0, c1, c0, 0	@ get CR" : "=r" (val) : : "cc");
34802250:	ee110f10 	mrc	15, 0, r0, cr1, cr0, {0}
}

int icache_status(void)
{
	return (get_cr() & CR_I) != 0;
}
34802254:	e7e00650 	ubfx	r0, r0, #12, #1
34802258:	e12fff1e 	bx	lr

3480225c <dcache_enable>:
	return 0;					/* always off */
}
#else
void dcache_enable(void)
{
	cache_enable(CR_C);
3480225c:	e3a00004 	mov	r0, #4
34802260:	eaffffba 	b	34802150 <cache_enable>

34802264 <dcache_disable>:
}

void dcache_disable(void)
{
	cache_disable(CR_C);
34802264:	e3a00004 	mov	r0, #4
34802268:	eaffffe6 	b	34802208 <cache_disable>

3480226c <dcache_status>:
3480226c:	ee110f10 	mrc	15, 0, r0, cr1, cr0, {0}
}

int dcache_status(void)
{
	return (get_cr() & CR_C) != 0;
}
34802270:	e7e00150 	ubfx	r0, r0, #2, #1
34802274:	e12fff1e 	bx	lr

34802278 <do_bdinfo>:
}

#elif defined(CONFIG_ARM)

int do_bdinfo(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
34802278:	e92d4030 	push	{r4, r5, lr}
	int i;
	bd_t *bd = gd->bd;
3480227c:	e5984000 	ldr	r4, [r8]
}

#elif defined(CONFIG_ARM)

int do_bdinfo(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
34802280:	e24dd014 	sub	sp, sp, #20
DECLARE_GLOBAL_DATA_PTR;

__maybe_unused
static void print_num(const char *name, ulong value)
{
	printf("%-12s= 0x%08lX\n", name, value);
34802284:	e5942004 	ldr	r2, [r4, #4]
34802288:	e59f1100 	ldr	r1, [pc, #256]	; 34802390 <do_bdinfo+0x118>
3480228c:	e59f0100 	ldr	r0, [pc, #256]	; 34802394 <do_bdinfo+0x11c>
34802290:	eb001b2d 	bl	34808f4c <printf>
34802294:	e5942008 	ldr	r2, [r4, #8]
34802298:	e59f10f8 	ldr	r1, [pc, #248]	; 34802398 <do_bdinfo+0x120>
3480229c:	e59f00f0 	ldr	r0, [pc, #240]	; 34802394 <do_bdinfo+0x11c>
348022a0:	eb001b29 	bl	34808f4c <printf>
348022a4:	e59f10f0 	ldr	r1, [pc, #240]	; 3480239c <do_bdinfo+0x124>
348022a8:	e3a02000 	mov	r2, #0
348022ac:	e59f00e0 	ldr	r0, [pc, #224]	; 34802394 <do_bdinfo+0x11c>
348022b0:	eb001b25 	bl	34808f4c <printf>
348022b4:	e5942018 	ldr	r2, [r4, #24]
348022b8:	e59f10e0 	ldr	r1, [pc, #224]	; 348023a0 <do_bdinfo+0x128>
348022bc:	e59f00d0 	ldr	r0, [pc, #208]	; 34802394 <do_bdinfo+0x11c>
348022c0:	eb001b21 	bl	34808f4c <printf>
{
	char name[10], *val;
	if (idx)
		sprintf(name, "eth%iaddr", idx);
	else
		strcpy(name, "ethaddr");
348022c4:	e28d5004 	add	r5, sp, #4
DECLARE_GLOBAL_DATA_PTR;

__maybe_unused
static void print_num(const char *name, ulong value)
{
	printf("%-12s= 0x%08lX\n", name, value);
348022c8:	e594201c 	ldr	r2, [r4, #28]
348022cc:	e59f10d0 	ldr	r1, [pc, #208]	; 348023a4 <do_bdinfo+0x12c>
348022d0:	e59f00bc 	ldr	r0, [pc, #188]	; 34802394 <do_bdinfo+0x11c>
348022d4:	eb001b1c 	bl	34808f4c <printf>
{
	char name[10], *val;
	if (idx)
		sprintf(name, "eth%iaddr", idx);
	else
		strcpy(name, "ethaddr");
348022d8:	e59f10c8 	ldr	r1, [pc, #200]	; 348023a8 <do_bdinfo+0x130>
348022dc:	e1a00005 	mov	r0, r5
348022e0:	eb0059c1 	bl	348189ec <strcpy>
	val = getenv(name);
348022e4:	e1a00005 	mov	r0, r5
348022e8:	eb0017d3 	bl	3480823c <getenv>
	if (!val)
		val = "(not set)";
348022ec:	e3500000 	cmp	r0, #0
348022f0:	e59f20b4 	ldr	r2, [pc, #180]	; 348023ac <do_bdinfo+0x134>
	printf("%-12s= %s\n", name, val);
348022f4:	e1a01005 	mov	r1, r5
		sprintf(name, "eth%iaddr", idx);
	else
		strcpy(name, "ethaddr");
	val = getenv(name);
	if (!val)
		val = "(not set)";
348022f8:	11a02000 	movne	r2, r0
	printf("%-12s= %s\n", name, val);
348022fc:	e59f00ac 	ldr	r0, [pc, #172]	; 348023b0 <do_bdinfo+0x138>
34802300:	eb001b11 	bl	34808f4c <printf>
		print_num("-> size",	bd->bi_dram[i].size);
	}

#if defined(CONFIG_CMD_NET)
	print_eth(0);
	printf("ip_addr     = %s\n", getenv("ipaddr"));
34802304:	e59f00a8 	ldr	r0, [pc, #168]	; 348023b4 <do_bdinfo+0x13c>
34802308:	eb0017cb 	bl	3480823c <getenv>
3480230c:	e1a01000 	mov	r1, r0
34802310:	e59f00a0 	ldr	r0, [pc, #160]	; 348023b8 <do_bdinfo+0x140>
34802314:	eb001b0c 	bl	34808f4c <printf>
#endif
	printf("baudrate    = %d bps\n", bd->bi_baudrate);
34802318:	e5941000 	ldr	r1, [r4]
3480231c:	e59f0098 	ldr	r0, [pc, #152]	; 348023bc <do_bdinfo+0x144>
34802320:	eb001b09 	bl	34808f4c <printf>
DECLARE_GLOBAL_DATA_PTR;

__maybe_unused
static void print_num(const char *name, ulong value)
{
	printf("%-12s= 0x%08lX\n", name, value);
34802324:	e59f1094 	ldr	r1, [pc, #148]	; 348023c0 <do_bdinfo+0x148>
	print_eth(0);
	printf("ip_addr     = %s\n", getenv("ipaddr"));
#endif
	printf("baudrate    = %d bps\n", bd->bi_baudrate);
#if !(defined(CONFIG_SYS_ICACHE_OFF) && defined(CONFIG_SYS_DCACHE_OFF))
	print_num("TLB addr", gd->tlb_addr);
34802328:	e598204c 	ldr	r2, [r8, #76]	; 0x4c
DECLARE_GLOBAL_DATA_PTR;

__maybe_unused
static void print_num(const char *name, ulong value)
{
	printf("%-12s= 0x%08lX\n", name, value);
3480232c:	e59f0060 	ldr	r0, [pc, #96]	; 34802394 <do_bdinfo+0x11c>
34802330:	eb001b05 	bl	34808f4c <printf>
34802334:	e59f1088 	ldr	r1, [pc, #136]	; 348023c4 <do_bdinfo+0x14c>
#endif
	printf("baudrate    = %d bps\n", bd->bi_baudrate);
#if !(defined(CONFIG_SYS_ICACHE_OFF) && defined(CONFIG_SYS_DCACHE_OFF))
	print_num("TLB addr", gd->tlb_addr);
#endif
	print_num("relocaddr", gd->relocaddr);
34802338:	e5982034 	ldr	r2, [r8, #52]	; 0x34
DECLARE_GLOBAL_DATA_PTR;

__maybe_unused
static void print_num(const char *name, ulong value)
{
	printf("%-12s= 0x%08lX\n", name, value);
3480233c:	e59f0050 	ldr	r0, [pc, #80]	; 34802394 <do_bdinfo+0x11c>
34802340:	eb001b01 	bl	34808f4c <printf>
34802344:	e59f107c 	ldr	r1, [pc, #124]	; 348023c8 <do_bdinfo+0x150>
	printf("baudrate    = %d bps\n", bd->bi_baudrate);
#if !(defined(CONFIG_SYS_ICACHE_OFF) && defined(CONFIG_SYS_DCACHE_OFF))
	print_num("TLB addr", gd->tlb_addr);
#endif
	print_num("relocaddr", gd->relocaddr);
	print_num("reloc off", gd->reloc_off);
34802348:	e5982048 	ldr	r2, [r8, #72]	; 0x48
DECLARE_GLOBAL_DATA_PTR;

__maybe_unused
static void print_num(const char *name, ulong value)
{
	printf("%-12s= 0x%08lX\n", name, value);
3480234c:	e59f0040 	ldr	r0, [pc, #64]	; 34802394 <do_bdinfo+0x11c>
34802350:	eb001afd 	bl	34808f4c <printf>
34802354:	e59f1070 	ldr	r1, [pc, #112]	; 348023cc <do_bdinfo+0x154>
#if !(defined(CONFIG_SYS_ICACHE_OFF) && defined(CONFIG_SYS_DCACHE_OFF))
	print_num("TLB addr", gd->tlb_addr);
#endif
	print_num("relocaddr", gd->relocaddr);
	print_num("reloc off", gd->reloc_off);
	print_num("irq_sp", gd->irq_sp);	/* irq stack pointer */
34802358:	e5982040 	ldr	r2, [r8, #64]	; 0x40
DECLARE_GLOBAL_DATA_PTR;

__maybe_unused
static void print_num(const char *name, ulong value)
{
	printf("%-12s= 0x%08lX\n", name, value);
3480235c:	e59f0030 	ldr	r0, [pc, #48]	; 34802394 <do_bdinfo+0x11c>
34802360:	eb001af9 	bl	34808f4c <printf>
34802364:	e59f1064 	ldr	r1, [pc, #100]	; 348023d0 <do_bdinfo+0x158>
	print_num("TLB addr", gd->tlb_addr);
#endif
	print_num("relocaddr", gd->relocaddr);
	print_num("reloc off", gd->reloc_off);
	print_num("irq_sp", gd->irq_sp);	/* irq stack pointer */
	print_num("sp start ", gd->start_addr_sp);
34802368:	e5982044 	ldr	r2, [r8, #68]	; 0x44
DECLARE_GLOBAL_DATA_PTR;

__maybe_unused
static void print_num(const char *name, ulong value)
{
	printf("%-12s= 0x%08lX\n", name, value);
3480236c:	e59f0020 	ldr	r0, [pc, #32]	; 34802394 <do_bdinfo+0x11c>
34802370:	eb001af5 	bl	34808f4c <printf>
34802374:	e59f1058 	ldr	r1, [pc, #88]	; 348023d4 <do_bdinfo+0x15c>
#endif
	print_num("relocaddr", gd->relocaddr);
	print_num("reloc off", gd->reloc_off);
	print_num("irq_sp", gd->irq_sp);	/* irq stack pointer */
	print_num("sp start ", gd->start_addr_sp);
	print_num("FB base  ", gd->fb_base);
34802378:	e5982018 	ldr	r2, [r8, #24]
DECLARE_GLOBAL_DATA_PTR;

__maybe_unused
static void print_num(const char *name, ulong value)
{
	printf("%-12s= 0x%08lX\n", name, value);
3480237c:	e59f0010 	ldr	r0, [pc, #16]	; 34802394 <do_bdinfo+0x11c>
34802380:	eb001af1 	bl	34808f4c <printf>
	printf("ARM frequency = %ld MHz\n", gd->bd->bi_arm_freq);
	printf("DSP frequency = %ld MHz\n", gd->bd->bi_dsp_freq);
	printf("DDR frequency = %ld MHz\n", gd->bd->bi_ddr_freq);
#endif
	return 0;
}
34802384:	e3a00000 	mov	r0, #0
34802388:	e28dd014 	add	sp, sp, #20
3480238c:	e8bd8030 	pop	{r4, r5, pc}
34802390:	34822f10 	.word	0x34822f10
34802394:	34822f00 	.word	0x34822f00
34802398:	34822f1c 	.word	0x34822f1c
3480239c:	34822f28 	.word	0x34822f28
348023a0:	34822f32 	.word	0x34822f32
348023a4:	34822f3b 	.word	0x34822f3b
348023a8:	34822f43 	.word	0x34822f43
348023ac:	34822ef6 	.word	0x34822ef6
348023b0:	34822f4b 	.word	0x34822f4b
348023b4:	34822f56 	.word	0x34822f56
348023b8:	34822f5d 	.word	0x34822f5d
348023bc:	34822f6f 	.word	0x34822f6f
348023c0:	34822f85 	.word	0x34822f85
348023c4:	34822f8e 	.word	0x34822f8e
348023c8:	34822f98 	.word	0x34822f98
348023cc:	34822fa2 	.word	0x34822fa2
348023d0:	34822fa9 	.word	0x34822fa9
348023d4:	34822fb3 	.word	0x34822fb3

348023d8 <do_go_exec>:
#ifdef CONFIG_CMD_GO

/* Allow ports to override the default behavior */
__attribute__((weak))
unsigned long do_go_exec (ulong (*entry)(int, char * const []), int argc, char * const argv[])
{
348023d8:	e92d4008 	push	{r3, lr}
348023dc:	e1a03000 	mov	r3, r0
	return entry (argc, argv);
348023e0:	e1a00001 	mov	r0, r1
348023e4:	e1a01002 	mov	r1, r2
348023e8:	e12fff33 	blx	r3
}
348023ec:	e8bd8008 	pop	{r3, pc}

348023f0 <do_go>:
int do_go (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	ulong	addr, rc;
	int     rcode = 0;

	if (argc < 2)
348023f0:	e3520001 	cmp	r2, #1
{
	return entry (argc, argv);
}

int do_go (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
348023f4:	e92d4070 	push	{r4, r5, r6, lr}
348023f8:	e1a04002 	mov	r4, r2
	ulong	addr, rc;
	int     rcode = 0;

	if (argc < 2)
		return CMD_RET_USAGE;
348023fc:	d3e04000 	mvnle	r4, #0
int do_go (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	ulong	addr, rc;
	int     rcode = 0;

	if (argc < 2)
34802400:	da000011 	ble	3480244c <do_go+0x5c>
		return CMD_RET_USAGE;

	addr = simple_strtoul(argv[1], NULL, 16);
34802404:	e5930004 	ldr	r0, [r3, #4]
34802408:	e3a02010 	mov	r2, #16
3480240c:	e3a01000 	mov	r1, #0
34802410:	e2835004 	add	r5, r3, #4
34802414:	eb005df7 	bl	34819bf8 <simple_strtoul>
34802418:	e1a06000 	mov	r6, r0

	printf ("## Starting application at 0x%08lX ...\n", addr);
3480241c:	e1a01006 	mov	r1, r6
34802420:	e59f002c 	ldr	r0, [pc, #44]	; 34802454 <do_go+0x64>
34802424:	eb001ac8 	bl	34808f4c <printf>

	/*
	 * pass address parameter as argv[0] (aka command name),
	 * and all remaining args
	 */
	rc = do_go_exec ((void *)addr, argc - 1, argv + 1);
34802428:	e2441001 	sub	r1, r4, #1
3480242c:	e1a00006 	mov	r0, r6
34802430:	e1a02005 	mov	r2, r5
34802434:	ebffffe7 	bl	348023d8 <do_go_exec>
}

int do_go (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	ulong	addr, rc;
	int     rcode = 0;
34802438:	e1a01000 	mov	r1, r0
3480243c:	e2504000 	subs	r4, r0, #0
34802440:	13a04001 	movne	r4, #1
	 * and all remaining args
	 */
	rc = do_go_exec ((void *)addr, argc - 1, argv + 1);
	if (rc != 0) rcode = 1;

	printf ("## Application terminated, rc = 0x%lX\n", rc);
34802444:	e59f000c 	ldr	r0, [pc, #12]	; 34802458 <do_go+0x68>
34802448:	eb001abf 	bl	34808f4c <printf>
	return rcode;
}
3480244c:	e1a00004 	mov	r0, r4
34802450:	e8bd8070 	pop	{r4, r5, r6, pc}
34802454:	34822fdf 	.word	0x34822fdf
34802458:	34823007 	.word	0x34823007

3480245c <__fswab32>:
}

static __inline__ __attribute__((const)) __u32 __fswab32(__u32 x)
{
	return __arch__swab32(x);
}
3480245c:	e6bf0f30 	rev	r0, r0
34802460:	e12fff1e 	bx	lr

34802464 <do_bootd>:
/*******************************************************************/
/* bootd - boot default image */
/*******************************************************************/
#if defined(CONFIG_CMD_BOOTD)
int do_bootd(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
34802464:	e92d4010 	push	{r4, lr}
	int rcode = 0;

	if (run_command(getenv("bootcmd"), flag) < 0)
34802468:	e59f0014 	ldr	r0, [pc, #20]	; 34802484 <do_bootd+0x20>
/*******************************************************************/
/* bootd - boot default image */
/*******************************************************************/
#if defined(CONFIG_CMD_BOOTD)
int do_bootd(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
3480246c:	e1a04001 	mov	r4, r1
	int rcode = 0;

	if (run_command(getenv("bootcmd"), flag) < 0)
34802470:	eb001771 	bl	3480823c <getenv>
34802474:	e1a01004 	mov	r1, r4
34802478:	eb002d90 	bl	3480dac0 <run_command>
		rcode = 1;
	return rcode;
}
3480247c:	e1a00fa0 	lsr	r0, r0, #31
34802480:	e8bd8010 	pop	{r4, pc}
34802484:	348230ce 	.word	0x348230ce

34802488 <do_bootm_rtems>:
static int do_bootm_rtems(int flag, int argc, char * const argv[],
			   bootm_headers_t *images)
{
	void (*entry_point)(bd_t *);

	if ((flag != 0) && (flag != BOOTM_STATE_OS_GO))
34802488:	e3500080 	cmp	r0, #128	; 0x80
3480248c:	13500000 	cmpne	r0, #0
#endif /* CONFIG_LYNXKDI */

#ifdef CONFIG_BOOTM_RTEMS
static int do_bootm_rtems(int flag, int argc, char * const argv[],
			   bootm_headers_t *images)
{
34802490:	e92d4010 	push	{r4, lr}
	void (*entry_point)(bd_t *);

	if ((flag != 0) && (flag != BOOTM_STATE_OS_GO))
34802494:	1a000007 	bne	348024b8 <do_bootm_rtems+0x30>
		fit_unsupported_reset("RTEMS");
		return 1;
	}
#endif

	entry_point = (void (*)(bd_t *))images->ep;
34802498:	e5934060 	ldr	r4, [r3, #96]	; 0x60

	printf("## Transferring control to RTEMS (at address %08lx) ...\n",
3480249c:	e59f001c 	ldr	r0, [pc, #28]	; 348024c0 <do_bootm_rtems+0x38>
348024a0:	e1a01004 	mov	r1, r4
348024a4:	eb001aa8 	bl	34808f4c <printf>
348024a8:	e3a0000f 	mov	r0, #15
348024ac:	eb002b1d 	bl	3480d128 <__show_boot_progress>

	/*
	 * RTEMS Parameters:
	 *   r3: ptr to board info data
	 */
	(*entry_point)(gd->bd);
348024b0:	e5980000 	ldr	r0, [r8]
348024b4:	e12fff34 	blx	r4

	return 1;
}
348024b8:	e3a00001 	mov	r0, #1
348024bc:	e8bd8010 	pop	{r4, pc}
348024c0:	348230d6 	.word	0x348230d6

348024c4 <do_bootm_netbsd>:
	image_header_t *os_hdr, *hdr;
	ulong kernel_data, kernel_len;
	char *consdev;
	char *cmdline;

	if ((flag != 0) && (flag != BOOTM_STATE_OS_GO))
348024c4:	e3500080 	cmp	r0, #128	; 0x80
348024c8:	13500000 	cmpne	r0, #0
/*******************************************************************/

#ifdef CONFIG_BOOTM_NETBSD
static int do_bootm_netbsd(int flag, int argc, char * const argv[],
			    bootm_headers_t *images)
{
348024cc:	e92d4eff 	push	{r0, r1, r2, r3, r4, r5, r6, r7, r9, sl, fp, lr}
348024d0:	e1a05001 	mov	r5, r1
348024d4:	e1a07002 	mov	r7, r2
348024d8:	e1a04003 	mov	r4, r3
	image_header_t *os_hdr, *hdr;
	ulong kernel_data, kernel_len;
	char *consdev;
	char *cmdline;

	if ((flag != 0) && (flag != BOOTM_STATE_OS_GO))
348024dc:	03a00000 	moveq	r0, #0
348024e0:	13a00001 	movne	r0, #1
348024e4:	1a00003e 	bne	348025e4 <do_bootm_netbsd+0x120>
	if (!images->legacy_hdr_valid) {
		fit_unsupported_reset("NetBSD");
		return 1;
	}
#endif
	hdr = images->legacy_hdr_os;
348024e8:	e5936000 	ldr	r6, [r3]
	 * besides the board info strucure, the loader expects a command
	 * line, the name of the console device, and (optionally) the
	 * address of the original image header.
	 */
	os_hdr = NULL;
	if (image_check_type(&images->legacy_hdr_os_copy, IH_TYPE_MULTI)) {
348024ec:	e5d33022 	ldrb	r3, [r3, #34]	; 0x22
348024f0:	e3530004 	cmp	r3, #4
	 * kernel.  The only differences are the parameters being passed:
	 * besides the board info strucure, the loader expects a command
	 * line, the name of the console device, and (optionally) the
	 * address of the original image header.
	 */
	os_hdr = NULL;
348024f4:	11a06000 	movne	r6, r0
	if (image_check_type(&images->legacy_hdr_os_copy, IH_TYPE_MULTI)) {
348024f8:	1a000007 	bne	3480251c <do_bootm_netbsd+0x58>
		image_multi_getimg(hdr, 1, &kernel_data, &kernel_len);
348024fc:	e1a00006 	mov	r0, r6
34802500:	e28d3008 	add	r3, sp, #8
34802504:	e3a01001 	mov	r1, #1
34802508:	e28d200c 	add	r2, sp, #12
3480250c:	eb00289f 	bl	3480c790 <image_multi_getimg>
	 * kernel.  The only differences are the parameters being passed:
	 * besides the board info strucure, the loader expects a command
	 * line, the name of the console device, and (optionally) the
	 * address of the original image header.
	 */
	os_hdr = NULL;
34802510:	e59d3008 	ldr	r3, [sp, #8]
34802514:	e3530000 	cmp	r3, #0
34802518:	03a06000 	moveq	r6, #0
	consdev = "scc2";
#elif defined(CONFIG_8xx_CONS_SCC3)
	consdev = "scc3";
#endif

	if (argc > 2) {
3480251c:	e3550002 	cmp	r5, #2
34802520:	da00001f 	ble	348025a4 <do_bootm_netbsd+0xe0>
/*******************************************************************/
/* OS booting routines */
/*******************************************************************/

#ifdef CONFIG_BOOTM_NETBSD
static int do_bootm_netbsd(int flag, int argc, char * const argv[],
34802524:	e287b004 	add	fp, r7, #4
34802528:	e3a09002 	mov	r9, #2
3480252c:	e3a0a000 	mov	sl, #0
	if (argc > 2) {
		ulong len;
		int   i;

		for (i = 2, len = 0; i < argc; i += 1)
			len += strlen(argv[i]) + 1;
34802530:	e5bb0004 	ldr	r0, [fp, #4]!
34802534:	eb005991 	bl	34818b80 <strlen>

	if (argc > 2) {
		ulong len;
		int   i;

		for (i = 2, len = 0; i < argc; i += 1)
34802538:	e2899001 	add	r9, r9, #1
			len += strlen(argv[i]) + 1;
3480253c:	e080a00a 	add	sl, r0, sl

	if (argc > 2) {
		ulong len;
		int   i;

		for (i = 2, len = 0; i < argc; i += 1)
34802540:	e1590005 	cmp	r9, r5
			len += strlen(argv[i]) + 1;
34802544:	e28aa001 	add	sl, sl, #1

	if (argc > 2) {
		ulong len;
		int   i;

		for (i = 2, len = 0; i < argc; i += 1)
34802548:	bafffff8 	blt	34802530 <do_bootm_netbsd+0x6c>
			len += strlen(argv[i]) + 1;
		cmdline = malloc(len);
3480254c:	e1a0000a 	mov	r0, sl
34802550:	eb001c44 	bl	34809668 <malloc>
/*******************************************************************/
/* OS booting routines */
/*******************************************************************/

#ifdef CONFIG_BOOTM_NETBSD
static int do_bootm_netbsd(int flag, int argc, char * const argv[],
34802554:	e2877008 	add	r7, r7, #8
		ulong len;
		int   i;

		for (i = 2, len = 0; i < argc; i += 1)
			len += strlen(argv[i]) + 1;
		cmdline = malloc(len);
34802558:	e1a0a000 	mov	sl, r0

		for (i = 2, len = 0; i < argc; i += 1) {
3480255c:	e3a0b002 	mov	fp, #2
34802560:	e3a09000 	mov	r9, #0
			if (i > 2)
				cmdline[len++] = ' ';
34802564:	e3a03020 	mov	r3, #32
34802568:	ea000002 	b	34802578 <do_bootm_netbsd+0xb4>
			strcpy(&cmdline[len], argv[i]);
			len += strlen(argv[i]);
3480256c:	e0809009 	add	r9, r0, r9
			len += strlen(argv[i]) + 1;
		cmdline = malloc(len);

		for (i = 2, len = 0; i < argc; i += 1) {
			if (i > 2)
				cmdline[len++] = ' ';
34802570:	e7ca3009 	strb	r3, [sl, r9]
34802574:	e2899001 	add	r9, r9, #1
			strcpy(&cmdline[len], argv[i]);
34802578:	e5971000 	ldr	r1, [r7]
3480257c:	e08a0009 	add	r0, sl, r9
34802580:	e58d3004 	str	r3, [sp, #4]

		for (i = 2, len = 0; i < argc; i += 1)
			len += strlen(argv[i]) + 1;
		cmdline = malloc(len);

		for (i = 2, len = 0; i < argc; i += 1) {
34802584:	e28bb001 	add	fp, fp, #1
			if (i > 2)
				cmdline[len++] = ' ';
			strcpy(&cmdline[len], argv[i]);
34802588:	eb005917 	bl	348189ec <strcpy>
			len += strlen(argv[i]);
3480258c:	e4970004 	ldr	r0, [r7], #4
34802590:	eb00597a 	bl	34818b80 <strlen>

		for (i = 2, len = 0; i < argc; i += 1)
			len += strlen(argv[i]) + 1;
		cmdline = malloc(len);

		for (i = 2, len = 0; i < argc; i += 1) {
34802594:	e15b0005 	cmp	fp, r5
34802598:	e59d3004 	ldr	r3, [sp, #4]
3480259c:	bafffff2 	blt	3480256c <do_bootm_netbsd+0xa8>
348025a0:	ea000004 	b	348025b8 <do_bootm_netbsd+0xf4>
			if (i > 2)
				cmdline[len++] = ' ';
			strcpy(&cmdline[len], argv[i]);
			len += strlen(argv[i]);
		}
	} else if ((cmdline = getenv("bootargs")) == NULL) {
348025a4:	e59f0044 	ldr	r0, [pc, #68]	; 348025f0 <do_bootm_netbsd+0x12c>
348025a8:	eb001723 	bl	3480823c <getenv>
		cmdline = "";
348025ac:	e3500000 	cmp	r0, #0
348025b0:	e59fa03c 	ldr	sl, [pc, #60]	; 348025f4 <do_bootm_netbsd+0x130>
348025b4:	11a0a000 	movne	sl, r0
	}

	loader = (void (*)(bd_t *, image_header_t *, char *, char *))images->ep;
348025b8:	e5944060 	ldr	r4, [r4, #96]	; 0x60

	printf("## Transferring control to NetBSD stage-2 loader "
348025bc:	e59f0034 	ldr	r0, [pc, #52]	; 348025f8 <do_bootm_netbsd+0x134>
348025c0:	e1a01004 	mov	r1, r4
348025c4:	eb001a60 	bl	34808f4c <printf>
348025c8:	e3a0000f 	mov	r0, #15
348025cc:	eb002ad5 	bl	3480d128 <__show_boot_progress>
	 *   r3: ptr to board info data
	 *   r4: image address
	 *   r5: console device
	 *   r6: boot args string
	 */
	(*loader)(gd->bd, os_hdr, consdev, cmdline);
348025d0:	e1a01006 	mov	r1, r6
348025d4:	e5980000 	ldr	r0, [r8]
348025d8:	e59f2014 	ldr	r2, [pc, #20]	; 348025f4 <do_bootm_netbsd+0x130>
348025dc:	e1a0300a 	mov	r3, sl
348025e0:	e12fff34 	blx	r4

	return 1;
}
348025e4:	e3a00001 	mov	r0, #1
348025e8:	e28dd010 	add	sp, sp, #16
348025ec:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
348025f0:	34822c1e 	.word	0x34822c1e
348025f4:	34824054 	.word	0x34824054
348025f8:	3482310f 	.word	0x3482310f

348025fc <image_check_magic.clone.9>:
phys_size_t getenv_bootm_size(void);
phys_size_t getenv_bootm_mapsize(void);
void memmove_wd(void *to, void *from, size_t len, ulong chunksz);
#endif

static inline int image_check_magic(const image_header_t *hdr)
348025fc:	e92d4008 	push	{r3, lr}
#define image_get_hdr_l(f) \
	static inline uint32_t image_get_##f(const image_header_t *hdr) \
	{ \
		return uimage_to_cpu(hdr->ih_##f); \
	}
image_get_hdr_l(magic)		/* image_get_magic */
34802600:	ebffff95 	bl	3480245c <__fswab32>
#endif

static inline int image_check_magic(const image_header_t *hdr)
{
	return (image_get_magic(hdr) == IH_MAGIC);
}
34802604:	e59f300c 	ldr	r3, [pc, #12]	; 34802618 <image_check_magic.clone.9+0x1c>
34802608:	e1500003 	cmp	r0, r3
3480260c:	13a00000 	movne	r0, #0
34802610:	03a00001 	moveq	r0, #1
34802614:	e8bd8008 	pop	{r3, pc}
34802618:	27051956 	.word	0x27051956

3480261c <image_info>:
	}
	return rcode;
}

static int image_info(ulong addr)
{
3480261c:	e92d4038 	push	{r3, r4, r5, lr}
34802620:	e1a04000 	mov	r4, r0
	void *hdr = (void *)addr;

	printf("\n## Checking Image at %08lx ...\n", addr);
34802624:	e1a01004 	mov	r1, r4
34802628:	e59f0094 	ldr	r0, [pc, #148]	; 348026c4 <image_info+0xa8>
3480262c:	eb001a46 	bl	34808f4c <printf>

	switch (genimg_get_format(hdr)) {
34802630:	e1a00004 	mov	r0, r4
34802634:	eb00296a 	bl	3480cbe4 <genimg_get_format>
34802638:	e3500001 	cmp	r0, #1
3480263c:	e1a05000 	mov	r5, r0
34802640:	1a00001a 	bne	348026b0 <image_info+0x94>
	case IMAGE_FORMAT_LEGACY:
		puts("   Legacy image found\n");
34802644:	e59f007c 	ldr	r0, [pc, #124]	; 348026c8 <image_info+0xac>
34802648:	eb001a35 	bl	34808f24 <puts>
		if (!image_check_magic(hdr)) {
3480264c:	e5940000 	ldr	r0, [r4]
34802650:	ebffffe9 	bl	348025fc <image_check_magic.clone.9>
34802654:	e3500000 	cmp	r0, #0
			puts("   Bad Magic Number\n");
34802658:	059f006c 	ldreq	r0, [pc, #108]	; 348026cc <image_info+0xb0>
	printf("\n## Checking Image at %08lx ...\n", addr);

	switch (genimg_get_format(hdr)) {
	case IMAGE_FORMAT_LEGACY:
		puts("   Legacy image found\n");
		if (!image_check_magic(hdr)) {
3480265c:	0a000004 	beq	34802674 <image_info+0x58>
			puts("   Bad Magic Number\n");
			return 1;
		}

		if (!image_check_hcrc(hdr)) {
34802660:	e1a00004 	mov	r0, r4
34802664:	eb00281d 	bl	3480c6e0 <image_check_hcrc>
34802668:	e3500000 	cmp	r0, #0
3480266c:	1a000002 	bne	3480267c <image_info+0x60>
			puts("   Bad Header Checksum\n");
34802670:	e59f0058 	ldr	r0, [pc, #88]	; 348026d0 <image_info+0xb4>
34802674:	eb001a2a 	bl	34808f24 <puts>
			return 1;
34802678:	ea00000f 	b	348026bc <image_info+0xa0>
		}

		image_print_contents(hdr);
3480267c:	e1a00004 	mov	r0, r4
34802680:	eb0028ce 	bl	3480c9c0 <image_print_contents>

		puts("   Verifying Checksum ... ");
34802684:	e59f0048 	ldr	r0, [pc, #72]	; 348026d4 <image_info+0xb8>
34802688:	eb001a25 	bl	34808f24 <puts>
		if (!image_check_dcrc(hdr)) {
3480268c:	e1a00004 	mov	r0, r4
34802690:	eb002826 	bl	3480c730 <image_check_dcrc>
34802694:	e3500000 	cmp	r0, #0
			puts("   Bad Data CRC\n");
34802698:	059f0038 	ldreq	r0, [pc, #56]	; 348026d8 <image_info+0xbc>
		}

		image_print_contents(hdr);

		puts("   Verifying Checksum ... ");
		if (!image_check_dcrc(hdr)) {
3480269c:	0afffff4 	beq	34802674 <image_info+0x58>
			puts("   Bad Data CRC\n");
			return 1;
		}
		puts("OK\n");
348026a0:	e59f0034 	ldr	r0, [pc, #52]	; 348026dc <image_info+0xc0>
348026a4:	eb001a1e 	bl	34808f24 <puts>
		return 0;
348026a8:	e3a05000 	mov	r5, #0
348026ac:	ea000002 	b	348026bc <image_info+0xa0>
		}

		return 0;
#endif
	default:
		puts("Unknown image format!\n");
348026b0:	e59f0028 	ldr	r0, [pc, #40]	; 348026e0 <image_info+0xc4>
348026b4:	eb001a1a 	bl	34808f24 <puts>
		break;
	}

	return 1;
348026b8:	e3a05001 	mov	r5, #1
}
348026bc:	e1a00005 	mov	r0, r5
348026c0:	e8bd8038 	pop	{r3, r4, r5, pc}
348026c4:	34823158 	.word	0x34823158
348026c8:	34823179 	.word	0x34823179
348026cc:	34823190 	.word	0x34823190
348026d0:	348231a5 	.word	0x348231a5
348026d4:	348231bd 	.word	0x348231bd
348026d8:	348231d8 	.word	0x348231d8
348026dc:	348231e9 	.word	0x348231e9
348026e0:	348231ed 	.word	0x348231ed

348026e4 <do_iminfo>:
{
	int	arg;
	ulong	addr;
	int	rcode = 0;

	if (argc < 2) {
348026e4:	e3520001 	cmp	r2, #1
/*******************************************************************/
/* iminfo - print header info for a requested image */
/*******************************************************************/
#if defined(CONFIG_CMD_IMI)
int do_iminfo(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
348026e8:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
348026ec:	e1a04002 	mov	r4, r2
	int	arg;
	ulong	addr;
	int	rcode = 0;

	if (argc < 2) {
		return image_info(load_addr);
348026f0:	c1a07003 	movgt	r7, r3
{
	int	arg;
	ulong	addr;
	int	rcode = 0;

	if (argc < 2) {
348026f4:	c3a05000 	movgt	r5, #0
348026f8:	c3a06001 	movgt	r6, #1
348026fc:	ca000003 	bgt	34802710 <do_iminfo+0x2c>
		return image_info(load_addr);
34802700:	e59f3038 	ldr	r3, [pc, #56]	; 34802740 <do_iminfo+0x5c>
34802704:	e5930000 	ldr	r0, [r3]
		addr = simple_strtoul(argv[arg], NULL, 16);
		if (image_info(addr) != 0)
			rcode = 1;
	}
	return rcode;
}
34802708:	e8bd41f0 	pop	{r4, r5, r6, r7, r8, lr}
	int	arg;
	ulong	addr;
	int	rcode = 0;

	if (argc < 2) {
		return image_info(load_addr);
3480270c:	eaffffc2 	b	3480261c <image_info>
	}

	for (arg = 1; arg < argc; ++arg) {
		addr = simple_strtoul(argv[arg], NULL, 16);
34802710:	e3a01000 	mov	r1, #0
34802714:	e3a02010 	mov	r2, #16
34802718:	e5b70004 	ldr	r0, [r7, #4]!
3480271c:	eb005d35 	bl	34819bf8 <simple_strtoul>
		if (image_info(addr) != 0)
34802720:	ebffffbd 	bl	3480261c <image_info>

	if (argc < 2) {
		return image_info(load_addr);
	}

	for (arg = 1; arg < argc; ++arg) {
34802724:	e2866001 	add	r6, r6, #1
		addr = simple_strtoul(argv[arg], NULL, 16);
		if (image_info(addr) != 0)
			rcode = 1;
34802728:	e3500000 	cmp	r0, #0
3480272c:	13a05001 	movne	r5, #1

	if (argc < 2) {
		return image_info(load_addr);
	}

	for (arg = 1; arg < argc; ++arg) {
34802730:	e1560004 	cmp	r6, r4
34802734:	bafffff5 	blt	34802710 <do_iminfo+0x2c>
		addr = simple_strtoul(argv[arg], NULL, 16);
		if (image_info(addr) != 0)
			rcode = 1;
	}
	return rcode;
}
34802738:	e1a00005 	mov	r0, r5
3480273c:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
34802740:	348283c4 	.word	0x348283c4

34802744 <image_get_size.clone.10>:
		return uimage_to_cpu(hdr->ih_##f); \
	}
image_get_hdr_l(magic)		/* image_get_magic */
image_get_hdr_l(hcrc)		/* image_get_hcrc */
image_get_hdr_l(time)		/* image_get_time */
image_get_hdr_l(size)		/* image_get_size */
34802744:	eaffff44 	b	3480245c <__fswab32>

34802748 <bootm_load_os.clone.18>:
}

#define BOOTM_ERR_RESET		-1
#define BOOTM_ERR_OVERLAP	-2
#define BOOTM_ERR_UNIMPLEMENTED	-3
static int bootm_load_os(image_info_t os, ulong *load_end, int boot_progress)
34802748:	e92d46f7 	push	{r0, r1, r2, r4, r5, r6, r7, r9, sl, lr}
3480274c:	e1a07000 	mov	r7, r0
34802750:	e5dd0030 	ldrb	r0, [sp, #48]	; 0x30
34802754:	e1a09001 	mov	r9, r1
34802758:	e5dd602c 	ldrb	r6, [sp, #44]	; 0x2c
3480275c:	e1a0a002 	mov	sl, r2
34802760:	e59d4028 	ldr	r4, [sp, #40]	; 0x28
34802764:	e59d5034 	ldr	r5, [sp, #52]	; 0x34
	uint8_t comp = os.comp;
	ulong load = os.load;
	ulong blob_start = os.start;
	ulong blob_end = os.end;
	ulong image_start = os.image_start;
	ulong image_len = os.image_len;
34802768:	e58d3004 	str	r3, [sp, #4]
	int no_overlap = 0;
#if defined(CONFIG_LZMA) || defined(CONFIG_LZO)
	int ret;
#endif /* defined(CONFIG_LZMA) || defined(CONFIG_LZO) */

	const char *type_name = genimg_get_type_name(os.type);
3480276c:	eb002887 	bl	3480c990 <genimg_get_type_name>

	switch (comp) {
34802770:	e3560000 	cmp	r6, #0
	int no_overlap = 0;
#if defined(CONFIG_LZMA) || defined(CONFIG_LZO)
	int ret;
#endif /* defined(CONFIG_LZMA) || defined(CONFIG_LZO) */

	const char *type_name = genimg_get_type_name(os.type);
34802774:	e1a01000 	mov	r1, r0

	switch (comp) {
34802778:	0a000002 	beq	34802788 <bootm_load_os.clone.18+0x40>
3480277c:	e3560001 	cmp	r6, #1
34802780:	1a00002a 	bne	34802830 <bootm_load_os.clone.18+0xe8>
34802784:	ea000015 	b	348027e0 <bootm_load_os.clone.18+0x98>
	case IH_COMP_NONE:
		if (load == blob_start || load == image_start) {
34802788:	e1540007 	cmp	r4, r7
3480278c:	1154000a 	cmpne	r4, sl
34802790:	13a06000 	movne	r6, #0
34802794:	03a06001 	moveq	r6, #1
34802798:	1a000003 	bne	348027ac <bootm_load_os.clone.18+0x64>
			printf("   XIP %s ... ", type_name);
3480279c:	e59f00f8 	ldr	r0, [pc, #248]	; 3480289c <bootm_load_os.clone.18+0x154>
348027a0:	eb0019e9 	bl	34808f4c <printf>
			no_overlap = 1;
348027a4:	e3a06001 	mov	r6, #1
348027a8:	ea000006 	b	348027c8 <bootm_load_os.clone.18+0x80>
		} else {
			printf("   Loading %s ... ", type_name);
348027ac:	e59f00ec 	ldr	r0, [pc, #236]	; 348028a0 <bootm_load_os.clone.18+0x158>
348027b0:	eb0019e5 	bl	34808f4c <printf>
			memmove_wd((void *)load, (void *)image_start,
348027b4:	e1a00004 	mov	r0, r4
348027b8:	e1a0100a 	mov	r1, sl
348027bc:	e59d2004 	ldr	r2, [sp, #4]
348027c0:	e3a03801 	mov	r3, #65536	; 0x10000
348027c4:	eb00284b 	bl	3480c8f8 <memmove_wd>
					image_len, CHUNKSZ);
		}
		*load_end = load + image_len;
348027c8:	e59d3004 	ldr	r3, [sp, #4]
		puts("OK\n");
348027cc:	e59f00d0 	ldr	r0, [pc, #208]	; 348028a4 <bootm_load_os.clone.18+0x15c>
		} else {
			printf("   Loading %s ... ", type_name);
			memmove_wd((void *)load, (void *)image_start,
					image_len, CHUNKSZ);
		}
		*load_end = load + image_len;
348027d0:	e0843003 	add	r3, r4, r3
348027d4:	e5853000 	str	r3, [r5]
		puts("OK\n");
348027d8:	eb0019d1 	bl	34808f24 <puts>
348027dc:	ea000018 	b	34802844 <bootm_load_os.clone.18+0xfc>
		break;
#ifdef CONFIG_GZIP
	case IH_COMP_GZIP:
		printf("   Uncompressing %s ... ", type_name);
348027e0:	e59f00c0 	ldr	r0, [pc, #192]	; 348028a8 <bootm_load_os.clone.18+0x160>
348027e4:	eb0019d8 	bl	34808f4c <printf>
		if (gunzip((void *)load, unc_len,
348027e8:	e28d3004 	add	r3, sp, #4
348027ec:	e1a00004 	mov	r0, r4
348027f0:	e3a01502 	mov	r1, #8388608	; 0x800000
348027f4:	e1a0200a 	mov	r2, sl
348027f8:	eb005368 	bl	348175a0 <gunzip>
348027fc:	e2506000 	subs	r6, r0, #0
			if (boot_progress)
				bootstage_error(BOOTSTAGE_ID_DECOMP_IMAGE);
			return BOOTM_ERR_RESET;
		}

		*load_end = load + image_len;
34802800:	059d3004 	ldreq	r3, [sp, #4]
34802804:	00843003 	addeq	r3, r4, r3
34802808:	05853000 	streq	r3, [r5]
		puts("OK\n");
		break;
#ifdef CONFIG_GZIP
	case IH_COMP_GZIP:
		printf("   Uncompressing %s ... ", type_name);
		if (gunzip((void *)load, unc_len,
3480280c:	0a00000c 	beq	34802844 <bootm_load_os.clone.18+0xfc>
				(uchar *)image_start, &image_len) != 0) {
			puts("GUNZIP: uncompress, out-of-mem or overwrite "
34802810:	e59f0094 	ldr	r0, [pc, #148]	; 348028ac <bootm_load_os.clone.18+0x164>
34802814:	eb0019c2 	bl	34808f24 <puts>
				"error - must RESET board to recover\n");
			if (boot_progress)
34802818:	e59d3038 	ldr	r3, [sp, #56]	; 0x38
3480281c:	e3530000 	cmp	r3, #0
34802820:	0a00001b 	beq	34802894 <bootm_load_os.clone.18+0x14c>
	return 0;
}

static inline ulong bootstage_error(enum bootstage_id id)
{
	show_boot_progress(-id);
34802824:	e3e00005 	mvn	r0, #5
34802828:	eb002a3e 	bl	3480d128 <__show_boot_progress>
3480282c:	ea000018 	b	34802894 <bootm_load_os.clone.18+0x14c>

		*load_end = load + unc_len;
		break;
#endif /* CONFIG_LZO */
	default:
		printf("Unimplemented compression type %d\n", comp);
34802830:	e59f0078 	ldr	r0, [pc, #120]	; 348028b0 <bootm_load_os.clone.18+0x168>
34802834:	e1a01006 	mov	r1, r6
34802838:	eb0019c3 	bl	34808f4c <printf>
		return BOOTM_ERR_UNIMPLEMENTED;
3480283c:	e3e00002 	mvn	r0, #2
34802840:	ea000014 	b	34802898 <bootm_load_os.clone.18+0x150>
	}

	flush_cache(load, (*load_end - load) * sizeof(ulong));
34802844:	e5951000 	ldr	r1, [r5]
34802848:	e1a00004 	mov	r0, r4
3480284c:	e0641001 	rsb	r1, r4, r1
34802850:	e1a01101 	lsl	r1, r1, #2
34802854:	ebfff9f1 	bl	34801020 <flush_cache>

	puts("OK\n");
34802858:	e59f0044 	ldr	r0, [pc, #68]	; 348028a4 <bootm_load_os.clone.18+0x15c>
3480285c:	eb0019b0 	bl	34808f24 <puts>
 * and won't even do that unless CONFIG_SHOW_BOOT_PROGRESS is defined
 */

static inline ulong bootstage_mark(enum bootstage_id id)
{
	show_boot_progress(id);
34802860:	e3a00007 	mov	r0, #7
34802864:	eb002a2f 	bl	3480d128 <__show_boot_progress>
	debug("   kernel loaded at 0x%08lx, end = 0x%08lx\n", load, *load_end);
	bootstage_mark(BOOTSTAGE_ID_KERNEL_LOADED);

	if (!no_overlap && (load < blob_end) && (*load_end > blob_start)) {
34802868:	e2760001 	rsbs	r0, r6, #1
3480286c:	33a00000 	movcc	r0, #0
34802870:	e1540009 	cmp	r4, r9
34802874:	23a00000 	movcs	r0, #0
34802878:	e3500000 	cmp	r0, #0
3480287c:	0a000005 	beq	34802898 <bootm_load_os.clone.18+0x150>
34802880:	e5953000 	ldr	r3, [r5]
34802884:	e1530007 	cmp	r3, r7
			*load_end);

		return BOOTM_ERR_OVERLAP;
	}

	return 0;
34802888:	83e00001 	mvnhi	r0, #1
3480288c:	93a00000 	movls	r0, #0
34802890:	ea000000 	b	34802898 <bootm_load_os.clone.18+0x150>
				(uchar *)image_start, &image_len) != 0) {
			puts("GUNZIP: uncompress, out-of-mem or overwrite "
				"error - must RESET board to recover\n");
			if (boot_progress)
				bootstage_error(BOOTSTAGE_ID_DECOMP_IMAGE);
			return BOOTM_ERR_RESET;
34802894:	e3e00000 	mvn	r0, #0

		return BOOTM_ERR_OVERLAP;
	}

	return 0;
}
34802898:	e8bd86fe 	pop	{r1, r2, r3, r4, r5, r6, r7, r9, sl, pc}
3480289c:	34823204 	.word	0x34823204
348028a0:	34823213 	.word	0x34823213
348028a4:	348231e9 	.word	0x348231e9
348028a8:	34823226 	.word	0x34823226
348028ac:	3482323f 	.word	0x3482323f
348028b0:	34823290 	.word	0x34823290

348028b4 <bootm_start.clone.17>:
#else
#define lmb_reserve(lmb, base, size)
static inline void boot_start_lmb(bootm_headers_t *images) { }
#endif

static int bootm_start(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
348028b4:	e92d4ef3 	push	{r0, r1, r4, r5, r6, r7, r9, sl, fp, lr}
{
	void		*os_hdr;
	int		ret;

	memset((void *)&images, 0, sizeof(images));
348028b8:	e59f4358 	ldr	r4, [pc, #856]	; 34802c18 <bootm_start.clone.17+0x364>
#else
#define lmb_reserve(lmb, base, size)
static inline void boot_start_lmb(bootm_headers_t *images) { }
#endif

static int bootm_start(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
348028bc:	e1a07001 	mov	r7, r1
348028c0:	e1a0a000 	mov	sl, r0
{
	void		*os_hdr;
	int		ret;

	memset((void *)&images, 0, sizeof(images));
348028c4:	e3a01000 	mov	r1, #0
348028c8:	e1a00004 	mov	r0, r4
#else
#define lmb_reserve(lmb, base, size)
static inline void boot_start_lmb(bootm_headers_t *images) { }
#endif

static int bootm_start(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
348028cc:	e1a06002 	mov	r6, r2
{
	void		*os_hdr;
	int		ret;

	memset((void *)&images, 0, sizeof(images));
348028d0:	e3a02f4b 	mov	r2, #300	; 0x12c
348028d4:	eb005949 	bl	34818e00 <memset>
	images.verify = getenv_yesno("verify");
348028d8:	e59f033c 	ldr	r0, [pc, #828]	; 34802c1c <bootm_start.clone.17+0x368>
348028dc:	eb0027cc 	bl	3480c814 <getenv_yesno>
348028e0:	e5840084 	str	r0, [r4, #132]	; 0x84
static void boot_start_lmb(bootm_headers_t *images)
{
	ulong		mem_start;
	phys_size_t	mem_size;

	lmb_init(&images->lmb);
348028e4:	e284008c 	add	r0, r4, #140	; 0x8c
348028e8:	eb005706 	bl	34818508 <lmb_init>

	mem_start = getenv_bootm_low();
348028ec:	eb0027d2 	bl	3480c83c <getenv_bootm_low>
348028f0:	e1a05000 	mov	r5, r0
	mem_size = getenv_bootm_size();
348028f4:	eb0027dc 	bl	3480c86c <getenv_bootm_size>

	lmb_add(&images->lmb, (phys_addr_t)mem_start, mem_size);
348028f8:	e1a01005 	mov	r1, r5
	phys_size_t	mem_size;

	lmb_init(&images->lmb);

	mem_start = getenv_bootm_low();
	mem_size = getenv_bootm_size();
348028fc:	e1a02000 	mov	r2, r0

	lmb_add(&images->lmb, (phys_addr_t)mem_start, mem_size);
34802900:	e284008c 	add	r0, r4, #140	; 0x8c
34802904:	eb005709 	bl	34818530 <lmb_add>

	arch_lmb_reserve(&images->lmb);
34802908:	e284008c 	add	r0, r4, #140	; 0x8c
3480290c:	ebfffd35 	bl	34801de8 <arch_lmb_reserve>
	board_lmb_reserve(&images->lmb);
34802910:	e284008c 	add	r0, r4, #140	; 0x8c
34802914:	eb0057da 	bl	34818884 <__board_lmb_reserve>
	int		cfg_noffset;
	int		os_noffset;
#endif

	/* find out kernel image address */
	if (argc < 2) {
34802918:	e3570001 	cmp	r7, #1
		img_addr = load_addr;
3480291c:	d59f32fc 	ldrle	r3, [pc, #764]	; 34802c20 <bootm_start.clone.17+0x36c>
34802920:	d5934000 	ldrle	r4, [r3]
	int		cfg_noffset;
	int		os_noffset;
#endif

	/* find out kernel image address */
	if (argc < 2) {
34802924:	da000004 	ble	3480293c <bootm_start.clone.17+0x88>
							&fit_uname_kernel)) {
		debug("*  kernel: subimage '%s' from image at 0x%08lx\n",
				fit_uname_kernel, img_addr);
#endif
	} else {
		img_addr = simple_strtoul(argv[1], NULL, 16);
34802928:	e5960004 	ldr	r0, [r6, #4]
3480292c:	e3a01000 	mov	r1, #0
34802930:	e3a02010 	mov	r2, #16
34802934:	eb005caf 	bl	34819bf8 <simple_strtoul>
34802938:	e1a04000 	mov	r4, r0
3480293c:	e3a00001 	mov	r0, #1
34802940:	eb0029f8 	bl	3480d128 <__show_boot_progress>
	}

	bootstage_mark(BOOTSTAGE_ID_CHECK_MAGIC);

	/* copy from dataflash if needed */
	img_addr = genimg_get_image(img_addr);
34802944:	e1a00004 	mov	r0, r4
34802948:	eb0028ab 	bl	3480cbfc <genimg_get_image>

	/* check image type, for FIT images get FIT kernel node */
	*os_data = *os_len = 0;
3480294c:	e59fb2c4 	ldr	fp, [pc, #708]	; 34802c18 <bootm_start.clone.17+0x364>
34802950:	e3a09000 	mov	r9, #0
34802954:	e58b9054 	str	r9, [fp, #84]	; 0x54
34802958:	e58b9050 	str	r9, [fp, #80]	; 0x50
	}

	bootstage_mark(BOOTSTAGE_ID_CHECK_MAGIC);

	/* copy from dataflash if needed */
	img_addr = genimg_get_image(img_addr);
3480295c:	e1a04000 	mov	r4, r0

	/* check image type, for FIT images get FIT kernel node */
	*os_data = *os_len = 0;
	switch (genimg_get_format((void *)img_addr)) {
34802960:	e1a05000 	mov	r5, r0
34802964:	eb00289e 	bl	3480cbe4 <genimg_get_format>
34802968:	e3500001 	cmp	r0, #1
3480296c:	1a00005c 	bne	34802ae4 <bootm_start.clone.17+0x230>
	case IMAGE_FORMAT_LEGACY:
		printf("## Booting kernel from Legacy Image at %08lx ...\n",
34802970:	e1a01004 	mov	r1, r4
34802974:	e59f02a8 	ldr	r0, [pc, #680]	; 34802c24 <bootm_start.clone.17+0x370>
34802978:	eb001973 	bl	34808f4c <printf>
 */
static image_header_t *image_get_kernel(ulong img_addr, int verify)
{
	image_header_t *hdr = (image_header_t *)img_addr;

	if (!image_check_magic(hdr)) {
3480297c:	e5940000 	ldr	r0, [r4]
34802980:	ebffff1d 	bl	348025fc <image_check_magic.clone.9>
34802984:	e3500000 	cmp	r0, #0
	*os_data = *os_len = 0;
	switch (genimg_get_format((void *)img_addr)) {
	case IMAGE_FORMAT_LEGACY:
		printf("## Booting kernel from Legacy Image at %08lx ...\n",
				img_addr);
		hdr = image_get_kernel(img_addr, images->verify);
34802988:	e59b9084 	ldr	r9, [fp, #132]	; 0x84
 */
static image_header_t *image_get_kernel(ulong img_addr, int verify)
{
	image_header_t *hdr = (image_header_t *)img_addr;

	if (!image_check_magic(hdr)) {
3480298c:	1a000003 	bne	348029a0 <bootm_start.clone.17+0xec>
		puts("Bad Magic Number\n");
34802990:	e59f0290 	ldr	r0, [pc, #656]	; 34802c28 <bootm_start.clone.17+0x374>
34802994:	eb001962 	bl	34808f24 <puts>
	return 0;
}

static inline ulong bootstage_error(enum bootstage_id id)
{
	show_boot_progress(-id);
34802998:	e3e00000 	mvn	r0, #0
3480299c:	ea000023 	b	34802a30 <bootm_start.clone.17+0x17c>
 * and won't even do that unless CONFIG_SHOW_BOOT_PROGRESS is defined
 */

static inline ulong bootstage_mark(enum bootstage_id id)
{
	show_boot_progress(id);
348029a0:	e3a00002 	mov	r0, #2
348029a4:	eb0029df 	bl	3480d128 <__show_boot_progress>
		bootstage_error(BOOTSTAGE_ID_CHECK_MAGIC);
		return NULL;
	}
	bootstage_mark(BOOTSTAGE_ID_CHECK_HEADER);

	if (!image_check_hcrc(hdr)) {
348029a8:	e1a00004 	mov	r0, r4
348029ac:	eb00274b 	bl	3480c6e0 <image_check_hcrc>
348029b0:	e3500000 	cmp	r0, #0
348029b4:	1a000003 	bne	348029c8 <bootm_start.clone.17+0x114>
		puts("Bad Header Checksum\n");
348029b8:	e59f026c 	ldr	r0, [pc, #620]	; 34802c2c <bootm_start.clone.17+0x378>
348029bc:	eb001958 	bl	34808f24 <puts>
	return 0;
}

static inline ulong bootstage_error(enum bootstage_id id)
{
	show_boot_progress(-id);
348029c0:	e3e00001 	mvn	r0, #1
348029c4:	ea000019 	b	34802a30 <bootm_start.clone.17+0x17c>
 * and won't even do that unless CONFIG_SHOW_BOOT_PROGRESS is defined
 */

static inline ulong bootstage_mark(enum bootstage_id id)
{
	show_boot_progress(id);
348029c8:	e3a00003 	mov	r0, #3
348029cc:	eb0029d5 	bl	3480d128 <__show_boot_progress>
		bootstage_error(BOOTSTAGE_ID_CHECK_HEADER);
		return NULL;
	}

	bootstage_mark(BOOTSTAGE_ID_CHECK_CHECKSUM);
	image_print_contents(hdr);
348029d0:	e1a00004 	mov	r0, r4
348029d4:	eb0027f9 	bl	3480c9c0 <image_print_contents>

	if (verify) {
348029d8:	e3590000 	cmp	r9, #0
348029dc:	0a00000b 	beq	34802a10 <bootm_start.clone.17+0x15c>
		puts("   Verifying Checksum ... ");
348029e0:	e59f0248 	ldr	r0, [pc, #584]	; 34802c30 <bootm_start.clone.17+0x37c>
348029e4:	eb00194e 	bl	34808f24 <puts>
		if (!image_check_dcrc(hdr)) {
348029e8:	e1a00004 	mov	r0, r4
348029ec:	eb00274f 	bl	3480c730 <image_check_dcrc>
348029f0:	e3500000 	cmp	r0, #0
348029f4:	1a000003 	bne	34802a08 <bootm_start.clone.17+0x154>
			printf("Bad Data CRC\n");
348029f8:	e59f0234 	ldr	r0, [pc, #564]	; 34802c34 <bootm_start.clone.17+0x380>
348029fc:	eb001952 	bl	34808f4c <printf>
	return 0;
}

static inline ulong bootstage_error(enum bootstage_id id)
{
	show_boot_progress(-id);
34802a00:	e3e00002 	mvn	r0, #2
34802a04:	ea000009 	b	34802a30 <bootm_start.clone.17+0x17c>
			bootstage_error(BOOTSTAGE_ID_CHECK_CHECKSUM);
			return NULL;
		}
		puts("OK\n");
34802a08:	e59f0228 	ldr	r0, [pc, #552]	; 34802c38 <bootm_start.clone.17+0x384>
34802a0c:	eb001944 	bl	34808f24 <puts>
 * and won't even do that unless CONFIG_SHOW_BOOT_PROGRESS is defined
 */

static inline ulong bootstage_mark(enum bootstage_id id)
{
	show_boot_progress(id);
34802a10:	e3a00004 	mov	r0, #4
34802a14:	eb0029c3 	bl	3480d128 <__show_boot_progress>
	 *   r3: ptr to board info data
	 */
	(*entry_point)(gd->bd);

	return 1;
}
34802a18:	e5d4101d 	ldrb	r1, [r4, #29]
		}
		puts("OK\n");
	}
	bootstage_mark(BOOTSTAGE_ID_CHECK_ARCH);

	if (!image_check_target_arch(hdr)) {
34802a1c:	e3510002 	cmp	r1, #2
34802a20:	0a000005 	beq	34802a3c <bootm_start.clone.17+0x188>
		printf("Unsupported Architecture 0x%x\n", image_get_arch(hdr));
34802a24:	e59f0210 	ldr	r0, [pc, #528]	; 34802c3c <bootm_start.clone.17+0x388>
34802a28:	eb001947 	bl	34808f4c <printf>
	return 0;
}

static inline ulong bootstage_error(enum bootstage_id id)
{
	show_boot_progress(-id);
34802a2c:	e3e00003 	mvn	r0, #3
34802a30:	eb0029bc 	bl	3480d128 <__show_boot_progress>
	case IMAGE_FORMAT_LEGACY:
		printf("## Booting kernel from Legacy Image at %08lx ...\n",
				img_addr);
		hdr = image_get_kernel(img_addr, images->verify);
		if (!hdr)
			return NULL;
34802a34:	e3a05000 	mov	r5, #0
34802a38:	ea00002f 	b	34802afc <bootm_start.clone.17+0x248>
 * and won't even do that unless CONFIG_SHOW_BOOT_PROGRESS is defined
 */

static inline ulong bootstage_mark(enum bootstage_id id)
{
	show_boot_progress(id);
34802a3c:	e3a00005 	mov	r0, #5
34802a40:	eb0029b8 	bl	3480d128 <__show_boot_progress>
		bootstage_mark(BOOTSTAGE_ID_CHECK_IMAGETYPE);

		/* get os_data and os_len */
		switch (image_get_type(hdr)) {
34802a44:	e5d4301e 	ldrb	r3, [r4, #30]
34802a48:	e3530002 	cmp	r3, #2
34802a4c:	0a00000d 	beq	34802a88 <bootm_start.clone.17+0x1d4>
34802a50:	8a000001 	bhi	34802a5c <bootm_start.clone.17+0x1a8>
34802a54:	e3530001 	cmp	r3, #1
34802a58:	ea000002 	b	34802a68 <bootm_start.clone.17+0x1b4>
34802a5c:	e3530004 	cmp	r3, #4
34802a60:	0a000002 	beq	34802a70 <bootm_start.clone.17+0x1bc>
34802a64:	e353000e 	cmp	r3, #14
34802a68:	1a00000d 	bne	34802aa4 <bootm_start.clone.17+0x1f0>
34802a6c:	ea000005 	b	34802a88 <bootm_start.clone.17+0x1d4>
		case IH_TYPE_KERNEL_NOLOAD:
			*os_data = image_get_data(hdr);
			*os_len = image_get_data_size(hdr);
			break;
		case IH_TYPE_MULTI:
			image_multi_getimg(hdr, 0, os_data, os_len);
34802a70:	e59f21c8 	ldr	r2, [pc, #456]	; 34802c40 <bootm_start.clone.17+0x38c>
34802a74:	e1a00004 	mov	r0, r4
34802a78:	e3a01000 	mov	r1, #0
34802a7c:	e2823004 	add	r3, r2, #4
34802a80:	eb002742 	bl	3480c790 <image_multi_getimg>
34802a84:	ea00000b 	b	34802ab8 <bootm_start.clone.17+0x204>
			break;
		case IH_TYPE_STANDALONE:
			*os_data = image_get_data(hdr);
34802a88:	e59fa188 	ldr	sl, [pc, #392]	; 34802c18 <bootm_start.clone.17+0x364>
 * returns:
 *     image payload data start address
 */
static inline ulong image_get_data(const image_header_t *hdr)
{
	return ((ulong)hdr + image_get_header_size());
34802a8c:	e2843040 	add	r3, r4, #64	; 0x40
	return (char *)hdr->ih_name;
}

static inline uint32_t image_get_data_size(const image_header_t *hdr)
{
	return image_get_size(hdr);
34802a90:	e594000c 	ldr	r0, [r4, #12]
34802a94:	e58a3050 	str	r3, [sl, #80]	; 0x50
34802a98:	ebffff29 	bl	34802744 <image_get_size.clone.10>
			*os_len = image_get_data_size(hdr);
34802a9c:	e58a0054 	str	r0, [sl, #84]	; 0x54
34802aa0:	ea000004 	b	34802ab8 <bootm_start.clone.17+0x204>
			break;
		default:
			printf("Wrong Image Type for %s command\n",
34802aa4:	e59f0198 	ldr	r0, [pc, #408]	; 34802c44 <bootm_start.clone.17+0x390>
34802aa8:	e59a1000 	ldr	r1, [sl]
34802aac:	eb001926 	bl	34808f4c <printf>
	return 0;
}

static inline ulong bootstage_error(enum bootstage_id id)
{
	show_boot_progress(-id);
34802ab0:	e3e00004 	mvn	r0, #4
34802ab4:	eaffffdd 	b	34802a30 <bootm_start.clone.17+0x17c>

		/*
		 * copy image header to allow for image overwrites during
		 * kernel decompression.
		 */
		memmove(&images->legacy_hdr_os_copy, hdr,
34802ab8:	e59fa158 	ldr	sl, [pc, #344]	; 34802c18 <bootm_start.clone.17+0x364>
34802abc:	e1a01004 	mov	r1, r4
34802ac0:	e28a0004 	add	r0, sl, #4
34802ac4:	e3a02040 	mov	r2, #64	; 0x40
34802ac8:	eb00590d 	bl	34818f04 <memmove>
			sizeof(image_header_t));

		/* save pointer to image header */
		images->legacy_hdr_os = hdr;

		images->legacy_hdr_valid = 1;
34802acc:	e3a03001 	mov	r3, #1
		 */
		memmove(&images->legacy_hdr_os_copy, hdr,
			sizeof(image_header_t));

		/* save pointer to image header */
		images->legacy_hdr_os = hdr;
34802ad0:	e58a4000 	str	r4, [sl]

		images->legacy_hdr_valid = 1;
34802ad4:	e58a3044 	str	r3, [sl, #68]	; 0x44
 * and won't even do that unless CONFIG_SHOW_BOOT_PROGRESS is defined
 */

static inline ulong bootstage_mark(enum bootstage_id id)
{
	show_boot_progress(id);
34802ad8:	e3a00006 	mov	r0, #6
34802adc:	eb002991 	bl	3480d128 <__show_boot_progress>
34802ae0:	ea000005 	b	34802afc <bootm_start.clone.17+0x248>
		images->fit_uname_os = fit_uname_kernel;
		images->fit_noffset_os = os_noffset;
		break;
#endif
	default:
		printf("Wrong Image Format for %s command\n", cmdtp->name);
34802ae4:	e59a1000 	ldr	r1, [sl]
34802ae8:	e59f0158 	ldr	r0, [pc, #344]	; 34802c48 <bootm_start.clone.17+0x394>
34802aec:	eb001916 	bl	34808f4c <printf>
	return 0;
}

static inline ulong bootstage_error(enum bootstage_id id)
{
	show_boot_progress(-id);
34802af0:	e3e0006b 	mvn	r0, #107	; 0x6b
34802af4:	eb00298b 	bl	3480d128 <__show_boot_progress>
		bootstage_error(BOOTSTAGE_ID_FIT_KERNEL_INFO);
		return NULL;
34802af8:	e1a05009 	mov	r5, r9
	bootstage_mark_name(BOOTSTAGE_ID_BOOTM_START, "bootm_start");

	/* get kernel image header, start address and length */
	os_hdr = boot_get_kernel(cmdtp, flag, argc, argv,
			&images, &images.os.image_start, &images.os.image_len);
	if (images.os.image_len == 0) {
34802afc:	e59f4114 	ldr	r4, [pc, #276]	; 34802c18 <bootm_start.clone.17+0x364>
34802b00:	e5943054 	ldr	r3, [r4, #84]	; 0x54
34802b04:	e3530000 	cmp	r3, #0
		puts("ERROR: can't get kernel image!\n");
34802b08:	059f013c 	ldreq	r0, [pc, #316]	; 34802c4c <bootm_start.clone.17+0x398>
	bootstage_mark_name(BOOTSTAGE_ID_BOOTM_START, "bootm_start");

	/* get kernel image header, start address and length */
	os_hdr = boot_get_kernel(cmdtp, flag, argc, argv,
			&images, &images.os.image_start, &images.os.image_len);
	if (images.os.image_len == 0) {
34802b0c:	0a000017 	beq	34802b70 <bootm_start.clone.17+0x2bc>
		puts("ERROR: can't get kernel image!\n");
		return 1;
	}

	/* get image parameters */
	switch (genimg_get_format(os_hdr)) {
34802b10:	e1a00005 	mov	r0, r5
34802b14:	eb002832 	bl	3480cbe4 <genimg_get_format>
34802b18:	e3500001 	cmp	r0, #1
34802b1c:	e1a0b000 	mov	fp, r0
			return 1;
		}
		break;
#endif
	default:
		puts("ERROR: unknown image format type!\n");
34802b20:	159f0128 	ldrne	r0, [pc, #296]	; 34802c50 <bootm_start.clone.17+0x39c>
		puts("ERROR: can't get kernel image!\n");
		return 1;
	}

	/* get image parameters */
	switch (genimg_get_format(os_hdr)) {
34802b24:	1a000011 	bne	34802b70 <bootm_start.clone.17+0x2bc>
	 *   r3: ptr to board info data
	 */
	(*entry_point)(gd->bd);

	return 1;
}
34802b28:	e5d5a01e 	ldrb	sl, [r5, #30]
	}

	/* get image parameters */
	switch (genimg_get_format(os_hdr)) {
	case IMAGE_FORMAT_LEGACY:
		images.os.type = image_get_type(os_hdr);
34802b2c:	e5c4a05d 	strb	sl, [r4, #93]	; 0x5d
		images.os.comp = image_get_comp(os_hdr);
34802b30:	e5d5301f 	ldrb	r3, [r5, #31]
34802b34:	e5c4305c 	strb	r3, [r4, #92]	; 0x5c
	 *   r3: ptr to board info data
	 */
	(*entry_point)(gd->bd);

	return 1;
}
34802b38:	e5d5901c 	ldrb	r9, [r5, #28]
	/* get image parameters */
	switch (genimg_get_format(os_hdr)) {
	case IMAGE_FORMAT_LEGACY:
		images.os.type = image_get_type(os_hdr);
		images.os.comp = image_get_comp(os_hdr);
		images.os.os = image_get_os(os_hdr);
34802b3c:	e5c4905e 	strb	r9, [r4, #94]	; 0x5e
	return ((ulong)hdr + image_get_header_size());
}

static inline uint32_t image_get_image_size(const image_header_t *hdr)
{
	return (image_get_size(hdr) + image_get_header_size());
34802b40:	e595000c 	ldr	r0, [r5, #12]
34802b44:	ebfffefe 	bl	34802744 <image_get_size.clone.10>
34802b48:	e2853040 	add	r3, r5, #64	; 0x40
}
static inline ulong image_get_image_end(const image_header_t *hdr)
{
	return ((ulong)hdr + image_get_image_size(hdr));
34802b4c:	e0833000 	add	r3, r3, r0

		images.os.end = image_get_image_end(os_hdr);
34802b50:	e584304c 	str	r3, [r4, #76]	; 0x4c
	}
image_get_hdr_l(magic)		/* image_get_magic */
image_get_hdr_l(hcrc)		/* image_get_hcrc */
image_get_hdr_l(time)		/* image_get_time */
image_get_hdr_l(size)		/* image_get_size */
image_get_hdr_l(load)		/* image_get_load */
34802b54:	e5950010 	ldr	r0, [r5, #16]
34802b58:	ebfffe3f 	bl	3480245c <__fswab32>
		puts("ERROR: unknown image format type!\n");
		return 1;
	}

	/* find kernel entry point */
	if (images.legacy_hdr_valid) {
34802b5c:	e5943044 	ldr	r3, [r4, #68]	; 0x44
		images.os.type = image_get_type(os_hdr);
		images.os.comp = image_get_comp(os_hdr);
		images.os.os = image_get_os(os_hdr);

		images.os.end = image_get_image_end(os_hdr);
		images.os.load = image_get_load(os_hdr);
34802b60:	e5840058 	str	r0, [r4, #88]	; 0x58
		puts("ERROR: unknown image format type!\n");
		return 1;
	}

	/* find kernel entry point */
	if (images.legacy_hdr_valid) {
34802b64:	e3530000 	cmp	r3, #0
34802b68:	1a000003 	bne	34802b7c <bootm_start.clone.17+0x2c8>
34802b6c:	ea000008 	b	34802b94 <bootm_start.clone.17+0x2e0>
			return 1;
		}
		break;
#endif
	default:
		puts("ERROR: unknown image format type!\n");
34802b70:	eb0018eb 	bl	34808f24 <puts>
		return 1;
34802b74:	e3a00001 	mov	r0, #1
34802b78:	ea000025 	b	34802c14 <bootm_start.clone.17+0x360>
image_get_hdr_l(ep)		/* image_get_ep */
34802b7c:	e5940018 	ldr	r0, [r4, #24]
34802b80:	ebfffe35 	bl	3480245c <__fswab32>
	} else {
		puts("Could not find kernel entry point!\n");
		return 1;
	}

	if (images.os.type == IH_TYPE_KERNEL_NOLOAD) {
34802b84:	e35a000e 	cmp	sl, #14
		return 1;
	}

	/* find kernel entry point */
	if (images.legacy_hdr_valid) {
		images.ep = image_get_ep(&images.legacy_hdr_os_copy);
34802b88:	e5840060 	str	r0, [r4, #96]	; 0x60
	} else {
		puts("Could not find kernel entry point!\n");
		return 1;
	}

	if (images.os.type == IH_TYPE_KERNEL_NOLOAD) {
34802b8c:	1a000008 	bne	34802bb4 <bootm_start.clone.17+0x300>
34802b90:	ea000003 	b	34802ba4 <bootm_start.clone.17+0x2f0>
			puts("Can't get entry point property!\n");
			return 1;
		}
#endif
	} else {
		puts("Could not find kernel entry point!\n");
34802b94:	e59f00b8 	ldr	r0, [pc, #184]	; 34802c54 <bootm_start.clone.17+0x3a0>
34802b98:	eb0018e1 	bl	34808f24 <puts>
		return 1;
34802b9c:	e1a0000b 	mov	r0, fp
34802ba0:	ea00001b 	b	34802c14 <bootm_start.clone.17+0x360>
	}

	if (images.os.type == IH_TYPE_KERNEL_NOLOAD) {
		images.os.load = images.os.image_start;
34802ba4:	e5943050 	ldr	r3, [r4, #80]	; 0x50
34802ba8:	e5843058 	str	r3, [r4, #88]	; 0x58
		images.ep += images.os.load;
34802bac:	e0803003 	add	r3, r0, r3
34802bb0:	e5843060 	str	r3, [r4, #96]	; 0x60
	}

	if (((images.os.type == IH_TYPE_KERNEL) ||
34802bb4:	e35a0002 	cmp	sl, #2
34802bb8:	135a000e 	cmpne	sl, #14
34802bbc:	0a000001 	beq	34802bc8 <bootm_start.clone.17+0x314>
	     (images.os.type == IH_TYPE_KERNEL_NOLOAD) ||
34802bc0:	e35a0004 	cmp	sl, #4
34802bc4:	1a00000d 	bne	34802c00 <bootm_start.clone.17+0x34c>
	     (images.os.type == IH_TYPE_MULTI)) &&
34802bc8:	e3590005 	cmp	r9, #5
34802bcc:	1a00000b 	bne	34802c00 <bootm_start.clone.17+0x34c>
	    (images.os.os == IH_OS_LINUX)) {
		/* find ramdisk */
		ret = boot_get_ramdisk(argc, argv, &images, IH_INITRD_ARCH,
34802bd0:	e59f3080 	ldr	r3, [pc, #128]	; 34802c58 <bootm_start.clone.17+0x3a4>
34802bd4:	e1a00007 	mov	r0, r7
34802bd8:	e58d3000 	str	r3, [sp]
34802bdc:	e2833004 	add	r3, r3, #4
34802be0:	e58d3004 	str	r3, [sp, #4]
34802be4:	e1a01006 	mov	r1, r6
34802be8:	e59f2028 	ldr	r2, [pc, #40]	; 34802c18 <bootm_start.clone.17+0x364>
34802bec:	e3a03002 	mov	r3, #2
34802bf0:	eb002804 	bl	3480cc08 <boot_get_ramdisk>
				&images.rd_start, &images.rd_end);
		if (ret) {
34802bf4:	e3500000 	cmp	r0, #0
			puts("Ramdisk image is corrupt or invalid\n");
34802bf8:	159f005c 	ldrne	r0, [pc, #92]	; 34802c5c <bootm_start.clone.17+0x3a8>
	     (images.os.type == IH_TYPE_MULTI)) &&
	    (images.os.os == IH_OS_LINUX)) {
		/* find ramdisk */
		ret = boot_get_ramdisk(argc, argv, &images, IH_INITRD_ARCH,
				&images.rd_start, &images.rd_end);
		if (ret) {
34802bfc:	1affffdb 	bne	34802b70 <bootm_start.clone.17+0x2bc>

		set_working_fdt_addr(images.ft_addr);
#endif
	}

	images.os.start = (ulong)os_hdr;
34802c00:	e59f3010 	ldr	r3, [pc, #16]	; 34802c18 <bootm_start.clone.17+0x364>
	images.state = BOOTM_STATE_START;
34802c04:	e3a02001 	mov	r2, #1

		set_working_fdt_addr(images.ft_addr);
#endif
	}

	images.os.start = (ulong)os_hdr;
34802c08:	e5835048 	str	r5, [r3, #72]	; 0x48
	images.state = BOOTM_STATE_START;
34802c0c:	e5832088 	str	r2, [r3, #136]	; 0x88

	return 0;
34802c10:	e3a00000 	mov	r0, #0
}
34802c14:	e8bd8efc 	pop	{r2, r3, r4, r5, r6, r7, r9, sl, fp, pc}
34802c18:	34829080 	.word	0x34829080
34802c1c:	348232b3 	.word	0x348232b3
34802c20:	348283c4 	.word	0x348283c4
34802c24:	348232ba 	.word	0x348232ba
34802c28:	34823193 	.word	0x34823193
34802c2c:	348231a8 	.word	0x348231a8
34802c30:	348231bd 	.word	0x348231bd
34802c34:	348231db 	.word	0x348231db
34802c38:	348231e9 	.word	0x348231e9
34802c3c:	348232ec 	.word	0x348232ec
34802c40:	348290d0 	.word	0x348290d0
34802c44:	3482330b 	.word	0x3482330b
34802c48:	3482332c 	.word	0x3482332c
34802c4c:	3482334f 	.word	0x3482334f
34802c50:	3482336f 	.word	0x3482336f
34802c54:	34823392 	.word	0x34823392
34802c58:	348290e4 	.word	0x348290e4
34802c5c:	348233b6 	.word	0x348233b6

34802c60 <__arch_preboot_os>:

/* Allow for arch specific config before we boot */
void __arch_preboot_os(void)
{
	/* please define platform specific arch_preboot_os() */
}
34802c60:	e12fff1e 	bx	lr

34802c64 <do_bootm_subcommand>:
	U_BOOT_CMD_MKENT(go, 0, 1, (void *)BOOTM_STATE_OS_GO, "", ""),
};

int do_bootm_subcommand(cmd_tbl_t *cmdtp, int flag, int argc,
			char * const argv[])
{
34802c64:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
	int ret = 0;
	long state;
	cmd_tbl_t *c;
	boot_os_fn *boot_fn;

	c = find_cmd_tbl(argv[1], &cmd_bootm_sub[0], ARRAY_SIZE(cmd_bootm_sub));
34802c68:	e59f1218 	ldr	r1, [pc, #536]	; 34802e88 <do_bootm_subcommand+0x224>
	U_BOOT_CMD_MKENT(go, 0, 1, (void *)BOOTM_STATE_OS_GO, "", ""),
};

int do_bootm_subcommand(cmd_tbl_t *cmdtp, int flag, int argc,
			char * const argv[])
{
34802c6c:	e24dd030 	sub	sp, sp, #48	; 0x30
34802c70:	e1a04000 	mov	r4, r0
34802c74:	e1a05002 	mov	r5, r2
	int ret = 0;
	long state;
	cmd_tbl_t *c;
	boot_os_fn *boot_fn;

	c = find_cmd_tbl(argv[1], &cmd_bootm_sub[0], ARRAY_SIZE(cmd_bootm_sub));
34802c78:	e5930004 	ldr	r0, [r3, #4]
34802c7c:	e3a02007 	mov	r2, #7
	U_BOOT_CMD_MKENT(go, 0, 1, (void *)BOOTM_STATE_OS_GO, "", ""),
};

int do_bootm_subcommand(cmd_tbl_t *cmdtp, int flag, int argc,
			char * const argv[])
{
34802c80:	e1a07003 	mov	r7, r3
	int ret = 0;
	long state;
	cmd_tbl_t *c;
	boot_os_fn *boot_fn;

	c = find_cmd_tbl(argv[1], &cmd_bootm_sub[0], ARRAY_SIZE(cmd_bootm_sub));
34802c84:	e2836004 	add	r6, r3, #4
34802c88:	eb001727 	bl	3480892c <find_cmd_tbl>

	if (c) {
34802c8c:	e3500000 	cmp	r0, #0
34802c90:	0a000076 	beq	34802e70 <do_bootm_subcommand+0x20c>
		state = (long)c->cmd;
34802c94:	e590a00c 	ldr	sl, [r0, #12]

		/* treat start special since it resets the state machine */
		if (state == BOOTM_STATE_START) {
34802c98:	e35a0001 	cmp	sl, #1
34802c9c:	1a000005 	bne	34802cb8 <do_bootm_subcommand+0x54>
			argc--;
			argv++;
			return bootm_start(cmdtp, flag, argc, argv);
34802ca0:	e2451001 	sub	r1, r5, #1
34802ca4:	e1a00004 	mov	r0, r4
34802ca8:	e1a02006 	mov	r2, r6
34802cac:	ebffff00 	bl	348028b4 <bootm_start.clone.17>
34802cb0:	e1a05000 	mov	r5, r0
34802cb4:	ea000070 	b	34802e7c <do_bootm_subcommand+0x218>
	} else {
		/* Unrecognized command */
		return CMD_RET_USAGE;
	}

	if (images.state >= state) {
34802cb8:	e59f41cc 	ldr	r4, [pc, #460]	; 34802e8c <do_bootm_subcommand+0x228>
34802cbc:	e5943088 	ldr	r3, [r4, #136]	; 0x88
34802cc0:	e153000a 	cmp	r3, sl
34802cc4:	ba000002 	blt	34802cd4 <do_bootm_subcommand+0x70>
		printf("Trying to execute a command out of order\n");
34802cc8:	e59f01c0 	ldr	r0, [pc, #448]	; 34802e90 <do_bootm_subcommand+0x22c>
34802ccc:	eb00189e 	bl	34808f4c <printf>
34802cd0:	ea000066 	b	34802e70 <do_bootm_subcommand+0x20c>
		return CMD_RET_USAGE;
	}

	images.state |= state;
34802cd4:	e18a3003 	orr	r3, sl, r3
34802cd8:	e5843088 	str	r3, [r4, #136]	; 0x88
	boot_fn = boot_os[images.os.os];
34802cdc:	e5d4205e 	ldrb	r2, [r4, #94]	; 0x5e
34802ce0:	e59f31ac 	ldr	r3, [pc, #428]	; 34802e94 <do_bootm_subcommand+0x230>

	switch (state) {
34802ce4:	e35a0010 	cmp	sl, #16
		printf("Trying to execute a command out of order\n");
		return CMD_RET_USAGE;
	}

	images.state |= state;
	boot_fn = boot_os[images.os.os];
34802ce8:	e7936102 	ldr	r6, [r3, r2, lsl #2]

	switch (state) {
34802cec:	0a00003b 	beq	34802de0 <do_bootm_subcommand+0x17c>
34802cf0:	ca000004 	bgt	34802d08 <do_bootm_subcommand+0xa4>
34802cf4:	e35a0002 	cmp	sl, #2
34802cf8:	0a000009 	beq	34802d24 <do_bootm_subcommand+0xc0>
34802cfc:	e35a0004 	cmp	sl, #4
34802d00:	1a00005c 	bne	34802e78 <do_bootm_subcommand+0x214>
34802d04:	ea00001b 	b	34802d78 <do_bootm_subcommand+0x114>
34802d08:	e35a0040 	cmp	sl, #64	; 0x40
34802d0c:	0a000045 	beq	34802e28 <do_bootm_subcommand+0x1c4>
34802d10:	e35a0080 	cmp	sl, #128	; 0x80
34802d14:	0a00004d 	beq	34802e50 <do_bootm_subcommand+0x1ec>
34802d18:	e35a0020 	cmp	sl, #32
34802d1c:	1a000055 	bne	34802e78 <do_bootm_subcommand+0x214>
34802d20:	ea000037 	b	34802e04 <do_bootm_subcommand+0x1a0>
		ulong load_end;
		case BOOTM_STATE_START:
			/* should never occur */
			break;
		case BOOTM_STATE_LOADOS:
			ret = bootm_load_os(images.os, &load_end, 0);
34802d24:	e5943058 	ldr	r3, [r4, #88]	; 0x58
34802d28:	e58d3000 	str	r3, [sp]
34802d2c:	e5d4305c 	ldrb	r3, [r4, #92]	; 0x5c
34802d30:	e58d3004 	str	r3, [sp, #4]
34802d34:	e5d4305d 	ldrb	r3, [r4, #93]	; 0x5d
34802d38:	e58d3008 	str	r3, [sp, #8]
34802d3c:	e28d302c 	add	r3, sp, #44	; 0x2c
34802d40:	e58d300c 	str	r3, [sp, #12]
34802d44:	e3a03000 	mov	r3, #0
34802d48:	e58d3010 	str	r3, [sp, #16]
34802d4c:	e2840048 	add	r0, r4, #72	; 0x48
34802d50:	e890000f 	ldm	r0, {r0, r1, r2, r3}
34802d54:	ebfffe7b 	bl	34802748 <bootm_load_os.clone.18>
			if (ret)
34802d58:	e2505000 	subs	r5, r0, #0
34802d5c:	1a000046 	bne	34802e7c <do_bootm_subcommand+0x218>
				return ret;

			lmb_reserve(&images.lmb, images.os.load,
					(load_end - images.os.load));
34802d60:	e5941058 	ldr	r1, [r4, #88]	; 0x58
		case BOOTM_STATE_LOADOS:
			ret = bootm_load_os(images.os, &load_end, 0);
			if (ret)
				return ret;

			lmb_reserve(&images.lmb, images.os.load,
34802d64:	e59d202c 	ldr	r2, [sp, #44]	; 0x2c
34802d68:	e284008c 	add	r0, r4, #140	; 0x8c
34802d6c:	e0612002 	rsb	r2, r1, r2
34802d70:	eb005639 	bl	3481865c <lmb_reserve>
					(load_end - images.os.load));
			break;
34802d74:	ea000040 	b	34802e7c <do_bootm_subcommand+0x218>
#ifdef CONFIG_SYS_BOOT_RAMDISK_HIGH
		case BOOTM_STATE_RAMDISK:
		{
			ulong rd_len = images.rd_end - images.rd_start;
34802d78:	e5941064 	ldr	r1, [r4, #100]	; 0x64
34802d7c:	e5942068 	ldr	r2, [r4, #104]	; 0x68
			char str[17];

			ret = boot_ramdisk_high(&images.lmb, images.rd_start,
34802d80:	e2843074 	add	r3, r4, #116	; 0x74
34802d84:	e58d3000 	str	r3, [sp]
34802d88:	e284008c 	add	r0, r4, #140	; 0x8c
34802d8c:	e0612002 	rsb	r2, r1, r2
34802d90:	e2843070 	add	r3, r4, #112	; 0x70
34802d94:	eb002827 	bl	3480ce38 <boot_ramdisk_high>
				rd_len, &images.initrd_start, &images.initrd_end);
			if (ret)
34802d98:	e2505000 	subs	r5, r0, #0
34802d9c:	1a000036 	bne	34802e7c <do_bootm_subcommand+0x218>
				return ret;

			sprintf(str, "%lx", images.initrd_start);
34802da0:	e28d6018 	add	r6, sp, #24
34802da4:	e5942070 	ldr	r2, [r4, #112]	; 0x70
34802da8:	e1a00006 	mov	r0, r6
34802dac:	e59f10e4 	ldr	r1, [pc, #228]	; 34802e98 <do_bootm_subcommand+0x234>
34802db0:	eb005c36 	bl	34819e90 <sprintf>
			setenv("initrd_start", str);
34802db4:	e1a01006 	mov	r1, r6
34802db8:	e59f00dc 	ldr	r0, [pc, #220]	; 34802e9c <do_bootm_subcommand+0x238>
34802dbc:	eb001416 	bl	34807e1c <setenv>
			sprintf(str, "%lx", images.initrd_end);
34802dc0:	e1a00006 	mov	r0, r6
34802dc4:	e59f10cc 	ldr	r1, [pc, #204]	; 34802e98 <do_bootm_subcommand+0x234>
34802dc8:	e5942074 	ldr	r2, [r4, #116]	; 0x74
34802dcc:	eb005c2f 	bl	34819e90 <sprintf>
			setenv("initrd_end", str);
34802dd0:	e1a01006 	mov	r1, r6
34802dd4:	e59f00c4 	ldr	r0, [pc, #196]	; 34802ea0 <do_bootm_subcommand+0x23c>
34802dd8:	eb00140f 	bl	34807e1c <setenv>
		}
			break;
34802ddc:	ea000026 	b	34802e7c <do_bootm_subcommand+0x218>
				&images.ft_addr, &images.ft_len);
			break;
		}
#endif
		case BOOTM_STATE_OS_CMDLINE:
			ret = boot_fn(BOOTM_STATE_OS_CMDLINE, argc, argv, &images);
34802de0:	e1a01005 	mov	r1, r5
34802de4:	e1a0000a 	mov	r0, sl
34802de8:	e1a02007 	mov	r2, r7
34802dec:	e1a03004 	mov	r3, r4
34802df0:	e12fff36 	blx	r6
			if (ret)
34802df4:	e2505000 	subs	r5, r0, #0
				printf("cmdline subcommand not supported\n");
34802df8:	159f00a4 	ldrne	r0, [pc, #164]	; 34802ea4 <do_bootm_subcommand+0x240>
			break;
		}
#endif
		case BOOTM_STATE_OS_CMDLINE:
			ret = boot_fn(BOOTM_STATE_OS_CMDLINE, argc, argv, &images);
			if (ret)
34802dfc:	0a00001e 	beq	34802e7c <do_bootm_subcommand+0x218>
34802e00:	ea000010 	b	34802e48 <do_bootm_subcommand+0x1e4>
				printf("cmdline subcommand not supported\n");
			break;
		case BOOTM_STATE_OS_BD_T:
			ret = boot_fn(BOOTM_STATE_OS_BD_T, argc, argv, &images);
34802e04:	e1a01005 	mov	r1, r5
34802e08:	e1a0000a 	mov	r0, sl
34802e0c:	e1a02007 	mov	r2, r7
34802e10:	e1a03004 	mov	r3, r4
34802e14:	e12fff36 	blx	r6
			if (ret)
34802e18:	e2505000 	subs	r5, r0, #0
				printf("bdt subcommand not supported\n");
34802e1c:	159f0084 	ldrne	r0, [pc, #132]	; 34802ea8 <do_bootm_subcommand+0x244>
			if (ret)
				printf("cmdline subcommand not supported\n");
			break;
		case BOOTM_STATE_OS_BD_T:
			ret = boot_fn(BOOTM_STATE_OS_BD_T, argc, argv, &images);
			if (ret)
34802e20:	0a000015 	beq	34802e7c <do_bootm_subcommand+0x218>
34802e24:	ea000007 	b	34802e48 <do_bootm_subcommand+0x1e4>
				printf("bdt subcommand not supported\n");
			break;
		case BOOTM_STATE_OS_PREP:
			ret = boot_fn(BOOTM_STATE_OS_PREP, argc, argv, &images);
34802e28:	e1a01005 	mov	r1, r5
34802e2c:	e1a0000a 	mov	r0, sl
34802e30:	e1a02007 	mov	r2, r7
34802e34:	e1a03004 	mov	r3, r4
34802e38:	e12fff36 	blx	r6
			if (ret)
34802e3c:	e2505000 	subs	r5, r0, #0
34802e40:	0a00000d 	beq	34802e7c <do_bootm_subcommand+0x218>
				printf("prep subcommand not supported\n");
34802e44:	e59f0060 	ldr	r0, [pc, #96]	; 34802eac <do_bootm_subcommand+0x248>
34802e48:	eb00183f 	bl	34808f4c <printf>
34802e4c:	ea00000a 	b	34802e7c <do_bootm_subcommand+0x218>
			break;
		case BOOTM_STATE_OS_GO:
			disable_interrupts();
34802e50:	ebfffc0b 	bl	34801e84 <disable_interrupts>
			 * Stop the ethernet stack if NetConsole could have
			 * left it up
			 */
			eth_halt();
#endif
			arch_preboot_os();
34802e54:	ebffff81 	bl	34802c60 <__arch_preboot_os>
			boot_fn(BOOTM_STATE_OS_GO, argc, argv, &images);
34802e58:	e1a0000a 	mov	r0, sl
34802e5c:	e1a01005 	mov	r1, r5
34802e60:	e1a02007 	mov	r2, r7
34802e64:	e1a03004 	mov	r3, r4
34802e68:	e12fff36 	blx	r6
34802e6c:	ea000001 	b	34802e78 <do_bootm_subcommand+0x214>
			argv++;
			return bootm_start(cmdtp, flag, argc, argv);
		}
	} else {
		/* Unrecognized command */
		return CMD_RET_USAGE;
34802e70:	e3e05000 	mvn	r5, #0
34802e74:	ea000000 	b	34802e7c <do_bootm_subcommand+0x218>
};

int do_bootm_subcommand(cmd_tbl_t *cmdtp, int flag, int argc,
			char * const argv[])
{
	int ret = 0;
34802e78:	e3a05000 	mov	r5, #0
			boot_fn(BOOTM_STATE_OS_GO, argc, argv, &images);
			break;
	}

	return ret;
}
34802e7c:	e1a00005 	mov	r0, r5
34802e80:	e28dd030 	add	sp, sp, #48	; 0x30
34802e84:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
34802e88:	3482824c 	.word	0x3482824c
34802e8c:	34829080 	.word	0x34829080
34802e90:	348233db 	.word	0x348233db
34802e94:	348203ec 	.word	0x348203ec
34802e98:	34823405 	.word	0x34823405
34802e9c:	34823409 	.word	0x34823409
34802ea0:	34823416 	.word	0x34823416
34802ea4:	34823421 	.word	0x34823421
34802ea8:	34823443 	.word	0x34823443
34802eac:	34823461 	.word	0x34823461

34802eb0 <do_bootm>:
/*******************************************************************/
/* bootm - boot application image from image in memory */
/*******************************************************************/

int do_bootm(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
34802eb0:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
		relocated = 1;
	}
#endif

	/* determine if we have a sub command */
	if (argc > 1) {
34802eb4:	e3520001 	cmp	r2, #1
/*******************************************************************/
/* bootm - boot application image from image in memory */
/*******************************************************************/

int do_bootm(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
34802eb8:	e24dd040 	sub	sp, sp, #64	; 0x40
34802ebc:	e1a05003 	mov	r5, r3
	ulong		iflag;
	ulong		load_end = 0;
34802ec0:	e3a03000 	mov	r3, #0
/*******************************************************************/
/* bootm - boot application image from image in memory */
/*******************************************************************/

int do_bootm(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
34802ec4:	e1a07000 	mov	r7, r0
34802ec8:	e1a09001 	mov	r9, r1
34802ecc:	e1a06002 	mov	r6, r2
	ulong		iflag;
	ulong		load_end = 0;
34802ed0:	e58d303c 	str	r3, [sp, #60]	; 0x3c
		relocated = 1;
	}
#endif

	/* determine if we have a sub command */
	if (argc > 1) {
34802ed4:	da000010 	ble	34802f1c <do_bootm+0x6c>
		char *endp;

		simple_strtoul(argv[1], &endp, 16);
34802ed8:	e5950004 	ldr	r0, [r5, #4]
34802edc:	e28d1038 	add	r1, sp, #56	; 0x38
34802ee0:	e3a02010 	mov	r2, #16
34802ee4:	eb005b43 	bl	34819bf8 <simple_strtoul>
		 * If endp is ':' or '#' assume a FIT identifier so pass
		 * along for normal processing.
		 *
		 * Right now we assume the first arg should never be '-'
		 */
		if ((*endp != 0) && (*endp != ':') && (*endp != '#'))
34802ee8:	e59d3038 	ldr	r3, [sp, #56]	; 0x38
34802eec:	e5d33000 	ldrb	r3, [r3]
34802ef0:	e353003a 	cmp	r3, #58	; 0x3a
34802ef4:	13530000 	cmpne	r3, #0
34802ef8:	0a000007 	beq	34802f1c <do_bootm+0x6c>
34802efc:	e3530023 	cmp	r3, #35	; 0x23
34802f00:	0a000005 	beq	34802f1c <do_bootm+0x6c>
			return do_bootm_subcommand(cmdtp, flag, argc, argv);
34802f04:	e1a00007 	mov	r0, r7
34802f08:	e1a01009 	mov	r1, r9
34802f0c:	e1a02006 	mov	r2, r6
34802f10:	e1a03005 	mov	r3, r5
34802f14:	ebffff52 	bl	34802c64 <do_bootm_subcommand>
34802f18:	ea00007f 	b	3480311c <do_bootm+0x26c>
	}

	if (bootm_start(cmdtp, flag, argc, argv))
34802f1c:	e1a00007 	mov	r0, r7
34802f20:	e1a01006 	mov	r1, r6
34802f24:	e1a02005 	mov	r2, r5
34802f28:	ebfffe61 	bl	348028b4 <bootm_start.clone.17>
34802f2c:	e3500000 	cmp	r0, #0
34802f30:	1a000078 	bne	34803118 <do_bootm+0x268>
	/*
	 * We have reached the point of no return: we are going to
	 * overwrite all exception vector code, so we cannot easily
	 * recover from any failures any more...
	 */
	iflag = disable_interrupts();
34802f34:	ebfffbd2 	bl	34801e84 <disable_interrupts>
	 *   r3: ptr to board info data
	 */
	(*entry_point)(gd->bd);

	return 1;
}
34802f38:	e59f41e4 	ldr	r4, [pc, #484]	; 34803124 <do_bootm+0x274>
	/*
	 * We have reached the point of no return: we are going to
	 * overwrite all exception vector code, so we cannot easily
	 * recover from any failures any more...
	 */
	iflag = disable_interrupts();
34802f3c:	e1a0b000 	mov	fp, r0
	 * details see the OpenHCI specification.
	 */
	usb_stop();
#endif

	ret = bootm_load_os(images.os, &load_end, 1);
34802f40:	e5943058 	ldr	r3, [r4, #88]	; 0x58
34802f44:	e58d3000 	str	r3, [sp]
34802f48:	e5d4305c 	ldrb	r3, [r4, #92]	; 0x5c
34802f4c:	e58d3004 	str	r3, [sp, #4]
34802f50:	e5d4305d 	ldrb	r3, [r4, #93]	; 0x5d
34802f54:	e58d3008 	str	r3, [sp, #8]
34802f58:	e28d303c 	add	r3, sp, #60	; 0x3c
34802f5c:	e58d300c 	str	r3, [sp, #12]
34802f60:	e3a03001 	mov	r3, #1
34802f64:	e58d3010 	str	r3, [sp, #16]
34802f68:	e2840048 	add	r0, r4, #72	; 0x48
34802f6c:	e890000f 	ldm	r0, {r0, r1, r2, r3}
34802f70:	ebfffdf4 	bl	34802748 <bootm_load_os.clone.18>

	if (ret < 0) {
34802f74:	e3500000 	cmp	r0, #0
34802f78:	aa00001d 	bge	34802ff4 <do_bootm+0x144>
		if (ret == BOOTM_ERR_RESET)
34802f7c:	e3700001 	cmn	r0, #1
34802f80:	0a00000e 	beq	34802fc0 <do_bootm+0x110>
			do_reset(cmdtp, flag, argc, argv);
		if (ret == BOOTM_ERR_OVERLAP) {
34802f84:	e3700002 	cmn	r0, #2
34802f88:	1a000012 	bne	34802fd8 <do_bootm+0x128>
			if (images.legacy_hdr_valid) {
34802f8c:	e5943044 	ldr	r3, [r4, #68]	; 0x44
34802f90:	e3530000 	cmp	r3, #0
34802f94:	0a000005 	beq	34802fb0 <do_bootm+0x100>
				image_header_t *hdr;
				hdr = &images.legacy_hdr_os_copy;
				if (image_get_type(hdr) == IH_TYPE_MULTI)
34802f98:	e5d43022 	ldrb	r3, [r4, #34]	; 0x22
34802f9c:	e3530004 	cmp	r3, #4
34802fa0:	1a000013 	bne	34802ff4 <do_bootm+0x144>
					puts("WARNING: legacy format multi "
34802fa4:	e59f017c 	ldr	r0, [pc, #380]	; 34803128 <do_bootm+0x278>
34802fa8:	eb0017dd 	bl	34808f24 <puts>
34802fac:	ea000010 	b	34802ff4 <do_bootm+0x144>
						"component image "
						"overwritten\n");
			} else {
				puts("ERROR: new format image overwritten - "
34802fb0:	e59f0174 	ldr	r0, [pc, #372]	; 3480312c <do_bootm+0x27c>
34802fb4:	eb0017da 	bl	34808f24 <puts>
34802fb8:	e3e00070 	mvn	r0, #112	; 0x70
34802fbc:	eb002859 	bl	3480d128 <__show_boot_progress>
					"must RESET the board to recover\n");
				bootstage_error(BOOTSTAGE_ID_OVERWRITTEN);
				do_reset(cmdtp, flag, argc, argv);
34802fc0:	e1a00007 	mov	r0, r7
34802fc4:	e1a01009 	mov	r1, r9
34802fc8:	e1a02006 	mov	r2, r6
34802fcc:	e1a03005 	mov	r3, r5
34802fd0:	ebfffc40 	bl	348020d8 <do_reset>
34802fd4:	ea000006 	b	34802ff4 <do_bootm+0x144>
			}
		}
		if (ret == BOOTM_ERR_UNIMPLEMENTED) {
34802fd8:	e3700003 	cmn	r0, #3
34802fdc:	1a000004 	bne	34802ff4 <do_bootm+0x144>
			if (iflag)
34802fe0:	e35b0000 	cmp	fp, #0
34802fe4:	0a000000 	beq	34802fec <do_bootm+0x13c>
				enable_interrupts();
34802fe8:	ebfffba4 	bl	34801e80 <enable_interrupts>
34802fec:	e3e00006 	mvn	r0, #6
34802ff0:	ea000039 	b	348030dc <do_bootm+0x22c>
			bootstage_error(BOOTSTAGE_ID_DECOMP_UNIMPL);
			return 1;
		}
	}

	lmb_reserve(&images.lmb, images.os.load, (load_end - images.os.load));
34802ff4:	e59fa128 	ldr	sl, [pc, #296]	; 34803124 <do_bootm+0x274>
34802ff8:	e59d203c 	ldr	r2, [sp, #60]	; 0x3c
34802ffc:	e59a1058 	ldr	r1, [sl, #88]	; 0x58
34803000:	e28a008c 	add	r0, sl, #140	; 0x8c
34803004:	e0612002 	rsb	r2, r1, r2
34803008:	eb005593 	bl	3481865c <lmb_reserve>

	if (images.os.type == IH_TYPE_STANDALONE) {
3480300c:	e5da305d 	ldrb	r3, [sl, #93]	; 0x5d
34803010:	e3530001 	cmp	r3, #1
34803014:	1a00001e 	bne	34803094 <do_bootm+0x1e4>
		if (iflag)
34803018:	e35b0000 	cmp	fp, #0
3480301c:	0a000000 	beq	34803024 <do_bootm+0x174>
			enable_interrupts();
34803020:	ebfffb96 	bl	34801e80 <enable_interrupts>
{
	char  *s;
	int   (*appl)(int, char * const []);

	/* Don't start if "autostart" is set to "no" */
	if (((s = getenv("autostart")) != NULL) && (strcmp(s, "no") == 0)) {
34803024:	e59f0104 	ldr	r0, [pc, #260]	; 34803130 <do_bootm+0x280>
34803028:	eb001483 	bl	3480823c <getenv>
3480302c:	e3500000 	cmp	r0, #0
34803030:	0a00000e 	beq	34803070 <do_bootm+0x1c0>
34803034:	e59f10f8 	ldr	r1, [pc, #248]	; 34803134 <do_bootm+0x284>
34803038:	eb00569c 	bl	34818ab0 <strcmp>
3480303c:	e2507000 	subs	r7, r0, #0
34803040:	1a00000a 	bne	34803070 <do_bootm+0x1c0>
		char buf[32];
		sprintf(buf, "%lX", images.os.image_len);
34803044:	e59f30d8 	ldr	r3, [pc, #216]	; 34803124 <do_bootm+0x274>
34803048:	e28d4018 	add	r4, sp, #24
3480304c:	e59f10e4 	ldr	r1, [pc, #228]	; 34803138 <do_bootm+0x288>
34803050:	e5932054 	ldr	r2, [r3, #84]	; 0x54
34803054:	e1a00004 	mov	r0, r4
34803058:	eb005b8c 	bl	34819e90 <sprintf>
		setenv("filesize", buf);
3480305c:	e59f00d8 	ldr	r0, [pc, #216]	; 3480313c <do_bootm+0x28c>
34803060:	e1a01004 	mov	r1, r4
34803064:	eb00136c 	bl	34807e1c <setenv>
	if (images.os.type == IH_TYPE_STANDALONE) {
		if (iflag)
			enable_interrupts();
		/* This may return when 'autostart' is 'no' */
		bootm_start_standalone(iflag, argc, argv);
		return 0;
34803068:	e1a00007 	mov	r0, r7
3480306c:	ea00002a 	b	3480311c <do_bootm+0x26c>
		char buf[32];
		sprintf(buf, "%lX", images.os.image_len);
		setenv("filesize", buf);
		return 0;
	}
	appl = (int (*)(int, char * const []))(ulong)ntohl(images.ep);
34803070:	e59f30ac 	ldr	r3, [pc, #172]	; 34803124 <do_bootm+0x274>
34803074:	e5930060 	ldr	r0, [r3, #96]	; 0x60
34803078:	ebfffcf7 	bl	3480245c <__fswab32>
	(*appl)(argc-1, &argv[1]);
3480307c:	e2851004 	add	r1, r5, #4
		char buf[32];
		sprintf(buf, "%lX", images.os.image_len);
		setenv("filesize", buf);
		return 0;
	}
	appl = (int (*)(int, char * const []))(ulong)ntohl(images.ep);
34803080:	e1a03000 	mov	r3, r0
	(*appl)(argc-1, &argv[1]);
34803084:	e2460001 	sub	r0, r6, #1
34803088:	e12fff33 	blx	r3
	if (images.os.type == IH_TYPE_STANDALONE) {
		if (iflag)
			enable_interrupts();
		/* This may return when 'autostart' is 'no' */
		bootm_start_standalone(iflag, argc, argv);
		return 0;
3480308c:	e3a00000 	mov	r0, #0
34803090:	ea000021 	b	3480311c <do_bootm+0x26c>
 * and won't even do that unless CONFIG_SHOW_BOOT_PROGRESS is defined
 */

static inline ulong bootstage_mark(enum bootstage_id id)
{
	show_boot_progress(id);
34803094:	e3a00008 	mov	r0, #8
34803098:	eb002822 	bl	3480d128 <__show_boot_progress>
#ifdef CONFIG_SILENT_CONSOLE
	if (images.os.os == IH_OS_LINUX)
		fixup_silent_linux();
#endif

	boot_fn = boot_os[images.os.os];
3480309c:	e5da205e 	ldrb	r2, [sl, #94]	; 0x5e
348030a0:	e59f3098 	ldr	r3, [pc, #152]	; 34803140 <do_bootm+0x290>
348030a4:	e7934102 	ldr	r4, [r3, r2, lsl #2]

	if (boot_fn == NULL) {
348030a8:	e3540000 	cmp	r4, #0
348030ac:	1a00000c 	bne	348030e4 <do_bootm+0x234>
		if (iflag)
348030b0:	e35b0000 	cmp	fp, #0
348030b4:	0a000000 	beq	348030bc <do_bootm+0x20c>
			enable_interrupts();
348030b8:	ebfffb70 	bl	34801e80 <enable_interrupts>
		printf("ERROR: booting os '%s' (%d) is not supported\n",
348030bc:	e59f4060 	ldr	r4, [pc, #96]	; 34803124 <do_bootm+0x274>
348030c0:	e5d4005e 	ldrb	r0, [r4, #94]	; 0x5e
348030c4:	eb002625 	bl	3480c960 <genimg_get_os_name>
348030c8:	e5d4205e 	ldrb	r2, [r4, #94]	; 0x5e
348030cc:	e1a01000 	mov	r1, r0
348030d0:	e59f006c 	ldr	r0, [pc, #108]	; 34803144 <do_bootm+0x294>
348030d4:	eb00179c 	bl	34808f4c <printf>
	return 0;
}

static inline ulong bootstage_error(enum bootstage_id id)
{
	show_boot_progress(-id);
348030d8:	e3e00007 	mvn	r0, #7
348030dc:	eb002811 	bl	3480d128 <__show_boot_progress>
348030e0:	ea00000c 	b	34803118 <do_bootm+0x268>
			genimg_get_os_name(images.os.os), images.os.os);
		bootstage_error(BOOTSTAGE_ID_CHECK_BOOT_OS);
		return 1;
	}

	arch_preboot_os();
348030e4:	ebfffedd 	bl	34802c60 <__arch_preboot_os>

	boot_fn(0, argc, argv, &images);
348030e8:	e1a01006 	mov	r1, r6
348030ec:	e1a02005 	mov	r2, r5
348030f0:	e1a0300a 	mov	r3, sl
348030f4:	e3a00000 	mov	r0, #0
348030f8:	e12fff34 	blx	r4
348030fc:	e3e00008 	mvn	r0, #8
34803100:	eb002808 	bl	3480d128 <__show_boot_progress>

	bootstage_error(BOOTSTAGE_ID_BOOT_OS_RETURNED);
#ifdef DEBUG
	puts("\n## Control returned to monitor - resetting...\n");
#endif
	do_reset(cmdtp, flag, argc, argv);
34803104:	e1a00007 	mov	r0, r7
34803108:	e1a01009 	mov	r1, r9
3480310c:	e1a02006 	mov	r2, r6
34803110:	e1a03005 	mov	r3, r5
34803114:	ebfffbef 	bl	348020d8 <do_reset>
		if ((*endp != 0) && (*endp != ':') && (*endp != '#'))
			return do_bootm_subcommand(cmdtp, flag, argc, argv);
	}

	if (bootm_start(cmdtp, flag, argc, argv))
		return 1;
34803118:	e3a00001 	mov	r0, #1
	puts("\n## Control returned to monitor - resetting...\n");
#endif
	do_reset(cmdtp, flag, argc, argv);

	return 1;
}
3480311c:	e28dd040 	add	sp, sp, #64	; 0x40
34803120:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
34803124:	34829080 	.word	0x34829080
34803128:	34823480 	.word	0x34823480
3480312c:	348234ba 	.word	0x348234ba
34803130:	34823501 	.word	0x34823501
34803134:	3482350b 	.word	0x3482350b
34803138:	3482350e 	.word	0x3482350e
3480313c:	34823512 	.word	0x34823512
34803140:	348203ec 	.word	0x348203ec
34803144:	3482351b 	.word	0x3482351b

34803148 <bootm_maybe_autostart>:

int bootm_maybe_autostart(cmd_tbl_t *cmdtp, const char *cmd)
{
34803148:	e92d4073 	push	{r0, r1, r4, r5, r6, lr}
3480314c:	e1a05000 	mov	r5, r0
	const char *ep = getenv("autostart");
34803150:	e59f0054 	ldr	r0, [pc, #84]	; 348031ac <bootm_maybe_autostart+0x64>

	return 1;
}

int bootm_maybe_autostart(cmd_tbl_t *cmdtp, const char *cmd)
{
34803154:	e1a06001 	mov	r6, r1
	const char *ep = getenv("autostart");
34803158:	eb001437 	bl	3480823c <getenv>

	if (ep && !strcmp(ep, "yes")) {
3480315c:	e2503000 	subs	r3, r0, #0
		local_args[1] = NULL;
		printf("Automatic boot of image at addr 0x%08lX ...\n", load_addr);
		return do_bootm(cmdtp, 0, 1, local_args);
	}

	return 0;
34803160:	01a00003 	moveq	r0, r3

int bootm_maybe_autostart(cmd_tbl_t *cmdtp, const char *cmd)
{
	const char *ep = getenv("autostart");

	if (ep && !strcmp(ep, "yes")) {
34803164:	0a00000f 	beq	348031a8 <bootm_maybe_autostart+0x60>
34803168:	e59f1040 	ldr	r1, [pc, #64]	; 348031b0 <bootm_maybe_autostart+0x68>
3480316c:	eb00564f 	bl	34818ab0 <strcmp>
34803170:	e2504000 	subs	r4, r0, #0
		local_args[1] = NULL;
		printf("Automatic boot of image at addr 0x%08lX ...\n", load_addr);
		return do_bootm(cmdtp, 0, 1, local_args);
	}

	return 0;
34803174:	13a00000 	movne	r0, #0

int bootm_maybe_autostart(cmd_tbl_t *cmdtp, const char *cmd)
{
	const char *ep = getenv("autostart");

	if (ep && !strcmp(ep, "yes")) {
34803178:	1a00000a 	bne	348031a8 <bootm_maybe_autostart+0x60>
		char *local_args[2];
		local_args[0] = (char *)cmd;
		local_args[1] = NULL;
		printf("Automatic boot of image at addr 0x%08lX ...\n", load_addr);
3480317c:	e59f3030 	ldr	r3, [pc, #48]	; 348031b4 <bootm_maybe_autostart+0x6c>
34803180:	e59f0030 	ldr	r0, [pc, #48]	; 348031b8 <bootm_maybe_autostart+0x70>
34803184:	e5931000 	ldr	r1, [r3]
{
	const char *ep = getenv("autostart");

	if (ep && !strcmp(ep, "yes")) {
		char *local_args[2];
		local_args[0] = (char *)cmd;
34803188:	e58d6000 	str	r6, [sp]
		local_args[1] = NULL;
3480318c:	e58d4004 	str	r4, [sp, #4]
		printf("Automatic boot of image at addr 0x%08lX ...\n", load_addr);
34803190:	eb00176d 	bl	34808f4c <printf>
		return do_bootm(cmdtp, 0, 1, local_args);
34803194:	e1a00005 	mov	r0, r5
34803198:	e1a01004 	mov	r1, r4
3480319c:	e3a02001 	mov	r2, #1
348031a0:	e1a0300d 	mov	r3, sp
348031a4:	ebffff41 	bl	34802eb0 <do_bootm>
	}

	return 0;
}
348031a8:	e8bd807c 	pop	{r2, r3, r4, r5, r6, pc}
348031ac:	34823501 	.word	0x34823501
348031b0:	34823549 	.word	0x34823549
348031b4:	348283c4 	.word	0x348283c4
348031b8:	3482354d 	.word	0x3482354d

348031bc <parse_argv>:
	}
	return 0;
}

static int parse_argv(const char *s)
{
348031bc:	e92d4010 	push	{r4, lr}
	if (strcmp(s, "flush") == 0)
348031c0:	e59f1044 	ldr	r1, [pc, #68]	; 3480320c <parse_argv+0x50>
	}
	return 0;
}

static int parse_argv(const char *s)
{
348031c4:	e1a04000 	mov	r4, r0
	if (strcmp(s, "flush") == 0)
348031c8:	eb005638 	bl	34818ab0 <strcmp>
348031cc:	e3500000 	cmp	r0, #0
		return 2;
348031d0:	03a00002 	moveq	r0, #2
	return 0;
}

static int parse_argv(const char *s)
{
	if (strcmp(s, "flush") == 0)
348031d4:	08bd8010 	popeq	{r4, pc}
		return 2;
	else if (strcmp(s, "on") == 0)
348031d8:	e1a00004 	mov	r0, r4
348031dc:	e59f102c 	ldr	r1, [pc, #44]	; 34803210 <parse_argv+0x54>
348031e0:	eb005632 	bl	34818ab0 <strcmp>
348031e4:	e3500000 	cmp	r0, #0
348031e8:	0a000005 	beq	34803204 <parse_argv+0x48>
		return 1;
	else if (strcmp(s, "off") == 0)
348031ec:	e1a00004 	mov	r0, r4
348031f0:	e59f101c 	ldr	r1, [pc, #28]	; 34803214 <parse_argv+0x58>
348031f4:	eb00562d 	bl	34818ab0 <strcmp>
348031f8:	e3500000 	cmp	r0, #0
		return 0;
348031fc:	13e00000 	mvnne	r0, #0
34803200:	e8bd8010 	pop	{r4, pc}
static int parse_argv(const char *s)
{
	if (strcmp(s, "flush") == 0)
		return 2;
	else if (strcmp(s, "on") == 0)
		return 1;
34803204:	e3a00001 	mov	r0, #1
	else if (strcmp(s, "off") == 0)
		return 0;

	return -1;
}
34803208:	e8bd8010 	pop	{r4, pc}
3480320c:	348238ff 	.word	0x348238ff
34803210:	34827ac6 	.word	0x34827ac6
34803214:	34822f9e 	.word	0x34822f9e
static int parse_argv(const char *);

void __weak invalidate_icache_all(void)
{
	/* please define arch specific invalidate_icache_all */
	puts("No arch specific invalidate_icache_all available!\n");
34803218:	e59f0000 	ldr	r0, [pc, #0]	; 34803220 <parse_argv+0x64>
3480321c:	ea001740 	b	34808f24 <puts>
34803220:	34823905 	.word	0x34823905

34803224 <do_icache>:
}

int do_icache(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	switch (argc) {
34803224:	e3520001 	cmp	r2, #1
	/* please define arch specific invalidate_icache_all */
	puts("No arch specific invalidate_icache_all available!\n");
}

int do_icache(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
34803228:	e92d4010 	push	{r4, lr}
	switch (argc) {
3480322c:	0a000012 	beq	3480327c <do_icache+0x58>
34803230:	e3520002 	cmp	r2, #2
	case 1:			/* get status */
		printf("Instruction Cache is %s\n",
			icache_status() ? "ON" : "OFF");
		return 0;
	default:
		return CMD_RET_USAGE;
34803234:	13e00000 	mvnne	r0, #0
	puts("No arch specific invalidate_icache_all available!\n");
}

int do_icache(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	switch (argc) {
34803238:	18bd8010 	popne	{r4, pc}
	case 2:			/* on / off	*/
		switch (parse_argv(argv[1])) {
3480323c:	e5930004 	ldr	r0, [r3, #4]
34803240:	ebffffdd 	bl	348031bc <parse_argv>
34803244:	e3500001 	cmp	r0, #1
34803248:	e1a04000 	mov	r4, r0
3480324c:	0a000006 	beq	3480326c <do_icache+0x48>
34803250:	e3500002 	cmp	r0, #2
34803254:	0a000006 	beq	34803274 <do_icache+0x50>
34803258:	e3500000 	cmp	r0, #0
3480325c:	1a00000f 	bne	348032a0 <do_icache+0x7c>
		case 0:
			icache_disable();
34803260:	ebfffbf8 	bl	34802248 <icache_disable>
			icache_status() ? "ON" : "OFF");
		return 0;
	default:
		return CMD_RET_USAGE;
	}
	return 0;
34803264:	e1a00004 	mov	r0, r4
	switch (argc) {
	case 2:			/* on / off	*/
		switch (parse_argv(argv[1])) {
		case 0:
			icache_disable();
			break;
34803268:	e8bd8010 	pop	{r4, pc}
		case 1:
			icache_enable();
3480326c:	ebfffbf3 	bl	34802240 <icache_enable>
34803270:	ea000008 	b	34803298 <do_icache+0x74>
			break;
		case 2:
			invalidate_icache_all();
34803274:	ebfff76b 	bl	34801028 <invalidate_icache_all>
34803278:	ea000006 	b	34803298 <do_icache+0x74>
			break;
		}
		break;
	case 1:			/* get status */
		printf("Instruction Cache is %s\n",
			icache_status() ? "ON" : "OFF");
3480327c:	ebfffbf3 	bl	34802250 <icache_status>
			invalidate_icache_all();
			break;
		}
		break;
	case 1:			/* get status */
		printf("Instruction Cache is %s\n",
34803280:	e59f3020 	ldr	r3, [pc, #32]	; 348032a8 <do_icache+0x84>
34803284:	e3500000 	cmp	r0, #0
34803288:	e59f101c 	ldr	r1, [pc, #28]	; 348032ac <do_icache+0x88>
3480328c:	e59f001c 	ldr	r0, [pc, #28]	; 348032b0 <do_icache+0x8c>
34803290:	11a01003 	movne	r1, r3
34803294:	eb00172c 	bl	34808f4c <printf>
			icache_status() ? "ON" : "OFF");
		return 0;
34803298:	e3a00000 	mov	r0, #0
3480329c:	e8bd8010 	pop	{r4, pc}
	default:
		return CMD_RET_USAGE;
	}
	return 0;
348032a0:	e3a00000 	mov	r0, #0
}
348032a4:	e8bd8010 	pop	{r4, pc}
348032a8:	3482618d 	.word	0x3482618d
348032ac:	34823938 	.word	0x34823938
348032b0:	3482393c 	.word	0x3482393c

void __weak flush_dcache_all(void)
{
	puts("No arch specific flush_dcache_all available!\n");
348032b4:	e59f0000 	ldr	r0, [pc, #0]	; 348032bc <do_icache+0x98>
348032b8:	ea001719 	b	34808f24 <puts>
348032bc:	34823955 	.word	0x34823955

348032c0 <do_dcache>:
	/* please define arch specific flush_dcache_all */
}

int do_dcache(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	switch (argc) {
348032c0:	e3520001 	cmp	r2, #1
	puts("No arch specific flush_dcache_all available!\n");
	/* please define arch specific flush_dcache_all */
}

int do_dcache(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
348032c4:	e92d4010 	push	{r4, lr}
	switch (argc) {
348032c8:	0a000012 	beq	34803318 <do_dcache+0x58>
348032cc:	e3520002 	cmp	r2, #2
	case 1:			/* get status */
		printf("Data (writethrough) Cache is %s\n",
			dcache_status() ? "ON" : "OFF");
		return 0;
	default:
		return CMD_RET_USAGE;
348032d0:	13e00000 	mvnne	r0, #0
	/* please define arch specific flush_dcache_all */
}

int do_dcache(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	switch (argc) {
348032d4:	18bd8010 	popne	{r4, pc}
	case 2:			/* on / off */
		switch (parse_argv(argv[1])) {
348032d8:	e5930004 	ldr	r0, [r3, #4]
348032dc:	ebffffb6 	bl	348031bc <parse_argv>
348032e0:	e3500001 	cmp	r0, #1
348032e4:	e1a04000 	mov	r4, r0
348032e8:	0a000006 	beq	34803308 <do_dcache+0x48>
348032ec:	e3500002 	cmp	r0, #2
348032f0:	0a000006 	beq	34803310 <do_dcache+0x50>
348032f4:	e3500000 	cmp	r0, #0
348032f8:	1a00000f 	bne	3480333c <do_dcache+0x7c>
		case 0:
			dcache_disable();
348032fc:	ebfffbd8 	bl	34802264 <dcache_disable>
			dcache_status() ? "ON" : "OFF");
		return 0;
	default:
		return CMD_RET_USAGE;
	}
	return 0;
34803300:	e1a00004 	mov	r0, r4
	switch (argc) {
	case 2:			/* on / off */
		switch (parse_argv(argv[1])) {
		case 0:
			dcache_disable();
			break;
34803304:	e8bd8010 	pop	{r4, pc}
		case 1:
			dcache_enable();
34803308:	ebfffbd3 	bl	3480225c <dcache_enable>
3480330c:	ea000008 	b	34803334 <do_dcache+0x74>
			break;
		case 2:
			flush_dcache_all();
34803310:	ebfff721 	bl	34800f9c <flush_dcache_all>
34803314:	ea000006 	b	34803334 <do_dcache+0x74>
			break;
		}
		break;
	case 1:			/* get status */
		printf("Data (writethrough) Cache is %s\n",
			dcache_status() ? "ON" : "OFF");
34803318:	ebfffbd3 	bl	3480226c <dcache_status>
			flush_dcache_all();
			break;
		}
		break;
	case 1:			/* get status */
		printf("Data (writethrough) Cache is %s\n",
3480331c:	e59f3020 	ldr	r3, [pc, #32]	; 34803344 <do_dcache+0x84>
34803320:	e3500000 	cmp	r0, #0
34803324:	e59f101c 	ldr	r1, [pc, #28]	; 34803348 <do_dcache+0x88>
34803328:	e59f001c 	ldr	r0, [pc, #28]	; 3480334c <do_dcache+0x8c>
3480332c:	11a01003 	movne	r1, r3
34803330:	eb001705 	bl	34808f4c <printf>
			dcache_status() ? "ON" : "OFF");
		return 0;
34803334:	e3a00000 	mov	r0, #0
34803338:	e8bd8010 	pop	{r4, pc}
	default:
		return CMD_RET_USAGE;
	}
	return 0;
3480333c:	e3a00000 	mov	r0, #0
}
34803340:	e8bd8010 	pop	{r4, pc}
34803344:	3482618d 	.word	0x3482618d
34803348:	34823938 	.word	0x34823938
3480334c:	34823983 	.word	0x34823983

34803350 <do_coninfo>:
#include <command.h>
#include <stdio_dev.h>

extern void _do_coninfo (void);
int do_coninfo (cmd_tbl_t * cmd, int flag, int argc, char * const argv[])
{
34803350:	e92d46f7 	push	{r0, r1, r2, r4, r5, r6, r7, r9, sl, lr}
	int l;
	struct list_head *list = stdio_get_list();
34803354:	eb002bda 	bl	3480e2c4 <stdio_get_list>
34803358:	e1a05000 	mov	r5, r0
	struct list_head *pos;
	struct stdio_dev *dev;

	/* Scan for valid output and input devices */

	puts ("List of available devices:\n");
3480335c:	e59f0090 	ldr	r0, [pc, #144]	; 348033f4 <do_coninfo+0xa4>
34803360:	eb0016ef 	bl	34808f24 <puts>
			(dev->flags & DEV_FLAGS_SYSTEM) ? 'S' : '.',
			(dev->flags & DEV_FLAGS_INPUT) ? 'I' : '.',
			(dev->flags & DEV_FLAGS_OUTPUT) ? 'O' : '.');

		for (l = 0; l < MAX_FILES; l++) {
			if (stdio_devices[l] == dev) {
34803364:	e59f708c 	ldr	r7, [pc, #140]	; 348033f8 <do_coninfo+0xa8>

	/* Scan for valid output and input devices */

	puts ("List of available devices:\n");

	list_for_each(pos, list) {
34803368:	e5954000 	ldr	r4, [r5]
			(dev->flags & DEV_FLAGS_INPUT) ? 'I' : '.',
			(dev->flags & DEV_FLAGS_OUTPUT) ? 'O' : '.');

		for (l = 0; l < MAX_FILES; l++) {
			if (stdio_devices[l] == dev) {
				printf ("%s ", stdio_names[l]);
3480336c:	e59fa088 	ldr	sl, [pc, #136]	; 348033fc <do_coninfo+0xac>

	/* Scan for valid output and input devices */

	puts ("List of available devices:\n");

	list_for_each(pos, list) {
34803370:	ea00001b 	b	348033e4 <do_coninfo+0x94>
		dev = list_entry(pos, struct stdio_dev, list);

		printf ("%-8s %08x %c%c%c ",
			dev->name,
			dev->flags,
			(dev->flags & DEV_FLAGS_SYSTEM) ? 'S' : '.',
34803374:	e5142034 	ldr	r2, [r4, #-52]	; 0x34
	/* Scan for valid output and input devices */

	puts ("List of available devices:\n");

	list_for_each(pos, list) {
		dev = list_entry(pos, struct stdio_dev, list);
34803378:	e2446034 	sub	r6, r4, #52	; 0x34

		printf ("%-8s %08x %c%c%c ",
3480337c:	e3120001 	tst	r2, #1
34803380:	03a0102e 	moveq	r1, #46	; 0x2e
34803384:	13a01049 	movne	r1, #73	; 0x49
34803388:	e3120002 	tst	r2, #2
3480338c:	03a0302e 	moveq	r3, #46	; 0x2e
34803390:	13a0304f 	movne	r3, #79	; 0x4f
34803394:	e3520000 	cmp	r2, #0
34803398:	e88d000a 	stm	sp, {r1, r3}
3480339c:	e59f005c 	ldr	r0, [pc, #92]	; 34803400 <do_coninfo+0xb0>
348033a0:	e2861008 	add	r1, r6, #8
348033a4:	a3a0302e 	movge	r3, #46	; 0x2e
348033a8:	b3a03053 	movlt	r3, #83	; 0x53
348033ac:	eb0016e6 	bl	34808f4c <printf>
348033b0:	e3a09000 	mov	r9, #0
			(dev->flags & DEV_FLAGS_SYSTEM) ? 'S' : '.',
			(dev->flags & DEV_FLAGS_INPUT) ? 'I' : '.',
			(dev->flags & DEV_FLAGS_OUTPUT) ? 'O' : '.');

		for (l = 0; l < MAX_FILES; l++) {
			if (stdio_devices[l] == dev) {
348033b4:	e7993007 	ldr	r3, [r9, r7]
348033b8:	e1530006 	cmp	r3, r6
348033bc:	1a000002 	bne	348033cc <do_coninfo+0x7c>
				printf ("%s ", stdio_names[l]);
348033c0:	e59f003c 	ldr	r0, [pc, #60]	; 34803404 <do_coninfo+0xb4>
348033c4:	e799100a 	ldr	r1, [r9, sl]
348033c8:	eb0016df 	bl	34808f4c <printf>
348033cc:	e2899004 	add	r9, r9, #4
			dev->flags,
			(dev->flags & DEV_FLAGS_SYSTEM) ? 'S' : '.',
			(dev->flags & DEV_FLAGS_INPUT) ? 'I' : '.',
			(dev->flags & DEV_FLAGS_OUTPUT) ? 'O' : '.');

		for (l = 0; l < MAX_FILES; l++) {
348033d0:	e359000c 	cmp	r9, #12
348033d4:	1afffff6 	bne	348033b4 <do_coninfo+0x64>
			if (stdio_devices[l] == dev) {
				printf ("%s ", stdio_names[l]);
			}
		}
		putc ('\n');
348033d8:	e3a0000a 	mov	r0, #10
348033dc:	eb0016c6 	bl	34808efc <putc>

	/* Scan for valid output and input devices */

	puts ("List of available devices:\n");

	list_for_each(pos, list) {
348033e0:	e5944000 	ldr	r4, [r4]
348033e4:	e1540005 	cmp	r4, r5
348033e8:	1affffe1 	bne	34803374 <do_coninfo+0x24>
			}
		}
		putc ('\n');
	}
	return 0;
}
348033ec:	e3a00000 	mov	r0, #0
348033f0:	e8bd86fe 	pop	{r1, r2, r3, r4, r5, r6, r7, r9, sl, pc}
348033f4:	34823a81 	.word	0x34823a81
348033f8:	3482ad24 	.word	0x3482ad24
348033fc:	34828874 	.word	0x34828874
34803400:	34823a9d 	.word	0x34823a9d
34803404:	34825e64 	.word	0x34825e64

34803408 <do_echo>:

#include <common.h>
#include <command.h>

int do_echo(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
34803408:	e92d4ef3 	push	{r0, r1, r4, r5, r6, r7, r9, sl, fp, lr}
	int i;
	int putnl = 1;
3480340c:	e3a07001 	mov	r7, #1

#include <common.h>
#include <command.h>

int do_echo(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
34803410:	e1a04002 	mov	r4, r2
34803414:	e1a0a003 	mov	sl, r3
	int i;
	int putnl = 1;

	for (i = 1; i < argc; i++) {
34803418:	e1a06007 	mov	r6, r7
			/*
			 * be paranoid and guess that someone might
			 * say \c more than once
			 */
			while (nls) {
				*nls = '\0';
3480341c:	e3a0b000 	mov	fp, #0
				puts(prenls);
				*nls = '\\';
34803420:	e3a0905c 	mov	r9, #92	; 0x5c
int do_echo(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	int i;
	int putnl = 1;

	for (i = 1; i < argc; i++) {
34803424:	ea00001e 	b	348034a4 <do_echo+0x9c>
		char *p = argv[i];
		char *nls; /* new-line suppression */

		if (i > 1)
34803428:	e3560001 	cmp	r6, #1
{
	int i;
	int putnl = 1;

	for (i = 1; i < argc; i++) {
		char *p = argv[i];
3480342c:	e5ba5004 	ldr	r5, [sl, #4]!
		char *nls; /* new-line suppression */

		if (i > 1)
34803430:	da000001 	ble	3480343c <do_echo+0x34>
			putc(' ');
34803434:	e3a00020 	mov	r0, #32
34803438:	eb0016af 	bl	34808efc <putc>

		nls = strstr(p, "\\c");
3480343c:	e1a00005 	mov	r0, r5
34803440:	e59f107c 	ldr	r1, [pc, #124]	; 348034c4 <do_echo+0xbc>
34803444:	eb0056dc 	bl	34818fbc <strstr>
		if (nls) {
34803448:	e2503000 	subs	r3, r0, #0
3480344c:	0a000011 	beq	34803498 <do_echo+0x90>
			/*
			 * be paranoid and guess that someone might
			 * say \c more than once
			 */
			while (nls) {
				*nls = '\0';
34803450:	e5c3b000 	strb	fp, [r3]
				puts(prenls);
34803454:	e1a00005 	mov	r0, r5
34803458:	e58d3004 	str	r3, [sp, #4]
3480345c:	eb0016b0 	bl	34808f24 <puts>
				*nls = '\\';
34803460:	e59d3004 	ldr	r3, [sp, #4]
				prenls = nls + 2;
				nls = strstr(prenls, "\\c");
34803464:	e59f1058 	ldr	r1, [pc, #88]	; 348034c4 <do_echo+0xbc>
			 * say \c more than once
			 */
			while (nls) {
				*nls = '\0';
				puts(prenls);
				*nls = '\\';
34803468:	e1a05003 	mov	r5, r3
3480346c:	e4c59002 	strb	r9, [r5], #2
				prenls = nls + 2;
				nls = strstr(prenls, "\\c");
34803470:	e1a00005 	mov	r0, r5
34803474:	eb0056d0 	bl	34818fbc <strstr>
			putnl = 0;
			/*
			 * be paranoid and guess that someone might
			 * say \c more than once
			 */
			while (nls) {
34803478:	e2503000 	subs	r3, r0, #0
3480347c:	1afffff3 	bne	34803450 <do_echo+0x48>
				puts(prenls);
				*nls = '\\';
				prenls = nls + 2;
				nls = strstr(prenls, "\\c");
			}
			puts(prenls);
34803480:	e1a00005 	mov	r0, r5
34803484:	e58d3004 	str	r3, [sp, #4]
34803488:	eb0016a5 	bl	34808f24 <puts>

		nls = strstr(p, "\\c");
		if (nls) {
			char *prenls = p;

			putnl = 0;
3480348c:	e59d3004 	ldr	r3, [sp, #4]
34803490:	e1a07003 	mov	r7, r3
34803494:	ea000001 	b	348034a0 <do_echo+0x98>
				prenls = nls + 2;
				nls = strstr(prenls, "\\c");
			}
			puts(prenls);
		} else {
			puts(p);
34803498:	e1a00005 	mov	r0, r5
3480349c:	eb0016a0 	bl	34808f24 <puts>
int do_echo(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	int i;
	int putnl = 1;

	for (i = 1; i < argc; i++) {
348034a0:	e2866001 	add	r6, r6, #1
348034a4:	e1560004 	cmp	r6, r4
348034a8:	baffffde 	blt	34803428 <do_echo+0x20>
		} else {
			puts(p);
		}
	}

	if (putnl)
348034ac:	e3570000 	cmp	r7, #0
348034b0:	0a000001 	beq	348034bc <do_echo+0xb4>
		putc('\n');
348034b4:	e3a0000a 	mov	r0, #10
348034b8:	eb00168f 	bl	34808efc <putc>

	return 0;
}
348034bc:	e3a00000 	mov	r0, #0
348034c0:	e8bd8efc 	pop	{r2, r3, r4, r5, r6, r7, r9, sl, fp, pc}
348034c4:	34823add 	.word	0x34823add

348034c8 <do_exit>:
int do_exit(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	int r;

	r = 0;
	if (argc > 1)
348034c8:	e3520001 	cmp	r2, #1

#include <common.h>
#include <command.h>

int do_exit(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
348034cc:	e92d4008 	push	{r3, lr}
	int r;

	r = 0;
348034d0:	d3a03000 	movle	r3, #0
	if (argc > 1)
348034d4:	da000004 	ble	348034ec <do_exit+0x24>
		r = simple_strtoul(argv[1], NULL, 10);
348034d8:	e5930004 	ldr	r0, [r3, #4]
348034dc:	e3a01000 	mov	r1, #0
348034e0:	e3a0200a 	mov	r2, #10
348034e4:	eb0059c3 	bl	34819bf8 <simple_strtoul>
348034e8:	e1a03000 	mov	r3, r0

	return -r - 2;
}
348034ec:	e3e00001 	mvn	r0, #1
348034f0:	e0630000 	rsb	r0, r3, r0
348034f4:	e8bd8008 	pop	{r3, pc}

348034f8 <do_help>:

#include <common.h>
#include <command.h>

int do_help(cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
{
348034f8:	e92d4007 	push	{r0, r1, r2, lr}
348034fc:	e1a0c001 	mov	ip, r1
34803500:	e1a0e000 	mov	lr, r0
	return _do_help(&__u_boot_cmd_start,
			&__u_boot_cmd_end - &__u_boot_cmd_start,
34803504:	e59f1028 	ldr	r1, [pc, #40]	; 34803534 <do_help+0x3c>
#include <common.h>
#include <command.h>

int do_help(cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
{
	return _do_help(&__u_boot_cmd_start,
34803508:	e59f0028 	ldr	r0, [pc, #40]	; 34803538 <do_help+0x40>
3480350c:	e58d3004 	str	r3, [sp, #4]
			&__u_boot_cmd_end - &__u_boot_cmd_start,
34803510:	e0601001 	rsb	r1, r0, r1
#include <common.h>
#include <command.h>

int do_help(cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
{
	return _do_help(&__u_boot_cmd_start,
34803514:	e59f3020 	ldr	r3, [pc, #32]	; 3480353c <do_help+0x44>
34803518:	e1a011c1 	asr	r1, r1, #3
3480351c:	e58d2000 	str	r2, [sp]
34803520:	e0010193 	mul	r1, r3, r1
34803524:	e1a0200e 	mov	r2, lr
34803528:	e1a0300c 	mov	r3, ip
3480352c:	eb001546 	bl	34808a4c <_do_help>
			&__u_boot_cmd_end - &__u_boot_cmd_start,
			cmdtp, flag, argc, argv);
}
34803530:	e8bd800e 	pop	{r1, r2, r3, pc}
	...
3480353c:	aaaaaaab 	.word	0xaaaaaaab

34803540 <evalstr>:
}

static char * evalstr(char *s)
{
	/* if the parameter starts with a * then assume a string pointer else its a literal */
	if (s[0] == '*') {
34803540:	e5d02000 	ldrb	r2, [r0]
34803544:	e352002a 	cmp	r2, #42	; 0x2a
34803548:	112fff1e 	bxne	lr
		return (char *)simple_strtoul(&s[1], NULL, 16);
3480354c:	e2800001 	add	r0, r0, #1
34803550:	e3a01000 	mov	r1, #0
34803554:	e3a02010 	mov	r2, #16
34803558:	ea0059a6 	b	34819bf8 <simple_strtoul>

3480355c <evalexp>:
	{ "-le", LE },
	{ "<=" , LE },
};

static long evalexp(char *s, int w)
{
3480355c:	e92d4010 	push	{r4, lr}
	long l = 0;
	long *p;

	/* if the parameter starts with a * then assume is a pointer to the value we want */
	if (s[0] == '*') {
34803560:	e5d02000 	ldrb	r2, [r0]
	{ "-le", LE },
	{ "<=" , LE },
};

static long evalexp(char *s, int w)
{
34803564:	e1a04001 	mov	r4, r1
	long l = 0;
	long *p;

	/* if the parameter starts with a * then assume is a pointer to the value we want */
	if (s[0] == '*') {
34803568:	e352002a 	cmp	r2, #42	; 0x2a
3480356c:	1a00000d 	bne	348035a8 <evalexp+0x4c>
		p = (long *)simple_strtoul(&s[1], NULL, 16);
34803570:	e2800001 	add	r0, r0, #1
34803574:	e3a01000 	mov	r1, #0
34803578:	e3a02010 	mov	r2, #16
3480357c:	eb00599d 	bl	34819bf8 <simple_strtoul>
		switch (w) {
34803580:	e3540002 	cmp	r4, #2
		case 1: return((long)(*(unsigned char *)p));
		case 2: return((long)(*(unsigned short *)p));
34803584:	01d000b0 	ldrheq	r0, [r0]
	long *p;

	/* if the parameter starts with a * then assume is a pointer to the value we want */
	if (s[0] == '*') {
		p = (long *)simple_strtoul(&s[1], NULL, 16);
		switch (w) {
34803588:	08bd8010 	popeq	{r4, pc}
3480358c:	e3540004 	cmp	r4, #4
		case 1: return((long)(*(unsigned char *)p));
		case 2: return((long)(*(unsigned short *)p));
		case 4: return(*p);
34803590:	05900000 	ldreq	r0, [r0]
	long *p;

	/* if the parameter starts with a * then assume is a pointer to the value we want */
	if (s[0] == '*') {
		p = (long *)simple_strtoul(&s[1], NULL, 16);
		switch (w) {
34803594:	08bd8010 	popeq	{r4, pc}
34803598:	e3540001 	cmp	r4, #1
		case 1: return((long)(*(unsigned char *)p));
3480359c:	05d00000 	ldrbeq	r0, [r0]
	long *p;

	/* if the parameter starts with a * then assume is a pointer to the value we want */
	if (s[0] == '*') {
		p = (long *)simple_strtoul(&s[1], NULL, 16);
		switch (w) {
348035a0:	1a000004 	bne	348035b8 <evalexp+0x5c>
348035a4:	e8bd8010 	pop	{r4, pc}
		case 1: return((long)(*(unsigned char *)p));
		case 2: return((long)(*(unsigned short *)p));
		case 4: return(*p);
		}
	} else {
		l = simple_strtoul(s, NULL, 16);
348035a8:	e3a01000 	mov	r1, #0
348035ac:	e3a02010 	mov	r2, #16
348035b0:	eb005990 	bl	34819bf8 <simple_strtoul>
348035b4:	ea000000 	b	348035bc <evalexp+0x60>
	{ "<=" , LE },
};

static long evalexp(char *s, int w)
{
	long l = 0;
348035b8:	e3a00000 	mov	r0, #0
		}
	} else {
		l = simple_strtoul(s, NULL, 16);
	}

	return (l & ((1 << (w * 8)) - 1));
348035bc:	e1a04184 	lsl	r4, r4, #3
348035c0:	e3e03000 	mvn	r3, #0
348035c4:	e1c00413 	bic	r0, r0, r3, lsl r4
}
348035c8:	e8bd8010 	pop	{r4, pc}

348035cc <binary_test>:
	}
	return (0);
}

int binary_test (char *op, char *arg1, char *arg2, int w)
{
348035cc:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
348035d0:	e1a09000 	mov	r9, r0
348035d4:	e1a05001 	mov	r5, r1
348035d8:	e1a04002 	mov	r4, r2
348035dc:	e1a07003 	mov	r7, r3
	int len, i;
	const op_tbl_t *optp;

	len = strlen(op);
348035e0:	eb005566 	bl	34818b80 <strlen>
	case GE: return (l >= r);
	}
	return (0);
}

int binary_test (char *op, char *arg1, char *arg2, int w)
348035e4:	e59fb190 	ldr	fp, [pc, #400]	; 3480377c <binary_test+0x1b0>
{
	int len, i;
	const op_tbl_t *optp;

	len = strlen(op);
348035e8:	e1a0a000 	mov	sl, r0

	for (optp = (op_tbl_t *)&op_table, i = 0;
348035ec:	e59f618c 	ldr	r6, [pc, #396]	; 34803780 <binary_test+0x1b4>
348035f0:	ea000058 	b	34803758 <binary_test+0x18c>
	     i < ARRAY_SIZE(op_table);
	     optp++, i++) {

		if ((strncmp (op, optp->op, len) == 0) && (len == strlen (optp->op))) {
348035f4:	e1a00009 	mov	r0, r9
348035f8:	e5961000 	ldr	r1, [r6]
348035fc:	e1a0200a 	mov	r2, sl
34803600:	eb005536 	bl	34818ae0 <strncmp>
34803604:	e3500000 	cmp	r0, #0
34803608:	1a000051 	bne	34803754 <binary_test+0x188>
3480360c:	e5960000 	ldr	r0, [r6]
34803610:	eb00555a 	bl	34818b80 <strlen>
34803614:	e15a0000 	cmp	sl, r0
34803618:	1a00004d 	bne	34803754 <binary_test+0x188>
			if (w == 0) {
3480361c:	e3570000 	cmp	r7, #0
34803620:	e5966004 	ldr	r6, [r6, #4]
34803624:	1a000023 	bne	348036b8 <binary_test+0xec>
static int stringcomp(char *s, char *t, int op)
{
	int p;
	char *l, *r;

	l = evalstr(s);
34803628:	e1a00005 	mov	r0, r5
3480362c:	ebffffc3 	bl	34803540 <evalstr>
34803630:	e1a05000 	mov	r5, r0
	r = evalstr(t);
34803634:	e1a00004 	mov	r0, r4
34803638:	ebffffc0 	bl	34803540 <evalstr>
3480363c:	e1a01000 	mov	r1, r0

	p = strcmp(l, r);
34803640:	e1a00005 	mov	r0, r5
34803644:	eb005519 	bl	34818ab0 <strcmp>
	switch (op) {
34803648:	e3560005 	cmp	r6, #5
3480364c:	979ff106 	ldrls	pc, [pc, r6, lsl #2]
34803650:	ea000045 	b	3480376c <binary_test+0x1a0>
34803654:	3480366c 	.word	0x3480366c
34803658:	34803678 	.word	0x34803678
3480365c:	34803684 	.word	0x34803684
34803660:	3480368c 	.word	0x3480368c
34803664:	3480369c 	.word	0x3480369c
34803668:	348036ac 	.word	0x348036ac
	case EQ: return (p == 0);
3480366c:	e2700001 	rsbs	r0, r0, #1
34803670:	33a00000 	movcc	r0, #0
34803674:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
	case NE: return (p != 0);
34803678:	e2500000 	subs	r0, r0, #0
3480367c:	13a00001 	movne	r0, #1
34803680:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
	case LT: return (p < 0);
34803684:	e1a00fa0 	lsr	r0, r0, #31
34803688:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
	case GT: return (p > 0);
3480368c:	e3500000 	cmp	r0, #0
34803690:	d3a00000 	movle	r0, #0
34803694:	c3a00001 	movgt	r0, #1
34803698:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
	case LE: return (p <= 0);
3480369c:	e3500000 	cmp	r0, #0
348036a0:	c3a00000 	movgt	r0, #0
348036a4:	d3a00001 	movle	r0, #1
348036a8:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
	case GE: return (p >= 0);
348036ac:	e1e00000 	mvn	r0, r0
348036b0:	e1a00fa0 	lsr	r0, r0, #31
348036b4:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}

static int arithcomp (char *s, char *t, int op, int w)
{
	long l, r;

	l = evalexp (s, w);
348036b8:	e1a00005 	mov	r0, r5
348036bc:	e1a01007 	mov	r1, r7
348036c0:	ebffffa5 	bl	3480355c <evalexp>
	r = evalexp (t, w);
348036c4:	e1a01007 	mov	r1, r7

static int arithcomp (char *s, char *t, int op, int w)
{
	long l, r;

	l = evalexp (s, w);
348036c8:	e1a05000 	mov	r5, r0
	r = evalexp (t, w);
348036cc:	e1a00004 	mov	r0, r4
348036d0:	ebffffa1 	bl	3480355c <evalexp>

	switch (op) {
348036d4:	e3560005 	cmp	r6, #5
348036d8:	979ff106 	ldrls	pc, [pc, r6, lsl #2]
348036dc:	ea000024 	b	34803774 <binary_test+0x1a8>
348036e0:	348036f8 	.word	0x348036f8
348036e4:	34803708 	.word	0x34803708
348036e8:	34803714 	.word	0x34803714
348036ec:	34803724 	.word	0x34803724
348036f0:	34803734 	.word	0x34803734
348036f4:	34803744 	.word	0x34803744
	case EQ: return (l == r);
348036f8:	e1550000 	cmp	r5, r0
348036fc:	13a00000 	movne	r0, #0
34803700:	03a00001 	moveq	r0, #1
34803704:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
	case NE: return (l != r);
34803708:	e0550000 	subs	r0, r5, r0
3480370c:	13a00001 	movne	r0, #1
34803710:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
	case LT: return (l < r);
34803714:	e1550000 	cmp	r5, r0
34803718:	a3a00000 	movge	r0, #0
3480371c:	b3a00001 	movlt	r0, #1
34803720:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
	case GT: return (l > r);
34803724:	e1550000 	cmp	r5, r0
34803728:	d3a00000 	movle	r0, #0
3480372c:	c3a00001 	movgt	r0, #1
34803730:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
	case LE: return (l <= r);
34803734:	e1550000 	cmp	r5, r0
34803738:	c3a00000 	movgt	r0, #0
3480373c:	d3a00001 	movle	r0, #1
34803740:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
	case GE: return (l >= r);
34803744:	e1550000 	cmp	r5, r0
34803748:	b3a00000 	movlt	r0, #0
3480374c:	a3a00001 	movge	r0, #1
34803750:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}

	len = strlen(op);

	for (optp = (op_tbl_t *)&op_table, i = 0;
	     i < ARRAY_SIZE(op_table);
	     optp++, i++) {
34803754:	e2866008 	add	r6, r6, #8
	int len, i;
	const op_tbl_t *optp;

	len = strlen(op);

	for (optp = (op_tbl_t *)&op_table, i = 0;
34803758:	e156000b 	cmp	r6, fp
3480375c:	1affffa4 	bne	348035f4 <binary_test+0x28>
				return (arithcomp (arg1, arg2, optp->opcode, w));
			}
		}
	}

	printf("Unknown operator '%s'\n", op);
34803760:	e59f001c 	ldr	r0, [pc, #28]	; 34803784 <binary_test+0x1b8>
34803764:	e1a01009 	mov	r1, r9
34803768:	eb0015f7 	bl	34808f4c <printf>
	case LT: return (p < 0);
	case GT: return (p > 0);
	case LE: return (p <= 0);
	case GE: return (p >= 0);
	}
	return (0);
3480376c:	e3a00000 	mov	r0, #0
34803770:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
	case LT: return (l < r);
	case GT: return (l > r);
	case LE: return (l <= r);
	case GE: return (l >= r);
	}
	return (0);
34803774:	e3a00000 	mov	r0, #0
		}
	}

	printf("Unknown operator '%s'\n", op);
	return 0;	/* op code not found */
}
34803778:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
3480377c:	348204a0 	.word	0x348204a0
34803780:	34820438 	.word	0x34820438
34803784:	34823bdb 	.word	0x34823bdb

34803788 <do_itest>:
int do_itest ( cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[] )
{
	int	value, w;

	/* Validate arguments */
	if ((argc != 4))
34803788:	e3520004 	cmp	r2, #4
	return 0;	/* op code not found */
}

/* command line interface to the shell test */
int do_itest ( cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[] )
{
3480378c:	e92d4010 	push	{r4, lr}
34803790:	e1a04003 	mov	r4, r3
	int	value, w;

	/* Validate arguments */
	if ((argc != 4))
34803794:	1a00001e 	bne	34803814 <do_itest+0x8c>

	/* Check for a data width specification.
	 * Defaults to long (4) if no specification.
	 * Uses -2 as 'width' for .s (string) so as not to upset existing code
	 */
	switch (w = cmd_get_data_size(argv[0], 4)) {
34803798:	e5930000 	ldr	r0, [r3]
3480379c:	e1a01002 	mov	r1, r2
348037a0:	eb00150b 	bl	34808bd4 <cmd_get_data_size>
348037a4:	e2802002 	add	r2, r0, #2
348037a8:	e1a03000 	mov	r3, r0
348037ac:	e3520006 	cmp	r2, #6
348037b0:	979ff102 	ldrls	pc, [pc, r2, lsl #2]
348037b4:	ea000010 	b	348037fc <do_itest+0x74>
348037b8:	348037e4 	.word	0x348037e4
348037bc:	348037fc 	.word	0x348037fc
348037c0:	348037fc 	.word	0x348037fc
348037c4:	348037d4 	.word	0x348037d4
348037c8:	348037d4 	.word	0x348037d4
348037cc:	348037fc 	.word	0x348037fc
348037d0:	348037d4 	.word	0x348037d4
	case 1:
	case 2:
	case 4:
		value = binary_test (argv[2], argv[1], argv[3], w);
348037d4:	e5940008 	ldr	r0, [r4, #8]
348037d8:	e5941004 	ldr	r1, [r4, #4]
348037dc:	e594200c 	ldr	r2, [r4, #12]
348037e0:	ea000003 	b	348037f4 <do_itest+0x6c>
		break;
	case -2:
		value = binary_test (argv[2], argv[1], argv[3], 0);
348037e4:	e5940008 	ldr	r0, [r4, #8]
348037e8:	e5941004 	ldr	r1, [r4, #4]
348037ec:	e594200c 	ldr	r2, [r4, #12]
348037f0:	e3a03000 	mov	r3, #0
348037f4:	ebffff74 	bl	348035cc <binary_test>
		break;
348037f8:	ea000002 	b	34803808 <do_itest+0x80>
	case -1:
	default:
		puts("Invalid data width specifier\n");
348037fc:	e59f0018 	ldr	r0, [pc, #24]	; 3480381c <do_itest+0x94>
34803800:	eb0015c7 	bl	34808f24 <puts>
		value = 0;
34803804:	e3a00000 	mov	r0, #0
		break;
	}

	return !value;
34803808:	e2700001 	rsbs	r0, r0, #1
3480380c:	33a00000 	movcc	r0, #0
34803810:	e8bd8010 	pop	{r4, pc}
{
	int	value, w;

	/* Validate arguments */
	if ((argc != 4))
		return CMD_RET_USAGE;
34803814:	e3e00000 	mvn	r0, #0
		value = 0;
		break;
	}

	return !value;
}
34803818:	e8bd8010 	pop	{r4, pc}
3480381c:	34823bf2 	.word	0x34823bf2

34803820 <bin_data_init>:
static char *os_data_addr, *os_data_addr_saved;
static char *bin_start_address;

static void bin_data_init (void)
{
	os_data_state = 0;
34803820:	e59f3010 	ldr	r3, [pc, #16]	; 34803838 <bin_data_init+0x18>
34803824:	e3a02000 	mov	r2, #0
34803828:	e5832000 	str	r2, [r3]
	os_data_addr = bin_start_address;
3480382c:	e5932008 	ldr	r2, [r3, #8]
34803830:	e5832004 	str	r2, [r3, #4]
}
34803834:	e12fff1e 	bx	lr
34803838:	348291ac 	.word	0x348291ac

3480383c <bin_data_char>:
	os_data_addr = os_data_addr_saved;
}

static void bin_data_char (char new_char)
{
	switch (os_data_state) {
3480383c:	e59f3014 	ldr	r3, [pc, #20]	; 34803858 <bin_data_char+0x1c>
34803840:	e5932000 	ldr	r2, [r3]
34803844:	e3520000 	cmp	r2, #0
	case 0:					/* data */
		*os_data_addr++ = new_char;
34803848:	05932004 	ldreq	r2, [r3, #4]
3480384c:	04c20001 	strbeq	r0, [r2], #1
34803850:	05832004 	streq	r2, [r3, #4]
34803854:	e12fff1e 	bx	lr
34803858:	348291ac 	.word	0x348291ac

3480385c <load_serial_ymodem>:
	if (tstc())
		return (getc());
	return -1;
}
static ulong load_serial_ymodem (ulong offset)
{
3480385c:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
34803860:	e24dde43 	sub	sp, sp, #1072	; 0x430
	ulong store_addr = ~0;
	ulong addr = 0;

	size = 0;
	info.mode = xyzModem_ymodem;
	res = xyzModem_stream_open (&info, &err);
34803864:	e28dae42 	add	sl, sp, #1056	; 0x420
34803868:	e28aa00c 	add	sl, sl, #12
	char ymodemBuf[1024];
	ulong store_addr = ~0;
	ulong addr = 0;

	size = 0;
	info.mode = xyzModem_ymodem;
3480386c:	e3a03002 	mov	r3, #2
	if (tstc())
		return (getc());
	return -1;
}
static ulong load_serial_ymodem (ulong offset)
{
34803870:	e1a06000 	mov	r6, r0
	ulong store_addr = ~0;
	ulong addr = 0;

	size = 0;
	info.mode = xyzModem_ymodem;
	res = xyzModem_stream_open (&info, &err);
34803874:	e1a0100a 	mov	r1, sl
34803878:	e28d0e42 	add	r0, sp, #1056	; 0x420
	char ymodemBuf[1024];
	ulong store_addr = ~0;
	ulong addr = 0;

	size = 0;
	info.mode = xyzModem_ymodem;
3480387c:	e58d3424 	str	r3, [sp, #1060]	; 0x424
	res = xyzModem_stream_open (&info, &err);
34803880:	eb002bfb 	bl	3480e874 <xyzModem_stream_open>
	if (!res) {
34803884:	e2505000 	subs	r5, r0, #0
34803888:	01a04005 	moveq	r4, r5

		while ((res =
			xyzModem_stream_read (ymodemBuf, 1024, &err)) > 0) {
3480388c:	01a0700d 	moveq	r7, sp
	ulong addr = 0;

	size = 0;
	info.mode = xyzModem_ymodem;
	res = xyzModem_stream_open (&info, &err);
	if (!res) {
34803890:	0a000005 	beq	348038ac <load_serial_ymodem+0x50>
34803894:	ea00000b 	b	348038c8 <load_serial_ymodem+0x6c>

		while ((res =
			xyzModem_stream_read (ymodemBuf, 1024, &err)) > 0) {
			store_addr = addr + offset;
34803898:	e0850006 	add	r0, r5, r6
					return (~0);
				}
			} else
#endif
			{
				memcpy ((char *) (store_addr), ymodemBuf,
3480389c:	e1a0100d 	mov	r1, sp
	if (!res) {

		while ((res =
			xyzModem_stream_read (ymodemBuf, 1024, &err)) > 0) {
			store_addr = addr + offset;
			size += res;
348038a0:	e0844002 	add	r4, r4, r2
			addr += res;
348038a4:	e0855002 	add	r5, r5, r2
					return (~0);
				}
			} else
#endif
			{
				memcpy ((char *) (store_addr), ymodemBuf,
348038a8:	eb005578 	bl	34818e90 <memcpy>
	size = 0;
	info.mode = xyzModem_ymodem;
	res = xyzModem_stream_open (&info, &err);
	if (!res) {

		while ((res =
348038ac:	e1a0200a 	mov	r2, sl
348038b0:	e1a0000d 	mov	r0, sp
348038b4:	e3a01b01 	mov	r1, #1024	; 0x400
348038b8:	eb002c3f 	bl	3480e9bc <xyzModem_stream_read>
348038bc:	e2502000 	subs	r2, r0, #0
348038c0:	cafffff4 	bgt	34803898 <load_serial_ymodem+0x3c>
348038c4:	ea000005 	b	348038e0 <load_serial_ymodem+0x84>
					res);
			}

		}
	} else {
		printf ("%s\n", xyzModem_error (err));
348038c8:	e59d042c 	ldr	r0, [sp, #1068]	; 0x42c
348038cc:	eb002d07 	bl	3480ecf0 <xyzModem_error>
348038d0:	e1a01000 	mov	r1, r0
348038d4:	e59f0064 	ldr	r0, [pc, #100]	; 34803940 <load_serial_ymodem+0xe4>
348038d8:	eb00159b 	bl	34808f4c <printf>
	connection_info_t info;
	char ymodemBuf[1024];
	ulong store_addr = ~0;
	ulong addr = 0;

	size = 0;
348038dc:	e3a04000 	mov	r4, #0
		}
	} else {
		printf ("%s\n", xyzModem_error (err));
	}

	xyzModem_stream_close (&err);
348038e0:	e28d0e42 	add	r0, sp, #1056	; 0x420
348038e4:	e280000c 	add	r0, r0, #12
348038e8:	eb002cc7 	bl	3480ec0c <xyzModem_stream_close>
	xyzModem_stream_terminate (false, &getcxmodem);
348038ec:	e3a00000 	mov	r0, #0
348038f0:	e59f104c 	ldr	r1, [pc, #76]	; 34803944 <load_serial_ymodem+0xe8>
348038f4:	eb002cd8 	bl	3480ec5c <xyzModem_stream_terminate>


	flush_cache (offset, size);
348038f8:	e1a00006 	mov	r0, r6
348038fc:	e1a01004 	mov	r1, r4
34803900:	ebfff5c6 	bl	34801020 <flush_cache>

	printf ("## Total Size      = 0x%08x = %d Bytes\n", size, size);
	sprintf (buf, "%X", size);
34803904:	e28d5b01 	add	r5, sp, #1024	; 0x400
	xyzModem_stream_terminate (false, &getcxmodem);


	flush_cache (offset, size);

	printf ("## Total Size      = 0x%08x = %d Bytes\n", size, size);
34803908:	e1a01004 	mov	r1, r4
3480390c:	e1a02004 	mov	r2, r4
34803910:	e59f0030 	ldr	r0, [pc, #48]	; 34803948 <load_serial_ymodem+0xec>
34803914:	eb00158c 	bl	34808f4c <printf>
	sprintf (buf, "%X", size);
34803918:	e1a02004 	mov	r2, r4
3480391c:	e1a00005 	mov	r0, r5
34803920:	e59f1024 	ldr	r1, [pc, #36]	; 3480394c <load_serial_ymodem+0xf0>
34803924:	eb005959 	bl	34819e90 <sprintf>
	setenv ("filesize", buf);
34803928:	e1a01005 	mov	r1, r5
3480392c:	e59f001c 	ldr	r0, [pc, #28]	; 34803950 <load_serial_ymodem+0xf4>
34803930:	eb001139 	bl	34807e1c <setenv>

	return offset;
}
34803934:	e1a00006 	mov	r0, r6
34803938:	e28dde43 	add	sp, sp, #1072	; 0x430
3480393c:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
34803940:	34825dd8 	.word	0x34825dd8
34803944:	34803954 	.word	0x34803954
34803948:	34823c8e 	.word	0x34823c8e
3480394c:	34823cb6 	.word	0x34823cb6
34803950:	34823512 	.word	0x34823512

34803954 <getcxmodem>:
		}
	}
	return ((ulong) os_data_addr - (ulong) bin_start_address);
}

static int getcxmodem(void) {
34803954:	e92d4010 	push	{r4, lr}
	if (tstc())
34803958:	eb00155e 	bl	34808ed8 <tstc>
3480395c:	e3500000 	cmp	r0, #0
34803960:	0a000001 	beq	3480396c <getcxmodem+0x18>
		return (getc());
	return -1;
}
34803964:	e8bd4010 	pop	{r4, lr}
	return ((ulong) os_data_addr - (ulong) bin_start_address);
}

static int getcxmodem(void) {
	if (tstc())
		return (getc());
34803968:	ea001551 	b	34808eb4 <getc>
	return -1;
}
3480396c:	e3e00000 	mvn	r0, #0
34803970:	e8bd8010 	pop	{r4, pc}

34803974 <load_serial>:
	return rcode;
}

static ulong
load_serial (long offset)
{
34803974:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	ulong	size;				/* number of bytes transferred	*/
	char	buf[32];
	ulong	store_addr;
	ulong	start_addr = ~0;
	ulong	end_addr   =  0;
	int	line_count =  0;
34803978:	e3a05000 	mov	r5, #0
	return rcode;
}

static ulong
load_serial (long offset)
{
3480397c:	e24ddd0d 	sub	sp, sp, #832	; 0x340
34803980:	e58d000c 	str	r0, [sp, #12]
	ulong	addr;				/* load address from S-Record	*/
	ulong	size;				/* number of bytes transferred	*/
	char	buf[32];
	ulong	store_addr;
	ulong	start_addr = ~0;
	ulong	end_addr   =  0;
34803984:	e1a07005 	mov	r7, r5
	int	type;				/* return code for record type	*/
	ulong	addr;				/* load address from S-Record	*/
	ulong	size;				/* number of bytes transferred	*/
	char	buf[32];
	ulong	store_addr;
	ulong	start_addr = ~0;
34803988:	e3e04000 	mvn	r4, #0
#endif
	return rcode;
}

static ulong
load_serial (long offset)
3480398c:	e28d9f85 	add	r9, sp, #532	; 0x214

	--len;	/* always leave room for terminating '\0' byte */

	for (p=buf; p < buf+len; ++p) {
		c = getc();		/* read character		*/
		if (do_echo)
34803990:	e59f61dc 	ldr	r6, [pc, #476]	; 34803b74 <load_serial+0x200>
		}
	    }
	}

	/* line too long - truncate */
	*p = '\0';
34803994:	e1a0b005 	mov	fp, r5
	ulong	store_addr;
	ulong	start_addr = ~0;
	ulong	end_addr   =  0;
	int	line_count =  0;

	while (read_record(record, SREC_MAXRECLEN + 1) >= 0) {
34803998:	ea000044 	b	34803ab0 <load_serial+0x13c>
		type = srec_decode (record, &binlen, &addr, binbuf);
3480399c:	e28d0010 	add	r0, sp, #16
348039a0:	e28d1fcf 	add	r1, sp, #828	; 0x33c
348039a4:	e28d2fce 	add	r2, sp, #824	; 0x338
348039a8:	e28d3f86 	add	r3, sp, #536	; 0x218
348039ac:	eb00291b 	bl	3480de20 <srec_decode>

		if (type < 0) {
348039b0:	e3500000 	cmp	r0, #0
348039b4:	ba00006b 	blt	34803b68 <load_serial+0x1f4>
			return (~0);		/* Invalid S-Record		*/
		}

		switch (type) {
348039b8:	e2400001 	sub	r0, r0, #1
348039bc:	e3500008 	cmp	r0, #8
348039c0:	979ff100 	ldrls	pc, [pc, r0, lsl #2]
348039c4:	ea00002e 	b	34803a84 <load_serial+0x110>
348039c8:	348039ec 	.word	0x348039ec
348039cc:	348039ec 	.word	0x348039ec
348039d0:	348039ec 	.word	0x348039ec
348039d4:	34803a84 	.word	0x34803a84
348039d8:	34803a84 	.word	0x34803a84
348039dc:	34803a84 	.word	0x34803a84
348039e0:	34803a28 	.word	0x34803a28
348039e4:	34803a28 	.word	0x34803a28
348039e8:	34803a28 	.word	0x34803a28
		case SREC_DATA2:
		case SREC_DATA3:
		case SREC_DATA4:
		    store_addr = addr + offset;
348039ec:	e59d200c 	ldr	r2, [sp, #12]
348039f0:	e59da338 	ldr	sl, [sp, #824]	; 0x338
				return (~0);
			}
		    } else
#endif
		    {
			memcpy ((char *)(store_addr), binbuf, binlen);
348039f4:	e28d1f86 	add	r1, sp, #536	; 0x218

		switch (type) {
		case SREC_DATA2:
		case SREC_DATA3:
		case SREC_DATA4:
		    store_addr = addr + offset;
348039f8:	e082a00a 	add	sl, r2, sl
				return (~0);
			}
		    } else
#endif
		    {
			memcpy ((char *)(store_addr), binbuf, binlen);
348039fc:	e1a0000a 	mov	r0, sl
34803a00:	e59d233c 	ldr	r2, [sp, #828]	; 0x33c
34803a04:	eb005521 	bl	34818e90 <memcpy>
		    }
		    if ((store_addr) < start_addr)
			start_addr = store_addr;
		    if ((store_addr + binlen - 1) > end_addr)
34803a08:	e59d333c 	ldr	r3, [sp, #828]	; 0x33c
				return (~0);
			}
		    } else
#endif
		    {
			memcpy ((char *)(store_addr), binbuf, binlen);
34803a0c:	e154000a 	cmp	r4, sl
34803a10:	21a0400a 	movcs	r4, sl
		    }
		    if ((store_addr) < start_addr)
			start_addr = store_addr;
		    if ((store_addr + binlen - 1) > end_addr)
34803a14:	e2433001 	sub	r3, r3, #1
34803a18:	e083a00a 	add	sl, r3, sl
34803a1c:	e157000a 	cmp	r7, sl
34803a20:	31a0700a 	movcc	r7, sl
34803a24:	ea000016 	b	34803a84 <load_serial+0x110>
		    break;
		case SREC_END2:
		case SREC_END3:
		case SREC_END4:
		    udelay (10000);
		    size = end_addr - start_addr + 1;
34803a28:	e2875001 	add	r5, r7, #1
34803a2c:	e0645005 	rsb	r5, r4, r5
			end_addr = store_addr + binlen - 1;
		    break;
		case SREC_END2:
		case SREC_END3:
		case SREC_END4:
		    udelay (10000);
34803a30:	e3020710 	movw	r0, #10000	; 0x2710
34803a34:	eb0055a0 	bl	348190bc <udelay>
		    size = end_addr - start_addr + 1;
		    printf ("\n"
34803a38:	e1a03005 	mov	r3, r5
34803a3c:	e1a01004 	mov	r1, r4
34803a40:	e1a02007 	mov	r2, r7
34803a44:	e59f012c 	ldr	r0, [pc, #300]	; 34803b78 <load_serial+0x204>
34803a48:	e58d5000 	str	r5, [sp]
34803a4c:	eb00153e 	bl	34808f4c <printf>
			    "## First Load Addr = 0x%08lX\n"
			    "## Last  Load Addr = 0x%08lX\n"
			    "## Total Size      = 0x%08lX = %ld Bytes\n",
			    start_addr, end_addr, size, size
		    );
		    flush_cache (start_addr, size);
34803a50:	e1a00004 	mov	r0, r4
34803a54:	e1a01005 	mov	r1, r5
		    sprintf(buf, "%lX", size);
34803a58:	e28d4fc6 	add	r4, sp, #792	; 0x318
			    "## First Load Addr = 0x%08lX\n"
			    "## Last  Load Addr = 0x%08lX\n"
			    "## Total Size      = 0x%08lX = %ld Bytes\n",
			    start_addr, end_addr, size, size
		    );
		    flush_cache (start_addr, size);
34803a5c:	ebfff56f 	bl	34801020 <flush_cache>
		    sprintf(buf, "%lX", size);
34803a60:	e59f1114 	ldr	r1, [pc, #276]	; 34803b7c <load_serial+0x208>
34803a64:	e1a02005 	mov	r2, r5
34803a68:	e1a00004 	mov	r0, r4
34803a6c:	eb005907 	bl	34819e90 <sprintf>
		    setenv("filesize", buf);
34803a70:	e59f0108 	ldr	r0, [pc, #264]	; 34803b80 <load_serial+0x20c>
34803a74:	e1a01004 	mov	r1, r4
34803a78:	eb0010e7 	bl	34807e1c <setenv>
		    return (addr);
34803a7c:	e59d0338 	ldr	r0, [sp, #824]	; 0x338
34803a80:	ea000039 	b	34803b6c <load_serial+0x1f8>
		case SREC_START:
		    break;
		default:
		    break;
		}
		if (!do_echo) {	/* print a '.' every 100 lines */
34803a84:	e5963000 	ldr	r3, [r6]
34803a88:	e3530000 	cmp	r3, #0
34803a8c:	1a000007 	bne	34803ab0 <load_serial+0x13c>
			if ((++line_count % 100) == 0)
34803a90:	e2855001 	add	r5, r5, #1
34803a94:	e1a00005 	mov	r0, r5
34803a98:	e3a01064 	mov	r1, #100	; 0x64
34803a9c:	eb00720b 	bl	348202d0 <__aeabi_idivmod>
34803aa0:	e3510000 	cmp	r1, #0
34803aa4:	1a000001 	bne	34803ab0 <load_serial+0x13c>
				putc ('.');
34803aa8:	e3a0002e 	mov	r0, #46	; 0x2e
34803aac:	eb001512 	bl	34808efc <putc>
	ulong	store_addr;
	ulong	start_addr = ~0;
	ulong	end_addr   =  0;
	int	line_count =  0;

	while (read_record(record, SREC_MAXRECLEN + 1) >= 0) {
34803ab0:	e28d3010 	add	r3, sp, #16
34803ab4:	e58d5008 	str	r5, [sp, #8]
34803ab8:	e1a05004 	mov	r5, r4
34803abc:	e1a04003 	mov	r4, r3
	char c;

	--len;	/* always leave room for terminating '\0' byte */

	for (p=buf; p < buf+len; ++p) {
		c = getc();		/* read character		*/
34803ac0:	eb0014fb 	bl	34808eb4 <getc>
		if (do_echo)
34803ac4:	e5963000 	ldr	r3, [r6]
	char c;

	--len;	/* always leave room for terminating '\0' byte */

	for (p=buf; p < buf+len; ++p) {
		c = getc();		/* read character		*/
34803ac8:	e6efa070 	uxtb	sl, r0
		if (do_echo)
34803acc:	e3530000 	cmp	r3, #0
34803ad0:	0a000001 	beq	34803adc <load_serial+0x168>
			putc (c);	/* ... and echo it		*/
34803ad4:	e1a0000a 	mov	r0, sl
34803ad8:	eb001507 	bl	34808efc <putc>

		switch (c) {
34803adc:	e35a0003 	cmp	sl, #3
34803ae0:	0a000020 	beq	34803b68 <load_serial+0x1f4>
34803ae4:	8a000002 	bhi	34803af4 <load_serial+0x180>
34803ae8:	e35a0000 	cmp	sl, #0
34803aec:	0a00001d 	beq	34803b68 <load_serial+0x1f4>
34803af0:	ea00000a 	b	34803b20 <load_serial+0x1ac>
34803af4:	e35a000a 	cmp	sl, #10
34803af8:	0a000001 	beq	34803b04 <load_serial+0x190>
34803afc:	e35a000d 	cmp	sl, #13
34803b00:	1a000006 	bne	34803b20 <load_serial+0x1ac>
34803b04:	e1a03004 	mov	r3, r4
	ulong	store_addr;
	ulong	start_addr = ~0;
	ulong	end_addr   =  0;
	int	line_count =  0;

	while (read_record(record, SREC_MAXRECLEN + 1) >= 0) {
34803b08:	e28d2010 	add	r2, sp, #16
34803b0c:	e1a04005 	mov	r4, r5
34803b10:	e59d5008 	ldr	r5, [sp, #8]
			putc (c);	/* ... and echo it		*/

		switch (c) {
		case '\r':
		case '\n':
			*p = '\0';
34803b14:	e5c3b000 	strb	fp, [r3]
			return (p - buf);
34803b18:	e0623003 	rsb	r3, r2, r3
34803b1c:	ea00000f 	b	34803b60 <load_serial+0x1ec>
		case '\0':
		case 0x03:			/* ^C - Control C		*/
			return (-1);
		default:
			*p = c;
34803b20:	e4c4a001 	strb	sl, [r4], #1
		}

	    /* Check for the console hangup (if any different from serial) */
	    if (gd->jt[XF_getc] != getc) {
34803b24:	e5983054 	ldr	r3, [r8, #84]	; 0x54
34803b28:	e59f2054 	ldr	r2, [pc, #84]	; 34803b84 <load_serial+0x210>
34803b2c:	e5933004 	ldr	r3, [r3, #4]
34803b30:	e1530002 	cmp	r3, r2
34803b34:	0a000002 	beq	34803b44 <load_serial+0x1d0>
		if (ctrlc()) {
34803b38:	eb001528 	bl	34808fe0 <ctrlc>
34803b3c:	e3500000 	cmp	r0, #0
34803b40:	1a000008 	bne	34803b68 <load_serial+0x1f4>
	char *p;
	char c;

	--len;	/* always leave room for terminating '\0' byte */

	for (p=buf; p < buf+len; ++p) {
34803b44:	e1540009 	cmp	r4, r9
34803b48:	1affffdc 	bne	34803ac0 <load_serial+0x14c>
	ulong	store_addr;
	ulong	start_addr = ~0;
	ulong	end_addr   =  0;
	int	line_count =  0;

	while (read_record(record, SREC_MAXRECLEN + 1) >= 0) {
34803b4c:	e28d3010 	add	r3, sp, #16
34803b50:	e1a04005 	mov	r4, r5
	    }
	}

	/* line too long - truncate */
	*p = '\0';
	return (p - buf);
34803b54:	e0633009 	rsb	r3, r3, r9
34803b58:	e59d5008 	ldr	r5, [sp, #8]
		}
	    }
	}

	/* line too long - truncate */
	*p = '\0';
34803b5c:	e5c9b000 	strb	fp, [r9]
	ulong	store_addr;
	ulong	start_addr = ~0;
	ulong	end_addr   =  0;
	int	line_count =  0;

	while (read_record(record, SREC_MAXRECLEN + 1) >= 0) {
34803b60:	e3530000 	cmp	r3, #0
34803b64:	aaffff8c 	bge	3480399c <load_serial+0x28>
			if ((++line_count % 100) == 0)
				putc ('.');
		}
	}

	return (~0);			/* Download aborted		*/
34803b68:	e3e00000 	mvn	r0, #0
}
34803b6c:	e28ddd0d 	add	sp, sp, #832	; 0x340
34803b70:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
34803b74:	348282f4 	.word	0x348282f4
34803b78:	34823cb9 	.word	0x34823cb9
34803b7c:	3482350e 	.word	0x3482350e
34803b80:	34823512 	.word	0x34823512
34803b84:	34808eb4 	.word	0x34808eb4

34803b88 <do_load_serial>:

/* -------------------------------------------------------------------- */

#if defined(CONFIG_CMD_LOADS)
int do_load_serial (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
34803b88:	e92d4038 	push	{r3, r4, r5, lr}
	int load_baudrate, current_baudrate;

	load_baudrate = current_baudrate = gd->baudrate;
#endif

	if (((env_echo = getenv("loads_echo")) != NULL) && (*env_echo == '1')) {
34803b8c:	e59f00b8 	ldr	r0, [pc, #184]	; 34803c4c <do_load_serial+0xc4>

/* -------------------------------------------------------------------- */

#if defined(CONFIG_CMD_LOADS)
int do_load_serial (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
34803b90:	e1a04002 	mov	r4, r2
34803b94:	e1a05003 	mov	r5, r3
	int load_baudrate, current_baudrate;

	load_baudrate = current_baudrate = gd->baudrate;
#endif

	if (((env_echo = getenv("loads_echo")) != NULL) && (*env_echo == '1')) {
34803b98:	eb0011a7 	bl	3480823c <getenv>
34803b9c:	e3500000 	cmp	r0, #0
34803ba0:	0a000003 	beq	34803bb4 <do_load_serial+0x2c>
34803ba4:	e5d03000 	ldrb	r3, [r0]
34803ba8:	e3530031 	cmp	r3, #49	; 0x31
		do_echo = 1;
34803bac:	03a02001 	moveq	r2, #1
	int load_baudrate, current_baudrate;

	load_baudrate = current_baudrate = gd->baudrate;
#endif

	if (((env_echo = getenv("loads_echo")) != NULL) && (*env_echo == '1')) {
34803bb0:	0a000000 	beq	34803bb8 <do_load_serial+0x30>
		do_echo = 1;
	} else {
		do_echo = 0;
34803bb4:	e3a02000 	mov	r2, #0
34803bb8:	e59f3090 	ldr	r3, [pc, #144]	; 34803c50 <do_load_serial+0xc8>
			if (getc() == '\r')
				break;
		}
	}
#else	/* ! CONFIG_SYS_LOADS_BAUD_CHANGE */
	if (argc == 2) {
34803bbc:	e3540002 	cmp	r4, #2
#endif

	if (((env_echo = getenv("loads_echo")) != NULL) && (*env_echo == '1')) {
		do_echo = 1;
	} else {
		do_echo = 0;
34803bc0:	e5832000 	str	r2, [r3]
/* -------------------------------------------------------------------- */

#if defined(CONFIG_CMD_LOADS)
int do_load_serial (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	long offset = 0;
34803bc4:	13a04000 	movne	r4, #0
			if (getc() == '\r')
				break;
		}
	}
#else	/* ! CONFIG_SYS_LOADS_BAUD_CHANGE */
	if (argc == 2) {
34803bc8:	1a000004 	bne	34803be0 <do_load_serial+0x58>
		offset = simple_strtol(argv[1], NULL, 16);
34803bcc:	e5950004 	ldr	r0, [r5, #4]
34803bd0:	e3a01000 	mov	r1, #0
34803bd4:	e3a02010 	mov	r2, #16
34803bd8:	eb00584f 	bl	34819d1c <simple_strtol>
34803bdc:	e1a04000 	mov	r4, r0
	}
#endif	/* CONFIG_SYS_LOADS_BAUD_CHANGE */

	printf ("## Ready for S-Record download ...\n");
34803be0:	e59f006c 	ldr	r0, [pc, #108]	; 34803c54 <do_load_serial+0xcc>
34803be4:	eb0014d8 	bl	34808f4c <printf>

	addr = load_serial (offset);
34803be8:	e1a00004 	mov	r0, r4
34803bec:	ebffff60 	bl	34803974 <load_serial>
34803bf0:	e3a04064 	mov	r4, #100	; 0x64
34803bf4:	e1a05000 	mov	r5, r0
	 * Gather any trailing characters (for instance, the ^D which
	 * is sent by 'cu' after sending a file), and give the
	 * box some time (100 * 1 ms)
	 */
	for (i=0; i<100; ++i) {
		if (tstc()) {
34803bf8:	eb0014b6 	bl	34808ed8 <tstc>
34803bfc:	e3500000 	cmp	r0, #0
34803c00:	0a000000 	beq	34803c08 <do_load_serial+0x80>
			(void) getc();
34803c04:	eb0014aa 	bl	34808eb4 <getc>
		}
		udelay(1000);
34803c08:	e3a00ffa 	mov	r0, #1000	; 0x3e8
34803c0c:	eb00552a 	bl	348190bc <udelay>
	/*
	 * Gather any trailing characters (for instance, the ^D which
	 * is sent by 'cu' after sending a file), and give the
	 * box some time (100 * 1 ms)
	 */
	for (i=0; i<100; ++i) {
34803c10:	e2544001 	subs	r4, r4, #1
34803c14:	1afffff7 	bne	34803bf8 <do_load_serial+0x70>
			(void) getc();
		}
		udelay(1000);
	}

	if (addr == ~0) {
34803c18:	e3750001 	cmn	r5, #1
34803c1c:	1a000003 	bne	34803c30 <do_load_serial+0xa8>
		printf ("## S-Record download aborted\n");
34803c20:	e59f0030 	ldr	r0, [pc, #48]	; 34803c58 <do_load_serial+0xd0>
34803c24:	eb0014c8 	bl	34808f4c <printf>
		rcode = 1;
34803c28:	e3a00001 	mov	r0, #1
34803c2c:	e8bd8038 	pop	{r3, r4, r5, pc}
	} else {
		printf ("## Start Addr      = 0x%08lX\n", addr);
34803c30:	e1a01005 	mov	r1, r5
34803c34:	e59f0020 	ldr	r0, [pc, #32]	; 34803c5c <do_load_serial+0xd4>
34803c38:	eb0014c3 	bl	34808f4c <printf>
		load_addr = addr;
34803c3c:	e59f301c 	ldr	r3, [pc, #28]	; 34803c60 <do_load_serial+0xd8>
{
	long offset = 0;
	ulong addr;
	int i;
	char *env_echo;
	int rcode = 0;
34803c40:	e1a00004 	mov	r0, r4
	if (addr == ~0) {
		printf ("## S-Record download aborted\n");
		rcode = 1;
	} else {
		printf ("## Start Addr      = 0x%08lX\n", addr);
		load_addr = addr;
34803c44:	e5835000 	str	r5, [r3]
				break;
		}
	}
#endif
	return rcode;
}
34803c48:	e8bd8038 	pop	{r3, r4, r5, pc}
34803c4c:	34823d1e 	.word	0x34823d1e
34803c50:	348282f4 	.word	0x348282f4
34803c54:	34823d29 	.word	0x34823d29
34803c58:	34823d4d 	.word	0x34823d4d
34803c5c:	34823d6b 	.word	0x34823d6b
34803c60:	348283c4 	.word	0x348283c4

34803c64 <send_pad>:

	return offset;
}

void send_pad (void)
{
34803c64:	e92d4038 	push	{r3, r4, r5, lr}
34803c68:	e59f501c 	ldr	r5, [pc, #28]	; 34803c8c <send_pad+0x28>
34803c6c:	e595400c 	ldr	r4, [r5, #12]
	int count = his_pad_count;

	while (count-- > 0)
34803c70:	ea000002 	b	34803c80 <send_pad+0x1c>
		putc (his_pad_char);
34803c74:	e5d50010 	ldrb	r0, [r5, #16]
34803c78:	eb00149f 	bl	34808efc <putc>
34803c7c:	e2444001 	sub	r4, r4, #1

void send_pad (void)
{
	int count = his_pad_count;

	while (count-- > 0)
34803c80:	e3540000 	cmp	r4, #0
34803c84:	cafffffa 	bgt	34803c74 <send_pad+0x10>
		putc (his_pad_char);
}
34803c88:	e8bd8038 	pop	{r3, r4, r5, pc}
34803c8c:	348291ac 	.word	0x348291ac

34803c90 <ktrans>:

/* converts escaped kermit char to binary char */
char ktrans (char in)
{
	if ((in & 0x60) == 0x40) {
34803c90:	e2003060 	and	r3, r0, #96	; 0x60
34803c94:	e3530040 	cmp	r3, #64	; 0x40
		return (char) (in & ~0x40);
34803c98:	020000bf 	andeq	r0, r0, #191	; 0xbf
}

/* converts escaped kermit char to binary char */
char ktrans (char in)
{
	if ((in & 0x60) == 0x40) {
34803c9c:	012fff1e 	bxeq	lr
		return (char) (in & ~0x40);
	} else if ((in & 0x7f) == 0x3f) {
34803ca0:	e200307f 	and	r3, r0, #127	; 0x7f
34803ca4:	e353003f 	cmp	r3, #63	; 0x3f
		return (char) (in | 0x40);
34803ca8:	03800040 	orreq	r0, r0, #64	; 0x40
	} else
		return in;
}
34803cac:	e12fff1e 	bx	lr

34803cb0 <chk1>:

int chk1 (char *buffer)
{
	int total = 0;
34803cb0:	e3a03000 	mov	r3, #0

	while (*buffer) {
34803cb4:	ea000000 	b	34803cbc <chk1+0xc>
		total += *buffer++;
34803cb8:	e0833002 	add	r3, r3, r2

int chk1 (char *buffer)
{
	int total = 0;

	while (*buffer) {
34803cbc:	e4d02001 	ldrb	r2, [r0], #1
34803cc0:	e3520000 	cmp	r2, #0
34803cc4:	1afffffb 	bne	34803cb8 <chk1+0x8>
		total += *buffer++;
	}
	return (int) ((total + ((total >> 6) & 0x03)) & 0x3f);
34803cc8:	e7e12353 	ubfx	r2, r3, #6, #2
34803ccc:	e0823003 	add	r3, r2, r3
}
34803cd0:	e203003f 	and	r0, r3, #63	; 0x3f
34803cd4:	e12fff1e 	bx	lr

34803cd8 <s1_sendpacket>:

void s1_sendpacket (char *packet)
{
34803cd8:	e92d4010 	push	{r4, lr}
34803cdc:	e1a04000 	mov	r4, r0
	send_pad ();
34803ce0:	ebffffdf 	bl	34803c64 <send_pad>
	while (*packet) {
34803ce4:	ea000000 	b	34803cec <s1_sendpacket+0x14>
		putc (*packet++);
34803ce8:	eb001483 	bl	34808efc <putc>
}

void s1_sendpacket (char *packet)
{
	send_pad ();
	while (*packet) {
34803cec:	e4d40001 	ldrb	r0, [r4], #1
34803cf0:	e3500000 	cmp	r0, #0
34803cf4:	1afffffb 	bne	34803ce8 <s1_sendpacket+0x10>
		putc (*packet++);
	}
}
34803cf8:	e8bd8010 	pop	{r4, pc}

34803cfc <send_ack>:

static char a_b[24];
void send_ack (int n)
{
34803cfc:	e92d4070 	push	{r4, r5, r6, lr}
	a_b[0] = START_CHAR;
34803d00:	e59f404c 	ldr	r4, [pc, #76]	; 34803d54 <send_ack+0x58>
34803d04:	e3a03001 	mov	r3, #1
34803d08:	e5c43014 	strb	r3, [r4, #20]
	a_b[1] = tochar (3);
	a_b[2] = tochar (n);
34803d0c:	e2800020 	add	r0, r0, #32

static char a_b[24];
void send_ack (int n)
{
	a_b[0] = START_CHAR;
	a_b[1] = tochar (3);
34803d10:	e2833022 	add	r3, r3, #34	; 0x22
34803d14:	e5c43015 	strb	r3, [r4, #21]
	a_b[2] = tochar (n);
34803d18:	e5c40016 	strb	r0, [r4, #22]
	a_b[3] = ACK_TYPE;
34803d1c:	e2833036 	add	r3, r3, #54	; 0x36
	a_b[4] = '\0';
34803d20:	e3a05000 	mov	r5, #0
	a_b[4] = tochar (chk1 (&a_b[1]));
34803d24:	e2840015 	add	r0, r4, #21
void send_ack (int n)
{
	a_b[0] = START_CHAR;
	a_b[1] = tochar (3);
	a_b[2] = tochar (n);
	a_b[3] = ACK_TYPE;
34803d28:	e5c43017 	strb	r3, [r4, #23]
	a_b[4] = '\0';
34803d2c:	e5c45018 	strb	r5, [r4, #24]
	a_b[4] = tochar (chk1 (&a_b[1]));
34803d30:	ebffffde 	bl	34803cb0 <chk1>
34803d34:	e2800020 	add	r0, r0, #32
34803d38:	e5c40018 	strb	r0, [r4, #24]
	a_b[5] = his_eol;
34803d3c:	e5d4302c 	ldrb	r3, [r4, #44]	; 0x2c
	a_b[6] = '\0';
	s1_sendpacket (a_b);
34803d40:	e59f0010 	ldr	r0, [pc, #16]	; 34803d58 <send_ack+0x5c>
	a_b[1] = tochar (3);
	a_b[2] = tochar (n);
	a_b[3] = ACK_TYPE;
	a_b[4] = '\0';
	a_b[4] = tochar (chk1 (&a_b[1]));
	a_b[5] = his_eol;
34803d44:	e5c43019 	strb	r3, [r4, #25]
	a_b[6] = '\0';
34803d48:	e5c4501a 	strb	r5, [r4, #26]
	s1_sendpacket (a_b);
}
34803d4c:	e8bd4070 	pop	{r4, r5, r6, lr}
	a_b[3] = ACK_TYPE;
	a_b[4] = '\0';
	a_b[4] = tochar (chk1 (&a_b[1]));
	a_b[5] = his_eol;
	a_b[6] = '\0';
	s1_sendpacket (a_b);
34803d50:	eaffffe0 	b	34803cd8 <s1_sendpacket>
34803d54:	348291ac 	.word	0x348291ac
34803d58:	348291c0 	.word	0x348291c0

34803d5c <send_nack>:
}

void send_nack (int n)
{
34803d5c:	e92d4070 	push	{r4, r5, r6, lr}
	a_b[0] = START_CHAR;
34803d60:	e59f404c 	ldr	r4, [pc, #76]	; 34803db4 <send_nack+0x58>
34803d64:	e3a03001 	mov	r3, #1
34803d68:	e5c43014 	strb	r3, [r4, #20]
	a_b[1] = tochar (3);
	a_b[2] = tochar (n);
34803d6c:	e2800020 	add	r0, r0, #32
}

void send_nack (int n)
{
	a_b[0] = START_CHAR;
	a_b[1] = tochar (3);
34803d70:	e2833022 	add	r3, r3, #34	; 0x22
34803d74:	e5c43015 	strb	r3, [r4, #21]
	a_b[2] = tochar (n);
34803d78:	e5c40016 	strb	r0, [r4, #22]
	a_b[3] = NACK_TYPE;
34803d7c:	e283302b 	add	r3, r3, #43	; 0x2b
	a_b[4] = '\0';
34803d80:	e3a05000 	mov	r5, #0
	a_b[4] = tochar (chk1 (&a_b[1]));
34803d84:	e2840015 	add	r0, r4, #21
void send_nack (int n)
{
	a_b[0] = START_CHAR;
	a_b[1] = tochar (3);
	a_b[2] = tochar (n);
	a_b[3] = NACK_TYPE;
34803d88:	e5c43017 	strb	r3, [r4, #23]
	a_b[4] = '\0';
34803d8c:	e5c45018 	strb	r5, [r4, #24]
	a_b[4] = tochar (chk1 (&a_b[1]));
34803d90:	ebffffc6 	bl	34803cb0 <chk1>
34803d94:	e2800020 	add	r0, r0, #32
34803d98:	e5c40018 	strb	r0, [r4, #24]
	a_b[5] = his_eol;
34803d9c:	e5d4302c 	ldrb	r3, [r4, #44]	; 0x2c
	a_b[6] = '\0';
	s1_sendpacket (a_b);
34803da0:	e59f0010 	ldr	r0, [pc, #16]	; 34803db8 <send_nack+0x5c>
	a_b[1] = tochar (3);
	a_b[2] = tochar (n);
	a_b[3] = NACK_TYPE;
	a_b[4] = '\0';
	a_b[4] = tochar (chk1 (&a_b[1]));
	a_b[5] = his_eol;
34803da4:	e5c43019 	strb	r3, [r4, #25]
	a_b[6] = '\0';
34803da8:	e5c4501a 	strb	r5, [r4, #26]
	s1_sendpacket (a_b);
}
34803dac:	e8bd4070 	pop	{r4, r5, r6, lr}
	a_b[3] = NACK_TYPE;
	a_b[4] = '\0';
	a_b[4] = tochar (chk1 (&a_b[1]));
	a_b[5] = his_eol;
	a_b[6] = '\0';
	s1_sendpacket (a_b);
34803db0:	eaffffc8 	b	34803cd8 <s1_sendpacket>
34803db4:	348291ac 	.word	0x348291ac
34803db8:	348291c0 	.word	0x348291c0

34803dbc <k_data_init>:


/* k_data_* simply handles the kermit escape translations */
static int k_data_escape, k_data_escape_saved;
void k_data_init (void)
{
34803dbc:	e92d4008 	push	{r3, lr}
	k_data_escape = 0;
34803dc0:	e59f3010 	ldr	r3, [pc, #16]	; 34803dd8 <k_data_init+0x1c>
34803dc4:	e3a02000 	mov	r2, #0
34803dc8:	e5832030 	str	r2, [r3, #48]	; 0x30
	os_data_init ();
34803dcc:	e5933034 	ldr	r3, [r3, #52]	; 0x34
34803dd0:	e12fff33 	blx	r3
}
34803dd4:	e8bd8008 	pop	{r3, pc}
34803dd8:	348291ac 	.word	0x348291ac

34803ddc <k_data_save>:

void k_data_save (void)
{
	k_data_escape_saved = k_data_escape;
34803ddc:	e59f3018 	ldr	r3, [pc, #24]	; 34803dfc <k_data_save+0x20>
34803de0:	e5932030 	ldr	r2, [r3, #48]	; 0x30
34803de4:	e5832038 	str	r2, [r3, #56]	; 0x38
	os_data_addr = bin_start_address;
}

static void os_data_save (void)
{
	os_data_state_saved = os_data_state;
34803de8:	e5932000 	ldr	r2, [r3]
34803dec:	e583203c 	str	r2, [r3, #60]	; 0x3c
	os_data_addr_saved = os_data_addr;
34803df0:	e5932004 	ldr	r2, [r3, #4]
34803df4:	e5832040 	str	r2, [r3, #64]	; 0x40

void k_data_save (void)
{
	k_data_escape_saved = k_data_escape;
	os_data_save ();
}
34803df8:	e12fff1e 	bx	lr
34803dfc:	348291ac 	.word	0x348291ac

34803e00 <k_data_restore>:

void k_data_restore (void)
{
	k_data_escape = k_data_escape_saved;
34803e00:	e59f3018 	ldr	r3, [pc, #24]	; 34803e20 <k_data_restore+0x20>
34803e04:	e5932038 	ldr	r2, [r3, #56]	; 0x38
34803e08:	e5832030 	str	r2, [r3, #48]	; 0x30
	os_data_addr_saved = os_data_addr;
}

static void os_data_restore (void)
{
	os_data_state = os_data_state_saved;
34803e0c:	e593203c 	ldr	r2, [r3, #60]	; 0x3c
34803e10:	e5832000 	str	r2, [r3]
	os_data_addr = os_data_addr_saved;
34803e14:	e5932040 	ldr	r2, [r3, #64]	; 0x40
34803e18:	e5832004 	str	r2, [r3, #4]

void k_data_restore (void)
{
	k_data_escape = k_data_escape_saved;
	os_data_restore ();
}
34803e1c:	e12fff1e 	bx	lr
34803e20:	348291ac 	.word	0x348291ac

34803e24 <k_data_char>:

void k_data_char (char new_char)
{
34803e24:	e92d4010 	push	{r4, lr}
	if (k_data_escape) {
34803e28:	e59f4040 	ldr	r4, [pc, #64]	; 34803e70 <k_data_char+0x4c>
34803e2c:	e5942030 	ldr	r2, [r4, #48]	; 0x30
34803e30:	e3520000 	cmp	r2, #0
34803e34:	0a000004 	beq	34803e4c <k_data_char+0x28>
		/* last char was escape - translate this character */
		os_data_char (ktrans (new_char));
34803e38:	ebffff94 	bl	34803c90 <ktrans>
34803e3c:	e5943044 	ldr	r3, [r4, #68]	; 0x44
34803e40:	e12fff33 	blx	r3
		k_data_escape = 0;
34803e44:	e3a03000 	mov	r3, #0
34803e48:	ea000003 	b	34803e5c <k_data_char+0x38>
	} else {
		if (new_char == his_quote) {
34803e4c:	e5d42048 	ldrb	r2, [r4, #72]	; 0x48
34803e50:	e1520000 	cmp	r2, r0
34803e54:	1a000002 	bne	34803e64 <k_data_char+0x40>
			/* this char is escape - remember */
			k_data_escape = 1;
34803e58:	e3a03001 	mov	r3, #1
34803e5c:	e5843030 	str	r3, [r4, #48]	; 0x30
34803e60:	e8bd8010 	pop	{r4, pc}
		} else {
			/* otherwise send this char as-is */
			os_data_char (new_char);
34803e64:	e5943044 	ldr	r3, [r4, #68]	; 0x44
34803e68:	e12fff33 	blx	r3
34803e6c:	e8bd8010 	pop	{r4, pc}
34803e70:	348291ac 	.word	0x348291ac

34803e74 <handle_send_packet>:
{
	int length = 3;
	int bytes;

	/* initialize some protocol parameters */
	his_eol = END_CHAR;		/* default end of line character */
34803e74:	e59f31b8 	ldr	r3, [pc, #440]	; 34804034 <handle_send_packet+0x1c0>
34803e78:	e3a0200d 	mov	r2, #13
char *send_ptr;

/* handle_send_packet interprits the protocol info and builds and
   sends an appropriate ack for what we can do */
void handle_send_packet (int n)
{
34803e7c:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
	int length = 3;
	int bytes;

	/* initialize some protocol parameters */
	his_eol = END_CHAR;		/* default end of line character */
34803e80:	e5c3202c 	strb	r2, [r3, #44]	; 0x2c
	his_pad_count = 0;
34803e84:	e3a02000 	mov	r2, #0
	his_pad_char = '\0';
	his_quote = K_ESCAPE;

	/* ignore last character if it filled the buffer */
	if (send_ptr == &send_parms[SEND_DATA_SIZE - 1])
34803e88:	e593104c 	ldr	r1, [r3, #76]	; 0x4c
	int length = 3;
	int bytes;

	/* initialize some protocol parameters */
	his_eol = END_CHAR;		/* default end of line character */
	his_pad_count = 0;
34803e8c:	e583200c 	str	r2, [r3, #12]
	his_pad_char = '\0';
34803e90:	e5c32010 	strb	r2, [r3, #16]
	his_quote = K_ESCAPE;
34803e94:	e2822023 	add	r2, r2, #35	; 0x23
34803e98:	e5c32048 	strb	r2, [r3, #72]	; 0x48

	/* ignore last character if it filled the buffer */
	if (send_ptr == &send_parms[SEND_DATA_SIZE - 1])
34803e9c:	e2832063 	add	r2, r3, #99	; 0x63
34803ea0:	e1510002 	cmp	r1, r2
		--send_ptr;
34803ea4:	02832062 	addeq	r2, r3, #98	; 0x62
	bytes = send_ptr - send_parms;	/* how many bytes we'll process */
34803ea8:	e59f4184 	ldr	r4, [pc, #388]	; 34804034 <handle_send_packet+0x1c0>
	his_pad_char = '\0';
	his_quote = K_ESCAPE;

	/* ignore last character if it filled the buffer */
	if (send_ptr == &send_parms[SEND_DATA_SIZE - 1])
		--send_ptr;
34803eac:	0583204c 	streq	r2, [r3, #76]	; 0x4c
	bytes = send_ptr - send_parms;	/* how many bytes we'll process */
34803eb0:	e594504c 	ldr	r5, [r4, #76]	; 0x4c
34803eb4:	e2843050 	add	r3, r4, #80	; 0x50
34803eb8:	e0635005 	rsb	r5, r3, r5
	do {
		if (bytes-- <= 0)
34803ebc:	e3550000 	cmp	r5, #0
char *send_ptr;

/* handle_send_packet interprits the protocol info and builds and
   sends an appropriate ack for what we can do */
void handle_send_packet (int n)
{
34803ec0:	e1a07000 	mov	r7, r0
	int length = 3;
34803ec4:	d3a06003 	movle	r6, #3
	/* ignore last character if it filled the buffer */
	if (send_ptr == &send_parms[SEND_DATA_SIZE - 1])
		--send_ptr;
	bytes = send_ptr - send_parms;	/* how many bytes we'll process */
	do {
		if (bytes-- <= 0)
34803ec8:	da000040 	ble	34803fd0 <handle_send_packet+0x15c>
			break;
		/* handle MAXL - max length */
		/* ignore what he says - most I'll take (here) is 94 */
		a_b[++length] = tochar (94);
34803ecc:	e3a0307e 	mov	r3, #126	; 0x7e
		if (bytes-- <= 0)
34803ed0:	e2555001 	subs	r5, r5, #1
	do {
		if (bytes-- <= 0)
			break;
		/* handle MAXL - max length */
		/* ignore what he says - most I'll take (here) is 94 */
		a_b[++length] = tochar (94);
34803ed4:	e5c43018 	strb	r3, [r4, #24]
34803ed8:	03a06004 	moveq	r6, #4
		if (bytes-- <= 0)
34803edc:	0a00003b 	beq	34803fd0 <handle_send_packet+0x15c>
			break;
		/* handle TIME - time you should wait for my packets */
		/* ignore what he says - don't wait for my ack longer than 1 second */
		a_b[++length] = tochar (1);
34803ee0:	e3a03021 	mov	r3, #33	; 0x21
		if (bytes-- <= 0)
34803ee4:	e2555001 	subs	r5, r5, #1
		a_b[++length] = tochar (94);
		if (bytes-- <= 0)
			break;
		/* handle TIME - time you should wait for my packets */
		/* ignore what he says - don't wait for my ack longer than 1 second */
		a_b[++length] = tochar (1);
34803ee8:	e5c43019 	strb	r3, [r4, #25]
34803eec:	03a06005 	moveq	r6, #5
		if (bytes-- <= 0)
34803ef0:	0a000036 	beq	34803fd0 <handle_send_packet+0x15c>
			break;
		/* handle NPAD - number of pad chars I need */
		/* remember what he says - I need none */
		his_pad_count = untochar (send_parms[2]);
34803ef4:	e5d43052 	ldrb	r3, [r4, #82]	; 0x52
		a_b[++length] = tochar (0);
		if (bytes-- <= 0)
34803ef8:	e2555001 	subs	r5, r5, #1
		a_b[++length] = tochar (1);
		if (bytes-- <= 0)
			break;
		/* handle NPAD - number of pad chars I need */
		/* remember what he says - I need none */
		his_pad_count = untochar (send_parms[2]);
34803efc:	e2433020 	sub	r3, r3, #32
34803f00:	e20330ff 	and	r3, r3, #255	; 0xff
34803f04:	e584300c 	str	r3, [r4, #12]
		a_b[++length] = tochar (0);
34803f08:	e3a03020 	mov	r3, #32
34803f0c:	e5c4301a 	strb	r3, [r4, #26]
34803f10:	03a06006 	moveq	r6, #6
		if (bytes-- <= 0)
34803f14:	0a00002d 	beq	34803fd0 <handle_send_packet+0x15c>
			break;
		/* handle PADC - pad chars I need */
		/* remember what he says - I need none */
		his_pad_char = ktrans (send_parms[3]);
34803f18:	e5d40053 	ldrb	r0, [r4, #83]	; 0x53
34803f1c:	ebffff5b 	bl	34803c90 <ktrans>
			break;
		/* handle NPAD - number of pad chars I need */
		/* remember what he says - I need none */
		his_pad_count = untochar (send_parms[2]);
		a_b[++length] = tochar (0);
		if (bytes-- <= 0)
34803f20:	e2455001 	sub	r5, r5, #1
			break;
		/* handle PADC - pad chars I need */
		/* remember what he says - I need none */
		his_pad_char = ktrans (send_parms[3]);
		a_b[++length] = 0x40;	/* He should ignore this */
34803f24:	e3a03040 	mov	r3, #64	; 0x40
		if (bytes-- <= 0)
34803f28:	e3550000 	cmp	r5, #0
		a_b[++length] = tochar (0);
		if (bytes-- <= 0)
			break;
		/* handle PADC - pad chars I need */
		/* remember what he says - I need none */
		his_pad_char = ktrans (send_parms[3]);
34803f2c:	e5c40010 	strb	r0, [r4, #16]
		a_b[++length] = 0x40;	/* He should ignore this */
34803f30:	e5c4301b 	strb	r3, [r4, #27]
34803f34:	03a06007 	moveq	r6, #7
		if (bytes-- <= 0)
34803f38:	0a000024 	beq	34803fd0 <handle_send_packet+0x15c>
			break;
		/* handle EOL - end of line he needs */
		/* remember what he says - I need CR */
		his_eol = untochar (send_parms[4]);
34803f3c:	e5d43054 	ldrb	r3, [r4, #84]	; 0x54
		a_b[++length] = tochar (END_CHAR);
		if (bytes-- <= 0)
34803f40:	e2555001 	subs	r5, r5, #1
		a_b[++length] = 0x40;	/* He should ignore this */
		if (bytes-- <= 0)
			break;
		/* handle EOL - end of line he needs */
		/* remember what he says - I need CR */
		his_eol = untochar (send_parms[4]);
34803f44:	e2433020 	sub	r3, r3, #32
34803f48:	e5c4302c 	strb	r3, [r4, #44]	; 0x2c
		a_b[++length] = tochar (END_CHAR);
34803f4c:	e3a0302d 	mov	r3, #45	; 0x2d
34803f50:	e5c4301c 	strb	r3, [r4, #28]
34803f54:	03a06008 	moveq	r6, #8
		if (bytes-- <= 0)
34803f58:	0a00001c 	beq	34803fd0 <handle_send_packet+0x15c>
			break;
		/* handle QCTL - quote control char he'll use */
		/* remember what he says - I'll use '#' */
		his_quote = send_parms[5];
34803f5c:	e5d43055 	ldrb	r3, [r4, #85]	; 0x55
		a_b[++length] = '#';
		if (bytes-- <= 0)
34803f60:	e2555001 	subs	r5, r5, #1
		a_b[++length] = tochar (END_CHAR);
		if (bytes-- <= 0)
			break;
		/* handle QCTL - quote control char he'll use */
		/* remember what he says - I'll use '#' */
		his_quote = send_parms[5];
34803f64:	e5c43048 	strb	r3, [r4, #72]	; 0x48
		a_b[++length] = '#';
34803f68:	e3a03023 	mov	r3, #35	; 0x23
34803f6c:	e5c4301d 	strb	r3, [r4, #29]
34803f70:	03a06009 	moveq	r6, #9
		if (bytes-- <= 0)
34803f74:	0a000015 	beq	34803fd0 <handle_send_packet+0x15c>
			break;
		/* handle QBIN - 8-th bit prefixing */
		/* ignore what he says - I refuse */
		a_b[++length] = 'N';
34803f78:	e283302b 	add	r3, r3, #43	; 0x2b
		if (bytes-- <= 0)
34803f7c:	e2555001 	subs	r5, r5, #1
		a_b[++length] = '#';
		if (bytes-- <= 0)
			break;
		/* handle QBIN - 8-th bit prefixing */
		/* ignore what he says - I refuse */
		a_b[++length] = 'N';
34803f80:	e5c4301e 	strb	r3, [r4, #30]
34803f84:	03a0600a 	moveq	r6, #10
		if (bytes-- <= 0)
34803f88:	0a000010 	beq	34803fd0 <handle_send_packet+0x15c>
			break;
		/* handle CHKT - the clock check type */
		/* ignore what he says - I do type 1 (for now) */
		a_b[++length] = '1';
34803f8c:	e3a02031 	mov	r2, #49	; 0x31
		if (bytes-- <= 0)
34803f90:	e2555001 	subs	r5, r5, #1
		a_b[++length] = 'N';
		if (bytes-- <= 0)
			break;
		/* handle CHKT - the clock check type */
		/* ignore what he says - I do type 1 (for now) */
		a_b[++length] = '1';
34803f94:	e5c4201f 	strb	r2, [r4, #31]
34803f98:	03a0600b 	moveq	r6, #11
		if (bytes-- <= 0)
34803f9c:	0a00000b 	beq	34803fd0 <handle_send_packet+0x15c>
			break;
		/* handle REPT - the repeat prefix */
		/* ignore what he says - I refuse (for now) */
		a_b[++length] = 'N';
		if (bytes-- <= 0)
34803fa0:	e3550001 	cmp	r5, #1
		a_b[++length] = '1';
		if (bytes-- <= 0)
			break;
		/* handle REPT - the repeat prefix */
		/* ignore what he says - I refuse (for now) */
		a_b[++length] = 'N';
34803fa4:	e5c43020 	strb	r3, [r4, #32]
34803fa8:	03a0600c 	moveq	r6, #12
		if (bytes-- <= 0)
34803fac:	0a000007 	beq	34803fd0 <handle_send_packet+0x15c>
			break;
		/* handle CAPAS - the capabilities mask */
		/* ignore what he says - I only do long packets - I don't do windows */
		a_b[++length] = tochar (2);	/* only long packets */
34803fb0:	e3a02022 	mov	r2, #34	; 0x22
34803fb4:	e5c42021 	strb	r2, [r4, #33]	; 0x21
		a_b[++length] = tochar (0);	/* no windows */
34803fb8:	e3a02020 	mov	r2, #32
34803fbc:	e5c42022 	strb	r2, [r4, #34]	; 0x22
		a_b[++length] = tochar (94);	/* large packet msb */
34803fc0:	e282205e 	add	r2, r2, #94	; 0x5e
34803fc4:	e5c42023 	strb	r2, [r4, #35]	; 0x23
		a_b[++length] = tochar (94);	/* large packet lsb */
34803fc8:	e5c42024 	strb	r2, [r4, #36]	; 0x24
34803fcc:	e3a06010 	mov	r6, #16
	} while (0);

	a_b[0] = START_CHAR;
34803fd0:	e59f405c 	ldr	r4, [pc, #92]	; 34804034 <handle_send_packet+0x1c0>
34803fd4:	e3a03001 	mov	r3, #1
34803fd8:	e5c43014 	strb	r3, [r4, #20]
	a_b[1] = tochar (length);
	a_b[2] = tochar (n);
34803fdc:	e2877020 	add	r7, r7, #32
		a_b[++length] = tochar (94);	/* large packet msb */
		a_b[++length] = tochar (94);	/* large packet lsb */
	} while (0);

	a_b[0] = START_CHAR;
	a_b[1] = tochar (length);
34803fe0:	e2863020 	add	r3, r6, #32
	a_b[2] = tochar (n);
	a_b[3] = ACK_TYPE;
	a_b[++length] = '\0';
34803fe4:	e2866001 	add	r6, r6, #1
		a_b[++length] = tochar (94);	/* large packet msb */
		a_b[++length] = tochar (94);	/* large packet lsb */
	} while (0);

	a_b[0] = START_CHAR;
	a_b[1] = tochar (length);
34803fe8:	e5c43015 	strb	r3, [r4, #21]
	a_b[2] = tochar (n);
34803fec:	e5c47016 	strb	r7, [r4, #22]
	a_b[3] = ACK_TYPE;
34803ff0:	e3a03059 	mov	r3, #89	; 0x59
	a_b[++length] = '\0';
34803ff4:	e0847006 	add	r7, r4, r6
34803ff8:	e3a05000 	mov	r5, #0
	} while (0);

	a_b[0] = START_CHAR;
	a_b[1] = tochar (length);
	a_b[2] = tochar (n);
	a_b[3] = ACK_TYPE;
34803ffc:	e5c43017 	strb	r3, [r4, #23]
	a_b[++length] = '\0';
	a_b[length] = tochar (chk1 (&a_b[1]));
34804000:	e2840015 	add	r0, r4, #21

	a_b[0] = START_CHAR;
	a_b[1] = tochar (length);
	a_b[2] = tochar (n);
	a_b[3] = ACK_TYPE;
	a_b[++length] = '\0';
34804004:	e5c75014 	strb	r5, [r7, #20]
	a_b[length] = tochar (chk1 (&a_b[1]));
34804008:	ebffff28 	bl	34803cb0 <chk1>
	a_b[++length] = his_eol;
3480400c:	e2866001 	add	r6, r6, #1
	a_b[0] = START_CHAR;
	a_b[1] = tochar (length);
	a_b[2] = tochar (n);
	a_b[3] = ACK_TYPE;
	a_b[++length] = '\0';
	a_b[length] = tochar (chk1 (&a_b[1]));
34804010:	e2800020 	add	r0, r0, #32
	a_b[++length] = his_eol;
34804014:	e5d4302c 	ldrb	r3, [r4, #44]	; 0x2c
	a_b[0] = START_CHAR;
	a_b[1] = tochar (length);
	a_b[2] = tochar (n);
	a_b[3] = ACK_TYPE;
	a_b[++length] = '\0';
	a_b[length] = tochar (chk1 (&a_b[1]));
34804018:	e5c70014 	strb	r0, [r7, #20]
	a_b[++length] = his_eol;
3480401c:	e0846006 	add	r6, r4, r6
	a_b[++length] = '\0';
	s1_sendpacket (a_b);
34804020:	e2840014 	add	r0, r4, #20
	a_b[1] = tochar (length);
	a_b[2] = tochar (n);
	a_b[3] = ACK_TYPE;
	a_b[++length] = '\0';
	a_b[length] = tochar (chk1 (&a_b[1]));
	a_b[++length] = his_eol;
34804024:	e5c63014 	strb	r3, [r6, #20]
	a_b[++length] = '\0';
34804028:	e5c65015 	strb	r5, [r6, #21]
	s1_sendpacket (a_b);
}
3480402c:	e8bd41f0 	pop	{r4, r5, r6, r7, r8, lr}
	a_b[3] = ACK_TYPE;
	a_b[++length] = '\0';
	a_b[length] = tochar (chk1 (&a_b[1]));
	a_b[++length] = his_eol;
	a_b[++length] = '\0';
	s1_sendpacket (a_b);
34804030:	eaffff28 	b	34803cd8 <s1_sendpacket>
34804034:	348291ac 	.word	0x348291ac

34804038 <do_load_serial_bin>:
int  his_pad_count;  /* number of pad chars he needs */
char his_pad_char;   /* pad chars he needs */
char his_quote;      /* quote chars he'll use */

int do_load_serial_bin (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
34804038:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}

	/* pre-set offset from CONFIG_SYS_LOAD_ADDR */
	offset = CONFIG_SYS_LOAD_ADDR;

	/* pre-set offset from $loadaddr */
	if ((s = getenv("loadaddr")) != NULL) {
3480403c:	e59f0404 	ldr	r0, [pc, #1028]	; 34804448 <do_load_serial_bin+0x410>
int  his_pad_count;  /* number of pad chars he needs */
char his_pad_char;   /* pad chars he needs */
char his_quote;      /* quote chars he'll use */

int do_load_serial_bin (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
34804040:	e24dd028 	sub	sp, sp, #40	; 0x28
34804044:	e1a05002 	mov	r5, r2
34804048:	e1a06003 	mov	r6, r3

	/* pre-set offset from CONFIG_SYS_LOAD_ADDR */
	offset = CONFIG_SYS_LOAD_ADDR;

	/* pre-set offset from $loadaddr */
	if ((s = getenv("loadaddr")) != NULL) {
3480404c:	eb00107a 	bl	3480823c <getenv>
34804050:	e3500000 	cmp	r0, #0
	int load_baudrate, current_baudrate;
	int rcode = 0;
	char *s;

	/* pre-set offset from CONFIG_SYS_LOAD_ADDR */
	offset = CONFIG_SYS_LOAD_ADDR;
34804054:	03a04309 	moveq	r4, #603979776	; 0x24000000

	/* pre-set offset from $loadaddr */
	if ((s = getenv("loadaddr")) != NULL) {
34804058:	0a000003 	beq	3480406c <do_load_serial_bin+0x34>
		offset = simple_strtoul(s, NULL, 16);
3480405c:	e3a01000 	mov	r1, #0
34804060:	e3a02010 	mov	r2, #16
34804064:	eb0056e3 	bl	34819bf8 <simple_strtoul>
34804068:	e1a04000 	mov	r4, r0
	}

	load_baudrate = current_baudrate = gd->baudrate;

	if (argc >= 2) {
3480406c:	e3550001 	cmp	r5, #1
	/* pre-set offset from $loadaddr */
	if ((s = getenv("loadaddr")) != NULL) {
		offset = simple_strtoul(s, NULL, 16);
	}

	load_baudrate = current_baudrate = gd->baudrate;
34804070:	e5987008 	ldr	r7, [r8, #8]

	if (argc >= 2) {
34804074:	da0000eb 	ble	34804428 <do_load_serial_bin+0x3f0>
		offset = simple_strtoul(argv[1], NULL, 16);
34804078:	e5960004 	ldr	r0, [r6, #4]
3480407c:	e3a01000 	mov	r1, #0
34804080:	e3a02010 	mov	r2, #16
34804084:	eb0056db 	bl	34819bf8 <simple_strtoul>
	}
	if (argc == 3) {
34804088:	e3550003 	cmp	r5, #3
	}

	load_baudrate = current_baudrate = gd->baudrate;

	if (argc >= 2) {
		offset = simple_strtoul(argv[1], NULL, 16);
3480408c:	e1a04000 	mov	r4, r0
	}
	if (argc == 3) {
34804090:	1a0000e4 	bne	34804428 <do_load_serial_bin+0x3f0>
		load_baudrate = (int)simple_strtoul(argv[2], NULL, 10);
34804094:	e5960008 	ldr	r0, [r6, #8]
34804098:	e3a01000 	mov	r1, #0
3480409c:	e3a0200a 	mov	r2, #10
348040a0:	eb0056d4 	bl	34819bf8 <simple_strtoul>

		/* default to current baudrate */
		if (load_baudrate == 0)
348040a4:	e2505000 	subs	r5, r0, #0
348040a8:	0a0000de 	beq	34804428 <do_load_serial_bin+0x3f0>
			load_baudrate = current_baudrate;
	}

	if (load_baudrate != current_baudrate) {
348040ac:	e1550007 	cmp	r5, r7
348040b0:	0a00000b 	beq	348040e4 <do_load_serial_bin+0xac>
		printf ("## Switch baudrate to %d bps and press ENTER ...\n",
348040b4:	e1a01005 	mov	r1, r5
348040b8:	e59f038c 	ldr	r0, [pc, #908]	; 3480444c <do_load_serial_bin+0x414>
348040bc:	eb0013a2 	bl	34808f4c <printf>
			load_baudrate);
		udelay(50000);
348040c0:	e30c0350 	movw	r0, #50000	; 0xc350
348040c4:	eb0053fc 	bl	348190bc <udelay>
		gd->baudrate = load_baudrate;
348040c8:	e5885008 	str	r5, [r8, #8]
		serial_setbrg ();
348040cc:	eb00285f 	bl	3480e250 <serial_setbrg>
		udelay(50000);
348040d0:	e30c0350 	movw	r0, #50000	; 0xc350
348040d4:	eb0053f8 	bl	348190bc <udelay>
		for (;;) {
			if (getc() == '\r')
348040d8:	eb001375 	bl	34808eb4 <getc>
348040dc:	e350000d 	cmp	r0, #13
348040e0:	1afffffc 	bne	348040d8 <do_load_serial_bin+0xa0>
				break;
		}
	}

	if (strcmp(argv[0],"loady")==0) {
348040e4:	e5960000 	ldr	r0, [r6]
348040e8:	e59f1360 	ldr	r1, [pc, #864]	; 34804450 <do_load_serial_bin+0x418>
348040ec:	eb00526f 	bl	34818ab0 <strcmp>
348040f0:	e2509000 	subs	r9, r0, #0
348040f4:	1a000006 	bne	34804114 <do_load_serial_bin+0xdc>
		printf ("## Ready for binary (ymodem) download "
348040f8:	e1a01004 	mov	r1, r4
348040fc:	e1a02005 	mov	r2, r5
34804100:	e59f034c 	ldr	r0, [pc, #844]	; 34804454 <do_load_serial_bin+0x41c>
34804104:	eb001390 	bl	34808f4c <printf>
			"to 0x%08lX at %d bps...\n",
			offset,
			load_baudrate);

		addr = load_serial_ymodem (offset);
34804108:	e1a00004 	mov	r0, r4
3480410c:	ebfffdd2 	bl	3480385c <load_serial_ymodem>
34804110:	ea0000b3 	b	348043e4 <do_load_serial_bin+0x3ac>

	} else {

		printf ("## Ready for binary (kermit) download "
34804114:	e1a02005 	mov	r2, r5
34804118:	e1a01004 	mov	r1, r4
3480411c:	e59f0334 	ldr	r0, [pc, #820]	; 34804458 <do_load_serial_bin+0x420>
34804120:	eb001389 	bl	34808f4c <printf>
	}
}

static void set_kerm_bin_mode (unsigned long *addr)
{
	bin_start_address = (char *) addr;
34804124:	e59fa330 	ldr	sl, [pc, #816]	; 3480445c <do_load_serial_bin+0x424>
	os_data_init = bin_data_init;
34804128:	e59f3330 	ldr	r3, [pc, #816]	; 34804460 <do_load_serial_bin+0x428>
	int n, last_n;
	int len_lo, len_hi;

	/* initialize some protocol parameters */
	his_eol = END_CHAR;		/* default end of line character */
	his_pad_count = 0;
3480412c:	e3a06000 	mov	r6, #0
}

static void set_kerm_bin_mode (unsigned long *addr)
{
	bin_start_address = (char *) addr;
	os_data_init = bin_data_init;
34804130:	e58a3034 	str	r3, [sl, #52]	; 0x34
	os_data_char = bin_data_char;
34804134:	e59f3328 	ldr	r3, [pc, #808]	; 34804464 <do_load_serial_bin+0x42c>
	}
}

static void set_kerm_bin_mode (unsigned long *addr)
{
	bin_start_address = (char *) addr;
34804138:	e58a4008 	str	r4, [sl, #8]
	os_data_init = bin_data_init;
	os_data_char = bin_data_char;
3480413c:	e58a3044 	str	r3, [sl, #68]	; 0x44
	int length;
	int n, last_n;
	int len_lo, len_hi;

	/* initialize some protocol parameters */
	his_eol = END_CHAR;		/* default end of line character */
34804140:	e3a0300d 	mov	r3, #13
34804144:	e5ca302c 	strb	r3, [sl, #44]	; 0x2c
	his_pad_count = 0;
	his_pad_char = '\0';
	his_quote = K_ESCAPE;
34804148:	e2833016 	add	r3, r3, #22
3480414c:	e5ca3048 	strb	r3, [sl, #72]	; 0x48
	int n, last_n;
	int len_lo, len_hi;

	/* initialize some protocol parameters */
	his_eol = END_CHAR;		/* default end of line character */
	his_pad_count = 0;
34804150:	e58a600c 	str	r6, [sl, #12]
	his_pad_char = '\0';
34804154:	e5ca6010 	strb	r6, [sl, #16]
	his_quote = K_ESCAPE;

	/* initialize the k_recv and k_data state machine */
	done = 0;
	k_state = 0;
	k_data_init ();
34804158:	ebffff17 	bl	34803dbc <k_data_init>
	k_state_saved = k_state;
	k_data_save ();
3480415c:	ebffff1e 	bl	34803ddc <k_data_save>
	n = 0;				/* just to get rid of a warning */
	last_n = -1;
34804160:	e3e09000 	mvn	r9, #0
			new_char = getc ();
			if ((new_char & 0xE0) == 0)
				goto packet_error;
			sum += new_char & 0xff;
			len_lo = untochar (new_char);
			length = len_hi * 95 + len_lo;
34804164:	e58d5004 	str	r5, [sp, #4]
34804168:	e1a05004 	mov	r5, r4
	 */

	/* enter main loop */
	while (!done) {
		/* set the send packet pointer to begining of send packet parms */
		send_ptr = send_parms;
3480416c:	e59f12f4 	ldr	r1, [pc, #756]	; 34804468 <do_load_serial_bin+0x430>
34804170:	e58a104c 	str	r1, [sl, #76]	; 0x4c
#endif

		/* get a packet */
		/* wait for the starting character or ^C */
		for (;;) {
			switch (getc ()) {
34804174:	eb00134e 	bl	34808eb4 <getc>
34804178:	e3500001 	cmp	r0, #1
3480417c:	0a000002 	beq	3480418c <do_load_serial_bin+0x154>
34804180:	e3500003 	cmp	r0, #3
34804184:	1afffffa 	bne	34804174 <do_load_serial_bin+0x13c>
34804188:	ea00006e 	b	34804348 <do_load_serial_bin+0x310>
			}
		}
START:
		/* get length of packet */
		sum = 0;
		new_char = getc ();
3480418c:	eb001348 	bl	34808eb4 <getc>
		if ((new_char & 0xE0) == 0)
34804190:	e6ef4070 	uxtb	r4, r0
34804194:	e31400e0 	tst	r4, #224	; 0xe0
34804198:	0a000057 	beq	348042fc <do_load_serial_bin+0x2c4>
			goto packet_error;
		sum += new_char & 0xff;
		length = untochar (new_char);
		/* get sequence number */
		new_char = getc ();
3480419c:	eb001344 	bl	34808eb4 <getc>
		if ((new_char & 0xE0) == 0)
348041a0:	e6efb070 	uxtb	fp, r0
348041a4:	e31b00e0 	tst	fp, #224	; 0xe0
348041a8:	0a000053 	beq	348042fc <do_load_serial_bin+0x2c4>
			goto packet_error;
		sum += new_char & 0xff;
		n = untochar (new_char);
348041ac:	e24b6020 	sub	r6, fp, #32
348041b0:	e20660ff 	and	r6, r6, #255	; 0xff
		 * received.  Handling an invalid sequence number adds another layer
		 * of complexity that may not be needed - yet!  At this time, I'm hoping
		 * that I don't need to buffer the incoming data packets and can write
		 * the data into memory in real time.
		 */
		if (n == last_n) {
348041b4:	e1560009 	cmp	r6, r9
348041b8:	1a000001 	bne	348041c4 <do_load_serial_bin+0x18c>
			/* same sequence number, restore the previous state */
			k_state = k_state_saved;
			k_data_restore ();
348041bc:	ebffff0f 	bl	34803e00 <k_data_restore>
348041c0:	ea000000 	b	348041c8 <do_load_serial_bin+0x190>
		} else {
			/* new sequence number, checkpoint the download */
			last_n = n;
			k_state_saved = k_state;
			k_data_save ();
348041c4:	ebffff04 	bl	34803ddc <k_data_save>
		}
		/* END NEW CODE */

		/* get packet type */
		new_char = getc ();
348041c8:	eb001339 	bl	34808eb4 <getc>
348041cc:	e6ef9070 	uxtb	r9, r0
		if ((new_char & 0xE0) == 0)
348041d0:	e31900e0 	tst	r9, #224	; 0xe0
348041d4:	0a000047 	beq	348042f8 <do_load_serial_bin+0x2c0>
		length = untochar (new_char);
		/* get sequence number */
		new_char = getc ();
		if ((new_char & 0xE0) == 0)
			goto packet_error;
		sum += new_char & 0xff;
348041d8:	e08bb004 	add	fp, fp, r4
		sum = 0;
		new_char = getc ();
		if ((new_char & 0xE0) == 0)
			goto packet_error;
		sum += new_char & 0xff;
		length = untochar (new_char);
348041dc:	e2444020 	sub	r4, r4, #32
348041e0:	e20440ff 	and	r4, r4, #255	; 0xff
		new_char = getc ();
		if ((new_char & 0xE0) == 0)
			goto packet_error;
		sum += new_char & 0xff;
		k_state = new_char;
		--length;
348041e4:	e2444002 	sub	r4, r4, #2
		/* check for extended length */
		if (length == -2) {
348041e8:	e3740002 	cmn	r4, #2

		/* get packet type */
		new_char = getc ();
		if ((new_char & 0xE0) == 0)
			goto packet_error;
		sum += new_char & 0xff;
348041ec:	e08bb009 	add	fp, fp, r9
		k_state = new_char;
		--length;
		/* check for extended length */
		if (length == -2) {
348041f0:	1a000030 	bne	348042b8 <do_load_serial_bin+0x280>
			/* (length byte was 0, decremented twice) */
			/* get the two length bytes */
			new_char = getc ();
348041f4:	eb00132e 	bl	34808eb4 <getc>
			if ((new_char & 0xE0) == 0)
348041f8:	e6ef4070 	uxtb	r4, r0
348041fc:	e31400e0 	tst	r4, #224	; 0xe0
34804200:	0a00003c 	beq	348042f8 <do_load_serial_bin+0x2c0>
				goto packet_error;
			sum += new_char & 0xff;
			len_hi = untochar (new_char);
			new_char = getc ();
34804204:	eb00132a 	bl	34808eb4 <getc>
			if ((new_char & 0xE0) == 0)
34804208:	e6ef3070 	uxtb	r3, r0
3480420c:	e31300e0 	tst	r3, #224	; 0xe0
34804210:	0a000038 	beq	348042f8 <do_load_serial_bin+0x2c0>
				goto packet_error;
			sum += new_char & 0xff;
			len_lo = untochar (new_char);
			length = len_hi * 95 + len_lo;
			/* check header checksum */
			new_char = getc ();
34804214:	e58d3000 	str	r3, [sp]
34804218:	eb001325 	bl	34808eb4 <getc>
3480421c:	e6ef0070 	uxtb	r0, r0
			if ((new_char & 0xE0) == 0)
34804220:	e31000e0 	tst	r0, #224	; 0xe0
34804224:	e59d3000 	ldr	r3, [sp]
34804228:	0a000032 	beq	348042f8 <do_load_serial_bin+0x2c0>
			/* (length byte was 0, decremented twice) */
			/* get the two length bytes */
			new_char = getc ();
			if ((new_char & 0xE0) == 0)
				goto packet_error;
			sum += new_char & 0xff;
3480422c:	e084b00b 	add	fp, r4, fp
			len_hi = untochar (new_char);
			new_char = getc ();
			if ((new_char & 0xE0) == 0)
				goto packet_error;
			sum += new_char & 0xff;
34804230:	e08bb003 	add	fp, fp, r3
			length = len_hi * 95 + len_lo;
			/* check header checksum */
			new_char = getc ();
			if ((new_char & 0xE0) == 0)
				goto packet_error;
			if (new_char != tochar ((sum + ((sum >> 6) & 0x03)) & 0x3f))
34804234:	e7e1235b 	ubfx	r2, fp, #6, #2
34804238:	e082200b 	add	r2, r2, fp
3480423c:	e202203f 	and	r2, r2, #63	; 0x3f
34804240:	e2822020 	add	r2, r2, #32
34804244:	e1500002 	cmp	r0, r2
34804248:	1a00002a 	bne	348042f8 <do_load_serial_bin+0x2c0>
			/* get the two length bytes */
			new_char = getc ();
			if ((new_char & 0xE0) == 0)
				goto packet_error;
			sum += new_char & 0xff;
			len_hi = untochar (new_char);
3480424c:	e2444020 	sub	r4, r4, #32
34804250:	e20440ff 	and	r4, r4, #255	; 0xff
			new_char = getc ();
			if ((new_char & 0xE0) == 0)
				goto packet_error;
			sum += new_char & 0xff;
			len_lo = untochar (new_char);
			length = len_hi * 95 + len_lo;
34804254:	e3a0205f 	mov	r2, #95	; 0x5f
34804258:	e0040492 	mul	r4, r2, r4
			len_hi = untochar (new_char);
			new_char = getc ();
			if ((new_char & 0xE0) == 0)
				goto packet_error;
			sum += new_char & 0xff;
			len_lo = untochar (new_char);
3480425c:	e2433020 	sub	r3, r3, #32
			length = len_hi * 95 + len_lo;
34804260:	e6e44073 	uxtab	r4, r4, r3
			new_char = getc ();
			if ((new_char & 0xE0) == 0)
				goto packet_error;
			if (new_char != tochar ((sum + ((sum >> 6) & 0x03)) & 0x3f))
				goto packet_error;
			sum += new_char & 0xff;
34804264:	e080b00b 	add	fp, r0, fp
34804268:	ea000012 	b	348042b8 <do_load_serial_bin+0x280>
/* --length; */ /* new length includes only data and block check to come */
		}
		/* bring in rest of packet */
		while (length > 1) {
			new_char = getc ();
3480426c:	eb001310 	bl	34808eb4 <getc>
34804270:	e6ef0070 	uxtb	r0, r0
			if ((new_char & 0xE0) == 0)
34804274:	e31000e0 	tst	r0, #224	; 0xe0
34804278:	0a00001e 	beq	348042f8 <do_load_serial_bin+0x2c0>
				goto packet_error;
			sum += new_char & 0xff;
			--length;
			if (k_state == DATA_TYPE) {
3480427c:	e3590044 	cmp	r9, #68	; 0x44
		/* bring in rest of packet */
		while (length > 1) {
			new_char = getc ();
			if ((new_char & 0xE0) == 0)
				goto packet_error;
			sum += new_char & 0xff;
34804280:	e08bb000 	add	fp, fp, r0
			--length;
34804284:	e2444001 	sub	r4, r4, #1
			if (k_state == DATA_TYPE) {
34804288:	1a000001 	bne	34804294 <do_load_serial_bin+0x25c>
				/* pass on the data if this is a data packet */
				k_data_char (new_char);
3480428c:	ebfffee4 	bl	34803e24 <k_data_char>
34804290:	ea000008 	b	348042b8 <do_load_serial_bin+0x280>
			} else if (k_state == SEND_TYPE) {
34804294:	e3590053 	cmp	r9, #83	; 0x53
34804298:	1a000006 	bne	348042b8 <do_load_serial_bin+0x280>
				/* save send pack in buffer as is */
				*send_ptr++ = new_char;
3480429c:	e59a204c 	ldr	r2, [sl, #76]	; 0x4c
				/* if too much data, back off the pointer */
				if (send_ptr >= &send_parms[SEND_DATA_SIZE])
348042a0:	e59f11c4 	ldr	r1, [pc, #452]	; 3480446c <do_load_serial_bin+0x434>
			if (k_state == DATA_TYPE) {
				/* pass on the data if this is a data packet */
				k_data_char (new_char);
			} else if (k_state == SEND_TYPE) {
				/* save send pack in buffer as is */
				*send_ptr++ = new_char;
348042a4:	e1a03002 	mov	r3, r2
348042a8:	e4c30001 	strb	r0, [r3], #1
				/* if too much data, back off the pointer */
				if (send_ptr >= &send_parms[SEND_DATA_SIZE])
348042ac:	e1530001 	cmp	r3, r1
					--send_ptr;
348042b0:	21a03002 	movcs	r3, r2
348042b4:	e58a304c 	str	r3, [sl, #76]	; 0x4c
				goto packet_error;
			sum += new_char & 0xff;
/* --length; */ /* new length includes only data and block check to come */
		}
		/* bring in rest of packet */
		while (length > 1) {
348042b8:	e3540001 	cmp	r4, #1
348042bc:	caffffea 	bgt	3480426c <do_load_serial_bin+0x234>
				if (send_ptr >= &send_parms[SEND_DATA_SIZE])
					--send_ptr;
			}
		}
		/* get and validate checksum character */
		new_char = getc ();
348042c0:	eb0012fb 	bl	34808eb4 <getc>
348042c4:	e6ef0070 	uxtb	r0, r0
		if ((new_char & 0xE0) == 0)
348042c8:	e31000e0 	tst	r0, #224	; 0xe0
348042cc:	0a000009 	beq	348042f8 <do_load_serial_bin+0x2c0>
			goto packet_error;
		if (new_char != tochar ((sum + ((sum >> 6) & 0x03)) & 0x3f))
348042d0:	e7e1335b 	ubfx	r3, fp, #6, #2
348042d4:	e083b00b 	add	fp, r3, fp
348042d8:	e20bb03f 	and	fp, fp, #63	; 0x3f
348042dc:	e28bb020 	add	fp, fp, #32
348042e0:	e150000b 	cmp	r0, fp
348042e4:	1a000003 	bne	348042f8 <do_load_serial_bin+0x2c0>
			goto packet_error;
		/* get END_CHAR */
		new_char = getc ();
348042e8:	eb0012f1 	bl	34808eb4 <getc>
		if (new_char != END_CHAR) {
348042ec:	e6ef0070 	uxtb	r0, r0
348042f0:	e350000d 	cmp	r0, #13
348042f4:	0a000006 	beq	34804314 <do_load_serial_bin+0x2dc>
		/* get sequence number */
		new_char = getc ();
		if ((new_char & 0xE0) == 0)
			goto packet_error;
		sum += new_char & 0xff;
		n = untochar (new_char);
348042f8:	e1a09006 	mov	r9, r6
		new_char = getc ();
		if (new_char != END_CHAR) {
		  packet_error:
			/* restore state machines */
			k_state = k_state_saved;
			k_data_restore ();
348042fc:	ebfffebf 	bl	34803e00 <k_data_restore>
			/* send a negative acknowledge packet in */
			send_nack (n);
34804300:	e1a00006 	mov	r0, r6
34804304:	ebfffe94 	bl	34803d5c <send_nack>
34804308:	e1a03006 	mov	r3, r6
3480430c:	e1a06009 	mov	r6, r9
34804310:	ea000009 	b	3480433c <do_load_serial_bin+0x304>
		} else if (k_state == SEND_TYPE) {
34804314:	e3590053 	cmp	r9, #83	; 0x53
34804318:	1a000002 	bne	34804328 <do_load_serial_bin+0x2f0>
			/* crack the protocol parms, build an appropriate ack packet */
			handle_send_packet (n);
3480431c:	e1a00006 	mov	r0, r6
34804320:	ebfffed3 	bl	34803e74 <handle_send_packet>
34804324:	ea000003 	b	34804338 <do_load_serial_bin+0x300>
		} else {
			/* send simple acknowledge packet in */
			send_ack (n);
34804328:	e1a00006 	mov	r0, r6
3480432c:	ebfffe72 	bl	34803cfc <send_ack>
			/* quit if end of transmission */
			if (k_state == BREAK_TYPE)
34804330:	e3590042 	cmp	r9, #66	; 0x42
34804334:	0a00003d 	beq	34804430 <do_load_serial_bin+0x3f8>
		/* get sequence number */
		new_char = getc ();
		if ((new_char & 0xE0) == 0)
			goto packet_error;
		sum += new_char & 0xff;
		n = untochar (new_char);
34804338:	e1a03006 	mov	r3, r6
	/* pre-set offset from $loadaddr */
	if ((s = getenv("loadaddr")) != NULL) {
		offset = simple_strtoul(s, NULL, 16);
	}

	load_baudrate = current_baudrate = gd->baudrate;
3480433c:	e1a09006 	mov	r9, r6
34804340:	e1a06003 	mov	r6, r3
34804344:	eaffff88 	b	3480416c <do_load_serial_bin+0x134>
34804348:	e1a04005 	mov	r4, r5
3480434c:	e59d5004 	ldr	r5, [sp, #4]
		for (;;) {
			switch (getc ()) {
			case START_CHAR:	/* start packet */
				goto START;
			case ETX_CHAR:		/* ^C waiting for packet */
				return (0);
34804350:	e3a06000 	mov	r6, #0
34804354:	e3a09064 	mov	r9, #100	; 0x64
	 * Gather any trailing characters (for instance, the ^D which
	 * is sent by 'cu' after sending a file), and give the
	 * box some time (100 * 1 ms)
	 */
	for (i=0; i<100; ++i) {
		if (tstc()) {
34804358:	eb0012de 	bl	34808ed8 <tstc>
3480435c:	e3500000 	cmp	r0, #0
34804360:	0a000000 	beq	34804368 <do_load_serial_bin+0x330>
			(void) getc();
34804364:	eb0012d2 	bl	34808eb4 <getc>
		}
		udelay(1000);
34804368:	e3a00ffa 	mov	r0, #1000	; 0x3e8
3480436c:	eb005352 	bl	348190bc <udelay>
	/*
	 * Gather any trailing characters (for instance, the ^D which
	 * is sent by 'cu' after sending a file), and give the
	 * box some time (100 * 1 ms)
	 */
	for (i=0; i<100; ++i) {
34804370:	e2599001 	subs	r9, r9, #1
34804374:	1afffff7 	bne	34804358 <do_load_serial_bin+0x320>
			(void) getc();
		}
		udelay(1000);
	}

	flush_cache (offset, size);
34804378:	e1a01006 	mov	r1, r6
3480437c:	e1a00004 	mov	r0, r4
34804380:	ebfff326 	bl	34801020 <flush_cache>

	printf("## Total Size      = 0x%08x = %d Bytes\n", size, size);
	sprintf(buf, "%X", size);
34804384:	e28da008 	add	sl, sp, #8
		udelay(1000);
	}

	flush_cache (offset, size);

	printf("## Total Size      = 0x%08x = %d Bytes\n", size, size);
34804388:	e1a01006 	mov	r1, r6
3480438c:	e1a02006 	mov	r2, r6
34804390:	e59f00d8 	ldr	r0, [pc, #216]	; 34804470 <do_load_serial_bin+0x438>
34804394:	eb0012ec 	bl	34808f4c <printf>
	sprintf(buf, "%X", size);
34804398:	e1a02006 	mov	r2, r6
3480439c:	e59f10d0 	ldr	r1, [pc, #208]	; 34804474 <do_load_serial_bin+0x43c>
348043a0:	e1a0000a 	mov	r0, sl
348043a4:	eb0056b9 	bl	34819e90 <sprintf>
	setenv("filesize", buf);
348043a8:	e59f00c8 	ldr	r0, [pc, #200]	; 34804478 <do_load_serial_bin+0x440>
348043ac:	e1a0100a 	mov	r1, sl
348043b0:	eb000e99 	bl	34807e1c <setenv>
			"to 0x%08lX at %d bps...\n",
			offset,
			load_baudrate);
		addr = load_serial_bin (offset);

		if (addr == ~0) {
348043b4:	e3740001 	cmn	r4, #1
348043b8:	e59f60bc 	ldr	r6, [pc, #188]	; 3480447c <do_load_serial_bin+0x444>
348043bc:	1a000004 	bne	348043d4 <do_load_serial_bin+0x39c>
			load_addr = 0;
348043c0:	e5869000 	str	r9, [r6]
			printf ("## Binary (kermit) download aborted\n");
348043c4:	e59f00b4 	ldr	r0, [pc, #180]	; 34804480 <do_load_serial_bin+0x448>
348043c8:	eb0012df 	bl	34808f4c <printf>
			rcode = 1;
348043cc:	e3a09001 	mov	r9, #1
348043d0:	ea000003 	b	348043e4 <do_load_serial_bin+0x3ac>
		} else {
			printf ("## Start Addr      = 0x%08lX\n", addr);
348043d4:	e59f00a8 	ldr	r0, [pc, #168]	; 34804484 <do_load_serial_bin+0x44c>
348043d8:	e1a01004 	mov	r1, r4
348043dc:	eb0012da 	bl	34808f4c <printf>
			load_addr = addr;
348043e0:	e5864000 	str	r4, [r6]
		}
	}
	if (load_baudrate != current_baudrate) {
348043e4:	e1550007 	cmp	r5, r7
348043e8:	0a00000b 	beq	3480441c <do_load_serial_bin+0x3e4>
		printf ("## Switch baudrate to %d bps and press ESC ...\n",
348043ec:	e1a01007 	mov	r1, r7
348043f0:	e59f0090 	ldr	r0, [pc, #144]	; 34804488 <do_load_serial_bin+0x450>
348043f4:	eb0012d4 	bl	34808f4c <printf>
			current_baudrate);
		udelay (50000);
348043f8:	e30c0350 	movw	r0, #50000	; 0xc350
348043fc:	eb00532e 	bl	348190bc <udelay>
		gd->baudrate = current_baudrate;
34804400:	e5887008 	str	r7, [r8, #8]
		serial_setbrg ();
34804404:	eb002791 	bl	3480e250 <serial_setbrg>
		udelay (50000);
34804408:	e30c0350 	movw	r0, #50000	; 0xc350
3480440c:	eb00532a 	bl	348190bc <udelay>
		for (;;) {
			if (getc() == 0x1B) /* ESC */
34804410:	eb0012a7 	bl	34808eb4 <getc>
34804414:	e350001b 	cmp	r0, #27
34804418:	1afffffc 	bne	34804410 <do_load_serial_bin+0x3d8>
				break;
		}
	}

	return rcode;
}
3480441c:	e1a00009 	mov	r0, r9
34804420:	e28dd028 	add	sp, sp, #40	; 0x28
34804424:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
	/* pre-set offset from $loadaddr */
	if ((s = getenv("loadaddr")) != NULL) {
		offset = simple_strtoul(s, NULL, 16);
	}

	load_baudrate = current_baudrate = gd->baudrate;
34804428:	e1a05007 	mov	r5, r7
3480442c:	eaffff2c 	b	348040e4 <do_load_serial_bin+0xac>
			/* quit if end of transmission */
			if (k_state == BREAK_TYPE)
				done = 1;
		}
	}
	return ((ulong) os_data_addr - (ulong) bin_start_address);
34804430:	e59f3024 	ldr	r3, [pc, #36]	; 3480445c <do_load_serial_bin+0x424>
34804434:	e1a04005 	mov	r4, r5
34804438:	e9930044 	ldmib	r3, {r2, r6}
3480443c:	e0426006 	sub	r6, r2, r6
34804440:	e59d5004 	ldr	r5, [sp, #4]
34804444:	eaffffc2 	b	34804354 <do_load_serial_bin+0x31c>
34804448:	34822bcc 	.word	0x34822bcc
3480444c:	34823d89 	.word	0x34823d89
34804450:	34823dbb 	.word	0x34823dbb
34804454:	34823dc1 	.word	0x34823dc1
34804458:	34823e00 	.word	0x34823e00
3480445c:	348291ac 	.word	0x348291ac
34804460:	34803820 	.word	0x34803820
34804464:	3480383c 	.word	0x3480383c
34804468:	348291fc 	.word	0x348291fc
3480446c:	34829210 	.word	0x34829210
34804470:	34823c8e 	.word	0x34823c8e
34804474:	34823cb6 	.word	0x34823cb6
34804478:	34823512 	.word	0x34823512
3480447c:	348283c4 	.word	0x348283c4
34804480:	34823e3f 	.word	0x34823e3f
34804484:	34823d6b 	.word	0x34823d6b
34804488:	34823e64 	.word	0x34823e64

3480448c <do_mem_crc>:
{
	ulong addr, length;
	ulong crc;
	ulong *ptr;

	if (argc < 3)
3480448c:	e3520002 	cmp	r2, #2
#ifdef CONFIG_CMD_CRC32

#ifndef CONFIG_CRC32_VERIFY

int do_mem_crc (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
34804490:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
	ulong addr, length;
	ulong crc;
	ulong *ptr;

	if (argc < 3)
		return CMD_RET_USAGE;
34804494:	d3e00000 	mvnle	r0, #0
#ifdef CONFIG_CMD_CRC32

#ifndef CONFIG_CRC32_VERIFY

int do_mem_crc (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
34804498:	e1a07002 	mov	r7, r2
3480449c:	e1a04003 	mov	r4, r3
	ulong addr, length;
	ulong crc;
	ulong *ptr;

	if (argc < 3)
348044a0:	d8bd84f0 	pople	{r4, r5, r6, r7, sl, pc}
		return CMD_RET_USAGE;

	addr = simple_strtoul (argv[1], NULL, 16);
348044a4:	e5930004 	ldr	r0, [r3, #4]
348044a8:	e3a01000 	mov	r1, #0
348044ac:	e3a02010 	mov	r2, #16
348044b0:	eb0055d0 	bl	34819bf8 <simple_strtoul>
	addr += base_address;
348044b4:	e59f3074 	ldr	r3, [pc, #116]	; 34804530 <do_mem_crc+0xa4>

	length = simple_strtoul (argv[2], NULL, 16);
348044b8:	e3a01000 	mov	r1, #0

	if (argc < 3)
		return CMD_RET_USAGE;

	addr = simple_strtoul (argv[1], NULL, 16);
	addr += base_address;
348044bc:	e5935000 	ldr	r5, [r3]

	length = simple_strtoul (argv[2], NULL, 16);
348044c0:	e3a02010 	mov	r2, #16

	if (argc < 3)
		return CMD_RET_USAGE;

	addr = simple_strtoul (argv[1], NULL, 16);
	addr += base_address;
348044c4:	e0805005 	add	r5, r0, r5

	length = simple_strtoul (argv[2], NULL, 16);
348044c8:	e5940008 	ldr	r0, [r4, #8]
348044cc:	eb0055c9 	bl	34819bf8 <simple_strtoul>
348044d0:	e1a06000 	mov	r6, r0

	crc = crc32_wd (0, (const uchar *) addr, length, CHUNKSZ_CRC32);
348044d4:	e1a01005 	mov	r1, r5
348044d8:	e1a02006 	mov	r2, r6
348044dc:	e3a03801 	mov	r3, #65536	; 0x10000
348044e0:	e3a00000 	mov	r0, #0
348044e4:	eb004aec 	bl	3481709c <crc32_wd>

	printf ("CRC32 for %08lx ... %08lx ==> %08lx\n",
			addr, addr + length - 1, crc);
348044e8:	e2462001 	sub	r2, r6, #1
	addr = simple_strtoul (argv[1], NULL, 16);
	addr += base_address;

	length = simple_strtoul (argv[2], NULL, 16);

	crc = crc32_wd (0, (const uchar *) addr, length, CHUNKSZ_CRC32);
348044ec:	e1a0a000 	mov	sl, r0

	printf ("CRC32 for %08lx ... %08lx ==> %08lx\n",
348044f0:	e1a01005 	mov	r1, r5
348044f4:	e59f0038 	ldr	r0, [pc, #56]	; 34804534 <do_mem_crc+0xa8>
348044f8:	e0822005 	add	r2, r2, r5
348044fc:	e1a0300a 	mov	r3, sl
34804500:	eb001291 	bl	34808f4c <printf>
			addr, addr + length - 1, crc);

	if (argc > 3) {
34804504:	e3570003 	cmp	r7, #3
34804508:	0a000006 	beq	34804528 <do_mem_crc+0x9c>
		ptr = (ulong *) simple_strtoul (argv[3], NULL, 16);
3480450c:	e594000c 	ldr	r0, [r4, #12]
34804510:	e3a01000 	mov	r1, #0
34804514:	e3a02010 	mov	r2, #16
34804518:	eb0055b6 	bl	34819bf8 <simple_strtoul>
		*ptr = crc;
3480451c:	e580a000 	str	sl, [r0]
	}

	return 0;
34804520:	e3a00000 	mov	r0, #0
34804524:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
34804528:	e3a00000 	mov	r0, #0
}
3480452c:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
34804530:	34829210 	.word	0x34829210
34804534:	34823fc7 	.word	0x34823fc7

34804538 <do_mem_base>:
	return 0;
}

int do_mem_base (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	if (argc > 1) {
34804538:	e3520001 	cmp	r2, #1
	}
	return 0;
}

int do_mem_base (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
3480453c:	e92d4008 	push	{r3, lr}
	if (argc > 1) {
34804540:	da000005 	ble	3480455c <do_mem_base+0x24>
		/* Set new base address.
		*/
		base_address = simple_strtoul(argv[1], NULL, 16);
34804544:	e5930004 	ldr	r0, [r3, #4]
34804548:	e3a01000 	mov	r1, #0
3480454c:	e3a02010 	mov	r2, #16
34804550:	eb0055a8 	bl	34819bf8 <simple_strtoul>
34804554:	e59f3018 	ldr	r3, [pc, #24]	; 34804574 <do_mem_base+0x3c>
34804558:	e5830000 	str	r0, [r3]
	}
	/* Print the current base address.
	*/
	printf("Base Address: 0x%08lx\n", base_address);
3480455c:	e59f3010 	ldr	r3, [pc, #16]	; 34804574 <do_mem_base+0x3c>
34804560:	e59f0010 	ldr	r0, [pc, #16]	; 34804578 <do_mem_base+0x40>
34804564:	e5931000 	ldr	r1, [r3]
34804568:	eb001277 	bl	34808f4c <printf>
	return 0;
}
3480456c:	e3a00000 	mov	r0, #0
34804570:	e8bd8008 	pop	{r3, pc}
34804574:	34829210 	.word	0x34829210
34804578:	34823fec 	.word	0x34823fec

3480457c <do_mem_mtest>:
#else
	ulong	incr;
	ulong	pattern;
#endif

	if (argc > 1)
3480457c:	e3520001 	cmp	r2, #1
 * Perform a memory test. A more complete alternative test can be
 * configured using CONFIG_SYS_ALT_MEMTEST. The complete test loops until
 * interrupted by ctrl-c or by a failure of one of the sub-tests.
 */
int do_mem_mtest (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
34804580:	e92d4ef3 	push	{r0, r1, r4, r5, r6, r7, r9, sl, fp, lr}
34804584:	e1a05002 	mov	r5, r2
34804588:	e1a06003 	mov	r6, r3
#else
	ulong	incr;
	ulong	pattern;
#endif

	if (argc > 1)
3480458c:	da000056 	ble	348046ec <do_mem_mtest+0x170>
		start = (ulong *)simple_strtoul(argv[1], NULL, 16);
34804590:	e5930004 	ldr	r0, [r3, #4]
34804594:	e3a01000 	mov	r1, #0
34804598:	e3a02010 	mov	r2, #16
3480459c:	eb005595 	bl	34819bf8 <simple_strtoul>
	else
		start = (ulong *)CONFIG_SYS_MEMTEST_START;

	if (argc > 2)
348045a0:	e3550002 	cmp	r5, #2
	ulong	incr;
	ulong	pattern;
#endif

	if (argc > 1)
		start = (ulong *)simple_strtoul(argv[1], NULL, 16);
348045a4:	e58d0000 	str	r0, [sp]
	else
		start = (ulong *)CONFIG_SYS_MEMTEST_START;

	if (argc > 2)
348045a8:	0a000051 	beq	348046f4 <do_mem_mtest+0x178>
		end = (ulong *)simple_strtoul(argv[2], NULL, 16);
348045ac:	e5960008 	ldr	r0, [r6, #8]
348045b0:	e3a01000 	mov	r1, #0
348045b4:	e3a02010 	mov	r2, #16
348045b8:	eb00558e 	bl	34819bf8 <simple_strtoul>
	else
		end = (ulong *)(CONFIG_SYS_MEMTEST_END);

	if (argc > 3)
348045bc:	e3550003 	cmp	r5, #3
		start = (ulong *)simple_strtoul(argv[1], NULL, 16);
	else
		start = (ulong *)CONFIG_SYS_MEMTEST_START;

	if (argc > 2)
		end = (ulong *)simple_strtoul(argv[2], NULL, 16);
348045c0:	e58d0004 	str	r0, [sp, #4]
	else
		end = (ulong *)(CONFIG_SYS_MEMTEST_END);

	if (argc > 3)
348045c4:	0a00004c 	beq	348046fc <do_mem_mtest+0x180>
		pattern = (ulong)simple_strtoul(argv[3], NULL, 16);
348045c8:	e596000c 	ldr	r0, [r6, #12]
348045cc:	e3a01000 	mov	r1, #0
348045d0:	e3a02010 	mov	r2, #16
348045d4:	eb005587 	bl	34819bf8 <simple_strtoul>
	else
		pattern = 0;

	if (argc > 4)
348045d8:	e3550004 	cmp	r5, #4
		end = (ulong *)simple_strtoul(argv[2], NULL, 16);
	else
		end = (ulong *)(CONFIG_SYS_MEMTEST_END);

	if (argc > 3)
		pattern = (ulong)simple_strtoul(argv[3], NULL, 16);
348045dc:	e1a04000 	mov	r4, r0
		pattern = 0;

	if (argc > 4)
		iteration_limit = (ulong)simple_strtoul(argv[4], NULL, 16);
	else
		iteration_limit = 0;
348045e0:	03a0b000 	moveq	fp, #0
	if (argc > 3)
		pattern = (ulong)simple_strtoul(argv[3], NULL, 16);
	else
		pattern = 0;

	if (argc > 4)
348045e4:	0a000004 	beq	348045fc <do_mem_mtest+0x80>
		iteration_limit = (ulong)simple_strtoul(argv[4], NULL, 16);
348045e8:	e5960010 	ldr	r0, [r6, #16]
348045ec:	e3a01000 	mov	r1, #0
348045f0:	e3a02010 	mov	r2, #16
348045f4:	eb00557f 	bl	34819bf8 <simple_strtoul>
348045f8:	e1a0b000 	mov	fp, r0
		    start[offset] = 0;
		}
	}

#else /* The original, quickie test */
	incr = 1;
348045fc:	e3a05001 	mov	r5, #1
{
	vu_long	*addr, *start, *end;
	ulong	val;
	ulong	readback;
	ulong	errs = 0;
	int iterations = 1;
34804600:	e1a0a005 	mov	sl, r5
int do_mem_mtest (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	vu_long	*addr, *start, *end;
	ulong	val;
	ulong	readback;
	ulong	errs = 0;
34804604:	e3a09000 	mov	r9, #0
	}

#else /* The original, quickie test */
	incr = 1;
	for (;;) {
		if (ctrlc()) {
34804608:	eb001274 	bl	34808fe0 <ctrlc>
3480460c:	e3500000 	cmp	r0, #0
34804610:	1a000025 	bne	348046ac <do_mem_mtest+0x130>
			putc ('\n');
			return 1;
		}

		if (iteration_limit && iterations > iteration_limit) {
34804614:	e35b0000 	cmp	fp, #0
34804618:	115a000b 	cmpne	sl, fp
3480461c:	da000006 	ble	3480463c <do_mem_mtest+0xc0>
			printf("Tested %d iteration(s) with %lu errors.\n",
34804620:	e59f00e0 	ldr	r0, [pc, #224]	; 34804708 <do_mem_mtest+0x18c>
34804624:	e24a1001 	sub	r1, sl, #1
34804628:	e1a02009 	mov	r2, r9
3480462c:	eb001246 	bl	34808f4c <printf>
				iterations-1, errs);
			return errs != 0;
34804630:	e2590000 	subs	r0, r9, #0
34804634:	13a00001 	movne	r0, #1
34804638:	ea00002a 	b	348046e8 <do_mem_mtest+0x16c>
		}
		++iterations;

		printf ("\rPattern %08lX  Writing..."
3480463c:	e59f20c8 	ldr	r2, [pc, #200]	; 3480470c <do_mem_mtest+0x190>
34804640:	e59f00c8 	ldr	r0, [pc, #200]	; 34804710 <do_mem_mtest+0x194>
34804644:	e1a01004 	mov	r1, r4
34804648:	eb00123f 	bl	34808f4c <printf>
			"%12s"
			"\b\b\b\b\b\b\b\b\b\b",
			pattern, "");

		for (addr=start,val=pattern; addr<end; addr++) {
3480464c:	e1a02004 	mov	r2, r4
34804650:	e59d3000 	ldr	r3, [sp]
34804654:	ea000001 	b	34804660 <do_mem_mtest+0xe4>
			WATCHDOG_RESET();
			*addr = val;
34804658:	e4832004 	str	r2, [r3], #4
			val  += incr;
3480465c:	e0822005 	add	r2, r2, r5
		printf ("\rPattern %08lX  Writing..."
			"%12s"
			"\b\b\b\b\b\b\b\b\b\b",
			pattern, "");

		for (addr=start,val=pattern; addr<end; addr++) {
34804660:	e59d1004 	ldr	r1, [sp, #4]
34804664:	e1530001 	cmp	r3, r1
34804668:	3afffffa 	bcc	34804658 <do_mem_mtest+0xdc>
			WATCHDOG_RESET();
			*addr = val;
			val  += incr;
		}

		puts ("Reading...");
3480466c:	e59f00a0 	ldr	r0, [pc, #160]	; 34804714 <do_mem_mtest+0x198>
34804670:	eb00122b 	bl	34808f24 <puts>

		for (addr=start,val=pattern; addr<end; addr++) {
34804674:	e1a07004 	mov	r7, r4
34804678:	e59d6000 	ldr	r6, [sp]
3480467c:	ea000010 	b	348046c4 <do_mem_mtest+0x148>
			WATCHDOG_RESET();
			readback = *addr;
34804680:	e5962000 	ldr	r2, [r6]
			if (readback != val) {
34804684:	e1520007 	cmp	r2, r7
34804688:	0a00000b 	beq	348046bc <do_mem_mtest+0x140>
				printf ("\nMem error @ 0x%08X: "
3480468c:	e1a01006 	mov	r1, r6
34804690:	e1a03007 	mov	r3, r7
34804694:	e59f007c 	ldr	r0, [pc, #124]	; 34804718 <do_mem_mtest+0x19c>
34804698:	eb00122b 	bl	34808f4c <printf>
					"found %08lX, expected %08lX\n",
					(uint)(uintptr_t)addr, readback, val);
				errs++;
				if (ctrlc()) {
3480469c:	eb00124f 	bl	34808fe0 <ctrlc>
348046a0:	e3500000 	cmp	r0, #0
			readback = *addr;
			if (readback != val) {
				printf ("\nMem error @ 0x%08X: "
					"found %08lX, expected %08lX\n",
					(uint)(uintptr_t)addr, readback, val);
				errs++;
348046a4:	02899001 	addeq	r9, r9, #1
348046a8:	0a000003 	beq	348046bc <do_mem_mtest+0x140>
				if (ctrlc()) {
					putc ('\n');
348046ac:	e3a0000a 	mov	r0, #10
348046b0:	eb001211 	bl	34808efc <putc>
					return 1;
348046b4:	e3a00001 	mov	r0, #1
348046b8:	ea00000a 	b	348046e8 <do_mem_mtest+0x16c>
				}
			}
			val += incr;
348046bc:	e0877005 	add	r7, r7, r5
			val  += incr;
		}

		puts ("Reading...");

		for (addr=start,val=pattern; addr<end; addr++) {
348046c0:	e2866004 	add	r6, r6, #4
348046c4:	e59d3004 	ldr	r3, [sp, #4]
348046c8:	e1560003 	cmp	r6, r3
348046cc:	3affffeb 	bcc	34804680 <do_mem_mtest+0x104>
		 * Flip the pattern each time to make lots of zeros and
		 * then, the next time, lots of ones.  We decrement
		 * the "negative" patterns and increment the "positive"
		 * patterns to preserve this feature.
		 */
		if(pattern & 0x80000000) {
348046d0:	e3540000 	cmp	r4, #0
			pattern = -pattern;	/* complement & increment */
348046d4:	b2644000 	rsblt	r4, r4, #0
		}
		else {
			pattern = ~pattern;
348046d8:	a1e04004 	mvnge	r4, r4
		if (iteration_limit && iterations > iteration_limit) {
			printf("Tested %d iteration(s) with %lu errors.\n",
				iterations-1, errs);
			return errs != 0;
		}
		++iterations;
348046dc:	e28aa001 	add	sl, sl, #1
			pattern = -pattern;	/* complement & increment */
		}
		else {
			pattern = ~pattern;
		}
		incr = -incr;
348046e0:	e2655000 	rsb	r5, r5, #0
	}
348046e4:	eaffffc7 	b	34804608 <do_mem_mtest+0x8c>
#endif
	return 0;	/* not reached */
}
348046e8:	e8bd8efc 	pop	{r2, r3, r4, r5, r6, r7, r9, sl, fp, pc}
#endif

	if (argc > 1)
		start = (ulong *)simple_strtoul(argv[1], NULL, 16);
	else
		start = (ulong *)CONFIG_SYS_MEMTEST_START;
348046ec:	e3a01202 	mov	r1, #536870912	; 0x20000000
348046f0:	e58d1000 	str	r1, [sp]
348046f4:	e3a03425 	mov	r3, #620756992	; 0x25000000
348046f8:	e58d3004 	str	r3, [sp, #4]
		pattern = 0;

	if (argc > 4)
		iteration_limit = (ulong)simple_strtoul(argv[4], NULL, 16);
	else
		iteration_limit = 0;
348046fc:	e3a04000 	mov	r4, #0
34804700:	e1a0b004 	mov	fp, r4
34804704:	eaffffbc 	b	348045fc <do_mem_mtest+0x80>
34804708:	34824003 	.word	0x34824003
3480470c:	34824054 	.word	0x34824054
34804710:	3482402c 	.word	0x3482402c
34804714:	34824055 	.word	0x34824055
34804718:	34824060 	.word	0x34824060

3480471c <do_mem_loop>:
	int	size;
	volatile uint	*longp;
	volatile ushort *shortp;
	volatile u_char	*cp;

	if (argc < 3)
3480471c:	e3520002 	cmp	r2, #2
	printf("Base Address: 0x%08lx\n", base_address);
	return 0;
}

int do_mem_loop (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
34804720:	e92d4070 	push	{r4, r5, r6, lr}
	volatile uint	*longp;
	volatile ushort *shortp;
	volatile u_char	*cp;

	if (argc < 3)
		return CMD_RET_USAGE;
34804724:	d3e00000 	mvnle	r0, #0
	printf("Base Address: 0x%08lx\n", base_address);
	return 0;
}

int do_mem_loop (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
34804728:	e1a06003 	mov	r6, r3
	int	size;
	volatile uint	*longp;
	volatile ushort *shortp;
	volatile u_char	*cp;

	if (argc < 3)
3480472c:	d8bd8070 	pople	{r4, r5, r6, pc}
		return CMD_RET_USAGE;

	/* Check for a size spefication.
	 * Defaults to long if no or incorrect specification.
	 */
	if ((size = cmd_get_data_size(argv[0], 4)) < 0)
34804730:	e5930000 	ldr	r0, [r3]
34804734:	e3a01004 	mov	r1, #4
34804738:	eb001125 	bl	34808bd4 <cmd_get_data_size>
3480473c:	e2505000 	subs	r5, r0, #0
34804740:	ba000030 	blt	34804808 <do_mem_loop+0xec>
		return 1;

	/* Address is always specified.
	*/
	addr = simple_strtoul(argv[1], NULL, 16);
34804744:	e3a01000 	mov	r1, #0
34804748:	e3a02010 	mov	r2, #16
3480474c:	e5960004 	ldr	r0, [r6, #4]
34804750:	eb005528 	bl	34819bf8 <simple_strtoul>

	/* Length is the number of objects, not number of bytes.
	*/
	length = simple_strtoul(argv[2], NULL, 16);
34804754:	e3a01000 	mov	r1, #0
	if ((size = cmd_get_data_size(argv[0], 4)) < 0)
		return 1;

	/* Address is always specified.
	*/
	addr = simple_strtoul(argv[1], NULL, 16);
34804758:	e1a04000 	mov	r4, r0

	/* Length is the number of objects, not number of bytes.
	*/
	length = simple_strtoul(argv[2], NULL, 16);
3480475c:	e3a02010 	mov	r2, #16
34804760:	e5960008 	ldr	r0, [r6, #8]
34804764:	eb005523 	bl	34819bf8 <simple_strtoul>

	/* We want to optimize the loops to run as fast as possible.
	 * If we have only one object, just run infinite loops.
	 */
	if (length == 1) {
34804768:	e3500001 	cmp	r0, #1
3480476c:	1a000009 	bne	34804798 <do_mem_loop+0x7c>
		if (size == 4) {
34804770:	e3550004 	cmp	r5, #4
34804774:	1a000001 	bne	34804780 <do_mem_loop+0x64>
			longp = (uint *)addr;
			for (;;)
				i = *longp;
34804778:	e5943000 	ldr	r3, [r4]
3480477c:	eafffffd 	b	34804778 <do_mem_loop+0x5c>
		}
		if (size == 2) {
34804780:	e3550002 	cmp	r5, #2
34804784:	1a000001 	bne	34804790 <do_mem_loop+0x74>
			shortp = (ushort *)addr;
			for (;;)
				i = *shortp;
34804788:	e1d430b0 	ldrh	r3, [r4]
3480478c:	eafffffd 	b	34804788 <do_mem_loop+0x6c>
		}
		cp = (u_char *)addr;
		for (;;)
			i = *cp;
34804790:	e5d43000 	ldrb	r3, [r4]
34804794:	eafffffd 	b	34804790 <do_mem_loop+0x74>
	}

	if (size == 4) {
34804798:	e3550004 	cmp	r5, #4
3480479c:	1a000007 	bne	348047c0 <do_mem_loop+0xa4>
		for (;;) {
			longp = (uint *)addr;
348047a0:	e1a02004 	mov	r2, r4
			i = length;
			while (i-- > 0)
348047a4:	e1a03000 	mov	r3, r0
348047a8:	ea000001 	b	348047b4 <do_mem_loop+0x98>
				*longp++;
348047ac:	e4921004 	ldr	r1, [r2], #4
348047b0:	e2433001 	sub	r3, r3, #1

	if (size == 4) {
		for (;;) {
			longp = (uint *)addr;
			i = length;
			while (i-- > 0)
348047b4:	e3530000 	cmp	r3, #0
348047b8:	0afffff8 	beq	348047a0 <do_mem_loop+0x84>
348047bc:	eafffffa 	b	348047ac <do_mem_loop+0x90>
				*longp++;
		}
	}
	if (size == 2) {
348047c0:	e3550002 	cmp	r5, #2
348047c4:	1a000007 	bne	348047e8 <do_mem_loop+0xcc>
		for (;;) {
			shortp = (ushort *)addr;
348047c8:	e1a02004 	mov	r2, r4
			i = length;
			while (i-- > 0)
348047cc:	e1a03000 	mov	r3, r0
348047d0:	ea000001 	b	348047dc <do_mem_loop+0xc0>
				*shortp++;
348047d4:	e0d210b2 	ldrh	r1, [r2], #2
348047d8:	e2433001 	sub	r3, r3, #1
	}
	if (size == 2) {
		for (;;) {
			shortp = (ushort *)addr;
			i = length;
			while (i-- > 0)
348047dc:	e3530000 	cmp	r3, #0
348047e0:	0afffff8 	beq	348047c8 <do_mem_loop+0xac>
348047e4:	eafffffa 	b	348047d4 <do_mem_loop+0xb8>
				*shortp++;
		}
	}
	for (;;) {
		cp = (u_char *)addr;
348047e8:	e1a02004 	mov	r2, r4
		i = length;
		while (i-- > 0)
348047ec:	e1a03000 	mov	r3, r0
348047f0:	ea000001 	b	348047fc <do_mem_loop+0xe0>
			*cp++;
348047f4:	e4d21001 	ldrb	r1, [r2], #1
348047f8:	e2433001 	sub	r3, r3, #1
		}
	}
	for (;;) {
		cp = (u_char *)addr;
		i = length;
		while (i-- > 0)
348047fc:	e3530000 	cmp	r3, #0
34804800:	0afffff8 	beq	348047e8 <do_mem_loop+0xcc>
34804804:	eafffffa 	b	348047f4 <do_mem_loop+0xd8>

	/* Check for a size spefication.
	 * Defaults to long if no or incorrect specification.
	 */
	if ((size = cmd_get_data_size(argv[0], 4)) < 0)
		return 1;
34804808:	e3a00001 	mov	r0, #1
		cp = (u_char *)addr;
		i = length;
		while (i-- > 0)
			*cp++;
	}
}
3480480c:	e8bd8070 	pop	{r4, r5, r6, pc}

34804810 <do_mem_cp>:
int do_mem_cp ( cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	ulong	addr, dest, count;
	int	size;

	if (argc != 4)
34804810:	e3520004 	cmp	r2, #4
	printf("Total of %ld %s(s) were the same\n", ngood, type);
	return rcode;
}

int do_mem_cp ( cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
34804814:	e92d46f8 	push	{r3, r4, r5, r6, r7, r9, sl, lr}
	ulong	addr, dest, count;
	int	size;

	if (argc != 4)
		return CMD_RET_USAGE;
34804818:	13e00000 	mvnne	r0, #0
	printf("Total of %ld %s(s) were the same\n", ngood, type);
	return rcode;
}

int do_mem_cp ( cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
3480481c:	e1a05003 	mov	r5, r3
	ulong	addr, dest, count;
	int	size;

	if (argc != 4)
34804820:	18bd86f8 	popne	{r3, r4, r5, r6, r7, r9, sl, pc}
		return CMD_RET_USAGE;

	/* Check for size specification.
	*/
	if ((size = cmd_get_data_size(argv[0], 4)) < 0)
34804824:	e5930000 	ldr	r0, [r3]
34804828:	e1a01002 	mov	r1, r2
3480482c:	eb0010e8 	bl	34808bd4 <cmd_get_data_size>
34804830:	e2504000 	subs	r4, r0, #0
34804834:	ba000026 	blt	348048d4 <do_mem_cp+0xc4>
		return 1;

	addr = simple_strtoul(argv[1], NULL, 16);
34804838:	e3a01000 	mov	r1, #0
3480483c:	e3a02010 	mov	r2, #16
34804840:	e5950004 	ldr	r0, [r5, #4]
34804844:	eb0054eb 	bl	34819bf8 <simple_strtoul>
	addr += base_address;
34804848:	e59f608c 	ldr	r6, [pc, #140]	; 348048dc <do_mem_cp+0xcc>
	/* Check for size specification.
	*/
	if ((size = cmd_get_data_size(argv[0], 4)) < 0)
		return 1;

	addr = simple_strtoul(argv[1], NULL, 16);
3480484c:	e1a0a000 	mov	sl, r0
	addr += base_address;

	dest = simple_strtoul(argv[2], NULL, 16);
34804850:	e3a01000 	mov	r1, #0
34804854:	e3a02010 	mov	r2, #16
34804858:	e5950008 	ldr	r0, [r5, #8]
	*/
	if ((size = cmd_get_data_size(argv[0], 4)) < 0)
		return 1;

	addr = simple_strtoul(argv[1], NULL, 16);
	addr += base_address;
3480485c:	e5967000 	ldr	r7, [r6]

	dest = simple_strtoul(argv[2], NULL, 16);
34804860:	eb0054e4 	bl	34819bf8 <simple_strtoul>
	dest += base_address;

	count = simple_strtoul(argv[3], NULL, 16);
34804864:	e3a01000 	mov	r1, #0
		return 1;

	addr = simple_strtoul(argv[1], NULL, 16);
	addr += base_address;

	dest = simple_strtoul(argv[2], NULL, 16);
34804868:	e1a09000 	mov	r9, r0
	dest += base_address;

	count = simple_strtoul(argv[3], NULL, 16);
3480486c:	e3a02010 	mov	r2, #16
34804870:	e595000c 	ldr	r0, [r5, #12]

	addr = simple_strtoul(argv[1], NULL, 16);
	addr += base_address;

	dest = simple_strtoul(argv[2], NULL, 16);
	dest += base_address;
34804874:	e5966000 	ldr	r6, [r6]

	count = simple_strtoul(argv[3], NULL, 16);
34804878:	eb0054de 	bl	34819bf8 <simple_strtoul>

	if (count == 0) {
3480487c:	e3500000 	cmp	r0, #0
	*/
	if ((size = cmd_get_data_size(argv[0], 4)) < 0)
		return 1;

	addr = simple_strtoul(argv[1], NULL, 16);
	addr += base_address;
34804880:	108a7007 	addne	r7, sl, r7

	dest = simple_strtoul(argv[2], NULL, 16);
	dest += base_address;
34804884:	10896006 	addne	r6, r9, r6

	count = simple_strtoul(argv[3], NULL, 16);

	if (count == 0) {
34804888:	1a000003 	bne	3480489c <do_mem_cp+0x8c>
		puts ("Zero length ???\n");
3480488c:	e59f004c 	ldr	r0, [pc, #76]	; 348048e0 <do_mem_cp+0xd0>
34804890:	eb0011a3 	bl	34808f24 <puts>
		return 1;
34804894:	e3a00001 	mov	r0, #1
34804898:	e8bd86f8 	pop	{r3, r4, r5, r6, r7, r9, sl, pc}
		return 0;
	}
#endif

	while (count-- > 0) {
		if (size == 4)
3480489c:	e3540004 	cmp	r4, #4
			*((ulong  *)dest) = *((ulong  *)addr);
348048a0:	05973000 	ldreq	r3, [r7]
348048a4:	05863000 	streq	r3, [r6]
		return 0;
	}
#endif

	while (count-- > 0) {
		if (size == 4)
348048a8:	0a000004 	beq	348048c0 <do_mem_cp+0xb0>
			*((ulong  *)dest) = *((ulong  *)addr);
		else if (size == 2)
348048ac:	e3540002 	cmp	r4, #2
			*((ushort *)dest) = *((ushort *)addr);
348048b0:	01d730b0 	ldrheq	r3, [r7]
		else
			*((u_char *)dest) = *((u_char *)addr);
348048b4:	15d73000 	ldrbne	r3, [r7]

	while (count-- > 0) {
		if (size == 4)
			*((ulong  *)dest) = *((ulong  *)addr);
		else if (size == 2)
			*((ushort *)dest) = *((ushort *)addr);
348048b8:	01c630b0 	strheq	r3, [r6]
		else
			*((u_char *)dest) = *((u_char *)addr);
348048bc:	15c63000 	strbne	r3, [r6]
		memcpy((void *)dest, (void *)addr, count * size);
		return 0;
	}
#endif

	while (count-- > 0) {
348048c0:	e2500001 	subs	r0, r0, #1
			*((ulong  *)dest) = *((ulong  *)addr);
		else if (size == 2)
			*((ushort *)dest) = *((ushort *)addr);
		else
			*((u_char *)dest) = *((u_char *)addr);
		addr += size;
348048c4:	e0877004 	add	r7, r7, r4
348048c8:	e0866004 	add	r6, r6, r4
		memcpy((void *)dest, (void *)addr, count * size);
		return 0;
	}
#endif

	while (count-- > 0) {
348048cc:	1afffff2 	bne	3480489c <do_mem_cp+0x8c>
348048d0:	e8bd86f8 	pop	{r3, r4, r5, r6, r7, r9, sl, pc}
		return CMD_RET_USAGE;

	/* Check for size specification.
	*/
	if ((size = cmd_get_data_size(argv[0], 4)) < 0)
		return 1;
348048d4:	e3a00001 	mov	r0, #1
		/* reset watchdog from time to time */
		if ((count % (64 << 10)) == 0)
			WATCHDOG_RESET();
	}
	return 0;
}
348048d8:	e8bd86f8 	pop	{r3, r4, r5, r6, r7, r9, sl, pc}
348048dc:	34829210 	.word	0x34829210
348048e0:	34824092 	.word	0x34824092

348048e4 <do_mem_cmp>:
	return 0;
}
#endif /* CONFIG_MX_CYCLIC */

int do_mem_cmp (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
348048e4:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
	ulong	addr1, addr2, count, ngood;
	int	size;
	int     rcode = 0;
	const char *type;

	if (argc != 4)
348048e8:	e3520004 	cmp	r2, #4
	return 0;
}
#endif /* CONFIG_MX_CYCLIC */

int do_mem_cmp (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
348048ec:	e24dd018 	sub	sp, sp, #24
348048f0:	e1a05003 	mov	r5, r3
	int	size;
	int     rcode = 0;
	const char *type;

	if (argc != 4)
		return CMD_RET_USAGE;
348048f4:	13e06000 	mvnne	r6, #0
	ulong	addr1, addr2, count, ngood;
	int	size;
	int     rcode = 0;
	const char *type;

	if (argc != 4)
348048f8:	1a00003f 	bne	348049fc <do_mem_cmp+0x118>
		return CMD_RET_USAGE;

	/* Check for size specification.
	*/
	if ((size = cmd_get_data_size(argv[0], 4)) < 0)
348048fc:	e5930000 	ldr	r0, [r3]
34804900:	e1a01002 	mov	r1, r2
34804904:	eb0010b2 	bl	34808bd4 <cmd_get_data_size>
34804908:	e2506000 	subs	r6, r0, #0
		return 1;
3480490c:	b3a06001 	movlt	r6, #1
	if (argc != 4)
		return CMD_RET_USAGE;

	/* Check for size specification.
	*/
	if ((size = cmd_get_data_size(argv[0], 4)) < 0)
34804910:	ba000039 	blt	348049fc <do_mem_cmp+0x118>
		return 1;
	type = size == 4 ? "word" : size == 2 ? "halfword" : "byte";
34804914:	e3560004 	cmp	r6, #4
34804918:	059f40e8 	ldreq	r4, [pc, #232]	; 34804a08 <do_mem_cmp+0x124>
3480491c:	0a000003 	beq	34804930 <do_mem_cmp+0x4c>
34804920:	e59f30e4 	ldr	r3, [pc, #228]	; 34804a0c <do_mem_cmp+0x128>
34804924:	e3560002 	cmp	r6, #2
34804928:	e59f40e0 	ldr	r4, [pc, #224]	; 34804a10 <do_mem_cmp+0x12c>
3480492c:	01a04003 	moveq	r4, r3

	addr1 = simple_strtoul(argv[1], NULL, 16);
34804930:	e5950004 	ldr	r0, [r5, #4]
34804934:	e3a01000 	mov	r1, #0
34804938:	e3a02010 	mov	r2, #16
3480493c:	eb0054ad 	bl	34819bf8 <simple_strtoul>
	addr1 += base_address;
34804940:	e59fa0cc 	ldr	sl, [pc, #204]	; 34804a14 <do_mem_cmp+0x130>

	addr2 = simple_strtoul(argv[2], NULL, 16);
34804944:	e3a01000 	mov	r1, #0
	if ((size = cmd_get_data_size(argv[0], 4)) < 0)
		return 1;
	type = size == 4 ? "word" : size == 2 ? "halfword" : "byte";

	addr1 = simple_strtoul(argv[1], NULL, 16);
	addr1 += base_address;
34804948:	e59a7000 	ldr	r7, [sl]

	addr2 = simple_strtoul(argv[2], NULL, 16);
3480494c:	e3a02010 	mov	r2, #16
	if ((size = cmd_get_data_size(argv[0], 4)) < 0)
		return 1;
	type = size == 4 ? "word" : size == 2 ? "halfword" : "byte";

	addr1 = simple_strtoul(argv[1], NULL, 16);
	addr1 += base_address;
34804950:	e0807007 	add	r7, r0, r7

	addr2 = simple_strtoul(argv[2], NULL, 16);
34804954:	e5950008 	ldr	r0, [r5, #8]
34804958:	eb0054a6 	bl	34819bf8 <simple_strtoul>
	addr2 += base_address;
3480495c:	e59aa000 	ldr	sl, [sl]

	count = simple_strtoul(argv[3], NULL, 16);
34804960:	e3a01000 	mov	r1, #0

	addr1 = simple_strtoul(argv[1], NULL, 16);
	addr1 += base_address;

	addr2 = simple_strtoul(argv[2], NULL, 16);
	addr2 += base_address;
34804964:	e080a00a 	add	sl, r0, sl

	count = simple_strtoul(argv[3], NULL, 16);
34804968:	e3a02010 	mov	r2, #16
3480496c:	e595000c 	ldr	r0, [r5, #12]
34804970:	eb0054a0 	bl	34819bf8 <simple_strtoul>
		puts ("Comparison with L1 instruction memory not supported.\n\r");
		return 0;
	}
#endif

	for (ngood = 0; ngood < count; ++ngood) {
34804974:	e3a05000 	mov	r5, #0
34804978:	ea000018 	b	348049e0 <do_mem_cmp+0xfc>
		ulong word1, word2;
		if (size == 4) {
3480497c:	e3560004 	cmp	r6, #4
			word1 = *(ulong *)addr1;
34804980:	05972000 	ldreq	r2, [r7]
			word2 = *(ulong *)addr2;
34804984:	059a3000 	ldreq	r3, [sl]
	}
#endif

	for (ngood = 0; ngood < count; ++ngood) {
		ulong word1, word2;
		if (size == 4) {
34804988:	0a000004 	beq	348049a0 <do_mem_cmp+0xbc>
			word1 = *(ulong *)addr1;
			word2 = *(ulong *)addr2;
		} else if (size == 2) {
3480498c:	e3560002 	cmp	r6, #2
			word1 = *(ushort *)addr1;
34804990:	01d720b0 	ldrheq	r2, [r7]
			word2 = *(ushort *)addr2;
34804994:	01da30b0 	ldrheq	r3, [sl]
		} else {
			word1 = *(u_char *)addr1;
34804998:	15d72000 	ldrbne	r2, [r7]
			word2 = *(u_char *)addr2;
3480499c:	15da3000 	ldrbne	r3, [sl]
		}
		if (word1 != word2) {
348049a0:	e1520003 	cmp	r2, r3
348049a4:	0a00000a 	beq	348049d4 <do_mem_cmp+0xf0>
			printf("%s at 0x%08lx (%#0*lx) != %s at 0x%08lx (%#0*lx)\n",
348049a8:	e58d2000 	str	r2, [sp]
348049ac:	e58d3010 	str	r3, [sp, #16]
348049b0:	e59f0060 	ldr	r0, [pc, #96]	; 34804a18 <do_mem_cmp+0x134>
348049b4:	e1a03006 	mov	r3, r6
348049b8:	e1a01004 	mov	r1, r4
348049bc:	e1a02007 	mov	r2, r7
348049c0:	e58d600c 	str	r6, [sp, #12]
348049c4:	e98d0410 	stmib	sp, {r4, sl}
				type, addr1, size, word1,
				type, addr2, size, word2);
			rcode = 1;
348049c8:	e3a06001 	mov	r6, #1
		} else {
			word1 = *(u_char *)addr1;
			word2 = *(u_char *)addr2;
		}
		if (word1 != word2) {
			printf("%s at 0x%08lx (%#0*lx) != %s at 0x%08lx (%#0*lx)\n",
348049cc:	eb00115e 	bl	34808f4c <printf>
				type, addr1, size, word1,
				type, addr2, size, word2);
			rcode = 1;
			break;
348049d0:	ea000005 	b	348049ec <do_mem_cmp+0x108>
		}

		addr1 += size;
348049d4:	e0877006 	add	r7, r7, r6
348049d8:	e08aa006 	add	sl, sl, r6
		puts ("Comparison with L1 instruction memory not supported.\n\r");
		return 0;
	}
#endif

	for (ngood = 0; ngood < count; ++ngood) {
348049dc:	e2855001 	add	r5, r5, #1
348049e0:	e1550000 	cmp	r5, r0
348049e4:	3affffe4 	bcc	3480497c <do_mem_cmp+0x98>

int do_mem_cmp (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	ulong	addr1, addr2, count, ngood;
	int	size;
	int     rcode = 0;
348049e8:	e3a06000 	mov	r6, #0
		/* reset watchdog from time to time */
		if ((ngood % (64 << 10)) == 0)
			WATCHDOG_RESET();
	}

	printf("Total of %ld %s(s) were the same\n", ngood, type);
348049ec:	e59f0028 	ldr	r0, [pc, #40]	; 34804a1c <do_mem_cmp+0x138>
348049f0:	e1a01005 	mov	r1, r5
348049f4:	e1a02004 	mov	r2, r4
348049f8:	eb001153 	bl	34808f4c <printf>
	return rcode;
}
348049fc:	e1a00006 	mov	r0, r6
34804a00:	e28dd018 	add	sp, sp, #24
34804a04:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
34804a08:	348240ac 	.word	0x348240ac
34804a0c:	348240a8 	.word	0x348240a8
34804a10:	348240a3 	.word	0x348240a3
34804a14:	34829210 	.word	0x34829210
34804a18:	348240b1 	.word	0x348240b1
34804a1c:	348240e3 	.word	0x348240e3

34804a20 <do_mem_mw>:
{
	return mod_mem (cmdtp, 0, flag, argc, argv);
}

int do_mem_mw ( cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
34804a20:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
34804a24:	e1a06003 	mov	r6, r3
	ulong	addr, writeval, count;
	int	size;

	if ((argc < 3) || (argc > 4))
34804a28:	e2423003 	sub	r3, r2, #3
34804a2c:	e3530001 	cmp	r3, #1
{
	return mod_mem (cmdtp, 0, flag, argc, argv);
}

int do_mem_mw ( cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
34804a30:	e1a04002 	mov	r4, r2
	ulong	addr, writeval, count;
	int	size;

	if ((argc < 3) || (argc > 4))
		return CMD_RET_USAGE;
34804a34:	83e00000 	mvnhi	r0, #0
int do_mem_mw ( cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	ulong	addr, writeval, count;
	int	size;

	if ((argc < 3) || (argc > 4))
34804a38:	88bd84f0 	pophi	{r4, r5, r6, r7, sl, pc}
		return CMD_RET_USAGE;

	/* Check for size specification.
	*/
	if ((size = cmd_get_data_size(argv[0], 4)) < 1)
34804a3c:	e5960000 	ldr	r0, [r6]
34804a40:	e3a01004 	mov	r1, #4
34804a44:	eb001062 	bl	34808bd4 <cmd_get_data_size>
34804a48:	e2507000 	subs	r7, r0, #0
34804a4c:	da00001e 	ble	34804acc <do_mem_mw+0xac>
		return 1;

	/* Address is specified since argc > 1
	*/
	addr = simple_strtoul(argv[1], NULL, 16);
34804a50:	e3a01000 	mov	r1, #0
34804a54:	e3a02010 	mov	r2, #16
34804a58:	e5960004 	ldr	r0, [r6, #4]
34804a5c:	eb005465 	bl	34819bf8 <simple_strtoul>
	addr += base_address;
34804a60:	e59f306c 	ldr	r3, [pc, #108]	; 34804ad4 <do_mem_mw+0xb4>

	/* Get the value to write.
	*/
	writeval = simple_strtoul(argv[2], NULL, 16);
34804a64:	e3a01000 	mov	r1, #0
		return 1;

	/* Address is specified since argc > 1
	*/
	addr = simple_strtoul(argv[1], NULL, 16);
	addr += base_address;
34804a68:	e5935000 	ldr	r5, [r3]

	/* Get the value to write.
	*/
	writeval = simple_strtoul(argv[2], NULL, 16);
34804a6c:	e3a02010 	mov	r2, #16
		return 1;

	/* Address is specified since argc > 1
	*/
	addr = simple_strtoul(argv[1], NULL, 16);
	addr += base_address;
34804a70:	e0805005 	add	r5, r0, r5

	/* Get the value to write.
	*/
	writeval = simple_strtoul(argv[2], NULL, 16);
34804a74:	e5960008 	ldr	r0, [r6, #8]
34804a78:	eb00545e 	bl	34819bf8 <simple_strtoul>

	/* Count ? */
	if (argc == 4) {
34804a7c:	e3540004 	cmp	r4, #4
	addr = simple_strtoul(argv[1], NULL, 16);
	addr += base_address;

	/* Get the value to write.
	*/
	writeval = simple_strtoul(argv[2], NULL, 16);
34804a80:	e1a0a000 	mov	sl, r0

	/* Count ? */
	if (argc == 4) {
		count = simple_strtoul(argv[3], NULL, 16);
	} else {
		count = 1;
34804a84:	13a00001 	movne	r0, #1
	/* Get the value to write.
	*/
	writeval = simple_strtoul(argv[2], NULL, 16);

	/* Count ? */
	if (argc == 4) {
34804a88:	1a00000c 	bne	34804ac0 <do_mem_mw+0xa0>
		count = simple_strtoul(argv[3], NULL, 16);
34804a8c:	e596000c 	ldr	r0, [r6, #12]
34804a90:	e3a01000 	mov	r1, #0
34804a94:	e3a02010 	mov	r2, #16
34804a98:	eb005456 	bl	34819bf8 <simple_strtoul>
34804a9c:	ea000007 	b	34804ac0 <do_mem_mw+0xa0>
	} else {
		count = 1;
	}

	while (count-- > 0) {
		if (size == 4)
34804aa0:	e3570004 	cmp	r7, #4
			*((ulong  *)addr) = (ulong )writeval;
34804aa4:	0585a000 	streq	sl, [r5]
	} else {
		count = 1;
	}

	while (count-- > 0) {
		if (size == 4)
34804aa8:	0a000002 	beq	34804ab8 <do_mem_mw+0x98>
			*((ulong  *)addr) = (ulong )writeval;
		else if (size == 2)
34804aac:	e3570002 	cmp	r7, #2
			*((ushort *)addr) = (ushort)writeval;
34804ab0:	01c5a0b0 	strheq	sl, [r5]
		else
			*((u_char *)addr) = (u_char)writeval;
34804ab4:	15c5a000 	strbne	sl, [r5]
34804ab8:	e0855007 	add	r5, r5, r7
34804abc:	e2400001 	sub	r0, r0, #1
		count = simple_strtoul(argv[3], NULL, 16);
	} else {
		count = 1;
	}

	while (count-- > 0) {
34804ac0:	e3500000 	cmp	r0, #0
34804ac4:	1afffff5 	bne	34804aa0 <do_mem_mw+0x80>
34804ac8:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
		return CMD_RET_USAGE;

	/* Check for size specification.
	*/
	if ((size = cmd_get_data_size(argv[0], 4)) < 1)
		return 1;
34804acc:	e3a00001 	mov	r0, #1
		else
			*((u_char *)addr) = (u_char)writeval;
		addr += size;
	}
	return 0;
}
34804ad0:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
34804ad4:	34829210 	.word	0x34829210

34804ad8 <do_mem_md>:
 * Syntax:
 *	md{.b, .w, .l} {addr} {len}
 */
#define DISP_LINE_LEN	16
int do_mem_md ( cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
34804ad8:	e92d4ef3 	push	{r0, r1, r4, r5, r6, r7, r9, sl, fp, lr}
	int rc = 0;

	/* We use the last specified parameters, unless new ones are
	 * entered.
	 */
	addr = dp_last_addr;
34804adc:	e59fa0b8 	ldr	sl, [pc, #184]	; 34804b9c <do_mem_md+0xc4>
 * Syntax:
 *	md{.b, .w, .l} {addr} {len}
 */
#define DISP_LINE_LEN	16
int do_mem_md ( cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
34804ae0:	e1a07003 	mov	r7, r3
	/* We use the last specified parameters, unless new ones are
	 * entered.
	 */
	addr = dp_last_addr;
	size = dp_last_size;
	length = dp_last_length;
34804ae4:	e59f30b4 	ldr	r3, [pc, #180]	; 34804ba0 <do_mem_md+0xc8>

	if (argc < 2)
34804ae8:	e3520001 	cmp	r2, #1
 * Syntax:
 *	md{.b, .w, .l} {addr} {len}
 */
#define DISP_LINE_LEN	16
int do_mem_md ( cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
34804aec:	e1a0b002 	mov	fp, r2
	int rc = 0;

	/* We use the last specified parameters, unless new ones are
	 * entered.
	 */
	addr = dp_last_addr;
34804af0:	e59a6004 	ldr	r6, [sl, #4]
	size = dp_last_size;
34804af4:	e59a4008 	ldr	r4, [sl, #8]
	length = dp_last_length;
34804af8:	e5935000 	ldr	r5, [r3]

	if (argc < 2)
		return CMD_RET_USAGE;
34804afc:	d3e00000 	mvnle	r0, #0
	 */
	addr = dp_last_addr;
	size = dp_last_size;
	length = dp_last_length;

	if (argc < 2)
34804b00:	da000024 	ble	34804b98 <do_mem_md+0xc0>
		return CMD_RET_USAGE;

	if ((flag & CMD_FLAG_REPEAT) == 0) {
34804b04:	e2119001 	ands	r9, r1, #1
34804b08:	1a000012 	bne	34804b58 <do_mem_md+0x80>
		/* New command specified.  Check for a size specification.
		 * Defaults to long if no or incorrect specification.
		 */
		if ((size = cmd_get_data_size(argv[0], 4)) < 0)
34804b0c:	e5970000 	ldr	r0, [r7]
34804b10:	e3a01004 	mov	r1, #4
34804b14:	eb00102e 	bl	34808bd4 <cmd_get_data_size>
34804b18:	e2504000 	subs	r4, r0, #0
			return 1;
34804b1c:	b3a00001 	movlt	r0, #1

	if ((flag & CMD_FLAG_REPEAT) == 0) {
		/* New command specified.  Check for a size specification.
		 * Defaults to long if no or incorrect specification.
		 */
		if ((size = cmd_get_data_size(argv[0], 4)) < 0)
34804b20:	ba00001c 	blt	34804b98 <do_mem_md+0xc0>
			return 1;

		/* Address is specified since argc > 1
		*/
		addr = simple_strtoul(argv[1], NULL, 16);
34804b24:	e5970004 	ldr	r0, [r7, #4]
34804b28:	e1a01009 	mov	r1, r9
34804b2c:	e3a02010 	mov	r2, #16
34804b30:	eb005430 	bl	34819bf8 <simple_strtoul>
		addr += base_address;
34804b34:	e59a6000 	ldr	r6, [sl]

		/* If another parameter, it is the length to display.
		 * Length is the number of objects, not number of bytes.
		 */
		if (argc > 2)
34804b38:	e35b0002 	cmp	fp, #2
			return 1;

		/* Address is specified since argc > 1
		*/
		addr = simple_strtoul(argv[1], NULL, 16);
		addr += base_address;
34804b3c:	e0806006 	add	r6, r0, r6

		/* If another parameter, it is the length to display.
		 * Length is the number of objects, not number of bytes.
		 */
		if (argc > 2)
34804b40:	0a000004 	beq	34804b58 <do_mem_md+0x80>
			length = simple_strtoul(argv[2], NULL, 16);
34804b44:	e5970008 	ldr	r0, [r7, #8]
34804b48:	e1a01009 	mov	r1, r9
34804b4c:	e3a02010 	mov	r2, #16
34804b50:	eb005428 	bl	34819bf8 <simple_strtoul>
34804b54:	e1a05000 	mov	r5, r0
	} else
# endif

	{
		/* Print the lines. */
		print_buffer(addr, (void*)addr, size, length, DISP_LINE_LEN/size);
34804b58:	e1a01004 	mov	r1, r4
34804b5c:	e3a00010 	mov	r0, #16
34804b60:	eb006d52 	bl	348200b0 <__divsi3>
34804b64:	e1a01006 	mov	r1, r6
34804b68:	e58d0000 	str	r0, [sp]
34804b6c:	e1a00006 	mov	r0, r6
		addr += size*length;
34804b70:	e0266495 	mla	r6, r5, r4, r6
	} else
# endif

	{
		/* Print the lines. */
		print_buffer(addr, (void*)addr, size, length, DISP_LINE_LEN/size);
34804b74:	e1a02004 	mov	r2, r4
34804b78:	e1a03005 	mov	r3, r5
34804b7c:	eb0049a4 	bl	34817214 <print_buffer>
		addr += size*length;
	}
#endif

	dp_last_addr = addr;
34804b80:	e59f3014 	ldr	r3, [pc, #20]	; 34804b9c <do_mem_md+0xc4>
	dp_last_length = length;
34804b84:	e59f2014 	ldr	r2, [pc, #20]	; 34804ba0 <do_mem_md+0xc8>
		print_buffer(addr, (void*)addr, size, length, DISP_LINE_LEN/size);
		addr += size*length;
	}
#endif

	dp_last_addr = addr;
34804b88:	e5836004 	str	r6, [r3, #4]
	dp_last_length = length;
34804b8c:	e5825000 	str	r5, [r2]
	dp_last_size = size;
34804b90:	e5834008 	str	r4, [r3, #8]
	return (rc);
34804b94:	e3a00000 	mov	r0, #0
}
34804b98:	e8bd8efc 	pop	{r2, r3, r4, r5, r6, r7, r9, sl, fp, pc}
34804b9c:	34829210 	.word	0x34829210
34804ba0:	348282f8 	.word	0x348282f8

34804ba4 <mod_mem.clone.0>:
mod_mem(cmd_tbl_t *cmdtp, int incrflag, int flag, int argc, char * const argv[])
{
	ulong	addr, i;
	int	nbytes, size;

	if (argc != 2)
34804ba4:	e3520002 	cmp	r2, #2
 * Syntax:
 *	mm{.b, .w, .l} {addr}
 *	nm{.b, .w, .l} {addr}
 */
static int
mod_mem(cmd_tbl_t *cmdtp, int incrflag, int flag, int argc, char * const argv[])
34804ba8:	e92d46f7 	push	{r0, r1, r2, r4, r5, r6, r7, r9, sl, lr}
34804bac:	e1a04000 	mov	r4, r0
34804bb0:	e1a0a003 	mov	sl, r3
{
	ulong	addr, i;
	int	nbytes, size;

	if (argc != 2)
		return CMD_RET_USAGE;
34804bb4:	13e00000 	mvnne	r0, #0
mod_mem(cmd_tbl_t *cmdtp, int incrflag, int flag, int argc, char * const argv[])
{
	ulong	addr, i;
	int	nbytes, size;

	if (argc != 2)
34804bb8:	1a000040 	bne	34804cc0 <mod_mem.clone.0+0x11c>
	reset_cmd_timeout();	/* got a good command to get here */
#endif
	/* We use the last specified parameters, unless new ones are
	 * entered.
	 */
	addr = mm_last_addr;
34804bbc:	e59f7114 	ldr	r7, [pc, #276]	; 34804cd8 <mod_mem.clone.0+0x134>
	size = mm_last_size;

	if ((flag & CMD_FLAG_REPEAT) == 0) {
34804bc0:	e2119001 	ands	r9, r1, #1
	reset_cmd_timeout();	/* got a good command to get here */
#endif
	/* We use the last specified parameters, unless new ones are
	 * entered.
	 */
	addr = mm_last_addr;
34804bc4:	e597500c 	ldr	r5, [r7, #12]
	size = mm_last_size;
34804bc8:	e5976010 	ldr	r6, [r7, #16]

	if ((flag & CMD_FLAG_REPEAT) == 0) {
34804bcc:	1a00000b 	bne	34804c00 <mod_mem.clone.0+0x5c>
		/* New command specified.  Check for a size specification.
		 * Defaults to long if no or incorrect specification.
		 */
		if ((size = cmd_get_data_size(argv[0], 4)) < 0)
34804bd0:	e5930000 	ldr	r0, [r3]
34804bd4:	e3a01004 	mov	r1, #4
34804bd8:	eb000ffd 	bl	34808bd4 <cmd_get_data_size>
34804bdc:	e2506000 	subs	r6, r0, #0
			return 1;
34804be0:	b3a00001 	movlt	r0, #1

	if ((flag & CMD_FLAG_REPEAT) == 0) {
		/* New command specified.  Check for a size specification.
		 * Defaults to long if no or incorrect specification.
		 */
		if ((size = cmd_get_data_size(argv[0], 4)) < 0)
34804be4:	ba000035 	blt	34804cc0 <mod_mem.clone.0+0x11c>
			return 1;

		/* Address is specified since argc > 1
		*/
		addr = simple_strtoul(argv[1], NULL, 16);
34804be8:	e59a0004 	ldr	r0, [sl, #4]
34804bec:	e1a01009 	mov	r1, r9
34804bf0:	e3a02010 	mov	r2, #16
34804bf4:	eb0053ff 	bl	34819bf8 <simple_strtoul>
		addr += base_address;
34804bf8:	e5975000 	ldr	r5, [r7]
34804bfc:	e0805005 	add	r5, r0, r5
			break;	/* timed out, exit the command	*/
		}
#endif
		else {
			char *endp;
			i = simple_strtoul(console_buffer, &endp, 16);
34804c00:	e59f70d4 	ldr	r7, [pc, #212]	; 34804cdc <mod_mem.clone.0+0x138>
		if (nbytes == 0 || (nbytes == 1 && console_buffer[0] == '-')) {
			/* <CR> pressed as only input, don't modify current
			 * location and move to next. "-" pressed will go back.
			 */
			if (incrflag)
				addr += nbytes ? -size : size;
34804c04:	e266a000 	rsb	sl, r6, #0
			break;	/* timed out, exit the command	*/
		}
#endif
		else {
			char *endp;
			i = simple_strtoul(console_buffer, &endp, 16);
34804c08:	e28d9004 	add	r9, sp, #4

	/* Print the address, followed by value.  Then accept input for
	 * the next value.  A non-converted value exits.
	 */
	do {
		printf("%08lx:", addr);
34804c0c:	e1a01005 	mov	r1, r5
34804c10:	e59f00c8 	ldr	r0, [pc, #200]	; 34804ce0 <mod_mem.clone.0+0x13c>
34804c14:	eb0010cc 	bl	34808f4c <printf>
		if (size == 4)
34804c18:	e3560004 	cmp	r6, #4
			printf(" %08x", *((uint   *)addr));
34804c1c:	059f00c0 	ldreq	r0, [pc, #192]	; 34804ce4 <mod_mem.clone.0+0x140>
34804c20:	05951000 	ldreq	r1, [r5]
	/* Print the address, followed by value.  Then accept input for
	 * the next value.  A non-converted value exits.
	 */
	do {
		printf("%08lx:", addr);
		if (size == 4)
34804c24:	0a000004 	beq	34804c3c <mod_mem.clone.0+0x98>
			printf(" %08x", *((uint   *)addr));
		else if (size == 2)
34804c28:	e3560002 	cmp	r6, #2
			printf(" %04x", *((ushort *)addr));
34804c2c:	059f00b4 	ldreq	r0, [pc, #180]	; 34804ce8 <mod_mem.clone.0+0x144>
34804c30:	01d510b0 	ldrheq	r1, [r5]
		else
			printf(" %02x", *((u_char *)addr));
34804c34:	159f00b0 	ldrne	r0, [pc, #176]	; 34804cec <mod_mem.clone.0+0x148>
34804c38:	15d51000 	ldrbne	r1, [r5]
34804c3c:	eb0010c2 	bl	34808f4c <printf>

		nbytes = readline (" ? ");
34804c40:	e59f00a8 	ldr	r0, [pc, #168]	; 34804cf0 <mod_mem.clone.0+0x14c>
34804c44:	eb002375 	bl	3480da20 <readline>
		if (nbytes == 0 || (nbytes == 1 && console_buffer[0] == '-')) {
34804c48:	e3500000 	cmp	r0, #0
34804c4c:	0a000004 	beq	34804c64 <mod_mem.clone.0+0xc0>
34804c50:	e3500001 	cmp	r0, #1
34804c54:	1a000009 	bne	34804c80 <mod_mem.clone.0+0xdc>
34804c58:	e5d73000 	ldrb	r3, [r7]
34804c5c:	e353002d 	cmp	r3, #45	; 0x2d
34804c60:	1a000006 	bne	34804c80 <mod_mem.clone.0+0xdc>
			/* <CR> pressed as only input, don't modify current
			 * location and move to next. "-" pressed will go back.
			 */
			if (incrflag)
34804c64:	e3540000 	cmp	r4, #0
34804c68:	0affffe7 	beq	34804c0c <mod_mem.clone.0+0x68>
				addr += nbytes ? -size : size;
34804c6c:	e3500000 	cmp	r0, #0
34804c70:	01a03006 	moveq	r3, r6
34804c74:	11a0300a 	movne	r3, sl
34804c78:	e0855003 	add	r5, r5, r3
34804c7c:	eaffffe2 	b	34804c0c <mod_mem.clone.0+0x68>
			break;	/* timed out, exit the command	*/
		}
#endif
		else {
			char *endp;
			i = simple_strtoul(console_buffer, &endp, 16);
34804c80:	e59f0054 	ldr	r0, [pc, #84]	; 34804cdc <mod_mem.clone.0+0x138>
34804c84:	e1a01009 	mov	r1, r9
34804c88:	e3a02010 	mov	r2, #16
34804c8c:	eb0053d9 	bl	34819bf8 <simple_strtoul>
			nbytes = endp - console_buffer;
			if (nbytes) {
34804c90:	e59d3004 	ldr	r3, [sp, #4]
34804c94:	e1530007 	cmp	r3, r7
34804c98:	0a000009 	beq	34804cc4 <mod_mem.clone.0+0x120>
#ifdef CONFIG_BOOT_RETRY_TIME
				/* good enough to not time out
				 */
				reset_cmd_timeout();
#endif
				if (size == 4)
34804c9c:	e3560004 	cmp	r6, #4
					*((uint   *)addr) = i;
34804ca0:	05850000 	streq	r0, [r5]
#ifdef CONFIG_BOOT_RETRY_TIME
				/* good enough to not time out
				 */
				reset_cmd_timeout();
#endif
				if (size == 4)
34804ca4:	0a000002 	beq	34804cb4 <mod_mem.clone.0+0x110>
					*((uint   *)addr) = i;
				else if (size == 2)
34804ca8:	e3560002 	cmp	r6, #2
					*((ushort *)addr) = i;
34804cac:	01c500b0 	strheq	r0, [r5]
				else
					*((u_char *)addr) = i;
34804cb0:	15c50000 	strbne	r0, [r5]
				if (incrflag)
34804cb4:	e3540000 	cmp	r4, #0
					addr += size;
34804cb8:	10855006 	addne	r5, r5, r6
34804cbc:	eaffffd2 	b	34804c0c <mod_mem.clone.0+0x68>
	} while (nbytes);

	mm_last_addr = addr;
	mm_last_size = size;
	return 0;
}
34804cc0:	e8bd86fe 	pop	{r1, r2, r3, r4, r5, r6, r7, r9, sl, pc}
					addr += size;
			}
		}
	} while (nbytes);

	mm_last_addr = addr;
34804cc4:	e59f300c 	ldr	r3, [pc, #12]	; 34804cd8 <mod_mem.clone.0+0x134>
	mm_last_size = size;
	return 0;
34804cc8:	e3a00000 	mov	r0, #0
					addr += size;
			}
		}
	} while (nbytes);

	mm_last_addr = addr;
34804ccc:	e583500c 	str	r5, [r3, #12]
	mm_last_size = size;
34804cd0:	e5836010 	str	r6, [r3, #16]
34804cd4:	eafffff9 	b	34804cc0 <mod_mem.clone.0+0x11c>
34804cd8:	34829210 	.word	0x34829210
34804cdc:	3482abdc 	.word	0x3482abdc
34804ce0:	34824105 	.word	0x34824105
34804ce4:	34826f80 	.word	0x34826f80
34804ce8:	3482410c 	.word	0x3482410c
34804cec:	34824112 	.word	0x34824112
34804cf0:	34824118 	.word	0x34824118

34804cf4 <do_mem_nm>:
{
	return mod_mem (cmdtp, 1, flag, argc, argv);
}
int do_mem_nm ( cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	return mod_mem (cmdtp, 0, flag, argc, argv);
34804cf4:	e3a00000 	mov	r0, #0
34804cf8:	eaffffa9 	b	34804ba4 <mod_mem.clone.0>

34804cfc <do_mem_mm>:
	return (rc);
}

int do_mem_mm ( cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	return mod_mem (cmdtp, 1, flag, argc, argv);
34804cfc:	e3a00001 	mov	r0, #1
34804d00:	eaffffa7 	b	34804ba4 <mod_mem.clone.0>

34804d04 <do_mmcops>:

int do_mmcops(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	enum mmc_state state;

	if (argc < 2)
34804d04:	e3520001 	cmp	r2, #1
	"display MMC info",
	"- dislay info of the current MMC device"
);

int do_mmcops(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
34804d08:	e92d4ef3 	push	{r0, r1, r4, r5, r6, r7, r9, sl, fp, lr}
34804d0c:	e1a07002 	mov	r7, r2
34804d10:	e1a04003 	mov	r4, r3
	enum mmc_state state;

	if (argc < 2)
34804d14:	da0000eb 	ble	348050c8 <do_mmcops+0x3c4>
		return CMD_RET_USAGE;

	if (curr_device < 0) {
34804d18:	e59f53b4 	ldr	r5, [pc, #948]	; 348050d4 <do_mmcops+0x3d0>
34804d1c:	e5953000 	ldr	r3, [r5]
34804d20:	e3530000 	cmp	r3, #0
34804d24:	aa000005 	bge	34804d40 <do_mmcops+0x3c>
		if (get_mmc_num() > 0)
34804d28:	eb0034ac 	bl	34811fe0 <get_mmc_num>
34804d2c:	e3500000 	cmp	r0, #0
			curr_device = 0;
34804d30:	c3a03000 	movgt	r3, #0
34804d34:	c5853000 	strgt	r3, [r5]
		else {
			puts("No MMC device available\n");
34804d38:	d59f0398 	ldrle	r0, [pc, #920]	; 348050d8 <do_mmcops+0x3d4>

	if (argc < 2)
		return CMD_RET_USAGE;

	if (curr_device < 0) {
		if (get_mmc_num() > 0)
34804d3c:	da000027 	ble	34804de0 <do_mmcops+0xdc>
			puts("No MMC device available\n");
			return 1;
		}
	}

	if (strcmp(argv[1], "rescan") == 0) {
34804d40:	e5940004 	ldr	r0, [r4, #4]
34804d44:	e59f1390 	ldr	r1, [pc, #912]	; 348050dc <do_mmcops+0x3d8>
34804d48:	eb004f58 	bl	34818ab0 <strcmp>
34804d4c:	e2505000 	subs	r5, r0, #0
34804d50:	1a000009 	bne	34804d7c <do_mmcops+0x78>
		struct mmc *mmc = find_mmc_device(curr_device);
34804d54:	e59f4378 	ldr	r4, [pc, #888]	; 348050d4 <do_mmcops+0x3d0>
34804d58:	e5940000 	ldr	r0, [r4]
34804d5c:	eb002f63 	bl	34810af0 <find_mmc_device>

		if (!mmc) {
34804d60:	e2503000 	subs	r3, r0, #0
34804d64:	0a00000f 	beq	34804da8 <do_mmcops+0xa4>
			printf("no mmc device at slot %x\n", curr_device);
			return 1;
		}

		mmc->has_init = 0;
34804d68:	e5835034 	str	r5, [r3, #52]	; 0x34

		if (mmc_init(mmc))
34804d6c:	eb00343e 	bl	34811e6c <mmc_init>
int do_mmcops(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	enum mmc_state state;

	if (argc < 2)
		return CMD_RET_USAGE;
34804d70:	e2505000 	subs	r5, r0, #0
34804d74:	13a05001 	movne	r5, #1
34804d78:	ea0000d3 	b	348050cc <do_mmcops+0x3c8>

		if (mmc_init(mmc))
			return 1;
		else
			return 0;
	} else if (strncmp(argv[1], "part", 4) == 0) {
34804d7c:	e5940004 	ldr	r0, [r4, #4]
34804d80:	e59f1358 	ldr	r1, [pc, #856]	; 348050e0 <do_mmcops+0x3dc>
34804d84:	e3a02004 	mov	r2, #4
34804d88:	eb004f54 	bl	34818ae0 <strncmp>
34804d8c:	e2505000 	subs	r5, r0, #0
34804d90:	1a000014 	bne	34804de8 <do_mmcops+0xe4>
		block_dev_desc_t *mmc_dev;
		struct mmc *mmc = find_mmc_device(curr_device);
34804d94:	e59f4338 	ldr	r4, [pc, #824]	; 348050d4 <do_mmcops+0x3d0>
34804d98:	e5940000 	ldr	r0, [r4]
34804d9c:	eb002f53 	bl	34810af0 <find_mmc_device>

		if (!mmc) {
34804da0:	e3500000 	cmp	r0, #0
34804da4:	1a000002 	bne	34804db4 <do_mmcops+0xb0>
			printf("no mmc device at slot %x\n", curr_device);
34804da8:	e59f0334 	ldr	r0, [pc, #820]	; 348050e4 <do_mmcops+0x3e0>
34804dac:	e5941000 	ldr	r1, [r4]
34804db0:	ea000092 	b	34805000 <do_mmcops+0x2fc>
			return 1;
		}
		mmc_init(mmc);
34804db4:	eb00342c 	bl	34811e6c <mmc_init>
		mmc_dev = mmc_get_dev(curr_device);
34804db8:	e5940000 	ldr	r0, [r4]
34804dbc:	eb003462 	bl	34811f4c <mmc_get_dev>
		if (mmc_dev != NULL &&
34804dc0:	e2503000 	subs	r3, r0, #0
34804dc4:	0a000004 	beq	34804ddc <do_mmcops+0xd8>
34804dc8:	e5d3300b 	ldrb	r3, [r3, #11]
34804dcc:	e35300ff 	cmp	r3, #255	; 0xff
34804dd0:	0a000001 	beq	34804ddc <do_mmcops+0xd8>
				mmc_dev->type != DEV_TYPE_UNKNOWN) {
			print_part(mmc_dev);
34804dd4:	eb002874 	bl	3480efac <print_part>
			return 0;
34804dd8:	ea0000bb 	b	348050cc <do_mmcops+0x3c8>
		}

		puts("get mmc type error!\n");
34804ddc:	e59f0304 	ldr	r0, [pc, #772]	; 348050e8 <do_mmcops+0x3e4>
34804de0:	eb00104f 	bl	34808f24 <puts>
34804de4:	ea000086 	b	34805004 <do_mmcops+0x300>
		return 1;
	} else if (strcmp(argv[1], "list") == 0) {
34804de8:	e5940004 	ldr	r0, [r4, #4]
34804dec:	e59f12f8 	ldr	r1, [pc, #760]	; 348050ec <do_mmcops+0x3e8>
34804df0:	eb004f2e 	bl	34818ab0 <strcmp>
34804df4:	e2505000 	subs	r5, r0, #0
34804df8:	1a000002 	bne	34804e08 <do_mmcops+0x104>
		print_mmc_devices('\n');
34804dfc:	e280000a 	add	r0, r0, #10
34804e00:	eb00345d 	bl	34811f7c <print_mmc_devices>
		return 0;
34804e04:	ea0000b0 	b	348050cc <do_mmcops+0x3c8>
	} else if (strcmp(argv[1], "dev") == 0) {
34804e08:	e5940004 	ldr	r0, [r4, #4]
34804e0c:	e59f12dc 	ldr	r1, [pc, #732]	; 348050f0 <do_mmcops+0x3ec>
34804e10:	eb004f26 	bl	34818ab0 <strcmp>
34804e14:	e2505000 	subs	r5, r0, #0
34804e18:	1a000048 	bne	34804f40 <do_mmcops+0x23c>
		int dev, part = -1;
		struct mmc *mmc;

		if (argc == 2)
34804e1c:	e3570002 	cmp	r7, #2
			dev = curr_device;
34804e20:	059f32ac 	ldreq	r3, [pc, #684]	; 348050d4 <do_mmcops+0x3d0>
34804e24:	05934000 	ldreq	r4, [r3]
		return 0;
	} else if (strcmp(argv[1], "dev") == 0) {
		int dev, part = -1;
		struct mmc *mmc;

		if (argc == 2)
34804e28:	0a000006 	beq	34804e48 <do_mmcops+0x144>
			dev = curr_device;
		else if (argc == 3)
34804e2c:	e3570003 	cmp	r7, #3
34804e30:	1a000006 	bne	34804e50 <do_mmcops+0x14c>
			dev = simple_strtoul(argv[2], NULL, 10);
34804e34:	e5940008 	ldr	r0, [r4, #8]
34804e38:	e1a01005 	mov	r1, r5
34804e3c:	e3a0200a 	mov	r2, #10
34804e40:	eb00536c 	bl	34819bf8 <simple_strtoul>
34804e44:	e1a04000 	mov	r4, r0
		return 1;
	} else if (strcmp(argv[1], "list") == 0) {
		print_mmc_devices('\n');
		return 0;
	} else if (strcmp(argv[1], "dev") == 0) {
		int dev, part = -1;
34804e48:	e3e07000 	mvn	r7, #0
34804e4c:	ea000010 	b	34804e94 <do_mmcops+0x190>

		if (argc == 2)
			dev = curr_device;
		else if (argc == 3)
			dev = simple_strtoul(argv[2], NULL, 10);
		else if (argc == 4) {
34804e50:	e3570004 	cmp	r7, #4
34804e54:	1a00009b 	bne	348050c8 <do_mmcops+0x3c4>
			dev = (int)simple_strtoul(argv[2], NULL, 10);
34804e58:	e1a01005 	mov	r1, r5
34804e5c:	e3a0200a 	mov	r2, #10
34804e60:	e5940008 	ldr	r0, [r4, #8]
34804e64:	eb005363 	bl	34819bf8 <simple_strtoul>
			part = (int)simple_strtoul(argv[3], NULL, 10);
34804e68:	e1a01005 	mov	r1, r5
		if (argc == 2)
			dev = curr_device;
		else if (argc == 3)
			dev = simple_strtoul(argv[2], NULL, 10);
		else if (argc == 4) {
			dev = (int)simple_strtoul(argv[2], NULL, 10);
34804e6c:	e1a06000 	mov	r6, r0
			part = (int)simple_strtoul(argv[3], NULL, 10);
34804e70:	e3a0200a 	mov	r2, #10
34804e74:	e594000c 	ldr	r0, [r4, #12]
34804e78:	eb00535e 	bl	34819bf8 <simple_strtoul>
			if (part > PART_ACCESS_MASK) {
34804e7c:	e3500007 	cmp	r0, #7
			dev = curr_device;
		else if (argc == 3)
			dev = simple_strtoul(argv[2], NULL, 10);
		else if (argc == 4) {
			dev = (int)simple_strtoul(argv[2], NULL, 10);
			part = (int)simple_strtoul(argv[3], NULL, 10);
34804e80:	e1a07000 	mov	r7, r0
			if (part > PART_ACCESS_MASK) {
				printf("#part_num shouldn't be larger"
34804e84:	c3a01007 	movgt	r1, #7
34804e88:	c59f0264 	ldrgt	r0, [pc, #612]	; 348050f4 <do_mmcops+0x3f0>
		else if (argc == 3)
			dev = simple_strtoul(argv[2], NULL, 10);
		else if (argc == 4) {
			dev = (int)simple_strtoul(argv[2], NULL, 10);
			part = (int)simple_strtoul(argv[3], NULL, 10);
			if (part > PART_ACCESS_MASK) {
34804e8c:	ca00005b 	bgt	34805000 <do_mmcops+0x2fc>
		if (argc == 2)
			dev = curr_device;
		else if (argc == 3)
			dev = simple_strtoul(argv[2], NULL, 10);
		else if (argc == 4) {
			dev = (int)simple_strtoul(argv[2], NULL, 10);
34804e90:	e1a04006 	mov	r4, r6
				return 1;
			}
		} else
			return CMD_RET_USAGE;

		mmc = find_mmc_device(dev);
34804e94:	e1a00004 	mov	r0, r4
34804e98:	eb002f14 	bl	34810af0 <find_mmc_device>
		if (!mmc) {
34804e9c:	e2505000 	subs	r5, r0, #0
			printf("no mmc device at slot %x\n", dev);
34804ea0:	059f023c 	ldreq	r0, [pc, #572]	; 348050e4 <do_mmcops+0x3e0>
34804ea4:	01a01004 	moveq	r1, r4
			}
		} else
			return CMD_RET_USAGE;

		mmc = find_mmc_device(dev);
		if (!mmc) {
34804ea8:	0a000054 	beq	34805000 <do_mmcops+0x2fc>
			printf("no mmc device at slot %x\n", dev);
			return 1;
		}

		mmc_init(mmc);
34804eac:	eb0033ee 	bl	34811e6c <mmc_init>
		if (part != -1) {
34804eb0:	e3770001 	cmn	r7, #1
34804eb4:	0a000012 	beq	34804f04 <do_mmcops+0x200>
			int ret;
			if (mmc->part_config == MMCPART_NOAVAILABLE) {
34804eb8:	e5d53082 	ldrb	r3, [r5, #130]	; 0x82
34804ebc:	e35300ff 	cmp	r3, #255	; 0xff
34804ec0:	1a000002 	bne	34804ed0 <do_mmcops+0x1cc>
				printf("Card doesn't support part_switch\n");
34804ec4:	e59f022c 	ldr	r0, [pc, #556]	; 348050f8 <do_mmcops+0x3f4>
34804ec8:	eb00101f 	bl	34808f4c <printf>
34804ecc:	ea00004c 	b	34805004 <do_mmcops+0x300>
				return 1;
			}

			if (part != mmc->part_num) {
34804ed0:	e5d53083 	ldrb	r3, [r5, #131]	; 0x83
34804ed4:	e1570003 	cmp	r7, r3
34804ed8:	0a000009 	beq	34804f04 <do_mmcops+0x200>
				ret = mmc_switch_part(dev, part);
34804edc:	e1a01007 	mov	r1, r7
34804ee0:	e1a00004 	mov	r0, r4
34804ee4:	eb00313d 	bl	348113e0 <mmc_switch_part>
				if (!ret)
34804ee8:	e3500000 	cmp	r0, #0
					mmc->part_num = part;
34804eec:	05c57083 	strbeq	r7, [r5, #131]	; 0x83

				printf("switch to partions #%d, %s\n",
34804ef0:	059f2204 	ldreq	r2, [pc, #516]	; 348050fc <do_mmcops+0x3f8>
34804ef4:	159f2204 	ldrne	r2, [pc, #516]	; 34805100 <do_mmcops+0x3fc>
34804ef8:	e59f0204 	ldr	r0, [pc, #516]	; 34805104 <do_mmcops+0x400>
34804efc:	e1a01007 	mov	r1, r7
34804f00:	eb001011 	bl	34808f4c <printf>
						part, (!ret) ? "OK" : "ERROR");
			}
		}
		curr_device = dev;
34804f04:	e59f31c8 	ldr	r3, [pc, #456]	; 348050d4 <do_mmcops+0x3d0>
34804f08:	e5834000 	str	r4, [r3]
		if (mmc->part_config == MMCPART_NOAVAILABLE)
34804f0c:	e5d53082 	ldrb	r3, [r5, #130]	; 0x82
34804f10:	e35300ff 	cmp	r3, #255	; 0xff
34804f14:	1a000003 	bne	34804f28 <do_mmcops+0x224>
			printf("mmc%d is current device\n", curr_device);
34804f18:	e1a01004 	mov	r1, r4
34804f1c:	e59f01e4 	ldr	r0, [pc, #484]	; 34805108 <do_mmcops+0x404>
34804f20:	eb001009 	bl	34808f4c <printf>
34804f24:	ea000003 	b	34804f38 <do_mmcops+0x234>
		else
			printf("mmc%d(part %d) is current device\n",
34804f28:	e59f01dc 	ldr	r0, [pc, #476]	; 3480510c <do_mmcops+0x408>
34804f2c:	e1a01004 	mov	r1, r4
34804f30:	e5d52083 	ldrb	r2, [r5, #131]	; 0x83
34804f34:	eb001004 	bl	34808f4c <printf>
				curr_device, mmc->part_num);

		return 0;
34804f38:	e3a05000 	mov	r5, #0
34804f3c:	ea000062 	b	348050cc <do_mmcops+0x3c8>
	}

	if (strcmp(argv[1], "read") == 0)
34804f40:	e5940004 	ldr	r0, [r4, #4]
34804f44:	e59f11c4 	ldr	r1, [pc, #452]	; 34805110 <do_mmcops+0x40c>
34804f48:	eb004ed8 	bl	34818ab0 <strcmp>
34804f4c:	e3500000 	cmp	r0, #0
		state = MMC_READ;
34804f50:	03a06001 	moveq	r6, #1
				curr_device, mmc->part_num);

		return 0;
	}

	if (strcmp(argv[1], "read") == 0)
34804f54:	0a00000b 	beq	34804f88 <do_mmcops+0x284>
		state = MMC_READ;
	else if (strcmp(argv[1], "write") == 0)
34804f58:	e5940004 	ldr	r0, [r4, #4]
34804f5c:	e59f11b0 	ldr	r1, [pc, #432]	; 34805114 <do_mmcops+0x410>
34804f60:	eb004ed2 	bl	34818ab0 <strcmp>
34804f64:	e3500000 	cmp	r0, #0
		state = MMC_WRITE;
34804f68:	03a06002 	moveq	r6, #2
		return 0;
	}

	if (strcmp(argv[1], "read") == 0)
		state = MMC_READ;
	else if (strcmp(argv[1], "write") == 0)
34804f6c:	0a000005 	beq	34804f88 <do_mmcops+0x284>
		state = MMC_WRITE;
	else if (strcmp(argv[1], "erase") == 0)
34804f70:	e5940004 	ldr	r0, [r4, #4]
34804f74:	e59f119c 	ldr	r1, [pc, #412]	; 34805118 <do_mmcops+0x414>
34804f78:	eb004ecc 	bl	34818ab0 <strcmp>
34804f7c:	e3500000 	cmp	r0, #0
		state = MMC_ERASE;
34804f80:	03a06003 	moveq	r6, #3

	if (strcmp(argv[1], "read") == 0)
		state = MMC_READ;
	else if (strcmp(argv[1], "write") == 0)
		state = MMC_WRITE;
	else if (strcmp(argv[1], "erase") == 0)
34804f84:	1a00004f 	bne	348050c8 <do_mmcops+0x3c4>
		state = MMC_ERASE;
	else
		state = MMC_INVALID;

	if (state != MMC_INVALID) {
		struct mmc *mmc = find_mmc_device(curr_device);
34804f88:	e59f3144 	ldr	r3, [pc, #324]	; 348050d4 <do_mmcops+0x3d0>
34804f8c:	e5930000 	ldr	r0, [r3]
34804f90:	eb002ed6 	bl	34810af0 <find_mmc_device>
		int idx = 2;
		u32 blk, cnt, n;
		void *addr;

		if (state != MMC_ERASE) {
34804f94:	e3560003 	cmp	r6, #3
		state = MMC_ERASE;
	else
		state = MMC_INVALID;

	if (state != MMC_INVALID) {
		struct mmc *mmc = find_mmc_device(curr_device);
34804f98:	e1a07000 	mov	r7, r0

		if (state != MMC_ERASE) {
			addr = (void *)simple_strtoul(argv[idx], NULL, 16);
			++idx;
		} else
			addr = 0;
34804f9c:	03a0b000 	moveq	fp, #0
	else
		state = MMC_INVALID;

	if (state != MMC_INVALID) {
		struct mmc *mmc = find_mmc_device(curr_device);
		int idx = 2;
34804fa0:	03a05002 	moveq	r5, #2
		u32 blk, cnt, n;
		void *addr;

		if (state != MMC_ERASE) {
34804fa4:	0a000005 	beq	34804fc0 <do_mmcops+0x2bc>
			addr = (void *)simple_strtoul(argv[idx], NULL, 16);
34804fa8:	e5940008 	ldr	r0, [r4, #8]
34804fac:	e3a01000 	mov	r1, #0
34804fb0:	e3a02010 	mov	r2, #16
34804fb4:	eb00530f 	bl	34819bf8 <simple_strtoul>
			++idx;
34804fb8:	e3a05003 	mov	r5, #3
		int idx = 2;
		u32 blk, cnt, n;
		void *addr;

		if (state != MMC_ERASE) {
			addr = (void *)simple_strtoul(argv[idx], NULL, 16);
34804fbc:	e1a0b000 	mov	fp, r0
			++idx;
		} else
			addr = 0;
		blk = simple_strtoul(argv[idx], NULL, 16);
34804fc0:	e7940105 	ldr	r0, [r4, r5, lsl #2]
34804fc4:	e3a01000 	mov	r1, #0
34804fc8:	e3a02010 	mov	r2, #16
34804fcc:	eb005309 	bl	34819bf8 <simple_strtoul>
		cnt = simple_strtoul(argv[idx + 1], NULL, 16);
34804fd0:	e2855001 	add	r5, r5, #1
		if (state != MMC_ERASE) {
			addr = (void *)simple_strtoul(argv[idx], NULL, 16);
			++idx;
		} else
			addr = 0;
		blk = simple_strtoul(argv[idx], NULL, 16);
34804fd4:	e1a09000 	mov	r9, r0
		cnt = simple_strtoul(argv[idx + 1], NULL, 16);
34804fd8:	e3a01000 	mov	r1, #0
34804fdc:	e7940105 	ldr	r0, [r4, r5, lsl #2]
34804fe0:	e3a02010 	mov	r2, #16
34804fe4:	eb005303 	bl	34819bf8 <simple_strtoul>

		if (!mmc) {
34804fe8:	e3570000 	cmp	r7, #0
			addr = (void *)simple_strtoul(argv[idx], NULL, 16);
			++idx;
		} else
			addr = 0;
		blk = simple_strtoul(argv[idx], NULL, 16);
		cnt = simple_strtoul(argv[idx + 1], NULL, 16);
34804fec:	e1a05000 	mov	r5, r0
34804ff0:	e59fa0dc 	ldr	sl, [pc, #220]	; 348050d4 <do_mmcops+0x3d0>

		if (!mmc) {
34804ff4:	1a000004 	bne	3480500c <do_mmcops+0x308>
			printf("no mmc device at slot %x\n", curr_device);
34804ff8:	e59f00e4 	ldr	r0, [pc, #228]	; 348050e4 <do_mmcops+0x3e0>
34804ffc:	e59a1000 	ldr	r1, [sl]
34805000:	eb000fd1 	bl	34808f4c <printf>
			return 1;
34805004:	e3a05001 	mov	r5, #1
34805008:	ea00002f 	b	348050cc <do_mmcops+0x3c8>
		}

		printf("\nMMC %s: dev # %d, block # %d, count %d ... ",
3480500c:	e58d0000 	str	r0, [sp]
34805010:	e5941004 	ldr	r1, [r4, #4]
34805014:	e59a2000 	ldr	r2, [sl]
34805018:	e1a03009 	mov	r3, r9
3480501c:	e59f00f8 	ldr	r0, [pc, #248]	; 3480511c <do_mmcops+0x418>
34805020:	eb000fc9 	bl	34808f4c <printf>
				argv[1], curr_device, blk, cnt);

		mmc_init(mmc);
34805024:	e1a00007 	mov	r0, r7
34805028:	eb00338f 	bl	34811e6c <mmc_init>

		switch (state) {
3480502c:	e3560002 	cmp	r6, #2
34805030:	0a00000c 	beq	34805068 <do_mmcops+0x364>
34805034:	e3560003 	cmp	r6, #3
34805038:	0a000011 	beq	34805084 <do_mmcops+0x380>
		case MMC_READ:
			n = mmc->block_dev.block_read(curr_device, blk,
3480503c:	e1a01009 	mov	r1, r9
34805040:	e597c100 	ldr	ip, [r7, #256]	; 0x100
34805044:	e59a0000 	ldr	r0, [sl]
34805048:	e1a02005 	mov	r2, r5
3480504c:	e1a0300b 	mov	r3, fp
34805050:	e12fff3c 	blx	ip
						      cnt, addr);
			/* flush cache after read */
			flush_cache((ulong)addr, cnt * 512); /* FIXME */
34805054:	e1a01485 	lsl	r1, r5, #9

		mmc_init(mmc);

		switch (state) {
		case MMC_READ:
			n = mmc->block_dev.block_read(curr_device, blk,
34805058:	e1a06000 	mov	r6, r0
						      cnt, addr);
			/* flush cache after read */
			flush_cache((ulong)addr, cnt * 512); /* FIXME */
3480505c:	e1a0000b 	mov	r0, fp
34805060:	ebffefee 	bl	34801020 <flush_cache>
			break;
34805064:	ea00000c 	b	3480509c <do_mmcops+0x398>
		case MMC_WRITE:
			n = mmc->block_dev.block_write(curr_device, blk,
34805068:	e597c104 	ldr	ip, [r7, #260]	; 0x104
3480506c:	e59a0000 	ldr	r0, [sl]
34805070:	e1a01009 	mov	r1, r9
34805074:	e1a02005 	mov	r2, r5
34805078:	e1a0300b 	mov	r3, fp
3480507c:	e12fff3c 	blx	ip
34805080:	ea000004 	b	34805098 <do_mmcops+0x394>
						      cnt, addr);
			break;
		case MMC_ERASE:
			n = mmc->block_dev.block_erase(curr_device, blk, cnt);
34805084:	e5973108 	ldr	r3, [r7, #264]	; 0x108
34805088:	e59a0000 	ldr	r0, [sl]
3480508c:	e1a01009 	mov	r1, r9
34805090:	e1a02005 	mov	r2, r5
34805094:	e12fff33 	blx	r3
34805098:	e1a06000 	mov	r6, r0
			break;
		default:
			BUG();
		}

		printf("%d blocks %s: %s\n",
3480509c:	e59fc05c 	ldr	ip, [pc, #92]	; 34805100 <do_mmcops+0x3fc>
348050a0:	e1560005 	cmp	r6, r5
348050a4:	e59f3050 	ldr	r3, [pc, #80]	; 348050fc <do_mmcops+0x3f8>
348050a8:	e59f0070 	ldr	r0, [pc, #112]	; 34805120 <do_mmcops+0x41c>
348050ac:	11a0300c 	movne	r3, ip
348050b0:	e1a01006 	mov	r1, r6
348050b4:	e5942004 	ldr	r2, [r4, #4]
348050b8:	eb000fa3 	bl	34808f4c <printf>
				n, argv[1], (n == cnt) ? "OK" : "ERROR");
		return (n == cnt) ? 0 : 1;
348050bc:	e0565005 	subs	r5, r6, r5
348050c0:	13a05001 	movne	r5, #1
348050c4:	ea000000 	b	348050cc <do_mmcops+0x3c8>
	}

	return CMD_RET_USAGE;
348050c8:	e3e05000 	mvn	r5, #0
}
348050cc:	e1a00005 	mov	r0, r5
348050d0:	e8bd8efc 	pop	{r2, r3, r4, r5, r6, r7, r9, sl, fp, pc}
348050d4:	348282fc 	.word	0x348282fc
348050d8:	348243d7 	.word	0x348243d7
348050dc:	348243f0 	.word	0x348243f0
348050e0:	34824e8d 	.word	0x34824e8d
348050e4:	348243f7 	.word	0x348243f7
348050e8:	34824411 	.word	0x34824411
348050ec:	34824426 	.word	0x34824426
348050f0:	3482442b 	.word	0x3482442b
348050f4:	3482442f 	.word	0x3482442f
348050f8:	34824456 	.word	0x34824456
348050fc:	348243ce 	.word	0x348243ce
34805100:	348243d1 	.word	0x348243d1
34805104:	34824478 	.word	0x34824478
34805108:	34824494 	.word	0x34824494
3480510c:	348244ad 	.word	0x348244ad
34805110:	348244cf 	.word	0x348244cf
34805114:	348244d4 	.word	0x348244d4
34805118:	348244da 	.word	0x348244da
3480511c:	348244e0 	.word	0x348244e0
34805120:	3482450d 	.word	0x3482450d

34805124 <do_mmcinfo>:

	printf("Bus Width: %d-bit\n", mmc->bus_width);
}

int do_mmcinfo (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
34805124:	e92d4037 	push	{r0, r1, r2, r4, r5, lr}
	struct mmc *mmc;

	if (curr_device < 0) {
34805128:	e59f4128 	ldr	r4, [pc, #296]	; 34805258 <do_mmcinfo+0x134>
3480512c:	e5943000 	ldr	r3, [r4]
34805130:	e3530000 	cmp	r3, #0
34805134:	aa000007 	bge	34805158 <do_mmcinfo+0x34>
		if (get_mmc_num() > 0)
34805138:	eb0033a8 	bl	34811fe0 <get_mmc_num>
3480513c:	e3500000 	cmp	r0, #0
			curr_device = 0;
34805140:	c3a03000 	movgt	r3, #0
34805144:	c5843000 	strgt	r3, [r4]
int do_mmcinfo (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	struct mmc *mmc;

	if (curr_device < 0) {
		if (get_mmc_num() > 0)
34805148:	ca000002 	bgt	34805158 <do_mmcinfo+0x34>
			curr_device = 0;
		else {
			puts("No MMC device available\n");
3480514c:	e59f0108 	ldr	r0, [pc, #264]	; 3480525c <do_mmcinfo+0x138>
34805150:	eb000f73 	bl	34808f24 <puts>
34805154:	ea00003d 	b	34805250 <do_mmcinfo+0x12c>
			return 1;
		}
	}

	mmc = find_mmc_device(curr_device);
34805158:	e59f50f8 	ldr	r5, [pc, #248]	; 34805258 <do_mmcinfo+0x134>
3480515c:	e5950000 	ldr	r0, [r5]
34805160:	eb002e62 	bl	34810af0 <find_mmc_device>

	if (mmc) {
34805164:	e2504000 	subs	r4, r0, #0
34805168:	0a000035 	beq	34805244 <do_mmcinfo+0x120>
		mmc_init(mmc);
3480516c:	eb00333e 	bl	34811e6c <mmc_init>
	MMC_WRITE,
	MMC_ERASE,
};
static void print_mmcinfo(struct mmc *mmc)
{
	printf("Device: %s\n", mmc->name);
34805170:	e2841008 	add	r1, r4, #8
34805174:	e59f00e4 	ldr	r0, [pc, #228]	; 34805260 <do_mmcinfo+0x13c>
34805178:	eb000f73 	bl	34808f4c <printf>
	printf("Manufacturer ID: %x\n", mmc->cid[0] >> 24);
3480517c:	e5d41073 	ldrb	r1, [r4, #115]	; 0x73
34805180:	e59f00dc 	ldr	r0, [pc, #220]	; 34805264 <do_mmcinfo+0x140>
34805184:	eb000f70 	bl	34808f4c <printf>
	printf("OEM: %x\n", (mmc->cid[0] >> 8) & 0xffff);
34805188:	e5941070 	ldr	r1, [r4, #112]	; 0x70
3480518c:	e59f00d4 	ldr	r0, [pc, #212]	; 34805268 <do_mmcinfo+0x144>
34805190:	e7ef1451 	ubfx	r1, r1, #8, #16
34805194:	eb000f6c 	bl	34808f4c <printf>
	printf("Name: %c%c%c%c%c \n", mmc->cid[0] & 0xff,
			(mmc->cid[1] >> 24), (mmc->cid[1] >> 16) & 0xff,
34805198:	e5943074 	ldr	r3, [r4, #116]	; 0x74
static void print_mmcinfo(struct mmc *mmc)
{
	printf("Device: %s\n", mmc->name);
	printf("Manufacturer ID: %x\n", mmc->cid[0] >> 24);
	printf("OEM: %x\n", (mmc->cid[0] >> 8) & 0xffff);
	printf("Name: %c%c%c%c%c \n", mmc->cid[0] & 0xff,
3480519c:	e5d41070 	ldrb	r1, [r4, #112]	; 0x70
348051a0:	e7e72453 	ubfx	r2, r3, #8, #8
348051a4:	e58d2000 	str	r2, [sp]
348051a8:	e20320ff 	and	r2, r3, #255	; 0xff
348051ac:	e58d2004 	str	r2, [sp, #4]
348051b0:	e59f00b4 	ldr	r0, [pc, #180]	; 3480526c <do_mmcinfo+0x148>
348051b4:	e1a02c23 	lsr	r2, r3, #24
348051b8:	e7e73853 	ubfx	r3, r3, #16, #8
348051bc:	eb000f62 	bl	34808f4c <printf>
			(mmc->cid[1] >> 24), (mmc->cid[1] >> 16) & 0xff,
			(mmc->cid[1] >> 8) & 0xff, mmc->cid[1] & 0xff);

	printf("Tran Speed: %d\n", mmc->tran_speed);
348051c0:	e5941084 	ldr	r1, [r4, #132]	; 0x84
348051c4:	e59f00a4 	ldr	r0, [pc, #164]	; 34805270 <do_mmcinfo+0x14c>
348051c8:	eb000f5f 	bl	34808f4c <printf>
	printf("Rd Block Len: %d\n", mmc->read_bl_len);
348051cc:	e5941088 	ldr	r1, [r4, #136]	; 0x88
348051d0:	e59f009c 	ldr	r0, [pc, #156]	; 34805274 <do_mmcinfo+0x150>
348051d4:	eb000f5c 	bl	34808f4c <printf>

	printf("%s version %d.%d\n", IS_SD(mmc) ? "SD" : "MMC",
348051d8:	e5943030 	ldr	r3, [r4, #48]	; 0x30
348051dc:	e59f2094 	ldr	r2, [pc, #148]	; 34805278 <do_mmcinfo+0x154>
348051e0:	e59f1094 	ldr	r1, [pc, #148]	; 3480527c <do_mmcinfo+0x158>
348051e4:	e3130802 	tst	r3, #131072	; 0x20000
348051e8:	11a01002 	movne	r1, r2
348051ec:	e59f008c 	ldr	r0, [pc, #140]	; 34805280 <do_mmcinfo+0x15c>
348051f0:	e7e32253 	ubfx	r2, r3, #4, #4
348051f4:	e203300f 	and	r3, r3, #15
348051f8:	eb000f53 	bl	34808f4c <printf>
			(mmc->version >> 4) & 0xf, mmc->version & 0xf);

	printf("High Capacity: %s\n", mmc->high_capacity ? "Yes" : "No");
348051fc:	e5941040 	ldr	r1, [r4, #64]	; 0x40
34805200:	e59f307c 	ldr	r3, [pc, #124]	; 34805284 <do_mmcinfo+0x160>
34805204:	e59f207c 	ldr	r2, [pc, #124]	; 34805288 <do_mmcinfo+0x164>
34805208:	e3510000 	cmp	r1, #0
3480520c:	01a01002 	moveq	r1, r2
34805210:	11a01003 	movne	r1, r3
34805214:	e59f0070 	ldr	r0, [pc, #112]	; 3480528c <do_mmcinfo+0x168>
34805218:	eb000f4b 	bl	34808f4c <printf>
	puts("Capacity: ");
3480521c:	e59f006c 	ldr	r0, [pc, #108]	; 34805290 <do_mmcinfo+0x16c>
34805220:	eb000f3f 	bl	34808f24 <puts>
	print_size(mmc->capacity, "\n");
34805224:	e1c409d8 	ldrd	r0, [r4, #152]	; 0x98
34805228:	e59f2064 	ldr	r2, [pc, #100]	; 34805294 <do_mmcinfo+0x170>
3480522c:	eb0047ad 	bl	348170e8 <print_size>

	printf("Bus Width: %d-bit\n", mmc->bus_width);
34805230:	e59f0060 	ldr	r0, [pc, #96]	; 34805298 <do_mmcinfo+0x174>
34805234:	e5941044 	ldr	r1, [r4, #68]	; 0x44
34805238:	eb000f43 	bl	34808f4c <printf>

	if (mmc) {
		mmc_init(mmc);

		print_mmcinfo(mmc);
		return 0;
3480523c:	e3a00000 	mov	r0, #0
34805240:	ea000003 	b	34805254 <do_mmcinfo+0x130>
	} else {
		printf("no mmc device at slot %x\n", curr_device);
34805244:	e59f0050 	ldr	r0, [pc, #80]	; 3480529c <do_mmcinfo+0x178>
34805248:	e5951000 	ldr	r1, [r5]
3480524c:	eb000f3e 	bl	34808f4c <printf>
		return 1;
34805250:	e3a00001 	mov	r0, #1
	}
}
34805254:	e8bd803e 	pop	{r1, r2, r3, r4, r5, pc}
34805258:	348282fc 	.word	0x348282fc
3480525c:	348243d7 	.word	0x348243d7
34805260:	3482452a 	.word	0x3482452a
34805264:	34824536 	.word	0x34824536
34805268:	3482454b 	.word	0x3482454b
3480526c:	34824554 	.word	0x34824554
34805270:	34824567 	.word	0x34824567
34805274:	34824577 	.word	0x34824577
34805278:	348267a4 	.word	0x348267a4
3480527c:	3482451f 	.word	0x3482451f
34805280:	34824589 	.word	0x34824589
34805284:	34824523 	.word	0x34824523
34805288:	34824527 	.word	0x34824527
3480528c:	3482459b 	.word	0x3482459b
34805290:	348245ae 	.word	0x348245ae
34805294:	348260f7 	.word	0x348260f7
34805298:	348245b9 	.word	0x348245b9
3480529c:	348243f7 	.word	0x348243f7

348052a0 <mtd_part_info>:
 * @param dev device that is to be searched for a partition
 * @param part_num requested partition number
 * @return pointer to the part_info, NULL otherwise
 */
static struct part_info* mtd_part_info(struct mtd_device *dev, unsigned int part_num)
{
348052a0:	e92d4007 	push	{r0, r1, r2, lr}
	struct list_head *entry;
	struct part_info *part;
	int num;

	if (!dev)
348052a4:	e3500000 	cmp	r0, #0
348052a8:	0a00001c 	beq	34805320 <mtd_part_info+0x80>

	debug("\n--- mtd_part_info: partition number %d for device %s%d (%s)\n",
			part_num, MTD_DEV_TYPE(dev->id->type),
			dev->id->num, dev->id->mtd_id);

	if (part_num >= dev->num_parts) {
348052ac:	e1d030bc 	ldrh	r3, [r0, #12]
348052b0:	e1510003 	cmp	r1, r3
		return NULL;
	}

	/* locate partition number, return it */
	num = 0;
	list_for_each(entry, &dev->parts) {
348052b4:	31a0c000 	movcc	ip, r0
348052b8:	35bc3010 	ldrcc	r3, [ip, #16]!
				dev->id->num, dev->id->mtd_id);
		return NULL;
	}

	/* locate partition number, return it */
	num = 0;
348052bc:	33a02000 	movcc	r2, #0

	debug("\n--- mtd_part_info: partition number %d for device %s%d (%s)\n",
			part_num, MTD_DEV_TYPE(dev->id->type),
			dev->id->num, dev->id->mtd_id);

	if (part_num >= dev->num_parts) {
348052c0:	3a000013 	bcc	34805314 <mtd_part_info+0x74>
		printf("invalid partition number %d for device %s%d (%s)\n",
				part_num, MTD_DEV_TYPE(dev->id->type),
348052c4:	e5900008 	ldr	r0, [r0, #8]
348052c8:	e5d03008 	ldrb	r3, [r0, #8]
	debug("\n--- mtd_part_info: partition number %d for device %s%d (%s)\n",
			part_num, MTD_DEV_TYPE(dev->id->type),
			dev->id->num, dev->id->mtd_id);

	if (part_num >= dev->num_parts) {
		printf("invalid partition number %d for device %s%d (%s)\n",
348052cc:	e3530002 	cmp	r3, #2
348052d0:	059f204c 	ldreq	r2, [pc, #76]	; 34805324 <mtd_part_info+0x84>
348052d4:	0a000003 	beq	348052e8 <mtd_part_info+0x48>
				part_num, MTD_DEV_TYPE(dev->id->type),
348052d8:	e59fc048 	ldr	ip, [pc, #72]	; 34805328 <mtd_part_info+0x88>
348052dc:	e3530004 	cmp	r3, #4
348052e0:	e59f2044 	ldr	r2, [pc, #68]	; 3480532c <mtd_part_info+0x8c>
348052e4:	11a0200c 	movne	r2, ip
	debug("\n--- mtd_part_info: partition number %d for device %s%d (%s)\n",
			part_num, MTD_DEV_TYPE(dev->id->type),
			dev->id->num, dev->id->mtd_id);

	if (part_num >= dev->num_parts) {
		printf("invalid partition number %d for device %s%d (%s)\n",
348052e8:	e5d03009 	ldrb	r3, [r0, #9]
348052ec:	e5900010 	ldr	r0, [r0, #16]
348052f0:	e58d0000 	str	r0, [sp]
348052f4:	e59f0034 	ldr	r0, [pc, #52]	; 34805330 <mtd_part_info+0x90>
348052f8:	eb000f13 	bl	34808f4c <printf>
348052fc:	ea000006 	b	3480531c <mtd_part_info+0x7c>
	/* locate partition number, return it */
	num = 0;
	list_for_each(entry, &dev->parts) {
		part = list_entry(entry, struct part_info, link);

		if (part_num == num++) {
34805300:	e1510002 	cmp	r1, r2
	}

	/* locate partition number, return it */
	num = 0;
	list_for_each(entry, &dev->parts) {
		part = list_entry(entry, struct part_info, link);
34805304:	e1a00003 	mov	r0, r3

		if (part_num == num++) {
34805308:	0a000004 	beq	34805320 <mtd_part_info+0x80>
		return NULL;
	}

	/* locate partition number, return it */
	num = 0;
	list_for_each(entry, &dev->parts) {
3480530c:	e5933000 	ldr	r3, [r3]
		part = list_entry(entry, struct part_info, link);

		if (part_num == num++) {
34805310:	e2822001 	add	r2, r2, #1
		return NULL;
	}

	/* locate partition number, return it */
	num = 0;
	list_for_each(entry, &dev->parts) {
34805314:	e153000c 	cmp	r3, ip
34805318:	1afffff8 	bne	34805300 <mtd_part_info+0x60>
		if (part_num == num++) {
			return part;
		}
	}

	return NULL;
3480531c:	e3a00000 	mov	r0, #0
}
34805320:	e8bd800e 	pop	{r1, r2, r3, pc}
34805324:	34824ada 	.word	0x34824ada
34805328:	34824709 	.word	0x34824709
3480532c:	34824ad7 	.word	0x34824ad7
34805330:	3482470d 	.word	0x3482470d

34805334 <index_partitions>:
 * This routine does global indexing of all partitions. Resulting index for
 * current partition is saved in 'mtddevnum'. Current partition name in
 * 'mtddevname'.
 */
static void index_partitions(void)
{
34805334:	e92d401f 	push	{r0, r1, r2, r3, r4, lr}
	struct list_head *dentry;
	struct mtd_device *dev;

	debug("--- index partitions ---\n");

	if (current_mtd_dev) {
34805338:	e59f10a0 	ldr	r1, [pc, #160]	; 348053e0 <index_partitions+0xac>
3480533c:	e5914000 	ldr	r4, [r1]
34805340:	e3540000 	cmp	r4, #0
		mtddevnum = 0;
		list_for_each(dentry, &devices) {
34805344:	15b13004 	ldrne	r3, [r1, #4]!
	struct mtd_device *dev;

	debug("--- index partitions ---\n");

	if (current_mtd_dev) {
		mtddevnum = 0;
34805348:	13a02000 	movne	r2, #0
	struct list_head *dentry;
	struct mtd_device *dev;

	debug("--- index partitions ---\n");

	if (current_mtd_dev) {
3480534c:	1a000012 	bne	3480539c <index_partitions+0x68>
34805350:	ea00001b 	b	348053c4 <index_partitions+0x90>
		mtddevnum = 0;
		list_for_each(dentry, &devices) {
			dev = list_entry(dentry, struct mtd_device, link);
			if (dev == current_mtd_dev) {
34805354:	e1530004 	cmp	r3, r4
34805358:	1a00000b 	bne	3480538c <index_partitions+0x58>
				mtddevnum += current_mtd_partnum;
3480535c:	e59f307c 	ldr	r3, [pc, #124]	; 348053e0 <index_partitions+0xac>
				sprintf(buf, "%d", mtddevnum);
34805360:	e1a0000d 	mov	r0, sp
	if (current_mtd_dev) {
		mtddevnum = 0;
		list_for_each(dentry, &devices) {
			dev = list_entry(dentry, struct mtd_device, link);
			if (dev == current_mtd_dev) {
				mtddevnum += current_mtd_partnum;
34805364:	e5d3300c 	ldrb	r3, [r3, #12]
				sprintf(buf, "%d", mtddevnum);
34805368:	e59f1074 	ldr	r1, [pc, #116]	; 348053e4 <index_partitions+0xb0>
	if (current_mtd_dev) {
		mtddevnum = 0;
		list_for_each(dentry, &devices) {
			dev = list_entry(dentry, struct mtd_device, link);
			if (dev == current_mtd_dev) {
				mtddevnum += current_mtd_partnum;
3480536c:	e0822003 	add	r2, r2, r3
				sprintf(buf, "%d", mtddevnum);
34805370:	e6ff2072 	uxth	r2, r2
34805374:	eb0052c5 	bl	34819e90 <sprintf>
				setenv("mtddevnum", buf);
34805378:	e1a0100d 	mov	r1, sp
3480537c:	e59f0064 	ldr	r0, [pc, #100]	; 348053e8 <index_partitions+0xb4>
		mtddevnum = 0;
		list_for_each(dentry, &devices) {
			dev = list_entry(dentry, struct mtd_device, link);
			if (dev == current_mtd_dev) {
				mtddevnum += current_mtd_partnum;
				sprintf(buf, "%d", mtddevnum);
34805380:	e1a0400d 	mov	r4, sp
				setenv("mtddevnum", buf);
34805384:	eb000aa4 	bl	34807e1c <setenv>
				break;
34805388:	ea000005 	b	348053a4 <index_partitions+0x70>
			}
			mtddevnum += dev->num_parts;
3480538c:	e1d300bc 	ldrh	r0, [r3, #12]

	debug("--- index partitions ---\n");

	if (current_mtd_dev) {
		mtddevnum = 0;
		list_for_each(dentry, &devices) {
34805390:	e5933000 	ldr	r3, [r3]
				mtddevnum += current_mtd_partnum;
				sprintf(buf, "%d", mtddevnum);
				setenv("mtddevnum", buf);
				break;
			}
			mtddevnum += dev->num_parts;
34805394:	e0822000 	add	r2, r2, r0
34805398:	e6ff2072 	uxth	r2, r2

	debug("--- index partitions ---\n");

	if (current_mtd_dev) {
		mtddevnum = 0;
		list_for_each(dentry, &devices) {
3480539c:	e1530001 	cmp	r3, r1
348053a0:	1affffeb 	bne	34805354 <index_partitions+0x20>
				break;
			}
			mtddevnum += dev->num_parts;
		}

		part = mtd_part_info(current_mtd_dev, current_mtd_partnum);
348053a4:	e59f3034 	ldr	r3, [pc, #52]	; 348053e0 <index_partitions+0xac>
348053a8:	e5d3100c 	ldrb	r1, [r3, #12]
348053ac:	e5930000 	ldr	r0, [r3]
348053b0:	ebffffba 	bl	348052a0 <mtd_part_info>
348053b4:	e1a03000 	mov	r3, r0
		setenv("mtddevname", part->name);
348053b8:	e5931008 	ldr	r1, [r3, #8]
348053bc:	e59f0028 	ldr	r0, [pc, #40]	; 348053ec <index_partitions+0xb8>
348053c0:	ea000004 	b	348053d8 <index_partitions+0xa4>

		debug("=> mtddevnum %d,\n=> mtddevname %s\n", mtddevnum, part->name);
	} else {
		setenv("mtddevnum", NULL);
348053c4:	e1a01004 	mov	r1, r4
348053c8:	e59f0018 	ldr	r0, [pc, #24]	; 348053e8 <index_partitions+0xb4>
348053cc:	eb000a92 	bl	34807e1c <setenv>
		setenv("mtddevname", NULL);
348053d0:	e59f0014 	ldr	r0, [pc, #20]	; 348053ec <index_partitions+0xb8>
348053d4:	e1a01004 	mov	r1, r4
348053d8:	eb000a8f 	bl	34807e1c <setenv>

		debug("=> mtddevnum NULL\n=> mtddevname NULL\n");
	}
}
348053dc:	e8bd801f 	pop	{r0, r1, r2, r3, r4, pc}
348053e0:	34829224 	.word	0x34829224
348053e4:	34826e39 	.word	0x34826e39
348053e8:	3482473f 	.word	0x3482473f
348053ec:	34824749 	.word	0x34824749

348053f0 <memsize_format>:
{
#define SIZE_GB ((u32)1024*1024*1024)
#define SIZE_MB ((u32)1024*1024)
#define SIZE_KB ((u32)1024)

	if ((size % SIZE_GB) == 0)
348053f0:	e3c13103 	bic	r3, r1, #-1073741824	; 0xc0000000
 *
 * @param buf output buffer
 * @param size size to be converted to string
 */
static void memsize_format(char *buf, u32 size)
{
348053f4:	e1a02001 	mov	r2, r1
#define SIZE_GB ((u32)1024*1024*1024)
#define SIZE_MB ((u32)1024*1024)
#define SIZE_KB ((u32)1024)

	if ((size % SIZE_GB) == 0)
348053f8:	e3530000 	cmp	r3, #0
		sprintf(buf, "%ug", size/SIZE_GB);
348053fc:	059f1030 	ldreq	r1, [pc, #48]	; 34805434 <memsize_format+0x44>
34805400:	01a02f22 	lsreq	r2, r2, #30
{
#define SIZE_GB ((u32)1024*1024*1024)
#define SIZE_MB ((u32)1024*1024)
#define SIZE_KB ((u32)1024)

	if ((size % SIZE_GB) == 0)
34805404:	0a000009 	beq	34805430 <memsize_format+0x40>
		sprintf(buf, "%ug", size/SIZE_GB);
	else if ((size % SIZE_MB) == 0)
34805408:	e3c234ff 	bic	r3, r2, #-16777216	; 0xff000000
3480540c:	e3c3360f 	bic	r3, r3, #15728640	; 0xf00000
34805410:	e3530000 	cmp	r3, #0
		sprintf(buf, "%um", size/SIZE_MB);
34805414:	059f101c 	ldreq	r1, [pc, #28]	; 34805438 <memsize_format+0x48>
34805418:	01a02a22 	lsreq	r2, r2, #20
#define SIZE_MB ((u32)1024*1024)
#define SIZE_KB ((u32)1024)

	if ((size % SIZE_GB) == 0)
		sprintf(buf, "%ug", size/SIZE_GB);
	else if ((size % SIZE_MB) == 0)
3480541c:	0a000003 	beq	34805430 <memsize_format+0x40>
		sprintf(buf, "%um", size/SIZE_MB);
	else if (size % SIZE_KB == 0)
34805420:	e1b03b02 	lsls	r3, r2, #22
		sprintf(buf, "%uk", size/SIZE_KB);
34805424:	059f1010 	ldreq	r1, [pc, #16]	; 3480543c <memsize_format+0x4c>
	else
		sprintf(buf, "%u", size);
34805428:	159f1010 	ldrne	r1, [pc, #16]	; 34805440 <memsize_format+0x50>
	if ((size % SIZE_GB) == 0)
		sprintf(buf, "%ug", size/SIZE_GB);
	else if ((size % SIZE_MB) == 0)
		sprintf(buf, "%um", size/SIZE_MB);
	else if (size % SIZE_KB == 0)
		sprintf(buf, "%uk", size/SIZE_KB);
3480542c:	01a02522 	lsreq	r2, r2, #10
	else
		sprintf(buf, "%u", size);
34805430:	ea005296 	b	34819e90 <sprintf>
34805434:	34824754 	.word	0x34824754
34805438:	34824758 	.word	0x34824758
3480543c:	3482475c 	.word	0x3482475c
34805440:	34824760 	.word	0x34824760

34805444 <current_save>:

/**
 * Save current device and partition in environment variable 'partition'.
 */
static void current_save(void)
{
34805444:	e92d4030 	push	{r4, r5, lr}
	char buf[16];

	debug("--- current_save ---\n");

	if (current_mtd_dev) {
34805448:	e59f508c 	ldr	r5, [pc, #140]	; 348054dc <current_save+0x98>

/**
 * Save current device and partition in environment variable 'partition'.
 */
static void current_save(void)
{
3480544c:	e24dd01c 	sub	sp, sp, #28
	char buf[16];

	debug("--- current_save ---\n");

	if (current_mtd_dev) {
34805450:	e5954000 	ldr	r4, [r5]
34805454:	e3540000 	cmp	r4, #0
34805458:	0a000018 	beq	348054c0 <current_save+0x7c>
		sprintf(buf, "%s%d,%d", MTD_DEV_TYPE(current_mtd_dev->id->type),
3480545c:	e5943008 	ldr	r3, [r4, #8]
34805460:	e5d31008 	ldrb	r1, [r3, #8]
34805464:	e3510002 	cmp	r1, #2
34805468:	059f2070 	ldreq	r2, [pc, #112]	; 348054e0 <current_save+0x9c>
3480546c:	0a000003 	beq	34805480 <current_save+0x3c>
34805470:	e59f006c 	ldr	r0, [pc, #108]	; 348054e4 <current_save+0xa0>
34805474:	e3510004 	cmp	r1, #4
34805478:	e59f2068 	ldr	r2, [pc, #104]	; 348054e8 <current_save+0xa4>
3480547c:	11a02000 	movne	r2, r0
34805480:	e59f5054 	ldr	r5, [pc, #84]	; 348054dc <current_save+0x98>
34805484:	e28d4008 	add	r4, sp, #8
34805488:	e5d5100c 	ldrb	r1, [r5, #12]
3480548c:	e5d33009 	ldrb	r3, [r3, #9]
34805490:	e1a00004 	mov	r0, r4
34805494:	e58d1000 	str	r1, [sp]
34805498:	e59f104c 	ldr	r1, [pc, #76]	; 348054ec <current_save+0xa8>
3480549c:	eb00527b 	bl	34819e90 <sprintf>
					current_mtd_dev->id->num, current_mtd_partnum);

		setenv("partition", buf);
348054a0:	e1a01004 	mov	r1, r4
348054a4:	e59f0044 	ldr	r0, [pc, #68]	; 348054f0 <current_save+0xac>
348054a8:	eb000a5b 	bl	34807e1c <setenv>
		strncpy(last_partition, buf, 16);
348054ac:	e2850010 	add	r0, r5, #16
348054b0:	e1a01004 	mov	r1, r4
348054b4:	e3a02010 	mov	r2, #16
348054b8:	eb004d52 	bl	34818a08 <strncpy>
348054bc:	ea000003 	b	348054d0 <current_save+0x8c>

		debug("=> partition %s\n", buf);
	} else {
		setenv("partition", NULL);
348054c0:	e59f0028 	ldr	r0, [pc, #40]	; 348054f0 <current_save+0xac>
348054c4:	e1a01004 	mov	r1, r4
348054c8:	eb000a53 	bl	34807e1c <setenv>
		last_partition[0] = '\0';
348054cc:	e5c54010 	strb	r4, [r5, #16]

		debug("=> partition NULL\n");
	}
	index_partitions();
348054d0:	ebffff97 	bl	34805334 <index_partitions>
}
348054d4:	e28dd01c 	add	sp, sp, #28
348054d8:	e8bd8030 	pop	{r4, r5, pc}
348054dc:	34829224 	.word	0x34829224
348054e0:	34824ada 	.word	0x34824ada
348054e4:	34824709 	.word	0x34824709
348054e8:	34824ad7 	.word	0x34824ad7
348054ec:	34824763 	.word	0x34824763
348054f0:	34824ea0 	.word	0x34824ea0

348054f4 <part_sort_add>:
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
348054f4:	e5903010 	ldr	r3, [r0, #16]
 *
 * @param head list this partition is to be added to
 * @param new partition to be added
 */
static int part_sort_add(struct mtd_device *dev, struct part_info *part)
{
348054f8:	e92d4070 	push	{r4, r5, r6, lr}
	struct part_info *new_pi, *curr_pi;

	/* link partition to parrent dev */
	part->dev = dev;

	if (list_empty(&dev->parts)) {
348054fc:	e2806010 	add	r6, r0, #16
 *
 * @param head list this partition is to be added to
 * @param new partition to be added
 */
static int part_sort_add(struct mtd_device *dev, struct part_info *part)
{
34805500:	e1a05001 	mov	r5, r1
	struct part_info *new_pi, *curr_pi;

	/* link partition to parrent dev */
	part->dev = dev;

	if (list_empty(&dev->parts)) {
34805504:	e1530006 	cmp	r3, r6
 *
 * @param head list this partition is to be added to
 * @param new partition to be added
 */
static int part_sort_add(struct mtd_device *dev, struct part_info *part)
{
34805508:	e1a04000 	mov	r4, r0
	struct list_head *entry;
	struct part_info *new_pi, *curr_pi;

	/* link partition to parrent dev */
	part->dev = dev;
3480550c:	e5850024 	str	r0, [r5, #36]	; 0x24

	if (list_empty(&dev->parts)) {
34805510:	1a000007 	bne	34805534 <part_sort_add+0x40>
 */
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
34805514:	e5831004 	str	r1, [r3, #4]
	new->next = next;
34805518:	e5813000 	str	r3, [r1]
	new->prev = prev;
3480551c:	e5813004 	str	r3, [r1, #4]
		debug("part_sort_add: list empty\n");
		list_add(&part->link, &dev->parts);
		dev->num_parts++;
34805520:	e1d030bc 	ldrh	r3, [r0, #12]
	prev->next = new;
34805524:	e5841010 	str	r1, [r4, #16]
34805528:	e2833001 	add	r3, r3, #1
3480552c:	e1c030bc 	strh	r3, [r0, #12]
34805530:	ea000027 	b	348055d4 <part_sort_add+0xe0>

	new_pi = list_entry(&part->link, struct part_info, link);

	/* get current partition info if we are updating current device */
	curr_pi = NULL;
	if (dev == current_mtd_dev)
34805534:	e59f30dc 	ldr	r3, [pc, #220]	; 34805618 <part_sort_add+0x124>
34805538:	e5932000 	ldr	r2, [r3]
3480553c:	e1500002 	cmp	r0, r2
	}

	new_pi = list_entry(&part->link, struct part_info, link);

	/* get current partition info if we are updating current device */
	curr_pi = NULL;
34805540:	13a00000 	movne	r0, #0
	if (dev == current_mtd_dev)
34805544:	1a000001 	bne	34805550 <part_sort_add+0x5c>
		curr_pi = mtd_part_info(current_mtd_dev, current_mtd_partnum);
34805548:	e5d3100c 	ldrb	r1, [r3, #12]
3480554c:	ebffff53 	bl	348052a0 <mtd_part_info>

	list_for_each(entry, &dev->parts) {
34805550:	e5943010 	ldr	r3, [r4, #16]
34805554:	ea000022 	b	348055e4 <part_sort_add+0xf0>
		struct part_info *pi;

		pi = list_entry(entry, struct part_info, link);

		/* be compliant with kernel cmdline, allow only one partition at offset zero */
		if ((new_pi->offset == pi->offset) && (pi->offset == 0)) {
34805558:	e5952014 	ldr	r2, [r5, #20]
3480555c:	e5931014 	ldr	r1, [r3, #20]
34805560:	e1520001 	cmp	r2, r1
34805564:	1a000005 	bne	34805580 <part_sort_add+0x8c>
34805568:	e3520000 	cmp	r2, #0
3480556c:	1a000005 	bne	34805588 <part_sort_add+0x94>
			printf("cannot add second partition at offset 0\n");
34805570:	e59f00a4 	ldr	r0, [pc, #164]	; 3480561c <part_sort_add+0x128>
34805574:	eb000e74 	bl	34808f4c <printf>
			return 1;
34805578:	e3a00001 	mov	r0, #1
3480557c:	e8bd8070 	pop	{r4, r5, r6, pc}
		}

		if (new_pi->offset <= pi->offset) {
34805580:	8a000016 	bhi	348055e0 <part_sort_add+0xec>
		struct part_info *pi;

		pi = list_entry(entry, struct part_info, link);

		/* be compliant with kernel cmdline, allow only one partition at offset zero */
		if ((new_pi->offset == pi->offset) && (pi->offset == 0)) {
34805584:	e1a02001 	mov	r2, r1
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
34805588:	e5931004 	ldr	r1, [r3, #4]
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
	new->next = next;
3480558c:	e5853000 	str	r3, [r5]
 */
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
34805590:	e5835004 	str	r5, [r3, #4]
			return 1;
		}

		if (new_pi->offset <= pi->offset) {
			list_add_tail(&part->link, entry);
			dev->num_parts++;
34805594:	e1d430bc 	ldrh	r3, [r4, #12]

			if (curr_pi && (pi->offset <= curr_pi->offset)) {
34805598:	e3500000 	cmp	r0, #0
			return 1;
		}

		if (new_pi->offset <= pi->offset) {
			list_add_tail(&part->link, entry);
			dev->num_parts++;
3480559c:	e2833001 	add	r3, r3, #1
	new->next = next;
	new->prev = prev;
348055a0:	e5851004 	str	r1, [r5, #4]
	prev->next = new;
348055a4:	e5815000 	str	r5, [r1]
348055a8:	e1c430bc 	strh	r3, [r4, #12]

			if (curr_pi && (pi->offset <= curr_pi->offset)) {
348055ac:	0a000008 	beq	348055d4 <part_sort_add+0xe0>
348055b0:	e5903014 	ldr	r3, [r0, #20]
348055b4:	e1520003 	cmp	r2, r3
348055b8:	8a000005 	bhi	348055d4 <part_sort_add+0xe0>
				/* we are modyfing partitions for the current
				 * device, update current */
				current_mtd_partnum++;
348055bc:	e59f3054 	ldr	r3, [pc, #84]	; 34805618 <part_sort_add+0x124>
348055c0:	e5d3200c 	ldrb	r2, [r3, #12]
348055c4:	e2822001 	add	r2, r2, #1
348055c8:	e5c3200c 	strb	r2, [r3, #12]
				current_save();
348055cc:	ebffff9c 	bl	34805444 <current_save>
348055d0:	ea000000 	b	348055d8 <part_sort_add+0xe4>
			} else {
				index_partitions();
348055d4:	ebffff56 	bl	34805334 <index_partitions>
			}
			return 0;
348055d8:	e3a00000 	mov	r0, #0
348055dc:	e8bd8070 	pop	{r4, r5, r6, pc}
	/* get current partition info if we are updating current device */
	curr_pi = NULL;
	if (dev == current_mtd_dev)
		curr_pi = mtd_part_info(current_mtd_dev, current_mtd_partnum);

	list_for_each(entry, &dev->parts) {
348055e0:	e5933000 	ldr	r3, [r3]
348055e4:	e1530006 	cmp	r3, r6
348055e8:	1affffda 	bne	34805558 <part_sort_add+0x64>
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
	new->next = next;
348055ec:	e5853000 	str	r3, [r5]
			return 0;
		}
	}

	list_add_tail(&part->link, &dev->parts);
	dev->num_parts++;
348055f0:	e1d430bc 	ldrh	r3, [r4, #12]
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
348055f4:	e5942014 	ldr	r2, [r4, #20]
348055f8:	e2833001 	add	r3, r3, #1
 */
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
348055fc:	e5845014 	str	r5, [r4, #20]
	new->next = next;
	new->prev = prev;
	prev->next = new;
34805600:	e5825000 	str	r5, [r2]
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
	new->next = next;
	new->prev = prev;
34805604:	e5852004 	str	r2, [r5, #4]
34805608:	e1c430bc 	strh	r3, [r4, #12]
	index_partitions();
3480560c:	ebffff48 	bl	34805334 <index_partitions>
	return 0;
34805610:	e3a00000 	mov	r0, #0
}
34805614:	e8bd8070 	pop	{r4, r5, r6, pc}
34805618:	34829224 	.word	0x34829224
3480561c:	3482476b 	.word	0x3482476b

34805620 <part_delall>:
 * Delete all partitions from parts head list, free memory.
 *
 * @param head list of partitions to delete
 */
static void part_delall(struct list_head *head)
{
34805620:	e92d4070 	push	{r4, r5, r6, lr}
34805624:	e1a06000 	mov	r6, r0
	struct list_head *entry, *n;
	struct part_info *part_tmp;

	/* clean tmp_list and free allocated memory */
	list_for_each_safe(entry, n, head) {
34805628:	e5900000 	ldr	r0, [r0]
 * in an undefined state.
 */
static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
3480562c:	e3a05000 	mov	r5, #0
34805630:	e5904000 	ldr	r4, [r0]
34805634:	ea000007 	b	34805658 <part_delall+0x38>
 * Note: list_empty() on entry does not return true after this, the entry is
 * in an undefined state.
 */
static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
34805638:	e890000c 	ldm	r0, {r2, r3}
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head *prev, struct list_head *next)
{
	next->prev = prev;
3480563c:	e5823004 	str	r3, [r2, #4]
	prev->next = next;
34805640:	e5832000 	str	r2, [r3]
 */
static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
	entry->prev = LIST_POISON2;
34805644:	e5805004 	str	r5, [r0, #4]
 * in an undefined state.
 */
static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
34805648:	e5805000 	str	r5, [r0]
		part_tmp = list_entry(entry, struct part_info, link);

		list_del(entry);
		free(part_tmp);
3480564c:	eb000f7c 	bl	34809444 <free>
{
	struct list_head *entry, *n;
	struct part_info *part_tmp;

	/* clean tmp_list and free allocated memory */
	list_for_each_safe(entry, n, head) {
34805650:	e1a00004 	mov	r0, r4
34805654:	e5944000 	ldr	r4, [r4]
34805658:	e1500006 	cmp	r0, r6
3480565c:	1afffff5 	bne	34805638 <part_delall+0x18>
		part_tmp = list_entry(entry, struct part_info, link);

		list_del(entry);
		free(part_tmp);
	}
}
34805660:	e8bd8070 	pop	{r4, r5, r6, pc}

34805664 <device_del>:
 *
 * @param dev device to be deleted
 * @return 0 on success, 1 otherwise
 */
static int device_del(struct mtd_device *dev)
{
34805664:	e92d4038 	push	{r3, r4, r5, lr}
34805668:	e1a04000 	mov	r4, r0
	part_delall(&dev->parts);
3480566c:	e2800010 	add	r0, r0, #16
34805670:	ebffffea 	bl	34805620 <part_delall>
 * Note: list_empty() on entry does not return true after this, the entry is
 * in an undefined state.
 */
static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
34805674:	e894000c 	ldm	r4, {r2, r3}
	entry->next = LIST_POISON1;
34805678:	e3a05000 	mov	r5, #0
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head *prev, struct list_head *next)
{
	next->prev = prev;
3480567c:	e5823004 	str	r3, [r2, #4]
	prev->next = next;
34805680:	e5832000 	str	r2, [r3]
 */
static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
	entry->prev = LIST_POISON2;
34805684:	e5845004 	str	r5, [r4, #4]
 * in an undefined state.
 */
static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
34805688:	e5845000 	str	r5, [r4]
	list_del(&dev->link);
	free(dev);
3480568c:	e1a00004 	mov	r0, r4
34805690:	eb000f6b 	bl	34809444 <free>

	if (dev == current_mtd_dev) {
34805694:	e59f3034 	ldr	r3, [pc, #52]	; 348056d0 <device_del+0x6c>
34805698:	e5932000 	ldr	r2, [r3]
3480569c:	e1540002 	cmp	r4, r2
348056a0:	1a000007 	bne	348056c4 <device_del+0x60>
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
348056a4:	e1a02003 	mov	r2, r3
348056a8:	e5b21004 	ldr	r1, [r2, #4]!
		/* we just deleted current device */
		if (list_empty(&devices)) {
348056ac:	e1510002 	cmp	r1, r2
			current_mtd_dev = NULL;
348056b0:	05835000 	streq	r5, [r3]
		} else {
			/* reset first partition from first dev from the
			 * devices list as current */
			current_mtd_dev = list_entry(devices.next, struct mtd_device, link);
348056b4:	15831000 	strne	r1, [r3]
			current_mtd_partnum = 0;
348056b8:	15c3500c 	strbne	r5, [r3, #12]
		}
		current_save();
348056bc:	ebffff60 	bl	34805444 <current_save>
		return 0;
348056c0:	ea000000 	b	348056c8 <device_del+0x64>
	}

	index_partitions();
348056c4:	ebffff1a 	bl	34805334 <index_partitions>
	return 0;
}
348056c8:	e3a00000 	mov	r0, #0
348056cc:	e8bd8038 	pop	{r3, r4, r5, pc}
348056d0:	34829224 	.word	0x34829224

348056d4 <memsize_parse>:
 * @param ptr where parse begins
 * @param retptr output pointer to next char after parse completes (output)
 * @return resulting unsigned int
 */
static unsigned long memsize_parse (const char *const ptr, const char **retptr)
{
348056d4:	e92d4010 	push	{r4, lr}
	unsigned long ret = simple_strtoul(ptr, (char **)retptr, 0);
348056d8:	e3a02000 	mov	r2, #0
 * @param ptr where parse begins
 * @param retptr output pointer to next char after parse completes (output)
 * @return resulting unsigned int
 */
static unsigned long memsize_parse (const char *const ptr, const char **retptr)
{
348056dc:	e1a04001 	mov	r4, r1
	unsigned long ret = simple_strtoul(ptr, (char **)retptr, 0);
348056e0:	eb005144 	bl	34819bf8 <simple_strtoul>

	switch (**retptr) {
348056e4:	e5942000 	ldr	r2, [r4]
348056e8:	e5d23000 	ldrb	r3, [r2]
348056ec:	e353004d 	cmp	r3, #77	; 0x4d
348056f0:	0a00000c 	beq	34805728 <memsize_parse+0x54>
348056f4:	8a000004 	bhi	3480570c <memsize_parse+0x38>
348056f8:	e3530047 	cmp	r3, #71	; 0x47
348056fc:	0a000008 	beq	34805724 <memsize_parse+0x50>
34805700:	e353004b 	cmp	r3, #75	; 0x4b
34805704:	18bd8010 	popne	{r4, pc}
34805708:	ea000007 	b	3480572c <memsize_parse+0x58>
3480570c:	e353006b 	cmp	r3, #107	; 0x6b
34805710:	0a000005 	beq	3480572c <memsize_parse+0x58>
34805714:	e353006d 	cmp	r3, #109	; 0x6d
34805718:	0a000002 	beq	34805728 <memsize_parse+0x54>
3480571c:	e3530067 	cmp	r3, #103	; 0x67
34805720:	18bd8010 	popne	{r4, pc}
		case 'G':
		case 'g':
			ret <<= 10;
34805724:	e1a00500 	lsl	r0, r0, #10
		case 'M':
		case 'm':
			ret <<= 10;
34805728:	e1a00500 	lsl	r0, r0, #10
		case 'K':
		case 'k':
			ret <<= 10;
			(*retptr)++;
3480572c:	e2822001 	add	r2, r2, #1
		case 'M':
		case 'm':
			ret <<= 10;
		case 'K':
		case 'k':
			ret <<= 10;
34805730:	e1a00500 	lsl	r0, r0, #10
			(*retptr)++;
34805734:	e5842000 	str	r2, [r4]
		default:
			break;
	}

	return ret;
}
34805738:	e8bd8010 	pop	{r4, pc}

3480573c <get_mtd_info>:
 * @param num mtd number
 * @param mtd a pointer to an mtd_info instance (output)
 * @return 0 if device is valid, 1 otherwise
 */
static int get_mtd_info(u8 type, u8 num, struct mtd_info **mtd)
{
3480573c:	e92d4030 	push	{r4, r5, lr}
	char mtd_dev[16];

	sprintf(mtd_dev, "%s%d", MTD_DEV_TYPE(type), num);
34805740:	e3500002 	cmp	r0, #2
 * @param num mtd number
 * @param mtd a pointer to an mtd_info instance (output)
 * @return 0 if device is valid, 1 otherwise
 */
static int get_mtd_info(u8 type, u8 num, struct mtd_info **mtd)
{
34805744:	e1a05002 	mov	r5, r2
34805748:	e24dd014 	sub	sp, sp, #20
3480574c:	e1a03001 	mov	r3, r1
	char mtd_dev[16];

	sprintf(mtd_dev, "%s%d", MTD_DEV_TYPE(type), num);
34805750:	059f2050 	ldreq	r2, [pc, #80]	; 348057a8 <get_mtd_info+0x6c>
34805754:	0a000003 	beq	34805768 <get_mtd_info+0x2c>
34805758:	e59f104c 	ldr	r1, [pc, #76]	; 348057ac <get_mtd_info+0x70>
3480575c:	e3500004 	cmp	r0, #4
34805760:	e59f2048 	ldr	r2, [pc, #72]	; 348057b0 <get_mtd_info+0x74>
34805764:	11a02001 	movne	r2, r1
34805768:	e59f1044 	ldr	r1, [pc, #68]	; 348057b4 <get_mtd_info+0x78>
3480576c:	e1a0000d 	mov	r0, sp
34805770:	eb0051c6 	bl	34819e90 <sprintf>
	*mtd = get_mtd_device_nm(mtd_dev);
34805774:	e1a0000d 	mov	r0, sp
34805778:	eb0034cc 	bl	34812ab0 <get_mtd_device_nm>
	if (IS_ERR(*mtd)) {
3480577c:	e3700a01 	cmn	r0, #4096	; 0x1000
static int get_mtd_info(u8 type, u8 num, struct mtd_info **mtd)
{
	char mtd_dev[16];

	sprintf(mtd_dev, "%s%d", MTD_DEV_TYPE(type), num);
	*mtd = get_mtd_device_nm(mtd_dev);
34805780:	e5850000 	str	r0, [r5]
 */
static int get_mtd_info(u8 type, u8 num, struct mtd_info **mtd)
{
	char mtd_dev[16];

	sprintf(mtd_dev, "%s%d", MTD_DEV_TYPE(type), num);
34805784:	e1a0400d 	mov	r4, sp
	if (IS_ERR(*mtd)) {
		printf("Device %s not found!\n", mtd_dev);
		return 1;
	}

	return 0;
34805788:	93a00000 	movls	r0, #0
{
	char mtd_dev[16];

	sprintf(mtd_dev, "%s%d", MTD_DEV_TYPE(type), num);
	*mtd = get_mtd_device_nm(mtd_dev);
	if (IS_ERR(*mtd)) {
3480578c:	9a000003 	bls	348057a0 <get_mtd_info+0x64>
		printf("Device %s not found!\n", mtd_dev);
34805790:	e59f0020 	ldr	r0, [pc, #32]	; 348057b8 <get_mtd_info+0x7c>
34805794:	e1a0100d 	mov	r1, sp
34805798:	eb000deb 	bl	34808f4c <printf>
		return 1;
3480579c:	e3a00001 	mov	r0, #1
	}

	return 0;
}
348057a0:	e28dd014 	add	sp, sp, #20
348057a4:	e8bd8030 	pop	{r4, r5, pc}
348057a8:	34824ada 	.word	0x34824ada
348057ac:	34824709 	.word	0x34824709
348057b0:	34824ad7 	.word	0x34824ad7
348057b4:	34824794 	.word	0x34824794
348057b8:	34824799 	.word	0x34824799

348057bc <part_validate_eraseblock>:
 * @param id of the parent device
 * @param part partition to validate
 * @return 0 if partition is valid, 1 otherwise
 */
static int part_validate_eraseblock(struct mtdids *id, struct part_info *part)
{
348057bc:	e92d4ef3 	push	{r0, r1, r4, r5, r6, r7, r9, sl, fp, lr}
	struct mtd_info *mtd = NULL;
348057c0:	e3a03000 	mov	r3, #0
 * @param id of the parent device
 * @param part partition to validate
 * @return 0 if partition is valid, 1 otherwise
 */
static int part_validate_eraseblock(struct mtdids *id, struct part_info *part)
{
348057c4:	e1a05000 	mov	r5, r0
	struct mtd_info *mtd = NULL;
348057c8:	e28d2008 	add	r2, sp, #8
 * @param id of the parent device
 * @param part partition to validate
 * @return 0 if partition is valid, 1 otherwise
 */
static int part_validate_eraseblock(struct mtdids *id, struct part_info *part)
{
348057cc:	e1a04001 	mov	r4, r1
	struct mtd_info *mtd = NULL;
348057d0:	e5223004 	str	r3, [r2, #-4]!
	int i, j;
	ulong start;

	if (get_mtd_info(id->type, id->num, &mtd))
348057d4:	e5d00008 	ldrb	r0, [r0, #8]
348057d8:	e5d51009 	ldrb	r1, [r5, #9]
348057dc:	ebffffd6 	bl	3480573c <get_mtd_info>
348057e0:	e3500000 	cmp	r0, #0
348057e4:	1a00001f 	bne	34805868 <part_validate_eraseblock+0xac>
		return 1;

	part->sector_size = mtd->erasesize;
348057e8:	e59d7004 	ldr	r7, [sp, #4]

	if (!mtd->numeraseregions) {
348057ec:	e597c02c 	ldr	ip, [r7, #44]	; 0x2c
	ulong start;

	if (get_mtd_info(id->type, id->num, &mtd))
		return 1;

	part->sector_size = mtd->erasesize;
348057f0:	e5976010 	ldr	r6, [r7, #16]

	if (!mtd->numeraseregions) {
348057f4:	e35c0000 	cmp	ip, #0
	ulong start;

	if (get_mtd_info(id->type, id->num, &mtd))
		return 1;

	part->sector_size = mtd->erasesize;
348057f8:	e5846020 	str	r6, [r4, #32]

	if (!mtd->numeraseregions) {
348057fc:	11a06000 	movne	r6, r0
34805800:	1a00002b 	bne	348058b4 <part_validate_eraseblock+0xf8>
		/*
		 * Only one eraseregion (NAND, OneNAND or uniform NOR),
		 * checking for alignment is easy here
		 */
		if ((unsigned long)part->offset % mtd->erasesize) {
34805804:	e5940014 	ldr	r0, [r4, #20]
34805808:	e1a01006 	mov	r1, r6
3480580c:	eb006a1f 	bl	34820090 <__aeabi_uidivmod>
34805810:	e3510000 	cmp	r1, #0
34805814:	0a000009 	beq	34805840 <part_validate_eraseblock+0x84>
			printf("%s%d: partition (%s) start offset"
			       "alignment incorrect\n",
			       MTD_DEV_TYPE(id->type), id->num, part->name);
34805818:	e5d53008 	ldrb	r3, [r5, #8]
		/*
		 * Only one eraseregion (NAND, OneNAND or uniform NOR),
		 * checking for alignment is easy here
		 */
		if ((unsigned long)part->offset % mtd->erasesize) {
			printf("%s%d: partition (%s) start offset"
3480581c:	e3530002 	cmp	r3, #2
34805820:	059f113c 	ldreq	r1, [pc, #316]	; 34805964 <part_validate_eraseblock+0x1a8>
34805824:	0a000003 	beq	34805838 <part_validate_eraseblock+0x7c>
			       "alignment incorrect\n",
			       MTD_DEV_TYPE(id->type), id->num, part->name);
34805828:	e59f2138 	ldr	r2, [pc, #312]	; 34805968 <part_validate_eraseblock+0x1ac>
3480582c:	e3530004 	cmp	r3, #4
34805830:	e59f1134 	ldr	r1, [pc, #308]	; 3480596c <part_validate_eraseblock+0x1b0>
34805834:	01a01002 	moveq	r1, r2
		/*
		 * Only one eraseregion (NAND, OneNAND or uniform NOR),
		 * checking for alignment is easy here
		 */
		if ((unsigned long)part->offset % mtd->erasesize) {
			printf("%s%d: partition (%s) start offset"
34805838:	e59f0130 	ldr	r0, [pc, #304]	; 34805970 <part_validate_eraseblock+0x1b4>
3480583c:	ea000006 	b	3480585c <part_validate_eraseblock+0xa0>
			       "alignment incorrect\n",
			       MTD_DEV_TYPE(id->type), id->num, part->name);
			return 1;
		}

		if (part->size % mtd->erasesize) {
34805840:	e5940010 	ldr	r0, [r4, #16]
34805844:	e1a01006 	mov	r1, r6
34805848:	eb006a10 	bl	34820090 <__aeabi_uidivmod>
3480584c:	e2510000 	subs	r0, r1, #0
34805850:	1a000038 	bne	34805938 <part_validate_eraseblock+0x17c>
34805854:	ea000041 	b	34805960 <part_validate_eraseblock+0x1a4>
			printf("%s%d: partition (%s) size alignment incorrect\n",
34805858:	e59f0114 	ldr	r0, [pc, #276]	; 34805974 <part_validate_eraseblock+0x1b8>
3480585c:	e5d52009 	ldrb	r2, [r5, #9]
34805860:	e5943008 	ldr	r3, [r4, #8]
34805864:	eb000db8 	bl	34808f4c <printf>
			       MTD_DEV_TYPE(id->type), id->num, part->name);
			return 1;
34805868:	e3a00001 	mov	r0, #1
3480586c:	ea00003b 	b	34805960 <part_validate_eraseblock+0x1a4>
		 * checking for alignment is more complex here
		 */

		/* Check start alignment */
		for (i = 0; i < mtd->numeraseregions; i++) {
			start = mtd->eraseregions[i].offset;
34805870:	e5971030 	ldr	r1, [r7, #48]	; 0x30
			for (j = 0; j < mtd->eraseregions[i].numblocks; j++) {
34805874:	e3a0a000 	mov	sl, #0
		 * checking for alignment is more complex here
		 */

		/* Check start alignment */
		for (i = 0; i < mtd->numeraseregions; i++) {
			start = mtd->eraseregions[i].offset;
34805878:	e0819000 	add	r9, r1, r0
3480587c:	e7913000 	ldr	r3, [r1, r0]
			for (j = 0; j < mtd->eraseregions[i].numblocks; j++) {
34805880:	e599b00c 	ldr	fp, [r9, #12]
34805884:	ea000006 	b	348058a4 <part_validate_eraseblock+0xe8>
				if (part->offset == start)
34805888:	e5942014 	ldr	r2, [r4, #20]
3480588c:	e1520003 	cmp	r2, r3
34805890:	03a00000 	moveq	r0, #0
34805894:	0a000021 	beq	34805920 <part_validate_eraseblock+0x164>
					goto start_ok;
				start += mtd->eraseregions[i].erasesize;
34805898:	e5992008 	ldr	r2, [r9, #8]
		 */

		/* Check start alignment */
		for (i = 0; i < mtd->numeraseregions; i++) {
			start = mtd->eraseregions[i].offset;
			for (j = 0; j < mtd->eraseregions[i].numblocks; j++) {
3480589c:	e28aa001 	add	sl, sl, #1
				if (part->offset == start)
					goto start_ok;
				start += mtd->eraseregions[i].erasesize;
348058a0:	e0833002 	add	r3, r3, r2
		 */

		/* Check start alignment */
		for (i = 0; i < mtd->numeraseregions; i++) {
			start = mtd->eraseregions[i].offset;
			for (j = 0; j < mtd->eraseregions[i].numblocks; j++) {
348058a4:	e15a000b 	cmp	sl, fp
348058a8:	3afffff6 	bcc	34805888 <part_validate_eraseblock+0xcc>
		 * Multiple eraseregions (non-uniform NOR),
		 * checking for alignment is more complex here
		 */

		/* Check start alignment */
		for (i = 0; i < mtd->numeraseregions; i++) {
348058ac:	e2866001 	add	r6, r6, #1
348058b0:	e2800018 	add	r0, r0, #24
348058b4:	e156000c 	cmp	r6, ip
348058b8:	baffffec 	blt	34805870 <part_validate_eraseblock+0xb4>
				start += mtd->eraseregions[i].erasesize;
			}
		}

		printf("%s%d: partition (%s) start offset alignment incorrect\n",
		       MTD_DEV_TYPE(id->type), id->num, part->name);
348058bc:	e5d53008 	ldrb	r3, [r5, #8]
					goto start_ok;
				start += mtd->eraseregions[i].erasesize;
			}
		}

		printf("%s%d: partition (%s) start offset alignment incorrect\n",
348058c0:	e3530002 	cmp	r3, #2
348058c4:	059f1098 	ldreq	r1, [pc, #152]	; 34805964 <part_validate_eraseblock+0x1a8>
348058c8:	0a000003 	beq	348058dc <part_validate_eraseblock+0x120>
		       MTD_DEV_TYPE(id->type), id->num, part->name);
348058cc:	e59f2094 	ldr	r2, [pc, #148]	; 34805968 <part_validate_eraseblock+0x1ac>
348058d0:	e3530004 	cmp	r3, #4
348058d4:	e59f1090 	ldr	r1, [pc, #144]	; 3480596c <part_validate_eraseblock+0x1b0>
348058d8:	01a01002 	moveq	r1, r2
					goto start_ok;
				start += mtd->eraseregions[i].erasesize;
			}
		}

		printf("%s%d: partition (%s) start offset alignment incorrect\n",
348058dc:	e59f0094 	ldr	r0, [pc, #148]	; 34805978 <part_validate_eraseblock+0x1bc>
348058e0:	eaffffdd 	b	3480585c <part_validate_eraseblock+0xa0>

	start_ok:

		/* Check end/size alignment */
		for (i = 0; i < mtd->numeraseregions; i++) {
			start = mtd->eraseregions[i].offset;
348058e4:	e5913000 	ldr	r3, [r1]
			for (j = 0; j < mtd->eraseregions[i].numblocks; j++) {
348058e8:	e591700c 	ldr	r7, [r1, #12]
348058ec:	e3a06000 	mov	r6, #0
348058f0:	ea000006 	b	34805910 <part_validate_eraseblock+0x154>
				if ((part->offset + part->size) == start)
348058f4:	e594a010 	ldr	sl, [r4, #16]
348058f8:	e082a00a 	add	sl, r2, sl
348058fc:	e15a0003 	cmp	sl, r3
34805900:	0a000015 	beq	3480595c <part_validate_eraseblock+0x1a0>
					goto end_ok;
				start += mtd->eraseregions[i].erasesize;
34805904:	e591a008 	ldr	sl, [r1, #8]
	start_ok:

		/* Check end/size alignment */
		for (i = 0; i < mtd->numeraseregions; i++) {
			start = mtd->eraseregions[i].offset;
			for (j = 0; j < mtd->eraseregions[i].numblocks; j++) {
34805908:	e2866001 	add	r6, r6, #1
				if ((part->offset + part->size) == start)
					goto end_ok;
				start += mtd->eraseregions[i].erasesize;
3480590c:	e083300a 	add	r3, r3, sl
	start_ok:

		/* Check end/size alignment */
		for (i = 0; i < mtd->numeraseregions; i++) {
			start = mtd->eraseregions[i].offset;
			for (j = 0; j < mtd->eraseregions[i].numblocks; j++) {
34805910:	e1560007 	cmp	r6, r7
34805914:	3afffff6 	bcc	348058f4 <part_validate_eraseblock+0x138>
		return 1;

	start_ok:

		/* Check end/size alignment */
		for (i = 0; i < mtd->numeraseregions; i++) {
34805918:	e2800001 	add	r0, r0, #1
3480591c:	e2811018 	add	r1, r1, #24
34805920:	e150000c 	cmp	r0, ip
34805924:	baffffee 	blt	348058e4 <part_validate_eraseblock+0x128>
					goto end_ok;
				start += mtd->eraseregions[i].erasesize;
			}
		}
		/* Check last sector alignment */
		if ((part->offset + part->size) == start)
34805928:	e5941010 	ldr	r1, [r4, #16]
3480592c:	e0822001 	add	r2, r2, r1
34805930:	e1520003 	cmp	r2, r3
34805934:	0a000008 	beq	3480595c <part_validate_eraseblock+0x1a0>
			goto end_ok;

		printf("%s%d: partition (%s) size alignment incorrect\n",
		       MTD_DEV_TYPE(id->type), id->num, part->name);
34805938:	e5d53008 	ldrb	r3, [r5, #8]
		}
		/* Check last sector alignment */
		if ((part->offset + part->size) == start)
			goto end_ok;

		printf("%s%d: partition (%s) size alignment incorrect\n",
3480593c:	e3530002 	cmp	r3, #2
			       MTD_DEV_TYPE(id->type), id->num, part->name);
			return 1;
		}

		if (part->size % mtd->erasesize) {
			printf("%s%d: partition (%s) size alignment incorrect\n",
34805940:	059f101c 	ldreq	r1, [pc, #28]	; 34805964 <part_validate_eraseblock+0x1a8>
		}
		/* Check last sector alignment */
		if ((part->offset + part->size) == start)
			goto end_ok;

		printf("%s%d: partition (%s) size alignment incorrect\n",
34805944:	0affffc3 	beq	34805858 <part_validate_eraseblock+0x9c>
		       MTD_DEV_TYPE(id->type), id->num, part->name);
34805948:	e59f2018 	ldr	r2, [pc, #24]	; 34805968 <part_validate_eraseblock+0x1ac>
3480594c:	e3530004 	cmp	r3, #4
34805950:	e59f1014 	ldr	r1, [pc, #20]	; 3480596c <part_validate_eraseblock+0x1b0>
34805954:	01a01002 	moveq	r1, r2
34805958:	eaffffbe 	b	34805858 <part_validate_eraseblock+0x9c>
		return 1;

	end_ok:
		return 0;
3480595c:	e3a00000 	mov	r0, #0
	}

	return 0;
}
34805960:	e8bd8efc 	pop	{r2, r3, r4, r5, r6, r7, r9, sl, fp, pc}
34805964:	34824ada 	.word	0x34824ada
34805968:	34824ad7 	.word	0x34824ad7
3480596c:	34824709 	.word	0x34824709
34805970:	348247af 	.word	0x348247af
34805974:	348247e5 	.word	0x348247e5
34805978:	34824814 	.word	0x34824814

3480597c <device_delall.clone.2>:
 * Delete all mtd devices from a supplied devices list, free memory allocated for
 * each device and delete all device partitions.
 *
 * @return 0 on success, 1 otherwise
 */
static int device_delall(struct list_head *head)
3480597c:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
{
	struct list_head *entry, *n;
	struct mtd_device *dev_tmp;

	/* clean devices list */
	list_for_each_safe(entry, n, head) {
34805980:	e59f6054 	ldr	r6, [pc, #84]	; 348059dc <device_delall.clone.2+0x60>
 * in an undefined state.
 */
static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
34805984:	e3a07000 	mov	r7, #0
34805988:	e5b64004 	ldr	r4, [r6, #4]!
3480598c:	e5945000 	ldr	r5, [r4]
34805990:	ea00000a 	b	348059c0 <device_delall.clone.2+0x44>
 * Note: list_empty() on entry does not return true after this, the entry is
 * in an undefined state.
 */
static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
34805994:	e894000c 	ldm	r4, {r2, r3}
		dev_tmp = list_entry(entry, struct mtd_device, link);
		list_del(entry);
		part_delall(&dev_tmp->parts);
34805998:	e2840010 	add	r0, r4, #16
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head *prev, struct list_head *next)
{
	next->prev = prev;
3480599c:	e5823004 	str	r3, [r2, #4]
	prev->next = next;
348059a0:	e5832000 	str	r2, [r3]
 */
static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
	entry->prev = LIST_POISON2;
348059a4:	e5847004 	str	r7, [r4, #4]
 * in an undefined state.
 */
static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
348059a8:	e5847000 	str	r7, [r4]
348059ac:	ebffff1b 	bl	34805620 <part_delall>
		free(dev_tmp);
348059b0:	e1a00004 	mov	r0, r4
348059b4:	eb000ea2 	bl	34809444 <free>
{
	struct list_head *entry, *n;
	struct mtd_device *dev_tmp;

	/* clean devices list */
	list_for_each_safe(entry, n, head) {
348059b8:	e1a04005 	mov	r4, r5
348059bc:	e5955000 	ldr	r5, [r5]
348059c0:	e1540006 	cmp	r4, r6
{
	last_parts[0] = '\0';
	current_mtd_dev = NULL;
	current_save();

	return device_delall(&devices);
348059c4:	e59f3010 	ldr	r3, [pc, #16]	; 348059dc <device_delall.clone.2+0x60>
{
	struct list_head *entry, *n;
	struct mtd_device *dev_tmp;

	/* clean devices list */
	list_for_each_safe(entry, n, head) {
348059c8:	1afffff1 	bne	34805994 <device_delall.clone.2+0x18>
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
348059cc:	e5834004 	str	r4, [r3, #4]
	list->prev = list;
348059d0:	e5834008 	str	r4, [r3, #8]
		free(dev_tmp);
	}
	INIT_LIST_HEAD(&devices);

	return 0;
}
348059d4:	e3a00000 	mov	r0, #0
348059d8:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
348059dc:	34829224 	.word	0x34829224

348059e0 <mtd_devices_init>:
 *
 * @return 0 on success, 1 otherwise
 */
static int mtd_devices_init(void)
{
	last_parts[0] = '\0';
348059e0:	e59f3018 	ldr	r3, [pc, #24]	; 34805a00 <mtd_devices_init+0x20>
348059e4:	e3a02000 	mov	r2, #0
 * Initialize global device list.
 *
 * @return 0 on success, 1 otherwise
 */
static int mtd_devices_init(void)
{
348059e8:	e92d4010 	push	{r4, lr}
	last_parts[0] = '\0';
348059ec:	e5c32020 	strb	r2, [r3, #32]
	current_mtd_dev = NULL;
348059f0:	e5832000 	str	r2, [r3]
	current_save();
348059f4:	ebfffe92 	bl	34805444 <current_save>

	return device_delall(&devices);
}
348059f8:	e8bd4010 	pop	{r4, lr}
{
	last_parts[0] = '\0';
	current_mtd_dev = NULL;
	current_save();

	return device_delall(&devices);
348059fc:	eaffffde 	b	3480597c <device_delall.clone.2>
34805a00:	34829224 	.word	0x34829224

34805a04 <generate_mtdparts_save.clone.1>:
 *
 * @param buf output buffer holding generated mtdparts string (output)
 * @param buflen buffer size
 * @return 0 on success, 1 otherwise
 */
static int generate_mtdparts_save(char *buf, u32 buflen)
34805a04:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
34805a08:	e59f52a8 	ldr	r5, [pc, #680]	; 34805cb8 <generate_mtdparts_save.clone.1+0x2b4>
34805a0c:	e24dd030 	sub	sp, sp, #48	; 0x30
	u32 size, offset, len, part_cnt;
	u32 maxlen = buflen - 1;

	debug("--- generate_mtdparts ---\n");

	if (list_empty(&devices)) {
34805a10:	e5952004 	ldr	r2, [r5, #4]
34805a14:	e2853004 	add	r3, r5, #4
34805a18:	e1520003 	cmp	r2, r3
		buf[0] = '\0';
34805a1c:	03a04000 	moveq	r4, #0
34805a20:	05c54020 	strbeq	r4, [r5, #32]
	u32 size, offset, len, part_cnt;
	u32 maxlen = buflen - 1;

	debug("--- generate_mtdparts ---\n");

	if (list_empty(&devices)) {
34805a24:	0a000095 	beq	34805c80 <generate_mtdparts_save.clone.1+0x27c>
		buf[0] = '\0';
		return 0;
	}

	sprintf(p, "mtdparts=");
34805a28:	e2850020 	add	r0, r5, #32
34805a2c:	e59f1288 	ldr	r1, [pc, #648]	; 34805cbc <generate_mtdparts_save.clone.1+0x2b8>
34805a30:	eb005116 	bl	34819e90 <sprintf>
	struct mtd_device *dev;
	struct part_info *part, *prev_part;
	char *p = buf;
	char tmpbuf[32];
	u32 size, offset, len, part_cnt;
	u32 maxlen = buflen - 1;
34805a34:	e30041ff 	movw	r4, #511	; 0x1ff
	}

	sprintf(p, "mtdparts=");
	p += 9;

	list_for_each(dentry, &devices) {
34805a38:	e5957004 	ldr	r7, [r5, #4]
			size = part->size;
			offset = part->offset;
			part_cnt++;

			/* partition size */
			memsize_format(tmpbuf, size);
34805a3c:	e28d9010 	add	r9, sp, #16
		buf[0] = '\0';
		return 0;
	}

	sprintf(p, "mtdparts=");
	p += 9;
34805a40:	e2855029 	add	r5, r5, #41	; 0x29
34805a44:	ea000083 	b	34805c58 <generate_mtdparts_save.clone.1+0x254>

	list_for_each(dentry, &devices) {
		dev = list_entry(dentry, struct mtd_device, link);

		/* copy mtd_id */
		len = strlen(dev->id->mtd_id) + 1;
34805a48:	e5973008 	ldr	r3, [r7, #8]
34805a4c:	e5930010 	ldr	r0, [r3, #16]
34805a50:	eb004c4a 	bl	34818b80 <strlen>
34805a54:	e280a001 	add	sl, r0, #1
		if (len > maxlen)
34805a58:	e15a0004 	cmp	sl, r4

	list_for_each(dentry, &devices) {
		dev = list_entry(dentry, struct mtd_device, link);

		/* copy mtd_id */
		len = strlen(dev->id->mtd_id) + 1;
34805a5c:	e1a06000 	mov	r6, r0
		if (len > maxlen)
34805a60:	8a000082 	bhi	34805c70 <generate_mtdparts_save.clone.1+0x26c>
			goto cleanup;
		memcpy(p, dev->id->mtd_id, len - 1);
34805a64:	e5973008 	ldr	r3, [r7, #8]
34805a68:	e1a00005 	mov	r0, r5
34805a6c:	e5931010 	ldr	r1, [r3, #16]
34805a70:	e1a02006 	mov	r2, r6
34805a74:	eb004d05 	bl	34818e90 <memcpy>
		p += len - 1;
		*(p++) = ':';
34805a78:	e3a0203a 	mov	r2, #58	; 0x3a
34805a7c:	e7c52006 	strb	r2, [r5, r6]
		maxlen -= len;

		/* format partitions */
		prev_part = NULL;
		part_cnt = 0;
		list_for_each(pentry, &dev->parts) {
34805a80:	e1a02007 	mov	r2, r7
		/* copy mtd_id */
		len = strlen(dev->id->mtd_id) + 1;
		if (len > maxlen)
			goto cleanup;
		memcpy(p, dev->id->mtd_id, len - 1);
		p += len - 1;
34805a84:	e0853006 	add	r3, r5, r6
		*(p++) = ':';
		maxlen -= len;
34805a88:	e06a4004 	rsb	r4, sl, r4

		/* format partitions */
		prev_part = NULL;
		part_cnt = 0;
		list_for_each(pentry, &dev->parts) {
34805a8c:	e5b2a010 	ldr	sl, [r2, #16]!
		len = strlen(dev->id->mtd_id) + 1;
		if (len > maxlen)
			goto cleanup;
		memcpy(p, dev->id->mtd_id, len - 1);
		p += len - 1;
		*(p++) = ':';
34805a90:	e2835001 	add	r5, r3, #1
		maxlen -= len;

		/* format partitions */
		prev_part = NULL;
		part_cnt = 0;
34805a94:	e3a03000 	mov	r3, #0
		list_for_each(pentry, &dev->parts) {
34805a98:	e88d0088 	stm	sp, {r3, r7}
34805a9c:	e58d2004 	str	r2, [sp, #4]
		p += len - 1;
		*(p++) = ':';
		maxlen -= len;

		/* format partitions */
		prev_part = NULL;
34805aa0:	e1a0b003 	mov	fp, r3
34805aa4:	ea00005e 	b	34805c24 <generate_mtdparts_save.clone.1+0x220>
		part_cnt = 0;
		list_for_each(pentry, &dev->parts) {
			part = list_entry(pentry, struct part_info, link);
			size = part->size;
			offset = part->offset;
34805aa8:	e59a2014 	ldr	r2, [sl, #20]
			part_cnt++;

			/* partition size */
			memsize_format(tmpbuf, size);
34805aac:	e1a00009 	mov	r0, r9
34805ab0:	e59a1010 	ldr	r1, [sl, #16]
		prev_part = NULL;
		part_cnt = 0;
		list_for_each(pentry, &dev->parts) {
			part = list_entry(pentry, struct part_info, link);
			size = part->size;
			offset = part->offset;
34805ab4:	e58d2008 	str	r2, [sp, #8]

		/* format partitions */
		prev_part = NULL;
		part_cnt = 0;
		list_for_each(pentry, &dev->parts) {
			part = list_entry(pentry, struct part_info, link);
34805ab8:	e58da00c 	str	sl, [sp, #12]
			size = part->size;
			offset = part->offset;
			part_cnt++;

			/* partition size */
			memsize_format(tmpbuf, size);
34805abc:	ebfffe4b 	bl	348053f0 <memsize_format>
			len = strlen(tmpbuf);
34805ac0:	e1a00009 	mov	r0, r9
34805ac4:	eb004c2d 	bl	34818b80 <strlen>
			if (len > maxlen)
34805ac8:	e1500004 	cmp	r0, r4
			offset = part->offset;
			part_cnt++;

			/* partition size */
			memsize_format(tmpbuf, size);
			len = strlen(tmpbuf);
34805acc:	e1a06000 	mov	r6, r0
			if (len > maxlen)
34805ad0:	8a000066 	bhi	34805c70 <generate_mtdparts_save.clone.1+0x26c>
				goto cleanup;
			memcpy(p, tmpbuf, len);
34805ad4:	e1a00005 	mov	r0, r5
34805ad8:	e1a02006 	mov	r2, r6
34805adc:	e1a01009 	mov	r1, r9
34805ae0:	eb004cea 	bl	34818e90 <memcpy>
			maxlen -= len;


			/* add offset only when there is a gap between
			 * partitions */
			if ((!prev_part && (offset != 0)) ||
34805ae4:	e59d2008 	ldr	r2, [sp, #8]
34805ae8:	e27b3001 	rsbs	r3, fp, #1
34805aec:	33a03000 	movcc	r3, #0
34805af0:	e3520000 	cmp	r2, #0
34805af4:	03a03000 	moveq	r3, #0
34805af8:	e3530000 	cmp	r3, #0
			memsize_format(tmpbuf, size);
			len = strlen(tmpbuf);
			if (len > maxlen)
				goto cleanup;
			memcpy(p, tmpbuf, len);
			p += len;
34805afc:	e0855006 	add	r5, r5, r6
			maxlen -= len;
34805b00:	e0664004 	rsb	r4, r6, r4


			/* add offset only when there is a gap between
			 * partitions */
			if ((!prev_part && (offset != 0)) ||
34805b04:	1a000007 	bne	34805b28 <generate_mtdparts_save.clone.1+0x124>
34805b08:	e35b0000 	cmp	fp, #0
34805b0c:	0a000016 	beq	34805b6c <generate_mtdparts_save.clone.1+0x168>
					(prev_part && ((prev_part->offset + prev_part->size) != part->offset))) {
34805b10:	e59b3014 	ldr	r3, [fp, #20]
34805b14:	e59b2010 	ldr	r2, [fp, #16]
34805b18:	e0822003 	add	r2, r2, r3
34805b1c:	e59a3014 	ldr	r3, [sl, #20]
34805b20:	e1520003 	cmp	r2, r3
34805b24:	0a000010 	beq	34805b6c <generate_mtdparts_save.clone.1+0x168>

				memsize_format(tmpbuf, offset);
34805b28:	e1a00009 	mov	r0, r9
34805b2c:	e59d1008 	ldr	r1, [sp, #8]
34805b30:	ebfffe2e 	bl	348053f0 <memsize_format>
				len = strlen(tmpbuf) + 1;
34805b34:	e1a00009 	mov	r0, r9
34805b38:	eb004c10 	bl	34818b80 <strlen>
34805b3c:	e280b001 	add	fp, r0, #1
				if (len > maxlen)
34805b40:	e15b0004 	cmp	fp, r4
			 * partitions */
			if ((!prev_part && (offset != 0)) ||
					(prev_part && ((prev_part->offset + prev_part->size) != part->offset))) {

				memsize_format(tmpbuf, offset);
				len = strlen(tmpbuf) + 1;
34805b44:	e1a06000 	mov	r6, r0
				if (len > maxlen)
34805b48:	8a000048 	bhi	34805c70 <generate_mtdparts_save.clone.1+0x26c>
					goto cleanup;
				*(p++) = '@';
34805b4c:	e3a03040 	mov	r3, #64	; 0x40
34805b50:	e4c53001 	strb	r3, [r5], #1
				memcpy(p, tmpbuf, len - 1);
34805b54:	e1a00005 	mov	r0, r5
34805b58:	e1a01009 	mov	r1, r9
34805b5c:	e1a02006 	mov	r2, r6
34805b60:	eb004cca 	bl	34818e90 <memcpy>
				p += len - 1;
34805b64:	e0855006 	add	r5, r5, r6
				maxlen -= len;
34805b68:	e06b4004 	rsb	r4, fp, r4
			}

			/* copy name only if user supplied */
			if(!part->auto_name) {
34805b6c:	e5da300c 	ldrb	r3, [sl, #12]
34805b70:	e3530000 	cmp	r3, #0
34805b74:	1a000010 	bne	34805bbc <generate_mtdparts_save.clone.1+0x1b8>
				len = strlen(part->name) + 2;
34805b78:	e59a0008 	ldr	r0, [sl, #8]
34805b7c:	eb004bff 	bl	34818b80 <strlen>
34805b80:	e280b002 	add	fp, r0, #2
				if (len > maxlen)
34805b84:	e15b0004 	cmp	fp, r4
				maxlen -= len;
			}

			/* copy name only if user supplied */
			if(!part->auto_name) {
				len = strlen(part->name) + 2;
34805b88:	e1a06000 	mov	r6, r0
				if (len > maxlen)
34805b8c:	8a000037 	bhi	34805c70 <generate_mtdparts_save.clone.1+0x26c>
					goto cleanup;

				*(p++) = '(';
34805b90:	e3a02028 	mov	r2, #40	; 0x28
34805b94:	e4c52001 	strb	r2, [r5], #1
				memcpy(p, part->name, len - 2);
34805b98:	e1a00005 	mov	r0, r5
34805b9c:	e1a02006 	mov	r2, r6
34805ba0:	e59a1008 	ldr	r1, [sl, #8]
34805ba4:	eb004cb9 	bl	34818e90 <memcpy>
				p += len - 2;
34805ba8:	e0853006 	add	r3, r5, r6
				*(p++) = ')';
34805bac:	e3a02029 	mov	r2, #41	; 0x29
34805bb0:	e7c52006 	strb	r2, [r5, r6]
				maxlen -= len;
34805bb4:	e06b4004 	rsb	r4, fp, r4
					goto cleanup;

				*(p++) = '(';
				memcpy(p, part->name, len - 2);
				p += len - 2;
				*(p++) = ')';
34805bb8:	e2835001 	add	r5, r3, #1
				maxlen -= len;
			}

			/* ro mask flag */
			if (part->mask_flags && MTD_WRITEABLE_CMD) {
34805bbc:	e59a301c 	ldr	r3, [sl, #28]
34805bc0:	e3530000 	cmp	r3, #0
34805bc4:	0a000008 	beq	34805bec <generate_mtdparts_save.clone.1+0x1e8>
				len = 2;
				if (len > maxlen)
34805bc8:	e3540001 	cmp	r4, #1
34805bcc:	9a000027 	bls	34805c70 <generate_mtdparts_save.clone.1+0x26c>
					goto cleanup;
				*(p++) = 'r';
34805bd0:	e1a03005 	mov	r3, r5
34805bd4:	e3a02072 	mov	r2, #114	; 0x72
34805bd8:	e4c32001 	strb	r2, [r3], #1
				*(p++) = 'o';
34805bdc:	e3a0206f 	mov	r2, #111	; 0x6f
34805be0:	e5c52001 	strb	r2, [r5, #1]
				maxlen -= 2;
34805be4:	e2444002 	sub	r4, r4, #2
			if (part->mask_flags && MTD_WRITEABLE_CMD) {
				len = 2;
				if (len > maxlen)
					goto cleanup;
				*(p++) = 'r';
				*(p++) = 'o';
34805be8:	e2835001 	add	r5, r3, #1
		part_cnt = 0;
		list_for_each(pentry, &dev->parts) {
			part = list_entry(pentry, struct part_info, link);
			size = part->size;
			offset = part->offset;
			part_cnt++;
34805bec:	e59d3000 	ldr	r3, [sp]
34805bf0:	e2833001 	add	r3, r3, #1
34805bf4:	e58d3000 	str	r3, [sp]
				maxlen -= 2;
			}

			/* print ',' separator if there are other partitions
			 * following */
			if (dev->num_parts > part_cnt) {
34805bf8:	e59d2000 	ldr	r2, [sp]
34805bfc:	e1d730bc 	ldrh	r3, [r7, #12]
34805c00:	e1530002 	cmp	r3, r2
34805c04:	9a000004 	bls	34805c1c <generate_mtdparts_save.clone.1+0x218>
				if (1 > maxlen)
34805c08:	e3540000 	cmp	r4, #0
34805c0c:	0a000017 	beq	34805c70 <generate_mtdparts_save.clone.1+0x26c>
					goto cleanup;
				*(p++) = ',';
34805c10:	e3a0302c 	mov	r3, #44	; 0x2c
34805c14:	e4c53001 	strb	r3, [r5], #1
				maxlen--;
34805c18:	e2444001 	sub	r4, r4, #1
		maxlen -= len;

		/* format partitions */
		prev_part = NULL;
		part_cnt = 0;
		list_for_each(pentry, &dev->parts) {
34805c1c:	e59aa000 	ldr	sl, [sl]
34805c20:	e59db00c 	ldr	fp, [sp, #12]
34805c24:	e59d2004 	ldr	r2, [sp, #4]
34805c28:	e15a0002 	cmp	sl, r2
34805c2c:	1affff9d 	bne	34805aa8 <generate_mtdparts_save.clone.1+0xa4>
				maxlen--;
			}
			prev_part = part;
		}
		/* print ';' separator if there are other devices following */
		if (dentry->next != &devices) {
34805c30:	e5972000 	ldr	r2, [r7]
34805c34:	e59f3084 	ldr	r3, [pc, #132]	; 34805cc0 <generate_mtdparts_save.clone.1+0x2bc>
34805c38:	e1520003 	cmp	r2, r3
34805c3c:	0a000004 	beq	34805c54 <generate_mtdparts_save.clone.1+0x250>
			if (1 > maxlen)
34805c40:	e3540000 	cmp	r4, #0
34805c44:	0a000009 	beq	34805c70 <generate_mtdparts_save.clone.1+0x26c>
				goto cleanup;
			*(p++) = ';';
34805c48:	e3a0303b 	mov	r3, #59	; 0x3b
34805c4c:	e4c53001 	strb	r3, [r5], #1
			maxlen--;
34805c50:	e2444001 	sub	r4, r4, #1
	}

	sprintf(p, "mtdparts=");
	p += 9;

	list_for_each(dentry, &devices) {
34805c54:	e5977000 	ldr	r7, [r7]
34805c58:	e59f3060 	ldr	r3, [pc, #96]	; 34805cc0 <generate_mtdparts_save.clone.1+0x2bc>
34805c5c:	e1570003 	cmp	r7, r3
34805c60:	1affff78 	bne	34805a48 <generate_mtdparts_save.clone.1+0x44>
		}
	}

	/* we still have at least one char left, as we decremented maxlen at
	 * the begining */
	*p = '\0';
34805c64:	e3a04000 	mov	r4, #0
34805c68:	e5c54000 	strb	r4, [r5]
34805c6c:	ea000003 	b	34805c80 <generate_mtdparts_save.clone.1+0x27c>

	return 0;

cleanup:
	last_parts[0] = '\0';
34805c70:	e59f3040 	ldr	r3, [pc, #64]	; 34805cb8 <generate_mtdparts_save.clone.1+0x2b4>
34805c74:	e3a02000 	mov	r2, #0
34805c78:	e5c32020 	strb	r2, [r3, #32]
	return 1;
34805c7c:	e3a04001 	mov	r4, #1
{
	int ret;

	ret = generate_mtdparts(buf, buflen);

	if ((buf[0] != '\0') && (ret == 0))
34805c80:	e59f3030 	ldr	r3, [pc, #48]	; 34805cb8 <generate_mtdparts_save.clone.1+0x2b4>
34805c84:	e2242001 	eor	r2, r4, #1
34805c88:	e5d31020 	ldrb	r1, [r3, #32]
34805c8c:	e3510000 	cmp	r1, #0
34805c90:	03a01000 	moveq	r1, #0
34805c94:	12021001 	andne	r1, r2, #1
34805c98:	e3510000 	cmp	r1, #0
		setenv("mtdparts", buf);
34805c9c:	159f0020 	ldrne	r0, [pc, #32]	; 34805cc4 <generate_mtdparts_save.clone.1+0x2c0>
34805ca0:	12831020 	addne	r1, r3, #32
	else
		setenv("mtdparts", NULL);
34805ca4:	059f0018 	ldreq	r0, [pc, #24]	; 34805cc4 <generate_mtdparts_save.clone.1+0x2c0>
34805ca8:	eb00085b 	bl	34807e1c <setenv>

	return ret;
}
34805cac:	e1a00004 	mov	r0, r4
34805cb0:	e28dd030 	add	sp, sp, #48	; 0x30
34805cb4:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
34805cb8:	34829224 	.word	0x34829224
34805cbc:	3482484b 	.word	0x3482484b
34805cc0:	34829228 	.word	0x34829228
34805cc4:	34824855 	.word	0x34824855

34805cc8 <mtd_device_validate>:
 * @param num mtd number
 * @param size a pointer to the size of the mtd device (output)
 * @return 0 if device is valid, 1 otherwise
 */
int mtd_device_validate(u8 type, u8 num, u32 *size)
{
34805cc8:	e92d4013 	push	{r0, r1, r4, lr}
	struct mtd_info *mtd = NULL;
34805ccc:	e3a03000 	mov	r3, #0
 * @param num mtd number
 * @param size a pointer to the size of the mtd device (output)
 * @return 0 if device is valid, 1 otherwise
 */
int mtd_device_validate(u8 type, u8 num, u32 *size)
{
34805cd0:	e1a04002 	mov	r4, r2
	struct mtd_info *mtd = NULL;
34805cd4:	e28d2008 	add	r2, sp, #8
34805cd8:	e5223004 	str	r3, [r2, #-4]!

	if (get_mtd_info(type, num, &mtd))
34805cdc:	ebfffe96 	bl	3480573c <get_mtd_info>
34805ce0:	e3500000 	cmp	r0, #0
		return 1;

	*size = mtd->size;
34805ce4:	059d3004 	ldreq	r3, [sp, #4]
int mtd_device_validate(u8 type, u8 num, u32 *size)
{
	struct mtd_info *mtd = NULL;

	if (get_mtd_info(type, num, &mtd))
		return 1;
34805ce8:	13a00001 	movne	r0, #1

	*size = mtd->size;
34805cec:	05933008 	ldreq	r3, [r3, #8]
34805cf0:	05843000 	streq	r3, [r4]

	return 0;
}
34805cf4:	e8bd801c 	pop	{r2, r3, r4, pc}

34805cf8 <device_find>:
struct mtd_device *device_find(u8 type, u8 num)
{
	struct list_head *entry;
	struct mtd_device *dev_tmp;

	list_for_each(entry, &devices) {
34805cf8:	e59fc040 	ldr	ip, [pc, #64]	; 34805d40 <device_find+0x48>
 * @param type device type
 * @param num device number
 * @return NULL if requested device does not exist
 */
struct mtd_device *device_find(u8 type, u8 num)
{
34805cfc:	e92d4030 	push	{r4, r5, lr}
34805d00:	e1a03000 	mov	r3, r0
	struct list_head *entry;
	struct mtd_device *dev_tmp;

	list_for_each(entry, &devices) {
34805d04:	e5bc2004 	ldr	r2, [ip, #4]!
34805d08:	ea000008 	b	34805d30 <device_find+0x38>
		dev_tmp = list_entry(entry, struct mtd_device, link);

		if ((dev_tmp->id->type == type) && (dev_tmp->id->num == num))
34805d0c:	e5924008 	ldr	r4, [r2, #8]
{
	struct list_head *entry;
	struct mtd_device *dev_tmp;

	list_for_each(entry, &devices) {
		dev_tmp = list_entry(entry, struct mtd_device, link);
34805d10:	e1a00002 	mov	r0, r2

		if ((dev_tmp->id->type == type) && (dev_tmp->id->num == num))
34805d14:	e5d45008 	ldrb	r5, [r4, #8]
34805d18:	e1550003 	cmp	r5, r3
34805d1c:	1a000002 	bne	34805d2c <device_find+0x34>
34805d20:	e5d44009 	ldrb	r4, [r4, #9]
34805d24:	e1540001 	cmp	r4, r1
34805d28:	08bd8030 	popeq	{r4, r5, pc}
struct mtd_device *device_find(u8 type, u8 num)
{
	struct list_head *entry;
	struct mtd_device *dev_tmp;

	list_for_each(entry, &devices) {
34805d2c:	e5922000 	ldr	r2, [r2]
34805d30:	e152000c 	cmp	r2, ip
34805d34:	1afffff4 	bne	34805d0c <device_find+0x14>

		if ((dev_tmp->id->type == type) && (dev_tmp->id->num == num))
			return dev_tmp;
	}

	return NULL;
34805d38:	e3a00000 	mov	r0, #0
}
34805d3c:	e8bd8030 	pop	{r4, r5, pc}
34805d40:	34829224 	.word	0x34829224

34805d44 <device_parse>:
 * @param ret output pointer to next char after parse completes (output)
 * @param retdev pointer to the allocated device (output)
 * @return 0 on success, 1 otherwise
 */
static int device_parse(const char *const mtd_dev, const char **ret, struct mtd_device **retdev)
{
34805d44:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
34805d48:	e24dd028 	sub	sp, sp, #40	; 0x28
	struct mtdids *id;
	const char *mtd_id;
	unsigned int mtd_id_len;
	const char *p;
	const char *pend;
	LIST_HEAD(tmp_list);
34805d4c:	e28d301c 	add	r3, sp, #28
34805d50:	e58d301c 	str	r3, [sp, #28]
34805d54:	e58d3020 	str	r3, [sp, #32]
	debug("===device_parse===\n");

	assert(retdev);
	*retdev = NULL;

	if (ret)
34805d58:	e2517000 	subs	r7, r1, #0
	int err = 1;

	debug("===device_parse===\n");

	assert(retdev);
	*retdev = NULL;
34805d5c:	e3a03000 	mov	r3, #0
 * @param ret output pointer to next char after parse completes (output)
 * @param retdev pointer to the allocated device (output)
 * @return 0 on success, 1 otherwise
 */
static int device_parse(const char *const mtd_dev, const char **ret, struct mtd_device **retdev)
{
34805d60:	e58d2010 	str	r2, [sp, #16]
	if (ret)
		*ret = NULL;

	/* fetch <mtd-id> */
	mtd_id = p = mtd_dev;
	if (!(p = strchr(mtd_id, ':'))) {
34805d64:	e3a0103a 	mov	r1, #58	; 0x3a
	int err = 1;

	debug("===device_parse===\n");

	assert(retdev);
	*retdev = NULL;
34805d68:	e5823000 	str	r3, [r2]

	if (ret)
		*ret = NULL;
34805d6c:	15873000 	strne	r3, [r7]
 * @param ret output pointer to next char after parse completes (output)
 * @param retdev pointer to the allocated device (output)
 * @return 0 on success, 1 otherwise
 */
static int device_parse(const char *const mtd_dev, const char **ret, struct mtd_device **retdev)
{
34805d70:	e1a04000 	mov	r4, r0
	if (ret)
		*ret = NULL;

	/* fetch <mtd-id> */
	mtd_id = p = mtd_dev;
	if (!(p = strchr(mtd_id, ':'))) {
34805d74:	eb004b6b 	bl	34818b28 <strchr>
34805d78:	e2509000 	subs	r9, r0, #0
		printf("no <mtd-id> identifier\n");
34805d7c:	059f04cc 	ldreq	r0, [pc, #1228]	; 34806250 <device_parse+0x50c>
	if (ret)
		*ret = NULL;

	/* fetch <mtd-id> */
	mtd_id = p = mtd_dev;
	if (!(p = strchr(mtd_id, ':'))) {
34805d80:	0a000109 	beq	348061ac <device_parse+0x468>
	struct mtdids *id;

	debug("--- id_find_by_mtd_id: '%.*s' (len = %d)\n",
			mtd_id_len, mtd_id, mtd_id_len);

	list_for_each(entry, &mtdids) {
34805d84:	e59fa4c8 	ldr	sl, [pc, #1224]	; 34806254 <device_parse+0x510>
	}
	mtd_id_len = p - mtd_id + 1;
	p++;

	/* verify if we have a valid device specified */
	if ((id = id_find_by_mtd_id(mtd_id, mtd_id_len - 1)) == NULL) {
34805d88:	e0646009 	rsb	r6, r4, r9
	struct mtdids *id;

	debug("--- id_find_by_mtd_id: '%.*s' (len = %d)\n",
			mtd_id_len, mtd_id, mtd_id_len);

	list_for_each(entry, &mtdids) {
34805d8c:	e5ba5220 	ldr	r5, [sl, #544]!	; 0x220
34805d90:	ea00000a 	b	34805dc0 <device_parse+0x7c>
		id = list_entry(entry, struct mtdids, link);

		debug("entry: '%s' (len = %d)\n",
				id->mtd_id, strlen(id->mtd_id));

		if (mtd_id_len != strlen(id->mtd_id))
34805d94:	e5950010 	ldr	r0, [r5, #16]
34805d98:	eb004b78 	bl	34818b80 <strlen>
34805d9c:	e1560000 	cmp	r6, r0
34805da0:	1a000005 	bne	34805dbc <device_parse+0x78>
			continue;
		if (strncmp(id->mtd_id, mtd_id, mtd_id_len) == 0)
34805da4:	e5950010 	ldr	r0, [r5, #16]
34805da8:	e1a01004 	mov	r1, r4
34805dac:	e1a02006 	mov	r2, r6
34805db0:	eb004b4a 	bl	34818ae0 <strncmp>
34805db4:	e3500000 	cmp	r0, #0
34805db8:	0a000003 	beq	34805dcc <device_parse+0x88>
	struct mtdids *id;

	debug("--- id_find_by_mtd_id: '%.*s' (len = %d)\n",
			mtd_id_len, mtd_id, mtd_id_len);

	list_for_each(entry, &mtdids) {
34805dbc:	e5955000 	ldr	r5, [r5]
34805dc0:	e155000a 	cmp	r5, sl
34805dc4:	1afffff2 	bne	34805d94 <device_parse+0x50>
34805dc8:	ea000006 	b	34805de8 <device_parse+0xa4>

	/* parse partitions */
	num_parts = 0;

	offset = 0;
	if ((dev = device_find(id->type, id->num)) != NULL) {
34805dcc:	e5d50008 	ldrb	r0, [r5, #8]
34805dd0:	e5d51009 	ldrb	r1, [r5, #9]
34805dd4:	ebffffc7 	bl	34805cf8 <device_find>
34805dd8:	e3500000 	cmp	r0, #0


	/* parse partitions */
	num_parts = 0;

	offset = 0;
34805ddc:	058d0008 	streq	r0, [sp, #8]
	if ((dev = device_find(id->type, id->num)) != NULL) {
34805de0:	1a000005 	bne	34805dfc <device_parse+0xb8>
34805de4:	ea000009 	b	34805e10 <device_parse+0xcc>
	mtd_id_len = p - mtd_id + 1;
	p++;

	/* verify if we have a valid device specified */
	if ((id = id_find_by_mtd_id(mtd_id, mtd_id_len - 1)) == NULL) {
		printf("invalid mtd device '%.*s'\n", mtd_id_len - 1, mtd_id);
34805de8:	e1a01006 	mov	r1, r6
34805dec:	e1a02004 	mov	r2, r4
34805df0:	e59f0460 	ldr	r0, [pc, #1120]	; 34806258 <device_parse+0x514>
34805df4:	eb000c54 	bl	34808f4c <printf>
34805df8:	ea000111 	b	34806244 <device_parse+0x500>
	num_parts = 0;

	offset = 0;
	if ((dev = device_find(id->type, id->num)) != NULL) {
		/* if device already exists start at the end of the last partition */
		part = list_entry(dev->parts.prev, struct part_info, link);
34805dfc:	e5903014 	ldr	r3, [r0, #20]
		offset = part->offset + part->size;
34805e00:	e5932010 	ldr	r2, [r3, #16]
34805e04:	e5933014 	ldr	r3, [r3, #20]
34805e08:	e0823003 	add	r3, r2, r3
34805e0c:	e58d3008 	str	r3, [sp, #8]
	if (!(p = strchr(mtd_id, ':'))) {
		printf("no <mtd-id> identifier\n");
		return 1;
	}
	mtd_id_len = p - mtd_id + 1;
	p++;
34805e10:	e3a02000 	mov	r2, #0
34805e14:	e2896001 	add	r6, r9, #1
34805e18:	e3a00001 	mov	r0, #1
34805e1c:	e58d2004 	str	r2, [sp, #4]
34805e20:	e58d7014 	str	r7, [sp, #20]
34805e24:	ea0000a9 	b	348060d0 <device_parse+0x38c>
	const char *name;
	int name_len;
	unsigned int mask_flags;
	const char *p;

	p = partdef;
34805e28:	e58d6024 	str	r6, [sp, #36]	; 0x24
	*retpart = NULL;
	*ret = NULL;

	/* fetch the partition size */
	if (*p == '-') {
34805e2c:	e5d63000 	ldrb	r3, [r6]
34805e30:	e353002d 	cmp	r3, #45	; 0x2d
		/* assign all remaining space to this partition */
		debug("'-': remaining size assigned\n");
		size = SIZE_REMAINING;
		p++;
34805e34:	02866001 	addeq	r6, r6, #1
34805e38:	058d6024 	streq	r6, [sp, #36]	; 0x24

	/* fetch the partition size */
	if (*p == '-') {
		/* assign all remaining space to this partition */
		debug("'-': remaining size assigned\n");
		size = SIZE_REMAINING;
34805e3c:	03e09000 	mvneq	r9, #0
	p = partdef;
	*retpart = NULL;
	*ret = NULL;

	/* fetch the partition size */
	if (*p == '-') {
34805e40:	0a000008 	beq	34805e68 <device_parse+0x124>
		/* assign all remaining space to this partition */
		debug("'-': remaining size assigned\n");
		size = SIZE_REMAINING;
		p++;
	} else {
		size = memsize_parse(p, &p);
34805e44:	e1a00006 	mov	r0, r6
34805e48:	e28d1024 	add	r1, sp, #36	; 0x24
34805e4c:	ebfffe20 	bl	348056d4 <memsize_parse>
		if (size < MIN_PART_SIZE) {
34805e50:	e3003fff 	movw	r3, #4095	; 0xfff
34805e54:	e1500003 	cmp	r0, r3
		/* assign all remaining space to this partition */
		debug("'-': remaining size assigned\n");
		size = SIZE_REMAINING;
		p++;
	} else {
		size = memsize_parse(p, &p);
34805e58:	e1a09000 	mov	r9, r0
		if (size < MIN_PART_SIZE) {
			printf("partition size too small (%lx)\n", size);
34805e5c:	959f03f8 	ldrls	r0, [pc, #1016]	; 3480625c <device_parse+0x518>
34805e60:	91a01009 	movls	r1, r9
34805e64:	9a000039 	bls	34805f50 <device_parse+0x20c>
		}
	}

	/* check for offset */
	offset = OFFSET_NOT_SPECIFIED;
	if (*p == '@') {
34805e68:	e59d0024 	ldr	r0, [sp, #36]	; 0x24
34805e6c:	e5d03000 	ldrb	r3, [r0]
34805e70:	e3530040 	cmp	r3, #64	; 0x40
			return 1;
		}
	}

	/* check for offset */
	offset = OFFSET_NOT_SPECIFIED;
34805e74:	13e0b000 	mvnne	fp, #0
	if (*p == '@') {
34805e78:	1a000004 	bne	34805e90 <device_parse+0x14c>
		p++;
34805e7c:	e2800001 	add	r0, r0, #1
		offset = memsize_parse(p, &p);
34805e80:	e28d1024 	add	r1, sp, #36	; 0x24
	}

	/* check for offset */
	offset = OFFSET_NOT_SPECIFIED;
	if (*p == '@') {
		p++;
34805e84:	e58d0024 	str	r0, [sp, #36]	; 0x24
		offset = memsize_parse(p, &p);
34805e88:	ebfffe11 	bl	348056d4 <memsize_parse>
34805e8c:	e1a0b000 	mov	fp, r0
	}

	/* now look for the name */
	if (*p == '(') {
34805e90:	e59d7024 	ldr	r7, [sp, #36]	; 0x24
34805e94:	e5d73000 	ldrb	r3, [r7]
34805e98:	e3530028 	cmp	r3, #40	; 0x28
			return 1;
		}
		p++;
	} else {
		/* 0x00000000@0x00000000 */
		name_len = 22;
34805e9c:	13a0a016 	movne	sl, #22
		name = NULL;
34805ea0:	13a07000 	movne	r7, #0
		p++;
		offset = memsize_parse(p, &p);
	}

	/* now look for the name */
	if (*p == '(') {
34805ea4:	1a00000f 	bne	34805ee8 <device_parse+0x1a4>
		name = ++p;
34805ea8:	e2877001 	add	r7, r7, #1
		if ((p = strchr(name, ')')) == NULL) {
34805eac:	e1a00007 	mov	r0, r7
34805eb0:	e3a01029 	mov	r1, #41	; 0x29
		offset = memsize_parse(p, &p);
	}

	/* now look for the name */
	if (*p == '(') {
		name = ++p;
34805eb4:	e58d7024 	str	r7, [sp, #36]	; 0x24
		if ((p = strchr(name, ')')) == NULL) {
34805eb8:	eb004b1a 	bl	34818b28 <strchr>
34805ebc:	e3500000 	cmp	r0, #0
34805ec0:	e58d0024 	str	r0, [sp, #36]	; 0x24
			printf("no closing ) found in partition name\n");
34805ec4:	059f0394 	ldreq	r0, [pc, #916]	; 34806260 <device_parse+0x51c>
34805ec8:	0a00002a 	beq	34805f78 <device_parse+0x234>
			return 1;
		}
		name_len = p - name + 1;
34805ecc:	e267a001 	rsb	sl, r7, #1
34805ed0:	e080a00a 	add	sl, r0, sl
		if ((name_len - 1) == 0) {
34805ed4:	e35a0001 	cmp	sl, #1
			printf("empty partition name\n");
34805ed8:	059f0384 	ldreq	r0, [pc, #900]	; 34806264 <device_parse+0x520>
34805edc:	0a000025 	beq	34805f78 <device_parse+0x234>
			return 1;
		}
		p++;
34805ee0:	e2800001 	add	r0, r0, #1
34805ee4:	e58d0024 	str	r0, [sp, #36]	; 0x24
		name = NULL;
	}

	/* test for options */
	mask_flags = 0;
	if (strncmp(p, "ro", 2) == 0) {
34805ee8:	e3a02002 	mov	r2, #2
34805eec:	e59f1374 	ldr	r1, [pc, #884]	; 34806268 <device_parse+0x524>
34805ef0:	e59d0024 	ldr	r0, [sp, #36]	; 0x24
34805ef4:	eb004af9 	bl	34818ae0 <strncmp>
34805ef8:	e3500000 	cmp	r0, #0
		mask_flags |= MTD_WRITEABLE_CMD;
		p += 2;
34805efc:	059d3024 	ldreq	r3, [sp, #36]	; 0x24
	}

	/* test for options */
	mask_flags = 0;
	if (strncmp(p, "ro", 2) == 0) {
		mask_flags |= MTD_WRITEABLE_CMD;
34805f00:	03a02001 	moveq	r2, #1
		p += 2;
34805f04:	02833002 	addeq	r3, r3, #2
34805f08:	058d3024 	streq	r3, [sp, #36]	; 0x24
		name_len = 22;
		name = NULL;
	}

	/* test for options */
	mask_flags = 0;
34805f0c:	13a03000 	movne	r3, #0
		mask_flags |= MTD_WRITEABLE_CMD;
		p += 2;
	}

	/* check for next partition definition */
	if (*p == ',') {
34805f10:	e59d6024 	ldr	r6, [sp, #36]	; 0x24
	}

	/* test for options */
	mask_flags = 0;
	if (strncmp(p, "ro", 2) == 0) {
		mask_flags |= MTD_WRITEABLE_CMD;
34805f14:	058d200c 	streq	r2, [sp, #12]
		name_len = 22;
		name = NULL;
	}

	/* test for options */
	mask_flags = 0;
34805f18:	158d300c 	strne	r3, [sp, #12]
		mask_flags |= MTD_WRITEABLE_CMD;
		p += 2;
	}

	/* check for next partition definition */
	if (*p == ',') {
34805f1c:	e5d61000 	ldrb	r1, [r6]
34805f20:	e351002c 	cmp	r1, #44	; 0x2c
34805f24:	1a000005 	bne	34805f40 <device_parse+0x1fc>
		if (size == SIZE_REMAINING) {
34805f28:	e3790001 	cmn	r9, #1
			*ret = NULL;
			printf("no partitions allowed after a fill-up partition\n");
34805f2c:	059f0338 	ldreq	r0, [pc, #824]	; 3480626c <device_parse+0x528>
34805f30:	0a000010 	beq	34805f78 <device_parse+0x234>
			return 1;
		}
		*ret = ++p;
34805f34:	e2866001 	add	r6, r6, #1
34805f38:	e58d6024 	str	r6, [sp, #36]	; 0x24
34805f3c:	ea000005 	b	34805f58 <device_parse+0x214>
	} else if ((*p == ';') || (*p == '\0')) {
34805f40:	e351003b 	cmp	r1, #59	; 0x3b
34805f44:	13510000 	cmpne	r1, #0
34805f48:	0a000002 	beq	34805f58 <device_parse+0x214>
		*ret = p;
	} else {
		printf("unexpected character '%c' at the end of partition\n", *p);
34805f4c:	e59f031c 	ldr	r0, [pc, #796]	; 34806270 <device_parse+0x52c>
34805f50:	eb000bfd 	bl	34808f4c <printf>
34805f54:	ea000067 	b	348060f8 <device_parse+0x3b4>
		*ret = NULL;
		return 1;
	}

	/*  allocate memory */
	part = (struct part_info *)malloc(sizeof(struct part_info) + name_len);
34805f58:	e28a2028 	add	r2, sl, #40	; 0x28
34805f5c:	e1a00002 	mov	r0, r2
34805f60:	e58d2000 	str	r2, [sp]
34805f64:	eb000dbf 	bl	34809668 <malloc>
	if (!part) {
34805f68:	e2504000 	subs	r4, r0, #0
34805f6c:	e59d2000 	ldr	r2, [sp]
34805f70:	1a000002 	bne	34805f80 <device_parse+0x23c>
		printf("out of memory\n");
34805f74:	e59f02f8 	ldr	r0, [pc, #760]	; 34806274 <device_parse+0x530>
34805f78:	eb000bf3 	bl	34808f4c <printf>
34805f7c:	ea00005d 	b	348060f8 <device_parse+0x3b4>
		return 1;
	}
	memset(part, 0, sizeof(struct part_info) + name_len);
34805f80:	e3a01000 	mov	r1, #0
34805f84:	eb004b9d 	bl	34818e00 <memset>
	part->size = size;
	part->offset = offset;
	part->mask_flags = mask_flags;
34805f88:	e59d200c 	ldr	r2, [sp, #12]
	part->name = (char *)(part + 1);
34805f8c:	e2840028 	add	r0, r4, #40	; 0x28

	if (name) {
34805f90:	e3570000 	cmp	r7, #0
	if (!part) {
		printf("out of memory\n");
		return 1;
	}
	memset(part, 0, sizeof(struct part_info) + name_len);
	part->size = size;
34805f94:	e5849010 	str	r9, [r4, #16]
	part->offset = offset;
34805f98:	e584b014 	str	fp, [r4, #20]
	part->mask_flags = mask_flags;
34805f9c:	e584201c 	str	r2, [r4, #28]
	part->name = (char *)(part + 1);
34805fa0:	e5840008 	str	r0, [r4, #8]

	if (name) {
34805fa4:	0a000005 	beq	34805fc0 <device_parse+0x27c>
		/* copy user provided name */
		strncpy(part->name, name, name_len - 1);
34805fa8:	e1a01007 	mov	r1, r7
34805fac:	e24a2001 	sub	r2, sl, #1
34805fb0:	eb004a94 	bl	34818a08 <strncpy>
		part->auto_name = 0;
34805fb4:	e3a03000 	mov	r3, #0
34805fb8:	e5c4300c 	strb	r3, [r4, #12]
34805fbc:	ea000005 	b	34805fd8 <device_parse+0x294>
	} else {
		/* auto generated name in form of size@offset */
		sprintf(part->name, "0x%08lx@0x%08lx", size, offset);
34805fc0:	e1a02009 	mov	r2, r9
34805fc4:	e59f12ac 	ldr	r1, [pc, #684]	; 34806278 <device_parse+0x534>
34805fc8:	e1a0300b 	mov	r3, fp
34805fcc:	eb004faf 	bl	34819e90 <sprintf>
		part->auto_name = 1;
34805fd0:	e3a02001 	mov	r2, #1
34805fd4:	e5c4200c 	strb	r2, [r4, #12]
	}

	part->name[name_len - 1] = '\0';
34805fd8:	e5943008 	ldr	r3, [r4, #8]
34805fdc:	e083a00a 	add	sl, r3, sl
34805fe0:	e3a03000 	mov	r3, #0
34805fe4:	e54a3001 	strb	r3, [sl, #-1]
		err = 1;
		if ((part_parse(p, &p, &part) != 0) || (!part))
			break;

		/* calculate offset when not specified */
		if (part->offset == OFFSET_NOT_SPECIFIED)
34805fe8:	e5947014 	ldr	r7, [r4, #20]
 * @param part partition to validate
 * @return 0 if partition is valid, 1 otherwise
 */
static int part_validate(struct mtdids *id, struct part_info *part)
{
	if (part->size == SIZE_REMAINING)
34805fec:	e5943010 	ldr	r3, [r4, #16]
		err = 1;
		if ((part_parse(p, &p, &part) != 0) || (!part))
			break;

		/* calculate offset when not specified */
		if (part->offset == OFFSET_NOT_SPECIFIED)
34805ff0:	e3770001 	cmn	r7, #1
			part->offset = offset;
34805ff4:	059d2008 	ldreq	r2, [sp, #8]
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
34805ff8:	e5844000 	str	r4, [r4]
34805ffc:	05842014 	streq	r2, [r4, #20]
34806000:	01a07002 	moveq	r7, r2
 * @param part partition to validate
 * @return 0 if partition is valid, 1 otherwise
 */
static int part_validate(struct mtdids *id, struct part_info *part)
{
	if (part->size == SIZE_REMAINING)
34806004:	e3730001 	cmn	r3, #1
		part->size = id->size - part->offset;
34806008:	0595200c 	ldreq	r2, [r5, #12]
3480600c:	05943014 	ldreq	r3, [r4, #20]
	list->prev = list;
34806010:	e5844004 	str	r4, [r4, #4]
34806014:	00633002 	rsbeq	r3, r3, r2
34806018:	05843010 	streq	r3, [r4, #16]

	if (part->offset > id->size) {
3480601c:	e5942014 	ldr	r2, [r4, #20]
34806020:	e595300c 	ldr	r3, [r5, #12]
34806024:	e1520003 	cmp	r2, r3
		printf("%s: offset %08x beyond flash size %08x\n",
34806028:	859f024c 	ldrhi	r0, [pc, #588]	; 3480627c <device_parse+0x538>
3480602c:	85951010 	ldrhi	r1, [r5, #16]
34806030:	8a00000e 	bhi	34806070 <device_parse+0x32c>
				id->mtd_id, part->offset, id->size);
		return 1;
	}

	if ((part->offset + part->size) <= part->offset) {
34806034:	e5941010 	ldr	r1, [r4, #16]
34806038:	e0821001 	add	r1, r2, r1
3480603c:	e1510002 	cmp	r1, r2
34806040:	8a00000c 	bhi	34806078 <device_parse+0x334>
		printf("%s%d: partition (%s) size too big\n",
				MTD_DEV_TYPE(id->type), id->num, part->name);
34806044:	e5d53008 	ldrb	r3, [r5, #8]
				id->mtd_id, part->offset, id->size);
		return 1;
	}

	if ((part->offset + part->size) <= part->offset) {
		printf("%s%d: partition (%s) size too big\n",
34806048:	e3530002 	cmp	r3, #2
3480604c:	059f122c 	ldreq	r1, [pc, #556]	; 34806280 <device_parse+0x53c>
34806050:	0a000003 	beq	34806064 <device_parse+0x320>
				MTD_DEV_TYPE(id->type), id->num, part->name);
34806054:	e59f2228 	ldr	r2, [pc, #552]	; 34806284 <device_parse+0x540>
34806058:	e3530004 	cmp	r3, #4
3480605c:	e59f1224 	ldr	r1, [pc, #548]	; 34806288 <device_parse+0x544>
34806060:	01a01002 	moveq	r1, r2
				id->mtd_id, part->offset, id->size);
		return 1;
	}

	if ((part->offset + part->size) <= part->offset) {
		printf("%s%d: partition (%s) size too big\n",
34806064:	e59f0220 	ldr	r0, [pc, #544]	; 3480628c <device_parse+0x548>
34806068:	e5d52009 	ldrb	r2, [r5, #9]
3480606c:	e5943008 	ldr	r3, [r4, #8]
34806070:	eb000bb5 	bl	34808f4c <printf>
34806074:	ea00001f 	b	348060f8 <device_parse+0x3b4>
				MTD_DEV_TYPE(id->type), id->num, part->name);
		return 1;
	}

	if (part->offset + part->size > id->size) {
34806078:	e1510003 	cmp	r1, r3
		printf("%s: partitioning exceeds flash size\n", id->mtd_id);
3480607c:	859f020c 	ldrhi	r0, [pc, #524]	; 34806290 <device_parse+0x54c>
34806080:	85951010 	ldrhi	r1, [r5, #16]
34806084:	8affffb1 	bhi	34805f50 <device_parse+0x20c>

	/*
	 * Now we need to check if the partition starts and ends on
	 * sector (eraseblock) regions
	 */
	return part_validate_eraseblock(id, part);
34806088:	e1a00005 	mov	r0, r5
3480608c:	e1a01004 	mov	r1, r4
34806090:	ebfffdc9 	bl	348057bc <part_validate_eraseblock>
			part->offset = offset;
		else
			offset = part->offset;

		/* verify alignment and size */
		if (part_validate(id, part) != 0)
34806094:	e3500000 	cmp	r0, #0
34806098:	1a000016 	bne	348060f8 <device_parse+0x3b4>
			break;

		offset += part->size;
3480609c:	e5943010 	ldr	r3, [r4, #16]
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
	new->next = next;
348060a0:	e28d201c 	add	r2, sp, #28
348060a4:	e0873003 	add	r3, r7, r3
348060a8:	e5842000 	str	r2, [r4]
348060ac:	e58d3008 	str	r3, [sp, #8]

		/* partition is ok, add it to the list */
		list_add_tail(&part->link, &tmp_list);
		num_parts++;
348060b0:	e59d2004 	ldr	r2, [sp, #4]
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
348060b4:	e59d3020 	ldr	r3, [sp, #32]
 */
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
348060b8:	e58d4020 	str	r4, [sp, #32]
	new->next = next;
	new->prev = prev;
	prev->next = new;
348060bc:	e5834000 	str	r4, [r3]
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
	new->next = next;
	new->prev = prev;
348060c0:	e5843004 	str	r3, [r4, #4]
348060c4:	e2823001 	add	r3, r2, #1
348060c8:	e6ff3073 	uxth	r3, r3
348060cc:	e58d3004 	str	r3, [sp, #4]
		/* if device already exists start at the end of the last partition */
		part = list_entry(dev->parts.prev, struct part_info, link);
		offset = part->offset + part->size;
	}

	while (p && (*p != '\0') && (*p != ';')) {
348060d0:	e3560000 	cmp	r6, #0
348060d4:	0a000004 	beq	348060ec <device_parse+0x3a8>
348060d8:	e5d63000 	ldrb	r3, [r6]
348060dc:	e3530000 	cmp	r3, #0
348060e0:	0a000001 	beq	348060ec <device_parse+0x3a8>
348060e4:	e353003b 	cmp	r3, #59	; 0x3b
348060e8:	1affff4e 	bne	34805e28 <device_parse+0xe4>
		/* partition is ok, add it to the list */
		list_add_tail(&part->link, &tmp_list);
		num_parts++;
		err = 0;
	}
	if (err == 1) {
348060ec:	e3500001 	cmp	r0, #1
348060f0:	e59d7014 	ldr	r7, [sp, #20]
348060f4:	1a000002 	bne	34806104 <device_parse+0x3c0>
		part_delall(&tmp_list);
348060f8:	e28d001c 	add	r0, sp, #28
348060fc:	ebfffd47 	bl	34805620 <part_delall>
34806100:	ea00004f 	b	34806244 <device_parse+0x500>
		return 1;
	}

	if (num_parts == 0) {
34806104:	e59d3004 	ldr	r3, [sp, #4]
34806108:	e3530000 	cmp	r3, #0
3480610c:	1a00000c 	bne	34806144 <device_parse+0x400>
		printf("no partitions for device %s%d (%s)\n",
				MTD_DEV_TYPE(id->type), id->num, id->mtd_id);
34806110:	e5d53008 	ldrb	r3, [r5, #8]
		part_delall(&tmp_list);
		return 1;
	}

	if (num_parts == 0) {
		printf("no partitions for device %s%d (%s)\n",
34806114:	e3530002 	cmp	r3, #2
34806118:	059f1160 	ldreq	r1, [pc, #352]	; 34806280 <device_parse+0x53c>
3480611c:	0a000003 	beq	34806130 <device_parse+0x3ec>
				MTD_DEV_TYPE(id->type), id->num, id->mtd_id);
34806120:	e59f215c 	ldr	r2, [pc, #348]	; 34806284 <device_parse+0x540>
34806124:	e3530004 	cmp	r3, #4
34806128:	e59f1158 	ldr	r1, [pc, #344]	; 34806288 <device_parse+0x544>
3480612c:	01a01002 	moveq	r1, r2
		part_delall(&tmp_list);
		return 1;
	}

	if (num_parts == 0) {
		printf("no partitions for device %s%d (%s)\n",
34806130:	e5d52009 	ldrb	r2, [r5, #9]
34806134:	e5953010 	ldr	r3, [r5, #16]
34806138:	e59f0154 	ldr	r0, [pc, #340]	; 34806294 <device_parse+0x550>
3480613c:	eb000b82 	bl	34808f4c <printf>
34806140:	ea00003f 	b	34806244 <device_parse+0x500>
	}

	debug("\ntotal partitions: %d\n", num_parts);

	/* check for next device presence */
	if (p) {
34806144:	e3560000 	cmp	r6, #0
34806148:	0a000012 	beq	34806198 <device_parse+0x454>
		if (*p == ';') {
3480614c:	e5d61000 	ldrb	r1, [r6]
34806150:	e351003b 	cmp	r1, #59	; 0x3b
34806154:	1a000003 	bne	34806168 <device_parse+0x424>
			if (ret)
34806158:	e3570000 	cmp	r7, #0
				*ret = ++p;
3480615c:	12866001 	addne	r6, r6, #1
	debug("\ntotal partitions: %d\n", num_parts);

	/* check for next device presence */
	if (p) {
		if (*p == ';') {
			if (ret)
34806160:	1a000004 	bne	34806178 <device_parse+0x434>
34806164:	ea00000b 	b	34806198 <device_parse+0x454>
				*ret = ++p;
		} else if (*p == '\0') {
34806168:	e3510000 	cmp	r1, #0
3480616c:	1a000003 	bne	34806180 <device_parse+0x43c>
			if (ret)
34806170:	e3570000 	cmp	r7, #0
34806174:	0a000007 	beq	34806198 <device_parse+0x454>
				*ret = p;
34806178:	e5876000 	str	r6, [r7]
3480617c:	ea000005 	b	34806198 <device_parse+0x454>
		} else {
			printf("unexpected character '%c' at the end of device\n", *p);
34806180:	e59f0110 	ldr	r0, [pc, #272]	; 34806298 <device_parse+0x554>
34806184:	eb000b70 	bl	34808f4c <printf>
			if (ret)
34806188:	e3570000 	cmp	r7, #0
				*ret = NULL;
3480618c:	13a03000 	movne	r3, #0
34806190:	15873000 	strne	r3, [r7]
34806194:	ea00002a 	b	34806244 <device_parse+0x500>
			return 1;
		}
	}

	/* allocate memory for mtd_device structure */
	if ((dev = (struct mtd_device *)malloc(sizeof(struct mtd_device))) == NULL) {
34806198:	e3a00018 	mov	r0, #24
3480619c:	eb000d31 	bl	34809668 <malloc>
348061a0:	e2504000 	subs	r4, r0, #0
348061a4:	1a000002 	bne	348061b4 <device_parse+0x470>
		printf("out of memory\n");
348061a8:	e59f00c4 	ldr	r0, [pc, #196]	; 34806274 <device_parse+0x530>
348061ac:	eb000b66 	bl	34808f4c <printf>
348061b0:	ea000023 	b	34806244 <device_parse+0x500>
		return 1;
	}
	memset(dev, 0, sizeof(struct mtd_device));
348061b4:	e3a01000 	mov	r1, #0
348061b8:	e3a02018 	mov	r2, #24
	dev->num_parts = 0; /* part_sort_add increments num_parts */
	INIT_LIST_HEAD(&dev->parts);
	INIT_LIST_HEAD(&dev->link);

	/* move partitions from tmp_list to dev->parts */
	list_for_each_safe(entry, n, &tmp_list) {
348061bc:	e28d6028 	add	r6, sp, #40	; 0x28
	/* allocate memory for mtd_device structure */
	if ((dev = (struct mtd_device *)malloc(sizeof(struct mtd_device))) == NULL) {
		printf("out of memory\n");
		return 1;
	}
	memset(dev, 0, sizeof(struct mtd_device));
348061c0:	eb004b0e 	bl	34818e00 <memset>
	dev->id = id;
	dev->num_parts = 0; /* part_sort_add increments num_parts */
	INIT_LIST_HEAD(&dev->parts);
348061c4:	e2843010 	add	r3, r4, #16
	INIT_LIST_HEAD(&dev->link);

	/* move partitions from tmp_list to dev->parts */
	list_for_each_safe(entry, n, &tmp_list) {
348061c8:	e536100c 	ldr	r1, [r6, #-12]!
		printf("out of memory\n");
		return 1;
	}
	memset(dev, 0, sizeof(struct mtd_device));
	dev->id = id;
	dev->num_parts = 0; /* part_sort_add increments num_parts */
348061cc:	e3a02000 	mov	r2, #0
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
348061d0:	e5843010 	str	r3, [r4, #16]
348061d4:	e5844000 	str	r4, [r4]
	if ((dev = (struct mtd_device *)malloc(sizeof(struct mtd_device))) == NULL) {
		printf("out of memory\n");
		return 1;
	}
	memset(dev, 0, sizeof(struct mtd_device));
	dev->id = id;
348061d8:	e5845008 	str	r5, [r4, #8]
	dev->num_parts = 0; /* part_sort_add increments num_parts */
348061dc:	e1c420bc 	strh	r2, [r4, #12]
	list->prev = list;
348061e0:	e5843014 	str	r3, [r4, #20]
348061e4:	e5844004 	str	r4, [r4, #4]
	INIT_LIST_HEAD(&dev->parts);
	INIT_LIST_HEAD(&dev->link);

	/* move partitions from tmp_list to dev->parts */
	list_for_each_safe(entry, n, &tmp_list) {
348061e8:	e5915000 	ldr	r5, [r1]
 * in an undefined state.
 */
static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
348061ec:	e3a07000 	mov	r7, #0
348061f0:	ea00000d 	b	3480622c <device_parse+0x4e8>
 * Note: list_empty() on entry does not return true after this, the entry is
 * in an undefined state.
 */
static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
348061f4:	e891000c 	ldm	r1, {r2, r3}
		part = list_entry(entry, struct part_info, link);
		list_del(entry);
		if (part_sort_add(dev, part) != 0) {
348061f8:	e1a00004 	mov	r0, r4
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head *prev, struct list_head *next)
{
	next->prev = prev;
348061fc:	e5823004 	str	r3, [r2, #4]
	prev->next = next;
34806200:	e5832000 	str	r2, [r3]
 */
static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
	entry->prev = LIST_POISON2;
34806204:	e5817004 	str	r7, [r1, #4]
 * in an undefined state.
 */
static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
34806208:	e5817000 	str	r7, [r1]
3480620c:	ebfffcb8 	bl	348054f4 <part_sort_add>
34806210:	e3500000 	cmp	r0, #0
34806214:	0a000002 	beq	34806224 <device_parse+0x4e0>
			device_del(dev);
34806218:	e1a00004 	mov	r0, r4
3480621c:	ebfffd10 	bl	34805664 <device_del>
34806220:	ea000007 	b	34806244 <device_parse+0x500>
	dev->num_parts = 0; /* part_sort_add increments num_parts */
	INIT_LIST_HEAD(&dev->parts);
	INIT_LIST_HEAD(&dev->link);

	/* move partitions from tmp_list to dev->parts */
	list_for_each_safe(entry, n, &tmp_list) {
34806224:	e1a01005 	mov	r1, r5
34806228:	e5955000 	ldr	r5, [r5]
3480622c:	e1510006 	cmp	r1, r6
34806230:	1affffef 	bne	348061f4 <device_parse+0x4b0>
			device_del(dev);
			return 1;
		}
	}

	*retdev = dev;
34806234:	e59d3010 	ldr	r3, [sp, #16]

	debug("===\n\n");
	return 0;
34806238:	e3a00000 	mov	r0, #0
			device_del(dev);
			return 1;
		}
	}

	*retdev = dev;
3480623c:	e5834000 	str	r4, [r3]

	debug("===\n\n");
	return 0;
34806240:	ea000000 	b	34806248 <device_parse+0x504>
				*ret = p;
		} else {
			printf("unexpected character '%c' at the end of device\n", *p);
			if (ret)
				*ret = NULL;
			return 1;
34806244:	e3a00001 	mov	r0, #1

	*retdev = dev;

	debug("===\n\n");
	return 0;
}
34806248:	e28dd028 	add	sp, sp, #40	; 0x28
3480624c:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
34806250:	34824b6d 	.word	0x34824b6d
34806254:	34829224 	.word	0x34829224
34806258:	3482485e 	.word	0x3482485e
3480625c:	34824879 	.word	0x34824879
34806260:	34824899 	.word	0x34824899
34806264:	348248bf 	.word	0x348248bf
34806268:	348248d5 	.word	0x348248d5
3480626c:	348248d8 	.word	0x348248d8
34806270:	34824909 	.word	0x34824909
34806274:	3482493c 	.word	0x3482493c
34806278:	3482494b 	.word	0x3482494b
3480627c:	3482495b 	.word	0x3482495b
34806280:	34824ada 	.word	0x34824ada
34806284:	34824ad7 	.word	0x34824ad7
34806288:	34824709 	.word	0x34824709
3480628c:	34824983 	.word	0x34824983
34806290:	348249a6 	.word	0x348249a6
34806294:	348249cb 	.word	0x348249cb
34806298:	348249ef 	.word	0x348249ef

3480629c <mtd_id_parse>:
 * @param dev_type parsed device type (output)
 * @param dev_num parsed device number (output)
 * @return 0 on success, 1 otherwise
 */
int mtd_id_parse(const char *id, const char **ret_id, u8 *dev_type, u8 *dev_num)
{
3480629c:	e92d40f7 	push	{r0, r1, r2, r4, r5, r6, r7, lr}
348062a0:	e1a07003 	mov	r7, r3
	const char *p = id;

	*dev_type = 0;
348062a4:	e3a03000 	mov	r3, #0
 * @param dev_num parsed device number (output)
 * @return 0 on success, 1 otherwise
 */
int mtd_id_parse(const char *id, const char **ret_id, u8 *dev_type, u8 *dev_num)
{
	const char *p = id;
348062a8:	e58d0004 	str	r0, [sp, #4]
 * @param dev_type parsed device type (output)
 * @param dev_num parsed device number (output)
 * @return 0 on success, 1 otherwise
 */
int mtd_id_parse(const char *id, const char **ret_id, u8 *dev_type, u8 *dev_num)
{
348062ac:	e1a05001 	mov	r5, r1
	const char *p = id;

	*dev_type = 0;
348062b0:	e5c23000 	strb	r3, [r2]
 * @param dev_type parsed device type (output)
 * @param dev_num parsed device number (output)
 * @return 0 on success, 1 otherwise
 */
int mtd_id_parse(const char *id, const char **ret_id, u8 *dev_type, u8 *dev_num)
{
348062b4:	e1a04002 	mov	r4, r2
	const char *p = id;

	*dev_type = 0;
	if (strncmp(p, "nand", 4) == 0) {
348062b8:	e59f10d4 	ldr	r1, [pc, #212]	; 34806394 <mtd_id_parse+0xf8>
348062bc:	e3a02004 	mov	r2, #4
 * @param dev_type parsed device type (output)
 * @param dev_num parsed device number (output)
 * @return 0 on success, 1 otherwise
 */
int mtd_id_parse(const char *id, const char **ret_id, u8 *dev_type, u8 *dev_num)
{
348062c0:	e1a06000 	mov	r6, r0
	const char *p = id;

	*dev_type = 0;
	if (strncmp(p, "nand", 4) == 0) {
348062c4:	eb004a05 	bl	34818ae0 <strncmp>
348062c8:	e3500000 	cmp	r0, #0
		*dev_type = MTD_DEV_TYPE_NAND;
348062cc:	03a03002 	moveq	r3, #2
348062d0:	05c43000 	strbeq	r3, [r4]
		p += 4;
348062d4:	059d3004 	ldreq	r3, [sp, #4]
348062d8:	02833004 	addeq	r3, r3, #4
348062dc:	0a000013 	beq	34806330 <mtd_id_parse+0x94>
	} else if (strncmp(p, "nor", 3) == 0) {
348062e0:	e59d0004 	ldr	r0, [sp, #4]
348062e4:	e59f10ac 	ldr	r1, [pc, #172]	; 34806398 <mtd_id_parse+0xfc>
348062e8:	e3a02003 	mov	r2, #3
348062ec:	eb0049fb 	bl	34818ae0 <strncmp>
348062f0:	e3500000 	cmp	r0, #0
		*dev_type = MTD_DEV_TYPE_NOR;
348062f4:	03a03001 	moveq	r3, #1
348062f8:	05c43000 	strbeq	r3, [r4]
		p += 3;
348062fc:	059d3004 	ldreq	r3, [sp, #4]
34806300:	02833003 	addeq	r3, r3, #3
34806304:	0a000009 	beq	34806330 <mtd_id_parse+0x94>
	} else if (strncmp(p, "onenand", 7) == 0) {
34806308:	e59d0004 	ldr	r0, [sp, #4]
3480630c:	e59f1088 	ldr	r1, [pc, #136]	; 3480639c <mtd_id_parse+0x100>
34806310:	e3a02007 	mov	r2, #7
34806314:	eb0049f1 	bl	34818ae0 <strncmp>
34806318:	e3500000 	cmp	r0, #0
3480631c:	1a00000b 	bne	34806350 <mtd_id_parse+0xb4>
		*dev_type = MTD_DEV_TYPE_ONENAND;
34806320:	e3a03004 	mov	r3, #4
34806324:	e5c43000 	strb	r3, [r4]
		p += 7;
34806328:	e59d3004 	ldr	r3, [sp, #4]
3480632c:	e2833007 	add	r3, r3, #7
34806330:	e58d3004 	str	r3, [sp, #4]
	} else {
		printf("incorrect device type in %s\n", id);
		return 1;
	}

	if (!isdigit(*p)) {
34806334:	e59d0004 	ldr	r0, [sp, #4]
34806338:	e59f2060 	ldr	r2, [pc, #96]	; 348063a0 <mtd_id_parse+0x104>
3480633c:	e5d03000 	ldrb	r3, [r0]
34806340:	e7d23003 	ldrb	r3, [r2, r3]
34806344:	e3130004 	tst	r3, #4
34806348:	1a000007 	bne	3480636c <mtd_id_parse+0xd0>
3480634c:	ea000001 	b	34806358 <mtd_id_parse+0xbc>
		p += 3;
	} else if (strncmp(p, "onenand", 7) == 0) {
		*dev_type = MTD_DEV_TYPE_ONENAND;
		p += 7;
	} else {
		printf("incorrect device type in %s\n", id);
34806350:	e59f004c 	ldr	r0, [pc, #76]	; 348063a4 <mtd_id_parse+0x108>
34806354:	ea000000 	b	3480635c <mtd_id_parse+0xc0>
		return 1;
	}

	if (!isdigit(*p)) {
		printf("incorrect device number in %s\n", id);
34806358:	e59f0048 	ldr	r0, [pc, #72]	; 348063a8 <mtd_id_parse+0x10c>
3480635c:	e1a01006 	mov	r1, r6
34806360:	eb000af9 	bl	34808f4c <printf>
		return 1;
34806364:	e3a00001 	mov	r0, #1
34806368:	ea000008 	b	34806390 <mtd_id_parse+0xf4>
	}

	*dev_num = simple_strtoul(p, (char **)&p, 0);
3480636c:	e28d1004 	add	r1, sp, #4
34806370:	e3a02000 	mov	r2, #0
34806374:	eb004e1f 	bl	34819bf8 <simple_strtoul>
	if (ret_id)
34806378:	e3550000 	cmp	r5, #0
		*ret_id = p;
3480637c:	159d3004 	ldrne	r3, [sp, #4]
	if (!isdigit(*p)) {
		printf("incorrect device number in %s\n", id);
		return 1;
	}

	*dev_num = simple_strtoul(p, (char **)&p, 0);
34806380:	e5c70000 	strb	r0, [r7]
	if (ret_id)
		*ret_id = p;
34806384:	15853000 	strne	r3, [r5]
	return 0;
34806388:	13a00000 	movne	r0, #0
3480638c:	01a00005 	moveq	r0, r5
}
34806390:	e8bd80fe 	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
34806394:	34824ada 	.word	0x34824ada
34806398:	34824709 	.word	0x34824709
3480639c:	34824ad7 	.word	0x34824ad7
348063a0:	34821fd4 	.word	0x34821fd4
348063a4:	34824a1f 	.word	0x34824a1f
348063a8:	34824a3c 	.word	0x34824a3c

348063ac <find_dev_and_part>:
 * @param part pointer to requested partition (output)
 * @return 0 on success, 1 otherwise
 */
int find_dev_and_part(const char *id, struct mtd_device **dev,
		u8 *part_num, struct part_info **part)
{
348063ac:	e92d4eff 	push	{r0, r1, r2, r3, r4, r5, r6, r7, r9, sl, fp, lr}
	u8 type, dnum, pnum;
	const char *p;

	debug("--- find_dev_and_part ---\nid = %s\n", id);

	list_for_each(dentry, &devices) {
348063b0:	e59fb18c 	ldr	fp, [pc, #396]	; 34806544 <find_dev_and_part+0x198>
 * @param part pointer to requested partition (output)
 * @return 0 on success, 1 otherwise
 */
int find_dev_and_part(const char *id, struct mtd_device **dev,
		u8 *part_num, struct part_info **part)
{
348063b4:	e1a0a003 	mov	sl, r3
348063b8:	e1a07000 	mov	r7, r0
348063bc:	e1a05001 	mov	r5, r1
348063c0:	e1a04002 	mov	r4, r2
	u8 type, dnum, pnum;
	const char *p;

	debug("--- find_dev_and_part ---\nid = %s\n", id);

	list_for_each(dentry, &devices) {
348063c4:	e5bb6004 	ldr	r6, [fp, #4]!
		*part_num = 0;
348063c8:	e3a03000 	mov	r3, #0
	u8 type, dnum, pnum;
	const char *p;

	debug("--- find_dev_and_part ---\nid = %s\n", id);

	list_for_each(dentry, &devices) {
348063cc:	ea000014 	b	34806424 <find_dev_and_part+0x78>
		*part_num = 0;
348063d0:	e5c43000 	strb	r3, [r4]
		*dev = list_entry(dentry, struct mtd_device, link);
		list_for_each(pentry, &(*dev)->parts) {
348063d4:	e5969010 	ldr	r9, [r6, #16]

	debug("--- find_dev_and_part ---\nid = %s\n", id);

	list_for_each(dentry, &devices) {
		*part_num = 0;
		*dev = list_entry(dentry, struct mtd_device, link);
348063d8:	e5856000 	str	r6, [r5]
		list_for_each(pentry, &(*dev)->parts) {
348063dc:	ea00000b 	b	34806410 <find_dev_and_part+0x64>
			*part = list_entry(pentry, struct part_info, link);
			if (strcmp((*part)->name, id) == 0)
348063e0:	e5990008 	ldr	r0, [r9, #8]

	list_for_each(dentry, &devices) {
		*part_num = 0;
		*dev = list_entry(dentry, struct mtd_device, link);
		list_for_each(pentry, &(*dev)->parts) {
			*part = list_entry(pentry, struct part_info, link);
348063e4:	e58a9000 	str	r9, [sl]
			if (strcmp((*part)->name, id) == 0)
348063e8:	e1a01007 	mov	r1, r7
348063ec:	e58d3004 	str	r3, [sp, #4]
348063f0:	eb0049ae 	bl	34818ab0 <strcmp>
348063f4:	e3500000 	cmp	r0, #0
348063f8:	e59d3004 	ldr	r3, [sp, #4]
348063fc:	0a00004e 	beq	3480653c <find_dev_and_part+0x190>
				return 0;
			(*part_num)++;
34806400:	e5d42000 	ldrb	r2, [r4]
34806404:	e2822001 	add	r2, r2, #1
34806408:	e5c42000 	strb	r2, [r4]
	debug("--- find_dev_and_part ---\nid = %s\n", id);

	list_for_each(dentry, &devices) {
		*part_num = 0;
		*dev = list_entry(dentry, struct mtd_device, link);
		list_for_each(pentry, &(*dev)->parts) {
3480640c:	e5999000 	ldr	r9, [r9]
34806410:	e5952000 	ldr	r2, [r5]
34806414:	e2822010 	add	r2, r2, #16
34806418:	e1590002 	cmp	r9, r2
3480641c:	1affffef 	bne	348063e0 <find_dev_and_part+0x34>
	u8 type, dnum, pnum;
	const char *p;

	debug("--- find_dev_and_part ---\nid = %s\n", id);

	list_for_each(dentry, &devices) {
34806420:	e5966000 	ldr	r6, [r6]
34806424:	e156000b 	cmp	r6, fp
34806428:	1affffe8 	bne	348063d0 <find_dev_and_part+0x24>
				return 0;
			(*part_num)++;
		}
	}

	p = id;
3480642c:	e28d6010 	add	r6, sp, #16
34806430:	e5267008 	str	r7, [r6, #-8]!
	*dev = NULL;
34806434:	e3a03000 	mov	r3, #0
34806438:	e5853000 	str	r3, [r5]
	*part = NULL;
	*part_num = 0;

	if (mtd_id_parse(p, &p, &type, &dnum) != 0)
3480643c:	e28d200f 	add	r2, sp, #15
		}
	}

	p = id;
	*dev = NULL;
	*part = NULL;
34806440:	e58a3000 	str	r3, [sl]
	*part_num = 0;

	if (mtd_id_parse(p, &p, &type, &dnum) != 0)
34806444:	e1a00007 	mov	r0, r7
	}

	p = id;
	*dev = NULL;
	*part = NULL;
	*part_num = 0;
34806448:	e5c43000 	strb	r3, [r4]

	if (mtd_id_parse(p, &p, &type, &dnum) != 0)
3480644c:	e1a01006 	mov	r1, r6
34806450:	e28d300e 	add	r3, sp, #14
34806454:	ebffff90 	bl	3480629c <mtd_id_parse>
34806458:	e2502000 	subs	r2, r0, #0
3480645c:	1a000035 	bne	34806538 <find_dev_and_part+0x18c>
		return 1;

	if ((*p++ != ',') || (*p == '\0')) {
34806460:	e59d3008 	ldr	r3, [sp, #8]
34806464:	e1a00003 	mov	r0, r3
34806468:	e4d01001 	ldrb	r1, [r0], #1
3480646c:	e351002c 	cmp	r1, #44	; 0x2c
34806470:	e58d0008 	str	r0, [sp, #8]
34806474:	1a000002 	bne	34806484 <find_dev_and_part+0xd8>
34806478:	e5d33001 	ldrb	r3, [r3, #1]
3480647c:	e3530000 	cmp	r3, #0
34806480:	1a000002 	bne	34806490 <find_dev_and_part+0xe4>
		printf("no partition number specified\n");
34806484:	e59f00bc 	ldr	r0, [pc, #188]	; 34806548 <find_dev_and_part+0x19c>
34806488:	eb000aaf 	bl	34808f4c <printf>
3480648c:	ea000029 	b	34806538 <find_dev_and_part+0x18c>
		return 1;
	}
	pnum = simple_strtoul(p, (char **)&p, 0);
34806490:	e1a01006 	mov	r1, r6
34806494:	eb004dd7 	bl	34819bf8 <simple_strtoul>
	if (*p != '\0') {
34806498:	e59d3008 	ldr	r3, [sp, #8]

	if ((*p++ != ',') || (*p == '\0')) {
		printf("no partition number specified\n");
		return 1;
	}
	pnum = simple_strtoul(p, (char **)&p, 0);
3480649c:	e1a0b000 	mov	fp, r0
	if (*p != '\0') {
348064a0:	e5d36000 	ldrb	r6, [r3]
348064a4:	e3560000 	cmp	r6, #0
348064a8:	0a000003 	beq	348064bc <find_dev_and_part+0x110>
		printf("unexpected trailing character '%c'\n", *p);
348064ac:	e1a01006 	mov	r1, r6
348064b0:	e59f0094 	ldr	r0, [pc, #148]	; 3480654c <find_dev_and_part+0x1a0>
348064b4:	eb000aa4 	bl	34808f4c <printf>
348064b8:	ea00001e 	b	34806538 <find_dev_and_part+0x18c>
		return 1;
	}

	if ((*dev = device_find(type, dnum)) == NULL) {
348064bc:	e5dd700f 	ldrb	r7, [sp, #15]
348064c0:	e5dd900e 	ldrb	r9, [sp, #14]
348064c4:	e1a00007 	mov	r0, r7
348064c8:	e1a01009 	mov	r1, r9
348064cc:	ebfffe09 	bl	34805cf8 <device_find>
348064d0:	e3500000 	cmp	r0, #0
348064d4:	e5850000 	str	r0, [r5]
348064d8:	1a00000a 	bne	34806508 <find_dev_and_part+0x15c>
		printf("no such device %s%d\n", MTD_DEV_TYPE(type), dnum);
348064dc:	e3570002 	cmp	r7, #2
348064e0:	059f1068 	ldreq	r1, [pc, #104]	; 34806550 <find_dev_and_part+0x1a4>
348064e4:	0a000003 	beq	348064f8 <find_dev_and_part+0x14c>
348064e8:	e59f3064 	ldr	r3, [pc, #100]	; 34806554 <find_dev_and_part+0x1a8>
348064ec:	e3570004 	cmp	r7, #4
348064f0:	e59f1060 	ldr	r1, [pc, #96]	; 34806558 <find_dev_and_part+0x1ac>
348064f4:	01a01003 	moveq	r1, r3
348064f8:	e1a02009 	mov	r2, r9
348064fc:	e59f0058 	ldr	r0, [pc, #88]	; 3480655c <find_dev_and_part+0x1b0>
34806500:	eb000a91 	bl	34808f4c <printf>
34806504:	ea00000b 	b	34806538 <find_dev_and_part+0x18c>

	if ((*p++ != ',') || (*p == '\0')) {
		printf("no partition number specified\n");
		return 1;
	}
	pnum = simple_strtoul(p, (char **)&p, 0);
34806508:	e6ef707b 	uxtb	r7, fp
	if ((*dev = device_find(type, dnum)) == NULL) {
		printf("no such device %s%d\n", MTD_DEV_TYPE(type), dnum);
		return 1;
	}

	if ((*part = mtd_part_info(*dev, pnum)) == NULL) {
3480650c:	e1a01007 	mov	r1, r7
34806510:	ebfffb62 	bl	348052a0 <mtd_part_info>
34806514:	e3500000 	cmp	r0, #0
34806518:	e58a0000 	str	r0, [sl]
3480651c:	e1a09000 	mov	r9, r0
		printf("no such partition\n");
		*dev = NULL;
		return 1;
	}

	*part_num = pnum;
34806520:	15c47000 	strbne	r7, [r4]

	return 0;
34806524:	11a00006 	movne	r0, r6
	if ((*dev = device_find(type, dnum)) == NULL) {
		printf("no such device %s%d\n", MTD_DEV_TYPE(type), dnum);
		return 1;
	}

	if ((*part = mtd_part_info(*dev, pnum)) == NULL) {
34806528:	1a000003 	bne	3480653c <find_dev_and_part+0x190>
		printf("no such partition\n");
3480652c:	e59f002c 	ldr	r0, [pc, #44]	; 34806560 <find_dev_and_part+0x1b4>
34806530:	eb000a85 	bl	34808f4c <printf>
		*dev = NULL;
34806534:	e5859000 	str	r9, [r5]
	*dev = NULL;
	*part = NULL;
	*part_num = 0;

	if (mtd_id_parse(p, &p, &type, &dnum) != 0)
		return 1;
34806538:	e3a00001 	mov	r0, #1
	}

	*part_num = pnum;

	return 0;
}
3480653c:	e28dd010 	add	sp, sp, #16
34806540:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
34806544:	34829224 	.word	0x34829224
34806548:	34824a5b 	.word	0x34824a5b
3480654c:	34824a7a 	.word	0x34824a7a
34806550:	34824ada 	.word	0x34824ada
34806554:	34824ad7 	.word	0x34824ad7
34806558:	34824709 	.word	0x34824709
3480655c:	34824a9e 	.word	0x34824a9e
34806560:	34824ab3 	.word	0x34824ab3

34806564 <mtdparts_init>:
 * device/partition list.
 *
 * @return 0 on success, 1 otherwise
 */
int mtdparts_init(void)
{
34806564:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	const char *current_partition;
	int ids_changed;
	char tmp_ep[PARTITION_MAXLEN];

	debug("\n---mtdparts_init---\n");
	if (!initialized) {
34806568:	e59f4594 	ldr	r4, [pc, #1428]	; 34806b04 <mtdparts_init+0x5a0>
 * device/partition list.
 *
 * @return 0 on success, 1 otherwise
 */
int mtdparts_init(void)
{
3480656c:	e24dd028 	sub	sp, sp, #40	; 0x28
	const char *current_partition;
	int ids_changed;
	char tmp_ep[PARTITION_MAXLEN];

	debug("\n---mtdparts_init---\n");
	if (!initialized) {
34806570:	e5945228 	ldr	r5, [r4, #552]	; 0x228
34806574:	e3550000 	cmp	r5, #0
34806578:	1a000013 	bne	348065cc <mtdparts_init+0x68>
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
3480657c:	e2843e22 	add	r3, r4, #544	; 0x220
34806580:	e5843220 	str	r3, [r4, #544]	; 0x220
	list->prev = list;
34806584:	e5843224 	str	r3, [r4, #548]	; 0x224
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
34806588:	e2843004 	add	r3, r4, #4
3480658c:	e5843004 	str	r3, [r4, #4]
	list->prev = list;
34806590:	e5843008 	str	r3, [r4, #8]
		INIT_LIST_HEAD(&mtdids);
		INIT_LIST_HEAD(&devices);
		memset(last_ids, 0, MTDIDS_MAXLEN);
34806594:	e1a01005 	mov	r1, r5
34806598:	e3a02080 	mov	r2, #128	; 0x80
3480659c:	e2840f8b 	add	r0, r4, #556	; 0x22c
348065a0:	eb004a16 	bl	34818e00 <memset>
		memset(last_parts, 0, MTDPARTS_MAXLEN);
348065a4:	e1a01005 	mov	r1, r5
348065a8:	e3a02c02 	mov	r2, #512	; 0x200
348065ac:	e2840020 	add	r0, r4, #32
348065b0:	eb004a12 	bl	34818e00 <memset>
		memset(last_partition, 0, PARTITION_MAXLEN);
348065b4:	e2840010 	add	r0, r4, #16
348065b8:	e1a01005 	mov	r1, r5
348065bc:	e3a02010 	mov	r2, #16
348065c0:	eb004a0e 	bl	34818e00 <memset>
		initialized = 1;
348065c4:	e3a03001 	mov	r3, #1
348065c8:	e5843228 	str	r3, [r4, #552]	; 0x228
	}

	/* get variables */
	ids = getenv("mtdids");
348065cc:	e59f0534 	ldr	r0, [pc, #1332]	; 34806b08 <mtdparts_init+0x5a4>
348065d0:	eb000719 	bl	3480823c <getenv>
348065d4:	e1a05000 	mov	r5, r0
	parts = getenv("mtdparts");
348065d8:	e59f052c 	ldr	r0, [pc, #1324]	; 34806b0c <mtdparts_init+0x5a8>
348065dc:	eb000716 	bl	3480823c <getenv>
348065e0:	e1a04000 	mov	r4, r0
	current_partition = getenv("partition");
348065e4:	e59f0524 	ldr	r0, [pc, #1316]	; 34806b10 <mtdparts_init+0x5ac>
348065e8:	eb000713 	bl	3480823c <getenv>

	/* save it for later parsing, cannot rely on current partition pointer
	 * as 'partition' variable may be updated during init */
	tmp_ep[0] = '\0';
348065ec:	e3a03000 	mov	r3, #0
	if (current_partition)
348065f0:	e2501000 	subs	r1, r0, #0
	parts = getenv("mtdparts");
	current_partition = getenv("partition");

	/* save it for later parsing, cannot rely on current partition pointer
	 * as 'partition' variable may be updated during init */
	tmp_ep[0] = '\0';
348065f4:	e5cd3004 	strb	r3, [sp, #4]
	if (current_partition)
348065f8:	0a000002 	beq	34806608 <mtdparts_init+0xa4>
		strncpy(tmp_ep, current_partition, PARTITION_MAXLEN);
348065fc:	e28d0004 	add	r0, sp, #4
34806600:	e3a02010 	mov	r2, #16
34806604:	eb0048ff 	bl	34818a08 <strncpy>

	debug("last_partition : %s\n", last_partition);
	debug("env_partition  : %s\n", current_partition);

	/* if mtdids varible is empty try to use defaults */
	if (!ids) {
34806608:	e3550000 	cmp	r5, #0
3480660c:	1a000003 	bne	34806620 <mtdparts_init+0xbc>
		if (mtdids_default) {
			debug("mtdids variable not defined, using default\n");
			ids = mtdids_default;
			setenv("mtdids", (char *)ids);
34806610:	e59f04f0 	ldr	r0, [pc, #1264]	; 34806b08 <mtdparts_init+0x5a4>
34806614:	e59f14f8 	ldr	r1, [pc, #1272]	; 34806b14 <mtdparts_init+0x5b0>
34806618:	eb0005ff 	bl	34807e1c <setenv>

	/* if mtdids varible is empty try to use defaults */
	if (!ids) {
		if (mtdids_default) {
			debug("mtdids variable not defined, using default\n");
			ids = mtdids_default;
3480661c:	e59f54f0 	ldr	r5, [pc, #1264]	; 34806b14 <mtdparts_init+0x5b0>
		} else {
			printf("mtdids not defined, no default present\n");
			return 1;
		}
	}
	if (strlen(ids) > MTDIDS_MAXLEN - 1) {
34806620:	e1a00005 	mov	r0, r5
34806624:	eb004955 	bl	34818b80 <strlen>
34806628:	e350007f 	cmp	r0, #127	; 0x7f
		printf("mtdids too long (> %d)\n", MTDIDS_MAXLEN);
3480662c:	859f04e4 	ldrhi	r0, [pc, #1252]	; 34806b18 <mtdparts_init+0x5b4>
34806630:	83a01080 	movhi	r1, #128	; 0x80
		} else {
			printf("mtdids not defined, no default present\n");
			return 1;
		}
	}
	if (strlen(ids) > MTDIDS_MAXLEN - 1) {
34806634:	8a00000a 	bhi	34806664 <mtdparts_init+0x100>
		return 1;
	}

	/* do no try to use defaults when mtdparts variable is not defined,
	 * just check the length */
	if (!parts)
34806638:	e3540000 	cmp	r4, #0
3480663c:	1a000002 	bne	3480664c <mtdparts_init+0xe8>
		printf("mtdparts variable not set, see 'help mtdparts'\n");
34806640:	e59f04d4 	ldr	r0, [pc, #1236]	; 34806b1c <mtdparts_init+0x5b8>
34806644:	eb000a40 	bl	34808f4c <printf>
34806648:	ea000008 	b	34806670 <mtdparts_init+0x10c>

	if (parts && (strlen(parts) > MTDPARTS_MAXLEN - 1)) {
3480664c:	e1a00004 	mov	r0, r4
34806650:	eb00494a 	bl	34818b80 <strlen>
34806654:	e3500c02 	cmp	r0, #512	; 0x200
34806658:	3a000004 	bcc	34806670 <mtdparts_init+0x10c>
		printf("mtdparts too long (> %d)\n", MTDPARTS_MAXLEN);
3480665c:	e59f04bc 	ldr	r0, [pc, #1212]	; 34806b20 <mtdparts_init+0x5bc>
34806660:	e3a01c02 	mov	r1, #512	; 0x200
34806664:	eb000a38 	bl	34808f4c <printf>
		return 1;
34806668:	e3a00001 	mov	r0, #1
3480666c:	ea00010c 	b	34806aa4 <mtdparts_init+0x540>
	}

	/* check if we have already parsed those mtdids */
	if ((last_ids[0] != '\0') && (strcmp(last_ids, ids) == 0)) {
34806670:	e59f048c 	ldr	r0, [pc, #1164]	; 34806b04 <mtdparts_init+0x5a0>
34806674:	e5d0322c 	ldrb	r3, [r0, #556]	; 0x22c
34806678:	e3530000 	cmp	r3, #0
3480667c:	0a000005 	beq	34806698 <mtdparts_init+0x134>
34806680:	e1a01005 	mov	r1, r5
34806684:	e2800f8b 	add	r0, r0, #556	; 0x22c
34806688:	eb004908 	bl	34818ab0 <strcmp>
3480668c:	e3500000 	cmp	r0, #0
		ids_changed = 0;
34806690:	01a05000 	moveq	r5, r0
		printf("mtdparts too long (> %d)\n", MTDPARTS_MAXLEN);
		return 1;
	}

	/* check if we have already parsed those mtdids */
	if ((last_ids[0] != '\0') && (strcmp(last_ids, ids) == 0)) {
34806694:	0a000088 	beq	348068bc <mtdparts_init+0x358>
	int ret = 1;

	debug("\n---parse_mtdids---\nmtdids = %s\n\n", ids);

	/* clean global mtdids list */
	list_for_each_safe(entry, n, &mtdids) {
34806698:	e59f7464 	ldr	r7, [pc, #1124]	; 34806b04 <mtdparts_init+0x5a0>
 * @param ids mapping string
 * @return 0 on success, 1 otherwise
 */
static int parse_mtdids(const char *const ids)
{
	const char *p = ids;
3480669c:	e58d5018 	str	r5, [sp, #24]
	int ret = 1;

	debug("\n---parse_mtdids---\nmtdids = %s\n\n", ids);

	/* clean global mtdids list */
	list_for_each_safe(entry, n, &mtdids) {
348066a0:	e5b70220 	ldr	r0, [r7, #544]!	; 0x220
 * in an undefined state.
 */
static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
348066a4:	e3a0a000 	mov	sl, #0
348066a8:	e5906000 	ldr	r6, [r0]
348066ac:	ea000007 	b	348066d0 <mtdparts_init+0x16c>
 * Note: list_empty() on entry does not return true after this, the entry is
 * in an undefined state.
 */
static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
348066b0:	e890000c 	ldm	r0, {r2, r3}
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head *prev, struct list_head *next)
{
	next->prev = prev;
348066b4:	e5823004 	str	r3, [r2, #4]
	prev->next = next;
348066b8:	e5832000 	str	r2, [r3]
 */
static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
	entry->prev = LIST_POISON2;
348066bc:	e580a004 	str	sl, [r0, #4]
 * in an undefined state.
 */
static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
348066c0:	e580a000 	str	sl, [r0]
		id_tmp = list_entry(entry, struct mtdids, link);
		debug("mtdids del: %d %d\n", id_tmp->type, id_tmp->num);
		list_del(entry);
		free(id_tmp);
348066c4:	eb000b5e 	bl	34809444 <free>
	int ret = 1;

	debug("\n---parse_mtdids---\nmtdids = %s\n\n", ids);

	/* clean global mtdids list */
	list_for_each_safe(entry, n, &mtdids) {
348066c8:	e1a00006 	mov	r0, r6
348066cc:	e5966000 	ldr	r6, [r6]
348066d0:	e1500007 	cmp	r0, r7
348066d4:	e59f9428 	ldr	r9, [pc, #1064]	; 34806b04 <mtdparts_init+0x5a0>
348066d8:	1afffff4 	bne	348066b0 <mtdparts_init+0x14c>
		id_tmp = list_entry(entry, struct mtdids, link);
		debug("mtdids del: %d %d\n", id_tmp->type, id_tmp->num);
		list_del(entry);
		free(id_tmp);
	}
	last_ids[0] = '\0';
348066dc:	e3a03000 	mov	r3, #0
348066e0:	e5c9322c 	strb	r3, [r9, #556]	; 0x22c
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
348066e4:	e5890220 	str	r0, [r9, #544]	; 0x220
	list->prev = list;
348066e8:	e5890224 	str	r0, [r9, #548]	; 0x224
	struct mtdids *id;
	struct list_head *entry, *n;
	struct mtdids *id_tmp;
	u8 type, num;
	u32 size;
	int ret = 1;
348066ec:	e2833001 	add	r3, r3, #1
348066f0:	e1a0a005 	mov	sl, r5
348066f4:	ea000057 	b	34806858 <mtdparts_init+0x2f4>

	while(p && (*p != '\0')) {

		ret = 1;
		/* parse 'nor'|'nand'|'onenand'<dev-num> */
		if (mtd_id_parse(p, &p, &type, &num) != 0)
348066f8:	e28d1018 	add	r1, sp, #24
348066fc:	e28d2027 	add	r2, sp, #39	; 0x27
34806700:	e28d3020 	add	r3, sp, #32
34806704:	ebfffee4 	bl	3480629c <mtd_id_parse>
34806708:	e3500000 	cmp	r0, #0
3480670c:	1a000059 	bne	34806878 <mtdparts_init+0x314>
			break;

		if (*p != '=') {
34806710:	e59d3018 	ldr	r3, [sp, #24]
34806714:	e5d32000 	ldrb	r2, [r3]
34806718:	e352003d 	cmp	r2, #61	; 0x3d
			printf("mtdids: incorrect <dev-num>\n");
3480671c:	159f0400 	ldrne	r0, [pc, #1024]	; 34806b24 <mtdparts_init+0x5c0>
34806720:	1a000032 	bne	348067f0 <mtdparts_init+0x28c>
			break;
		}
		p++;
34806724:	e2833001 	add	r3, r3, #1

		/* check if requested device exists */
		if (mtd_device_validate(type, num, &size) != 0)
34806728:	e5dd0027 	ldrb	r0, [sp, #39]	; 0x27
3480672c:	e5dd1020 	ldrb	r1, [sp, #32]
34806730:	e28d201c 	add	r2, sp, #28

		if (*p != '=') {
			printf("mtdids: incorrect <dev-num>\n");
			break;
		}
		p++;
34806734:	e58d3018 	str	r3, [sp, #24]

		/* check if requested device exists */
		if (mtd_device_validate(type, num, &size) != 0)
34806738:	ebfffd62 	bl	34805cc8 <mtd_device_validate>
3480673c:	e3500000 	cmp	r0, #0
34806740:	1a00005b 	bne	348068b4 <mtdparts_init+0x350>
			return 1;

		/* locate <mtd-id> */
		mtd_id = p;
34806744:	e59d7018 	ldr	r7, [sp, #24]
		if ((p = strchr(mtd_id, ',')) != NULL) {
34806748:	e3a0102c 	mov	r1, #44	; 0x2c
3480674c:	e1a00007 	mov	r0, r7
34806750:	eb0048f4 	bl	34818b28 <strchr>
34806754:	e3500000 	cmp	r0, #0
34806758:	e58d0018 	str	r0, [sp, #24]
			mtd_id_len = p - mtd_id + 1;
3480675c:	12676001 	rsbne	r6, r7, #1
34806760:	10806006 	addne	r6, r0, r6
			p++;
34806764:	12800001 	addne	r0, r0, #1
34806768:	158d0018 	strne	r0, [sp, #24]
3480676c:	1a000002 	bne	3480677c <mtdparts_init+0x218>
		} else {
			mtd_id_len = strlen(mtd_id) + 1;
34806770:	e1a00007 	mov	r0, r7
34806774:	eb004901 	bl	34818b80 <strlen>
34806778:	e2806001 	add	r6, r0, #1
		}
		if (mtd_id_len == 0) {
3480677c:	e3560000 	cmp	r6, #0
			printf("mtdids: no <mtd-id> identifier\n");
34806780:	059f03a0 	ldreq	r0, [pc, #928]	; 34806b28 <mtdparts_init+0x5c4>
34806784:	0a000019 	beq	348067f0 <mtdparts_init+0x28c>
			break;
		}

		/* check if this id is already on the list */
		int double_entry = 0;
		list_for_each(entry, &mtdids) {
34806788:	e5993220 	ldr	r3, [r9, #544]	; 0x220
			id_tmp = list_entry(entry, struct mtdids, link);
			if ((id_tmp->type == type) && (id_tmp->num == num)) {
3480678c:	e5dd0027 	ldrb	r0, [sp, #39]	; 0x27
34806790:	e5dd1020 	ldrb	r1, [sp, #32]
34806794:	ea000006 	b	348067b4 <mtdparts_init+0x250>
34806798:	e5d32008 	ldrb	r2, [r3, #8]
3480679c:	e1520000 	cmp	r2, r0
348067a0:	1a000002 	bne	348067b0 <mtdparts_init+0x24c>
348067a4:	e5d32009 	ldrb	r2, [r3, #9]
348067a8:	e1520001 	cmp	r2, r1
348067ac:	0a000004 	beq	348067c4 <mtdparts_init+0x260>
			break;
		}

		/* check if this id is already on the list */
		int double_entry = 0;
		list_for_each(entry, &mtdids) {
348067b0:	e5933000 	ldr	r3, [r3]
348067b4:	e59f2370 	ldr	r2, [pc, #880]	; 34806b2c <mtdparts_init+0x5c8>
348067b8:	e1530002 	cmp	r3, r2
348067bc:	1afffff5 	bne	34806798 <mtdparts_init+0x234>
348067c0:	ea0000b9 	b	34806aac <mtdparts_init+0x548>
				double_entry = 1;
				break;
			}
		}
		if (double_entry) {
			printf("device id %s%d redefined, please correct mtdids variable\n",
348067c4:	e3500002 	cmp	r0, #2
348067c8:	059f1360 	ldreq	r1, [pc, #864]	; 34806b30 <mtdparts_init+0x5cc>
348067cc:	0a000003 	beq	348067e0 <mtdparts_init+0x27c>
					MTD_DEV_TYPE(type), num);
348067d0:	e59f335c 	ldr	r3, [pc, #860]	; 34806b34 <mtdparts_init+0x5d0>
348067d4:	e3500004 	cmp	r0, #4
348067d8:	e59f1358 	ldr	r1, [pc, #856]	; 34806b38 <mtdparts_init+0x5d4>
348067dc:	01a01003 	moveq	r1, r3
				double_entry = 1;
				break;
			}
		}
		if (double_entry) {
			printf("device id %s%d redefined, please correct mtdids variable\n",
348067e0:	e59f0354 	ldr	r0, [pc, #852]	; 34806b3c <mtdparts_init+0x5d8>
348067e4:	eb0009d8 	bl	34808f4c <printf>
348067e8:	ea000022 	b	34806878 <mtdparts_init+0x314>
			break;
		}

		/* allocate mtdids structure */
		if (!(id = (struct mtdids *)malloc(sizeof(struct mtdids) + mtd_id_len))) {
			printf("out of memory\n");
348067ec:	e59f034c 	ldr	r0, [pc, #844]	; 34806b40 <mtdparts_init+0x5dc>
348067f0:	eb0009d5 	bl	34808f4c <printf>
348067f4:	ea00001f 	b	34806878 <mtdparts_init+0x314>
			break;
		}
		memset(id, 0, sizeof(struct mtdids) + mtd_id_len);
348067f8:	e3a01000 	mov	r1, #0
348067fc:	e1a0200b 	mov	r2, fp
34806800:	eb00497e 	bl	34818e00 <memset>
		id->num = num;
34806804:	e5dd3020 	ldrb	r3, [sp, #32]
		id->type = type;
		id->size = size;
		id->mtd_id = (char *)(id + 1);
34806808:	e2850014 	add	r0, r5, #20
		if (!(id = (struct mtdids *)malloc(sizeof(struct mtdids) + mtd_id_len))) {
			printf("out of memory\n");
			break;
		}
		memset(id, 0, sizeof(struct mtdids) + mtd_id_len);
		id->num = num;
3480680c:	e5c53009 	strb	r3, [r5, #9]
		id->type = type;
34806810:	e5dd3027 	ldrb	r3, [sp, #39]	; 0x27
		id->size = size;
		id->mtd_id = (char *)(id + 1);
		strncpy(id->mtd_id, mtd_id, mtd_id_len - 1);
34806814:	e2462001 	sub	r2, r6, #1
			printf("out of memory\n");
			break;
		}
		memset(id, 0, sizeof(struct mtdids) + mtd_id_len);
		id->num = num;
		id->type = type;
34806818:	e5c53008 	strb	r3, [r5, #8]
		id->size = size;
3480681c:	e59d301c 	ldr	r3, [sp, #28]
		id->mtd_id = (char *)(id + 1);
		strncpy(id->mtd_id, mtd_id, mtd_id_len - 1);
34806820:	e1a01007 	mov	r1, r7
			break;
		}
		memset(id, 0, sizeof(struct mtdids) + mtd_id_len);
		id->num = num;
		id->type = type;
		id->size = size;
34806824:	e585300c 	str	r3, [r5, #12]
		id->mtd_id = (char *)(id + 1);
34806828:	e5850010 	str	r0, [r5, #16]
		strncpy(id->mtd_id, mtd_id, mtd_id_len - 1);
3480682c:	eb004875 	bl	34818a08 <strncpy>
		id->mtd_id[mtd_id_len - 1] = '\0';
34806830:	e5953010 	ldr	r3, [r5, #16]
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
34806834:	e59f12c8 	ldr	r1, [pc, #712]	; 34806b04 <mtdparts_init+0x5a0>
34806838:	e0836006 	add	r6, r3, r6
3480683c:	e3a03000 	mov	r3, #0
34806840:	e5463001 	strb	r3, [r6, #-1]
34806844:	e5912224 	ldr	r2, [r1, #548]	; 0x224
 */
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
34806848:	e5815224 	str	r5, [r1, #548]	; 0x224
	new->next = next;
3480684c:	e59f12d8 	ldr	r1, [pc, #728]	; 34806b2c <mtdparts_init+0x5c8>
	new->prev = prev;
34806850:	e8850006 	stm	r5, {r1, r2}
	prev->next = new;
34806854:	e5825000 	str	r5, [r2]
		free(id_tmp);
	}
	last_ids[0] = '\0';
	INIT_LIST_HEAD(&mtdids);

	while(p && (*p != '\0')) {
34806858:	e59d0018 	ldr	r0, [sp, #24]
3480685c:	e3500000 	cmp	r0, #0
34806860:	0a000002 	beq	34806870 <mtdparts_init+0x30c>
34806864:	e5d02000 	ldrb	r2, [r0]
34806868:	e3520000 	cmp	r2, #0
3480686c:	1affffa1 	bne	348066f8 <mtdparts_init+0x194>
				id->size, id->mtd_id);

		list_add_tail(&id->link, &mtdids);
		ret = 0;
	}
	if (ret == 1) {
34806870:	e3530001 	cmp	r3, #1
34806874:	1a000092 	bne	34806ac4 <mtdparts_init+0x560>
		/* clean mtdids list and free allocated memory */
		list_for_each_safe(entry, n, &mtdids) {
34806878:	e59f5284 	ldr	r5, [pc, #644]	; 34806b04 <mtdparts_init+0x5a0>
 * in an undefined state.
 */
static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
3480687c:	e3a06000 	mov	r6, #0
34806880:	e5b50220 	ldr	r0, [r5, #544]!	; 0x220
34806884:	e5904000 	ldr	r4, [r0]
34806888:	ea000007 	b	348068ac <mtdparts_init+0x348>
 * Note: list_empty() on entry does not return true after this, the entry is
 * in an undefined state.
 */
static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
3480688c:	e890000c 	ldm	r0, {r2, r3}
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head *prev, struct list_head *next)
{
	next->prev = prev;
34806890:	e5823004 	str	r3, [r2, #4]
	prev->next = next;
34806894:	e5832000 	str	r2, [r3]
 */
static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
	entry->prev = LIST_POISON2;
34806898:	e5806004 	str	r6, [r0, #4]
 * in an undefined state.
 */
static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
3480689c:	e5806000 	str	r6, [r0]
			id_tmp = list_entry(entry, struct mtdids, link);
			list_del(entry);
			free(id_tmp);
348068a0:	eb000ae7 	bl	34809444 <free>
		list_add_tail(&id->link, &mtdids);
		ret = 0;
	}
	if (ret == 1) {
		/* clean mtdids list and free allocated memory */
		list_for_each_safe(entry, n, &mtdids) {
348068a4:	e1a00004 	mov	r0, r4
348068a8:	e5944000 	ldr	r4, [r4]
348068ac:	e1500005 	cmp	r0, r5
348068b0:	1afffff5 	bne	3480688c <mtdparts_init+0x328>
		ids_changed = 0;
	} else {
		ids_changed = 1;

		if (parse_mtdids(ids) != 0) {
			mtd_devices_init();
348068b4:	ebfffc49 	bl	348059e0 <mtd_devices_init>
348068b8:	eaffff6a 	b	34806668 <mtdparts_init+0x104>
		/* ok it's good, save new ids */
		strncpy(last_ids, ids, MTDIDS_MAXLEN);
	}

	/* parse partitions if either mtdparts or mtdids were updated */
	if (parts && ((last_parts[0] == '\0') || ((strcmp(last_parts, parts) != 0)) || ids_changed)) {
348068bc:	e3540000 	cmp	r4, #0
348068c0:	e59f023c 	ldr	r0, [pc, #572]	; 34806b04 <mtdparts_init+0x5a0>
348068c4:	0a000056 	beq	34806a24 <mtdparts_init+0x4c0>
348068c8:	e5d03020 	ldrb	r3, [r0, #32]
348068cc:	e3530000 	cmp	r3, #0
348068d0:	0a000006 	beq	348068f0 <mtdparts_init+0x38c>
348068d4:	e2800020 	add	r0, r0, #32
348068d8:	e1a01004 	mov	r1, r4
348068dc:	eb004873 	bl	34818ab0 <strcmp>
348068e0:	e3500000 	cmp	r0, #0
348068e4:	1a000001 	bne	348068f0 <mtdparts_init+0x38c>
348068e8:	e3550000 	cmp	r5, #0
348068ec:	0a000080 	beq	34806af4 <mtdparts_init+0x590>
 * @param mtdparts string specifing mtd partitions
 * @return 0 on success, 1 otherwise
 */
static int parse_mtdparts(const char *const mtdparts)
{
	const char *p = mtdparts;
348068f0:	e58d4018 	str	r4, [sp, #24]
	int err = 1;

	debug("\n---parse_mtdparts---\nmtdparts = %s\n\n", p);

	/* delete all devices and partitions */
	if (mtd_devices_init() != 0) {
348068f4:	ebfffc39 	bl	348059e0 <mtd_devices_init>
348068f8:	e3500000 	cmp	r0, #0
		printf("could not initialise device list\n");
348068fc:	159f0240 	ldrne	r0, [pc, #576]	; 34806b44 <mtdparts_init+0x5e0>
	int err = 1;

	debug("\n---parse_mtdparts---\nmtdparts = %s\n\n", p);

	/* delete all devices and partitions */
	if (mtd_devices_init() != 0) {
34806900:	1a00003b 	bne	348069f4 <mtdparts_init+0x490>
		printf("could not initialise device list\n");
		return err;
	}

	/* re-read 'mtdparts' variable, mtd_devices_init may be updating env */
	p = getenv("mtdparts");
34806904:	e59f0200 	ldr	r0, [pc, #512]	; 34806b0c <mtdparts_init+0x5a8>
34806908:	eb00064b 	bl	3480823c <getenv>

	if (strncmp(p, "mtdparts=", 9) != 0) {
3480690c:	e59f1234 	ldr	r1, [pc, #564]	; 34806b48 <mtdparts_init+0x5e4>
34806910:	e3a02009 	mov	r2, #9
		printf("could not initialise device list\n");
		return err;
	}

	/* re-read 'mtdparts' variable, mtd_devices_init may be updating env */
	p = getenv("mtdparts");
34806914:	e58d0018 	str	r0, [sp, #24]

	if (strncmp(p, "mtdparts=", 9) != 0) {
34806918:	eb004870 	bl	34818ae0 <strncmp>
3480691c:	e3500000 	cmp	r0, #0
		printf("mtdparts variable doesn't start with 'mtdparts='\n");
34806920:	159f0224 	ldrne	r0, [pc, #548]	; 34806b4c <mtdparts_init+0x5e8>
	}

	/* re-read 'mtdparts' variable, mtd_devices_init may be updating env */
	p = getenv("mtdparts");

	if (strncmp(p, "mtdparts=", 9) != 0) {
34806924:	1a000032 	bne	348069f4 <mtdparts_init+0x490>
		printf("mtdparts variable doesn't start with 'mtdparts='\n");
		return err;
	}
	p += 9;
34806928:	e59d3018 	ldr	r3, [sp, #24]
3480692c:	e28d6028 	add	r6, sp, #40	; 0x28
34806930:	e2833009 	add	r3, r3, #9
34806934:	e5263010 	str	r3, [r6, #-16]!

	while (p && (*p != '\0')) {
		err = 1;
		if ((device_parse(p, &p, &dev) != 0) || (!dev))
34806938:	e28d7014 	add	r7, sp, #20
 */
static int parse_mtdparts(const char *const mtdparts)
{
	const char *p = mtdparts;
	struct mtd_device *dev;
	int err = 1;
3480693c:	e3a03001 	mov	r3, #1
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
34806940:	e59f51bc 	ldr	r5, [pc, #444]	; 34806b04 <mtdparts_init+0x5a0>
34806944:	ea00001f 	b	348069c8 <mtdparts_init+0x464>
	}
	p += 9;

	while (p && (*p != '\0')) {
		err = 1;
		if ((device_parse(p, &p, &dev) != 0) || (!dev))
34806948:	e1a01006 	mov	r1, r6
3480694c:	e1a02007 	mov	r2, r7
34806950:	ebfffcfb 	bl	34805d44 <device_parse>
34806954:	e3500000 	cmp	r0, #0
34806958:	1a000022 	bne	348069e8 <mtdparts_init+0x484>
3480695c:	e59da014 	ldr	sl, [sp, #20]
34806960:	e35a0000 	cmp	sl, #0
34806964:	0a00001f 	beq	348069e8 <mtdparts_init+0x484>

		debug("+ device: %s\t%d\t%s\n", MTD_DEV_TYPE(dev->id->type),
				dev->id->num, dev->id->mtd_id);

		/* check if parsed device is already on the list */
		if (device_find(dev->id->type, dev->id->num) != NULL) {
34806968:	e59a3008 	ldr	r3, [sl, #8]
3480696c:	e5d39008 	ldrb	r9, [r3, #8]
34806970:	e5d3b009 	ldrb	fp, [r3, #9]
34806974:	e1a00009 	mov	r0, r9
34806978:	e1a0100b 	mov	r1, fp
3480697c:	ebfffcdd 	bl	34805cf8 <device_find>
34806980:	e2503000 	subs	r3, r0, #0
34806984:	0a00000a 	beq	348069b4 <mtdparts_init+0x450>
			printf("device %s%d redefined, please correct mtdparts variable\n",
34806988:	e3590002 	cmp	r9, #2
3480698c:	059f119c 	ldreq	r1, [pc, #412]	; 34806b30 <mtdparts_init+0x5cc>
34806990:	0a000003 	beq	348069a4 <mtdparts_init+0x440>
					MTD_DEV_TYPE(dev->id->type), dev->id->num);
34806994:	e59f3198 	ldr	r3, [pc, #408]	; 34806b34 <mtdparts_init+0x5d0>
34806998:	e3590004 	cmp	r9, #4
3480699c:	e59f1194 	ldr	r1, [pc, #404]	; 34806b38 <mtdparts_init+0x5d4>
348069a0:	01a01003 	moveq	r1, r3
		debug("+ device: %s\t%d\t%s\n", MTD_DEV_TYPE(dev->id->type),
				dev->id->num, dev->id->mtd_id);

		/* check if parsed device is already on the list */
		if (device_find(dev->id->type, dev->id->num) != NULL) {
			printf("device %s%d redefined, please correct mtdparts variable\n",
348069a4:	e1a0200b 	mov	r2, fp
348069a8:	e59f01a0 	ldr	r0, [pc, #416]	; 34806b50 <mtdparts_init+0x5ec>
348069ac:	eb000966 	bl	34808f4c <printf>
348069b0:	ea00000c 	b	348069e8 <mtdparts_init+0x484>
348069b4:	e5952008 	ldr	r2, [r5, #8]
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
	new->next = next;
348069b8:	e59f1194 	ldr	r1, [pc, #404]	; 34806b54 <mtdparts_init+0x5f0>
 */
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
348069bc:	e585a008 	str	sl, [r5, #8]
	new->next = next;
348069c0:	e88a0006 	stm	sl, {r1, r2}
	new->prev = prev;
	prev->next = new;
348069c4:	e582a000 	str	sl, [r2]
		printf("mtdparts variable doesn't start with 'mtdparts='\n");
		return err;
	}
	p += 9;

	while (p && (*p != '\0')) {
348069c8:	e59d0018 	ldr	r0, [sp, #24]
348069cc:	e3500000 	cmp	r0, #0
348069d0:	0a000002 	beq	348069e0 <mtdparts_init+0x47c>
348069d4:	e5d02000 	ldrb	r2, [r0]
348069d8:	e3520000 	cmp	r2, #0
348069dc:	1affffd9 	bne	34806948 <mtdparts_init+0x3e4>
		}

		list_add_tail(&dev->link, &devices);
		err = 0;
	}
	if (err == 1) {
348069e0:	e3530001 	cmp	r3, #1
348069e4:	1a00003c 	bne	34806adc <mtdparts_init+0x578>
		device_delall(&devices);
348069e8:	ebfffbe3 	bl	3480597c <device_delall.clone.2>
348069ec:	eaffff1d 	b	34806668 <mtdparts_init+0x104>
	if (parts && ((last_parts[0] == '\0') || ((strcmp(last_parts, parts) != 0)) || ids_changed)) {
		if (parse_mtdparts(parts) != 0)
			return 1;

		if (list_empty(&devices)) {
			printf("mtdparts_init: no valid partitions\n");
348069f0:	e59f0160 	ldr	r0, [pc, #352]	; 34806b58 <mtdparts_init+0x5f4>
348069f4:	eb000954 	bl	34808f4c <printf>
348069f8:	eaffff1a 	b	34806668 <mtdparts_init+0x104>
			return 1;
		}

		/* ok it's good, save new parts */
		strncpy(last_parts, parts, MTDPARTS_MAXLEN);
348069fc:	e2850020 	add	r0, r5, #32
34806a00:	e1a01004 	mov	r1, r4
34806a04:	e3a02c02 	mov	r2, #512	; 0x200
34806a08:	eb0047fe 	bl	34818a08 <strncpy>

		/* reset first partition from first dev from the list as current */
		current_mtd_dev = list_entry(devices.next, struct mtd_device, link);
34806a0c:	e5953004 	ldr	r3, [r5, #4]
34806a10:	e5853000 	str	r3, [r5]
		current_mtd_partnum = 0;
34806a14:	e3a03000 	mov	r3, #0
34806a18:	e5c5300c 	strb	r3, [r5, #12]
		current_save();
34806a1c:	ebfffa88 	bl	34805444 <current_save>
34806a20:	ea000033 	b	34806af4 <mtdparts_init+0x590>
				MTD_DEV_TYPE(current_mtd_dev->id->type),
				current_mtd_dev->id->num, current_mtd_partnum);
	}

	/* mtdparts variable was reset to NULL, delete all devices/partitions */
	if (!parts && (last_parts[0] != '\0'))
34806a24:	e5d03020 	ldrb	r3, [r0, #32]
34806a28:	e3530000 	cmp	r3, #0
34806a2c:	0a000019 	beq	34806a98 <mtdparts_init+0x534>
		return mtd_devices_init();
34806a30:	ebfffbea 	bl	348059e0 <mtd_devices_init>
34806a34:	ea00001a 	b	34806aa4 <mtdparts_init+0x540>
	/* do not process current partition if mtdparts variable is null */
	if (!parts)
		return 0;

	/* is current partition set in environment? if so, use it */
	if ((tmp_ep[0] != '\0') && (strcmp(tmp_ep, last_partition) != 0)) {
34806a38:	e59f50c4 	ldr	r5, [pc, #196]	; 34806b04 <mtdparts_init+0x5a0>
34806a3c:	e28d4004 	add	r4, sp, #4
34806a40:	e1a00004 	mov	r0, r4
34806a44:	e2851010 	add	r1, r5, #16
34806a48:	eb004818 	bl	34818ab0 <strcmp>
34806a4c:	e3500000 	cmp	r0, #0
34806a50:	0a00000b 	beq	34806a84 <mtdparts_init+0x520>
		struct mtd_device *cdev;
		u8 pnum;

		debug("--- getting current partition: %s\n", tmp_ep);

		if (find_dev_and_part(tmp_ep, &cdev, &pnum, &p) == 0) {
34806a54:	e1a00004 	mov	r0, r4
34806a58:	e28d1014 	add	r1, sp, #20
34806a5c:	e28d2027 	add	r2, sp, #39	; 0x27
34806a60:	e28d3020 	add	r3, sp, #32
34806a64:	ebfffe50 	bl	348063ac <find_dev_and_part>
34806a68:	e2504000 	subs	r4, r0, #0
34806a6c:	1a00000b 	bne	34806aa0 <mtdparts_init+0x53c>
			current_mtd_dev = cdev;
34806a70:	e59d3014 	ldr	r3, [sp, #20]
34806a74:	e5853000 	str	r3, [r5]
			current_mtd_partnum = pnum;
34806a78:	e5dd3027 	ldrb	r3, [sp, #39]	; 0x27
34806a7c:	e5c5300c 	strb	r3, [r5, #12]
34806a80:	ea000003 	b	34806a94 <mtdparts_init+0x530>
			current_save();
		}
	} else if (getenv("partition") == NULL) {
34806a84:	e59f0084 	ldr	r0, [pc, #132]	; 34806b10 <mtdparts_init+0x5ac>
34806a88:	eb0005eb 	bl	3480823c <getenv>
34806a8c:	e2504000 	subs	r4, r0, #0
34806a90:	1a000002 	bne	34806aa0 <mtdparts_init+0x53c>
		debug("no partition variable set, setting...\n");
		current_save();
34806a94:	ebfffa6a 	bl	34805444 <current_save>
	if (!parts && (last_parts[0] != '\0'))
		return mtd_devices_init();

	/* do not process current partition if mtdparts variable is null */
	if (!parts)
		return 0;
34806a98:	e1a00004 	mov	r0, r4
34806a9c:	ea000000 	b	34806aa4 <mtdparts_init+0x540>
	} else if (getenv("partition") == NULL) {
		debug("no partition variable set, setting...\n");
		current_save();
	}

	return 0;
34806aa0:	e3a00000 	mov	r0, #0
}
34806aa4:	e28dd028 	add	sp, sp, #40	; 0x28
34806aa8:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
					MTD_DEV_TYPE(type), num);
			break;
		}

		/* allocate mtdids structure */
		if (!(id = (struct mtdids *)malloc(sizeof(struct mtdids) + mtd_id_len))) {
34806aac:	e286b014 	add	fp, r6, #20
34806ab0:	e1a0000b 	mov	r0, fp
34806ab4:	eb000aeb 	bl	34809668 <malloc>
34806ab8:	e2505000 	subs	r5, r0, #0
34806abc:	1affff4d 	bne	348067f8 <mtdparts_init+0x294>
34806ac0:	eaffff49 	b	348067ec <mtdparts_init+0x288>
			mtd_devices_init();
			return 1;
		}

		/* ok it's good, save new ids */
		strncpy(last_ids, ids, MTDIDS_MAXLEN);
34806ac4:	e59f0090 	ldr	r0, [pc, #144]	; 34806b5c <mtdparts_init+0x5f8>
34806ac8:	e1a0100a 	mov	r1, sl
34806acc:	e3a02080 	mov	r2, #128	; 0x80
34806ad0:	eb0047cc 	bl	34818a08 <strncpy>

	/* check if we have already parsed those mtdids */
	if ((last_ids[0] != '\0') && (strcmp(last_ids, ids) == 0)) {
		ids_changed = 0;
	} else {
		ids_changed = 1;
34806ad4:	e3a05001 	mov	r5, #1
34806ad8:	eaffff77 	b	348068bc <mtdparts_init+0x358>
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
34806adc:	e59f5020 	ldr	r5, [pc, #32]	; 34806b04 <mtdparts_init+0x5a0>
	/* parse partitions if either mtdparts or mtdids were updated */
	if (parts && ((last_parts[0] == '\0') || ((strcmp(last_parts, parts) != 0)) || ids_changed)) {
		if (parse_mtdparts(parts) != 0)
			return 1;

		if (list_empty(&devices)) {
34806ae0:	e5952004 	ldr	r2, [r5, #4]
34806ae4:	e2853004 	add	r3, r5, #4
34806ae8:	e1520003 	cmp	r2, r3
34806aec:	1affffc2 	bne	348069fc <mtdparts_init+0x498>
34806af0:	eaffffbe 	b	348069f0 <mtdparts_init+0x48c>
	/* do not process current partition if mtdparts variable is null */
	if (!parts)
		return 0;

	/* is current partition set in environment? if so, use it */
	if ((tmp_ep[0] != '\0') && (strcmp(tmp_ep, last_partition) != 0)) {
34806af4:	e5dd3004 	ldrb	r3, [sp, #4]
34806af8:	e3530000 	cmp	r3, #0
34806afc:	1affffcd 	bne	34806a38 <mtdparts_init+0x4d4>
34806b00:	eaffffdf 	b	34806a84 <mtdparts_init+0x520>
34806b04:	34829224 	.word	0x34829224
34806b08:	34824adf 	.word	0x34824adf
34806b0c:	34824855 	.word	0x34824855
34806b10:	34824ea0 	.word	0x34824ea0
34806b14:	34824ac6 	.word	0x34824ac6
34806b18:	34824ae6 	.word	0x34824ae6
34806b1c:	34824afe 	.word	0x34824afe
34806b20:	34824b2e 	.word	0x34824b2e
34806b24:	34824b48 	.word	0x34824b48
34806b28:	34824b65 	.word	0x34824b65
34806b2c:	34829444 	.word	0x34829444
34806b30:	34824ada 	.word	0x34824ada
34806b34:	34824ad7 	.word	0x34824ad7
34806b38:	34824709 	.word	0x34824709
34806b3c:	34824b85 	.word	0x34824b85
34806b40:	3482493c 	.word	0x3482493c
34806b44:	34824bbf 	.word	0x34824bbf
34806b48:	3482484b 	.word	0x3482484b
34806b4c:	34824be1 	.word	0x34824be1
34806b50:	34824c13 	.word	0x34824c13
34806b54:	34829228 	.word	0x34829228
34806b58:	34824c4c 	.word	0x34824c4c
34806b5c:	34829450 	.word	0x34829450

34806b60 <do_mtdparts>:
 * @param argc number of arguments supplied to the command
 * @param argv arguments list
 * @return 0 on success, 1 otherwise
 */
int do_mtdparts(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
34806b60:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	if (argc == 2) {
34806b64:	e3520002 	cmp	r2, #2
 * @param argc number of arguments supplied to the command
 * @param argv arguments list
 * @return 0 on success, 1 otherwise
 */
int do_mtdparts(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
34806b68:	e24dd060 	sub	sp, sp, #96	; 0x60
34806b6c:	e1a05002 	mov	r5, r2
34806b70:	e1a04003 	mov	r4, r3
	if (argc == 2) {
34806b74:	1a00001b 	bne	34806be8 <do_mtdparts+0x88>
		if (strcmp(argv[1], "default") == 0) {
34806b78:	e5930004 	ldr	r0, [r3, #4]
34806b7c:	e59f157c 	ldr	r1, [pc, #1404]	; 34807100 <do_mtdparts+0x5a0>
34806b80:	eb0047ca 	bl	34818ab0 <strcmp>
34806b84:	e2506000 	subs	r6, r0, #0
34806b88:	1a00000b 	bne	34806bbc <do_mtdparts+0x5c>
			setenv("mtdids", (char *)mtdids_default);
34806b8c:	e59f1570 	ldr	r1, [pc, #1392]	; 34807104 <do_mtdparts+0x5a4>
34806b90:	e59f0570 	ldr	r0, [pc, #1392]	; 34807108 <do_mtdparts+0x5a8>
34806b94:	eb0004a0 	bl	34807e1c <setenv>
			setenv("mtdparts", (char *)mtdparts_default);
34806b98:	e59f156c 	ldr	r1, [pc, #1388]	; 3480710c <do_mtdparts+0x5ac>
34806b9c:	e59f056c 	ldr	r0, [pc, #1388]	; 34807110 <do_mtdparts+0x5b0>
34806ba0:	eb00049d 	bl	34807e1c <setenv>
			setenv("partition", NULL);
34806ba4:	e1a01006 	mov	r1, r6
34806ba8:	e59f0564 	ldr	r0, [pc, #1380]	; 34807114 <do_mtdparts+0x5b4>
34806bac:	eb00049a 	bl	34807e1c <setenv>

			mtdparts_init();
34806bb0:	ebfffe6b 	bl	34806564 <mtdparts_init>
			return 0;
34806bb4:	e1a00006 	mov	r0, r6
34806bb8:	ea00014e 	b	348070f8 <do_mtdparts+0x598>
		} else if (strcmp(argv[1], "delall") == 0) {
34806bbc:	e5940004 	ldr	r0, [r4, #4]
34806bc0:	e59f1550 	ldr	r1, [pc, #1360]	; 34807118 <do_mtdparts+0x5b8>
34806bc4:	eb0047b9 	bl	34818ab0 <strcmp>
34806bc8:	e2506000 	subs	r6, r0, #0
34806bcc:	1a000005 	bne	34806be8 <do_mtdparts+0x88>
			/* this may be the first run, initialize lists if needed */
			mtdparts_init();
34806bd0:	ebfffe63 	bl	34806564 <mtdparts_init>

			setenv("mtdparts", NULL);
34806bd4:	e1a01006 	mov	r1, r6
34806bd8:	e59f0530 	ldr	r0, [pc, #1328]	; 34807110 <do_mtdparts+0x5b0>
34806bdc:	eb00048e 	bl	34807e1c <setenv>

			/* mtd_devices_init() calls current_save() */
			return mtd_devices_init();
34806be0:	ebfffb7e 	bl	348059e0 <mtd_devices_init>
34806be4:	ea000143 	b	348070f8 <do_mtdparts+0x598>
		}
	}

	/* make sure we are in sync with env variables */
	if (mtdparts_init() != 0)
34806be8:	ebfffe5d 	bl	34806564 <mtdparts_init>
34806bec:	e3500000 	cmp	r0, #0
34806bf0:	1a00013d 	bne	348070ec <do_mtdparts+0x58c>
		return 1;

	if (argc == 1) {
34806bf4:	e3550001 	cmp	r5, #1
34806bf8:	1a00005b 	bne	34806d6c <do_mtdparts+0x20c>
	struct list_head *dentry, *pentry;
	struct part_info *part;
	struct mtd_device *dev;
	int part_num;

	list_for_each(dentry, &devices) {
34806bfc:	e59fa518 	ldr	sl, [pc, #1304]	; 3480711c <do_mtdparts+0x5bc>
					part_num, part->name, part->size,
					net_size, size_note, part->offset,
					part->mask_flags);
#else /* !defined(CONFIG_CMD_MTDPARTS_SHOW_NET_SIZES) */
		printf("\ndevice %s%d <%s>, # parts = %d\n",
				MTD_DEV_TYPE(dev->id->type), dev->id->num,
34806c00:	e59f9518 	ldr	r9, [pc, #1304]	; 34807120 <do_mtdparts+0x5c0>
	struct list_head *dentry, *pentry;
	struct part_info *part;
	struct mtd_device *dev;
	int part_num;

	list_for_each(dentry, &devices) {
34806c04:	e5ba4004 	ldr	r4, [sl, #4]!
					part_num, part->name, part->size,
					net_size, size_note, part->offset,
					part->mask_flags);
#else /* !defined(CONFIG_CMD_MTDPARTS_SHOW_NET_SIZES) */
		printf("\ndevice %s%d <%s>, # parts = %d\n",
				MTD_DEV_TYPE(dev->id->type), dev->id->num,
34806c08:	e59fb514 	ldr	fp, [pc, #1300]	; 34807124 <do_mtdparts+0x5c4>
34806c0c:	ea000021 	b	34806c98 <do_mtdparts+0x138>
34806c10:	e5943008 	ldr	r3, [r4, #8]
34806c14:	e5d31008 	ldrb	r1, [r3, #8]
			printf("%2d: %-20s0x%08x\t0x%08x%s\t0x%08x\t%d\n",
					part_num, part->name, part->size,
					net_size, size_note, part->offset,
					part->mask_flags);
#else /* !defined(CONFIG_CMD_MTDPARTS_SHOW_NET_SIZES) */
		printf("\ndevice %s%d <%s>, # parts = %d\n",
34806c18:	e3510002 	cmp	r1, #2
34806c1c:	059f1504 	ldreq	r1, [pc, #1284]	; 34807128 <do_mtdparts+0x5c8>
34806c20:	0a000002 	beq	34806c30 <do_mtdparts+0xd0>
				MTD_DEV_TYPE(dev->id->type), dev->id->num,
34806c24:	e3510004 	cmp	r1, #4
34806c28:	11a01009 	movne	r1, r9
34806c2c:	01a0100b 	moveq	r1, fp
			printf("%2d: %-20s0x%08x\t0x%08x%s\t0x%08x\t%d\n",
					part_num, part->name, part->size,
					net_size, size_note, part->offset,
					part->mask_flags);
#else /* !defined(CONFIG_CMD_MTDPARTS_SHOW_NET_SIZES) */
		printf("\ndevice %s%d <%s>, # parts = %d\n",
34806c30:	e1d400bc 	ldrh	r0, [r4, #12]
34806c34:	e5d32009 	ldrb	r2, [r3, #9]
34806c38:	e58d0000 	str	r0, [sp]
34806c3c:	e5933010 	ldr	r3, [r3, #16]
34806c40:	e59f04e4 	ldr	r0, [pc, #1252]	; 3480712c <do_mtdparts+0x5cc>
34806c44:	eb0008c0 	bl	34808f4c <printf>
				MTD_DEV_TYPE(dev->id->type), dev->id->num,
				dev->id->mtd_id, dev->num_parts);
		printf(" #: name\t\tsize\t\toffset\t\tmask_flags\n");

		list_for_each(pentry, &dev->parts) {
34806c48:	e1a06004 	mov	r6, r4
					part->mask_flags);
#else /* !defined(CONFIG_CMD_MTDPARTS_SHOW_NET_SIZES) */
		printf("\ndevice %s%d <%s>, # parts = %d\n",
				MTD_DEV_TYPE(dev->id->type), dev->id->num,
				dev->id->mtd_id, dev->num_parts);
		printf(" #: name\t\tsize\t\toffset\t\tmask_flags\n");
34806c4c:	e59f04dc 	ldr	r0, [pc, #1244]	; 34807130 <do_mtdparts+0x5d0>
34806c50:	eb0008bd 	bl	34808f4c <printf>
	int part_num;

	list_for_each(dentry, &devices) {
		dev = list_entry(dentry, struct mtd_device, link);
		/* list partitions for given device */
		part_num = 0;
34806c54:	e3a07000 	mov	r7, #0
		printf("\ndevice %s%d <%s>, # parts = %d\n",
				MTD_DEV_TYPE(dev->id->type), dev->id->num,
				dev->id->mtd_id, dev->num_parts);
		printf(" #: name\t\tsize\t\toffset\t\tmask_flags\n");

		list_for_each(pentry, &dev->parts) {
34806c58:	e5b65010 	ldr	r5, [r6, #16]!
34806c5c:	ea00000a 	b	34806c8c <do_mtdparts+0x12c>
			part = list_entry(pentry, struct part_info, link);
			printf("%2d: %-20s0x%08x\t0x%08x\t%d\n",
34806c60:	e5953014 	ldr	r3, [r5, #20]
34806c64:	e1a01007 	mov	r1, r7
34806c68:	e58d3000 	str	r3, [sp]
34806c6c:	e595301c 	ldr	r3, [r5, #28]
34806c70:	e59f04bc 	ldr	r0, [pc, #1212]	; 34807134 <do_mtdparts+0x5d4>
34806c74:	e58d3004 	str	r3, [sp, #4]
34806c78:	e5952008 	ldr	r2, [r5, #8]
34806c7c:	e5953010 	ldr	r3, [r5, #16]
34806c80:	eb0008b1 	bl	34808f4c <printf>
		printf("\ndevice %s%d <%s>, # parts = %d\n",
				MTD_DEV_TYPE(dev->id->type), dev->id->num,
				dev->id->mtd_id, dev->num_parts);
		printf(" #: name\t\tsize\t\toffset\t\tmask_flags\n");

		list_for_each(pentry, &dev->parts) {
34806c84:	e5955000 	ldr	r5, [r5]
			part = list_entry(pentry, struct part_info, link);
			printf("%2d: %-20s0x%08x\t0x%08x\t%d\n",
					part_num, part->name, part->size,
					part->offset, part->mask_flags);
#endif /* defined(CONFIG_CMD_MTDPARTS_SHOW_NET_SIZES) */
			part_num++;
34806c88:	e2877001 	add	r7, r7, #1
		printf("\ndevice %s%d <%s>, # parts = %d\n",
				MTD_DEV_TYPE(dev->id->type), dev->id->num,
				dev->id->mtd_id, dev->num_parts);
		printf(" #: name\t\tsize\t\toffset\t\tmask_flags\n");

		list_for_each(pentry, &dev->parts) {
34806c8c:	e1550006 	cmp	r5, r6
34806c90:	1afffff2 	bne	34806c60 <do_mtdparts+0x100>
	struct list_head *dentry, *pentry;
	struct part_info *part;
	struct mtd_device *dev;
	int part_num;

	list_for_each(dentry, &devices) {
34806c94:	e5944000 	ldr	r4, [r4]
34806c98:	e154000a 	cmp	r4, sl
34806c9c:	1affffdb 	bne	34806c10 <do_mtdparts+0xb0>
#endif /* defined(CONFIG_CMD_MTDPARTS_SHOW_NET_SIZES) */
			part_num++;
		}
	}

	if (list_empty(&devices))
34806ca0:	e59f3474 	ldr	r3, [pc, #1140]	; 3480711c <do_mtdparts+0x5bc>
34806ca4:	e5933004 	ldr	r3, [r3, #4]
34806ca8:	e1530004 	cmp	r3, r4
34806cac:	1a000001 	bne	34806cb8 <do_mtdparts+0x158>
		printf("no partitions defined\n");
34806cb0:	e59f0480 	ldr	r0, [pc, #1152]	; 34807138 <do_mtdparts+0x5d8>
34806cb4:	eb0008a4 	bl	34808f4c <printf>

	debug("\n---list_partitions---\n");
	print_partition_table();

	/* current_mtd_dev is not NULL only when we have non empty device list */
	if (current_mtd_dev) {
34806cb8:	e59f445c 	ldr	r4, [pc, #1116]	; 3480711c <do_mtdparts+0x5bc>
34806cbc:	e5940000 	ldr	r0, [r4]
34806cc0:	e3500000 	cmp	r0, #0
34806cc4:	0a00001b 	beq	34806d38 <do_mtdparts+0x1d8>
		part = mtd_part_info(current_mtd_dev, current_mtd_partnum);
34806cc8:	e5d4100c 	ldrb	r1, [r4, #12]
34806ccc:	ebfff973 	bl	348052a0 <mtd_part_info>
		if (part) {
34806cd0:	e3500000 	cmp	r0, #0
34806cd4:	0a000015 	beq	34806d30 <do_mtdparts+0x1d0>
			printf("\nactive partition: %s%d,%d - (%s) 0x%08x @ 0x%08x\n",
					MTD_DEV_TYPE(current_mtd_dev->id->type),
34806cd8:	e5943000 	ldr	r3, [r4]
34806cdc:	e5933008 	ldr	r3, [r3, #8]
34806ce0:	e5d32008 	ldrb	r2, [r3, #8]

	/* current_mtd_dev is not NULL only when we have non empty device list */
	if (current_mtd_dev) {
		part = mtd_part_info(current_mtd_dev, current_mtd_partnum);
		if (part) {
			printf("\nactive partition: %s%d,%d - (%s) 0x%08x @ 0x%08x\n",
34806ce4:	e3520002 	cmp	r2, #2
34806ce8:	059f1438 	ldreq	r1, [pc, #1080]	; 34807128 <do_mtdparts+0x5c8>
34806cec:	0a000003 	beq	34806d00 <do_mtdparts+0x1a0>
					MTD_DEV_TYPE(current_mtd_dev->id->type),
34806cf0:	e59fc428 	ldr	ip, [pc, #1064]	; 34807120 <do_mtdparts+0x5c0>
34806cf4:	e3520004 	cmp	r2, #4
34806cf8:	e59f1424 	ldr	r1, [pc, #1060]	; 34807124 <do_mtdparts+0x5c4>
34806cfc:	11a0100c 	movne	r1, ip

	/* current_mtd_dev is not NULL only when we have non empty device list */
	if (current_mtd_dev) {
		part = mtd_part_info(current_mtd_dev, current_mtd_partnum);
		if (part) {
			printf("\nactive partition: %s%d,%d - (%s) 0x%08x @ 0x%08x\n",
34806d00:	e5d32009 	ldrb	r2, [r3, #9]
34806d04:	e590c008 	ldr	ip, [r0, #8]
34806d08:	e59f340c 	ldr	r3, [pc, #1036]	; 3480711c <do_mtdparts+0x5bc>
34806d0c:	e5d3300c 	ldrb	r3, [r3, #12]
34806d10:	e58dc000 	str	ip, [sp]
34806d14:	e590c010 	ldr	ip, [r0, #16]
34806d18:	e58dc004 	str	ip, [sp, #4]
34806d1c:	e5900014 	ldr	r0, [r0, #20]
34806d20:	e58d0008 	str	r0, [sp, #8]
34806d24:	e59f0410 	ldr	r0, [pc, #1040]	; 3480713c <do_mtdparts+0x5dc>
34806d28:	eb000887 	bl	34808f4c <printf>
34806d2c:	ea000001 	b	34806d38 <do_mtdparts+0x1d8>
					MTD_DEV_TYPE(current_mtd_dev->id->type),
					current_mtd_dev->id->num, current_mtd_partnum,
					part->name, part->size, part->offset);
		} else {
			printf("could not get current partition info\n\n");
34806d30:	e59f0408 	ldr	r0, [pc, #1032]	; 34807140 <do_mtdparts+0x5e0>
34806d34:	eb000884 	bl	34808f4c <printf>
		}
	}

	printf("\ndefaults:\n");
34806d38:	e59f0404 	ldr	r0, [pc, #1028]	; 34807144 <do_mtdparts+0x5e4>
34806d3c:	eb000882 	bl	34808f4c <printf>
	printf("mtdids  : %s\n",
34806d40:	e59f13bc 	ldr	r1, [pc, #956]	; 34807104 <do_mtdparts+0x5a4>
34806d44:	e59f03fc 	ldr	r0, [pc, #1020]	; 34807148 <do_mtdparts+0x5e8>
34806d48:	eb00087f 	bl	34808f4c <printf>
	/*
	 * Using printf() here results in printbuffer overflow
	 * if default mtdparts string is greater than console
	 * printbuffer. Use puts() to prevent system crashes.
	 */
	puts("mtdparts: ");
34806d4c:	e59f03f8 	ldr	r0, [pc, #1016]	; 3480714c <do_mtdparts+0x5ec>
34806d50:	eb000873 	bl	34808f24 <puts>
	puts(mtdparts_default ? mtdparts_default : "none");
34806d54:	e59f03b0 	ldr	r0, [pc, #944]	; 3480710c <do_mtdparts+0x5ac>
34806d58:	eb000871 	bl	34808f24 <puts>
	puts("\n");
34806d5c:	e59f03ec 	ldr	r0, [pc, #1004]	; 34807150 <do_mtdparts+0x5f0>
34806d60:	eb00086f 	bl	34808f24 <puts>
	if (mtdparts_init() != 0)
		return 1;

	if (argc == 1) {
		list_partitions();
		return 0;
34806d64:	e3a00000 	mov	r0, #0
34806d68:	ea0000e2 	b	348070f8 <do_mtdparts+0x598>
	}

	/* mtdparts add <mtd-dev> <size>[@<offset>] <name> [ro] */
	if (((argc == 5) || (argc == 6)) && (strncmp(argv[1], "add", 3) == 0)) {
34806d6c:	e2453005 	sub	r3, r5, #5
34806d70:	e3530001 	cmp	r3, #1
34806d74:	8a000090 	bhi	34806fbc <do_mtdparts+0x45c>
34806d78:	e59f13d4 	ldr	r1, [pc, #980]	; 34807154 <do_mtdparts+0x5f4>
34806d7c:	e5940004 	ldr	r0, [r4, #4]
34806d80:	e3a02003 	mov	r2, #3
34806d84:	eb004755 	bl	34818ae0 <strncmp>
34806d88:	e2501000 	subs	r1, r0, #0
34806d8c:	1a0000d8 	bne	348070f4 <do_mtdparts+0x594>
		struct mtd_device *dev;
		struct mtd_device *dev_tmp;
		struct mtdids *id;
		struct part_info *p;

		if (mtd_id_parse(argv[2], NULL, &type, &num) != 0)
34806d90:	e5940008 	ldr	r0, [r4, #8]
34806d94:	e28d2054 	add	r2, sp, #84	; 0x54
34806d98:	e28d305f 	add	r3, sp, #95	; 0x5f
34806d9c:	ebfffd3e 	bl	3480629c <mtd_id_parse>
34806da0:	e3500000 	cmp	r0, #0
34806da4:	1a0000d0 	bne	348070ec <do_mtdparts+0x58c>
static struct mtdids* id_find(u8 type, u8 num)
{
	struct list_head *entry;
	struct mtdids *id;

	list_for_each(entry, &mtdids) {
34806da8:	e59f336c 	ldr	r3, [pc, #876]	; 3480711c <do_mtdparts+0x5bc>
		struct part_info *p;

		if (mtd_id_parse(argv[2], NULL, &type, &num) != 0)
			return 1;

		if ((id = id_find(type, num)) == NULL) {
34806dac:	e5dd1054 	ldrb	r1, [sp, #84]	; 0x54
34806db0:	e5dd205f 	ldrb	r2, [sp, #95]	; 0x5f
static struct mtdids* id_find(u8 type, u8 num)
{
	struct list_head *entry;
	struct mtdids *id;

	list_for_each(entry, &mtdids) {
34806db4:	e5b35220 	ldr	r5, [r3, #544]!	; 0x220
34806db8:	ea000006 	b	34806dd8 <do_mtdparts+0x278>
		id = list_entry(entry, struct mtdids, link);

		if ((id->type == type) && (id->num == num))
34806dbc:	e5d50008 	ldrb	r0, [r5, #8]
34806dc0:	e1500001 	cmp	r0, r1
34806dc4:	1a000002 	bne	34806dd4 <do_mtdparts+0x274>
34806dc8:	e5d50009 	ldrb	r0, [r5, #9]
34806dcc:	e1500002 	cmp	r0, r2
34806dd0:	0a000003 	beq	34806de4 <do_mtdparts+0x284>
static struct mtdids* id_find(u8 type, u8 num)
{
	struct list_head *entry;
	struct mtdids *id;

	list_for_each(entry, &mtdids) {
34806dd4:	e5955000 	ldr	r5, [r5]
34806dd8:	e1550003 	cmp	r5, r3
34806ddc:	1afffff6 	bne	34806dbc <do_mtdparts+0x25c>
34806de0:	ea00000f 	b	34806e24 <do_mtdparts+0x2c4>
		if ((id = id_find(type, num)) == NULL) {
			printf("no such device %s defined in mtdids variable\n", argv[2]);
			return 1;
		}

		len = strlen(id->mtd_id) + 1;	/* 'mtd_id:' */
34806de4:	e5950010 	ldr	r0, [r5, #16]
34806de8:	eb004764 	bl	34818b80 <strlen>
34806dec:	e1a07000 	mov	r7, r0
		len += strlen(argv[3]);		/* size@offset */
34806df0:	e594000c 	ldr	r0, [r4, #12]
34806df4:	eb004761 	bl	34818b80 <strlen>
34806df8:	e1a06000 	mov	r6, r0
		len += strlen(argv[4]) + 2;	/* '(' name ')' */
34806dfc:	e5940010 	ldr	r0, [r4, #16]
34806e00:	eb00475e 	bl	34818b80 <strlen>
			printf("no such device %s defined in mtdids variable\n", argv[2]);
			return 1;
		}

		len = strlen(id->mtd_id) + 1;	/* 'mtd_id:' */
		len += strlen(argv[3]);		/* size@offset */
34806e04:	e0876006 	add	r6, r7, r6
		len += strlen(argv[4]) + 2;	/* '(' name ')' */
34806e08:	e2866003 	add	r6, r6, #3
34806e0c:	e6e06076 	uxtab	r6, r0, r6
		if (argv[5] && (strlen(argv[5]) == 2))
34806e10:	e5940014 	ldr	r0, [r4, #20]
			return 1;
		}

		len = strlen(id->mtd_id) + 1;	/* 'mtd_id:' */
		len += strlen(argv[3]);		/* size@offset */
		len += strlen(argv[4]) + 2;	/* '(' name ')' */
34806e14:	e6ef6076 	uxtb	r6, r6
		if (argv[5] && (strlen(argv[5]) == 2))
34806e18:	e3500000 	cmp	r0, #0
34806e1c:	1a000003 	bne	34806e30 <do_mtdparts+0x2d0>
34806e20:	ea000006 	b	34806e40 <do_mtdparts+0x2e0>

		if (mtd_id_parse(argv[2], NULL, &type, &num) != 0)
			return 1;

		if ((id = id_find(type, num)) == NULL) {
			printf("no such device %s defined in mtdids variable\n", argv[2]);
34806e24:	e59f032c 	ldr	r0, [pc, #812]	; 34807158 <do_mtdparts+0x5f8>
34806e28:	e5941008 	ldr	r1, [r4, #8]
34806e2c:	ea0000ad 	b	348070e8 <do_mtdparts+0x588>
		}

		len = strlen(id->mtd_id) + 1;	/* 'mtd_id:' */
		len += strlen(argv[3]);		/* size@offset */
		len += strlen(argv[4]) + 2;	/* '(' name ')' */
		if (argv[5] && (strlen(argv[5]) == 2))
34806e30:	eb004752 	bl	34818b80 <strlen>
34806e34:	e3500002 	cmp	r0, #2
			len += 2;		/* 'ro' */
34806e38:	02866002 	addeq	r6, r6, #2
34806e3c:	06ef6076 	uxtbeq	r6, r6

		if (len >= PART_ADD_DESC_MAXLEN) {
34806e40:	e356003f 	cmp	r6, #63	; 0x3f
			printf("too long partition description\n");
34806e44:	859f0310 	ldrhi	r0, [pc, #784]	; 3480715c <do_mtdparts+0x5fc>
		len += strlen(argv[3]);		/* size@offset */
		len += strlen(argv[4]) + 2;	/* '(' name ')' */
		if (argv[5] && (strlen(argv[5]) == 2))
			len += 2;		/* 'ro' */

		if (len >= PART_ADD_DESC_MAXLEN) {
34806e48:	8a0000a2 	bhi	348070d8 <do_mtdparts+0x578>
			printf("too long partition description\n");
			return 1;
		}
		sprintf(tmpbuf, "%s:%s(%s)%s",
				id->mtd_id, argv[3], argv[4], argv[5] ? argv[5] : "");
34806e4c:	e5941014 	ldr	r1, [r4, #20]

		if (len >= PART_ADD_DESC_MAXLEN) {
			printf("too long partition description\n");
			return 1;
		}
		sprintf(tmpbuf, "%s:%s(%s)%s",
34806e50:	e59fc308 	ldr	ip, [pc, #776]	; 34807160 <do_mtdparts+0x600>
34806e54:	e5940010 	ldr	r0, [r4, #16]
34806e58:	e3510000 	cmp	r1, #0
34806e5c:	e594300c 	ldr	r3, [r4, #12]
34806e60:	01a0100c 	moveq	r1, ip
34806e64:	e28d4014 	add	r4, sp, #20
34806e68:	e5952010 	ldr	r2, [r5, #16]
34806e6c:	e88d0003 	stm	sp, {r0, r1}
34806e70:	e1a00004 	mov	r0, r4
34806e74:	e59f12e8 	ldr	r1, [pc, #744]	; 34807164 <do_mtdparts+0x604>
34806e78:	eb004c04 	bl	34819e90 <sprintf>
				id->mtd_id, argv[3], argv[4], argv[5] ? argv[5] : "");
		debug("add tmpbuf: %s\n", tmpbuf);

		if ((device_parse(tmpbuf, NULL, &dev) != 0) || (!dev))
34806e7c:	e1a00004 	mov	r0, r4
34806e80:	e3a01000 	mov	r1, #0
34806e84:	e28d2058 	add	r2, sp, #88	; 0x58
34806e88:	ebfffbad 	bl	34805d44 <device_parse>
34806e8c:	e3500000 	cmp	r0, #0
34806e90:	1a000095 	bne	348070ec <do_mtdparts+0x58c>
34806e94:	e59d5058 	ldr	r5, [sp, #88]	; 0x58
34806e98:	e3550000 	cmp	r5, #0
34806e9c:	0a000092 	beq	348070ec <do_mtdparts+0x58c>
			spread_partition(mtd, p, &next_offset);
			debug("increased %s to %d bytes\n", p->name, p->size);
		}
#endif

		dev_tmp = device_find(dev->id->type, dev->id->num);
34806ea0:	e5953008 	ldr	r3, [r5, #8]
			return 1;

		debug("+ %s\t%d\t%s\n", MTD_DEV_TYPE(dev->id->type),
				dev->id->num, dev->id->mtd_id);

		p = list_entry(dev->parts.next, struct part_info, link);
34806ea4:	e5954010 	ldr	r4, [r5, #16]
			spread_partition(mtd, p, &next_offset);
			debug("increased %s to %d bytes\n", p->name, p->size);
		}
#endif

		dev_tmp = device_find(dev->id->type, dev->id->num);
34806ea8:	e5d30008 	ldrb	r0, [r3, #8]
34806eac:	e5d31009 	ldrb	r1, [r3, #9]
34806eb0:	ebfffb90 	bl	34805cf8 <device_find>
		if (dev_tmp == NULL) {
34806eb4:	e2506000 	subs	r6, r0, #0
34806eb8:	1a00000e 	bne	34806ef8 <do_mtdparts+0x398>
34806ebc:	e59f3258 	ldr	r3, [pc, #600]	; 3480711c <do_mtdparts+0x5bc>
 */
static void device_add(struct mtd_device *dev)
{
	u8 current_save_needed = 0;

	if (list_empty(&devices)) {
34806ec0:	e5931004 	ldr	r1, [r3, #4]
34806ec4:	e2832004 	add	r2, r3, #4
34806ec8:	e1510002 	cmp	r1, r2
		current_mtd_dev = dev;
		current_mtd_partnum = 0;
34806ecc:	05c3600c 	strbeq	r6, [r3, #12]
static void device_add(struct mtd_device *dev)
{
	u8 current_save_needed = 0;

	if (list_empty(&devices)) {
		current_mtd_dev = dev;
34806ed0:	05835000 	streq	r5, [r3]
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
34806ed4:	e59f3240 	ldr	r3, [pc, #576]	; 3480711c <do_mtdparts+0x5bc>
		current_mtd_partnum = 0;
		current_save_needed = 1;
34806ed8:	03a06001 	moveq	r6, #1
34806edc:	e5932008 	ldr	r2, [r3, #8]
 */
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
34806ee0:	e5835008 	str	r5, [r3, #8]
	new->next = next;
34806ee4:	e2833004 	add	r3, r3, #4
34806ee8:	e5853000 	str	r3, [r5]
	new->prev = prev;
34806eec:	e5852004 	str	r2, [r5, #4]
	prev->next = new;
34806ef0:	e5825000 	str	r5, [r2]
34806ef4:	ea00006e 	b	348070b4 <do_mtdparts+0x554>
 * @param part partition to validate
 * @return 0 if partition is valid, 1 otherwise
 */
static int part_validate(struct mtdids *id, struct part_info *part)
{
	if (part->size == SIZE_REMAINING)
34806ef8:	e5943010 	ldr	r3, [r4, #16]
 * @return 0 on success, 1 otherwise
 */
static int part_add(struct mtd_device *dev, struct part_info *part)
{
	/* verify alignment and size */
	if (part_validate(dev->id, part) != 0)
34806efc:	e596c008 	ldr	ip, [r6, #8]
 * @param part partition to validate
 * @return 0 if partition is valid, 1 otherwise
 */
static int part_validate(struct mtdids *id, struct part_info *part)
{
	if (part->size == SIZE_REMAINING)
34806f00:	e3730001 	cmn	r3, #1
		part->size = id->size - part->offset;
34806f04:	059c200c 	ldreq	r2, [ip, #12]
34806f08:	05943014 	ldreq	r3, [r4, #20]
34806f0c:	00633002 	rsbeq	r3, r3, r2
34806f10:	05843010 	streq	r3, [r4, #16]

	if (part->offset > id->size) {
34806f14:	e5942014 	ldr	r2, [r4, #20]
34806f18:	e59c300c 	ldr	r3, [ip, #12]
34806f1c:	e1520003 	cmp	r2, r3
		printf("%s: offset %08x beyond flash size %08x\n",
34806f20:	859f0240 	ldrhi	r0, [pc, #576]	; 34807168 <do_mtdparts+0x608>
34806f24:	859c1010 	ldrhi	r1, [ip, #16]
static int part_validate(struct mtdids *id, struct part_info *part)
{
	if (part->size == SIZE_REMAINING)
		part->size = id->size - part->offset;

	if (part->offset > id->size) {
34806f28:	8a00000e 	bhi	34806f68 <do_mtdparts+0x408>
		printf("%s: offset %08x beyond flash size %08x\n",
				id->mtd_id, part->offset, id->size);
		return 1;
	}

	if ((part->offset + part->size) <= part->offset) {
34806f2c:	e5941010 	ldr	r1, [r4, #16]
34806f30:	e0821001 	add	r1, r2, r1
34806f34:	e1510002 	cmp	r1, r2
34806f38:	8a00000c 	bhi	34806f70 <do_mtdparts+0x410>
		printf("%s%d: partition (%s) size too big\n",
				MTD_DEV_TYPE(id->type), id->num, part->name);
34806f3c:	e5dc3008 	ldrb	r3, [ip, #8]
				id->mtd_id, part->offset, id->size);
		return 1;
	}

	if ((part->offset + part->size) <= part->offset) {
		printf("%s%d: partition (%s) size too big\n",
34806f40:	e3530002 	cmp	r3, #2
34806f44:	059f11dc 	ldreq	r1, [pc, #476]	; 34807128 <do_mtdparts+0x5c8>
34806f48:	0a000003 	beq	34806f5c <do_mtdparts+0x3fc>
				MTD_DEV_TYPE(id->type), id->num, part->name);
34806f4c:	e59f21d0 	ldr	r2, [pc, #464]	; 34807124 <do_mtdparts+0x5c4>
34806f50:	e3530004 	cmp	r3, #4
34806f54:	e59f11c4 	ldr	r1, [pc, #452]	; 34807120 <do_mtdparts+0x5c0>
34806f58:	01a01002 	moveq	r1, r2
				id->mtd_id, part->offset, id->size);
		return 1;
	}

	if ((part->offset + part->size) <= part->offset) {
		printf("%s%d: partition (%s) size too big\n",
34806f5c:	e59f0208 	ldr	r0, [pc, #520]	; 3480716c <do_mtdparts+0x60c>
34806f60:	e5dc2009 	ldrb	r2, [ip, #9]
34806f64:	e5943008 	ldr	r3, [r4, #8]
34806f68:	eb0007f7 	bl	34808f4c <printf>
34806f6c:	ea00000f 	b	34806fb0 <do_mtdparts+0x450>
				MTD_DEV_TYPE(id->type), id->num, part->name);
		return 1;
	}

	if (part->offset + part->size > id->size) {
34806f70:	e1510003 	cmp	r1, r3
34806f74:	9a000003 	bls	34806f88 <do_mtdparts+0x428>
		printf("%s: partitioning exceeds flash size\n", id->mtd_id);
34806f78:	e59c1010 	ldr	r1, [ip, #16]
34806f7c:	e59f01ec 	ldr	r0, [pc, #492]	; 34807170 <do_mtdparts+0x610>
34806f80:	eb0007f1 	bl	34808f4c <printf>
34806f84:	ea000009 	b	34806fb0 <do_mtdparts+0x450>

	/*
	 * Now we need to check if the partition starts and ends on
	 * sector (eraseblock) regions
	 */
	return part_validate_eraseblock(id, part);
34806f88:	e1a0000c 	mov	r0, ip
34806f8c:	e1a01004 	mov	r1, r4
34806f90:	ebfffa09 	bl	348057bc <part_validate_eraseblock>
 * @return 0 on success, 1 otherwise
 */
static int part_add(struct mtd_device *dev, struct part_info *part)
{
	/* verify alignment and size */
	if (part_validate(dev->id, part) != 0)
34806f94:	e3500000 	cmp	r0, #0
34806f98:	1a000004 	bne	34806fb0 <do_mtdparts+0x450>
		return 1;

	/* partition is ok, add it to the list */
	if (part_sort_add(dev, part) != 0)
34806f9c:	e1a00006 	mov	r0, r6
34806fa0:	e1a01004 	mov	r1, r4
34806fa4:	ebfff952 	bl	348054f4 <part_sort_add>
34806fa8:	e3500000 	cmp	r0, #0
34806fac:	0a000045 	beq	348070c8 <do_mtdparts+0x568>
		dev_tmp = device_find(dev->id->type, dev->id->num);
		if (dev_tmp == NULL) {
			device_add(dev);
		} else if (part_add(dev_tmp, p) != 0) {
			/* merge new partition with existing ones*/
			device_del(dev);
34806fb0:	e59d0058 	ldr	r0, [sp, #88]	; 0x58
34806fb4:	ebfff9aa 	bl	34805664 <device_del>
34806fb8:	ea00004b 	b	348070ec <do_mtdparts+0x58c>

		return 0;
	}

	/* mtdparts del part-id */
	if ((argc == 3) && (strcmp(argv[1], "del") == 0)) {
34806fbc:	e3550003 	cmp	r5, #3
34806fc0:	1a00004b 	bne	348070f4 <do_mtdparts+0x594>
34806fc4:	e5940004 	ldr	r0, [r4, #4]
34806fc8:	e59f11a4 	ldr	r1, [pc, #420]	; 34807174 <do_mtdparts+0x614>
34806fcc:	eb0046b7 	bl	34818ab0 <strcmp>
34806fd0:	e3500000 	cmp	r0, #0
34806fd4:	1a000046 	bne	348070f4 <do_mtdparts+0x594>
		debug("del: part-id = %s\n", argv[2]);

		return delete_partition(argv[2]);
34806fd8:	e5944008 	ldr	r4, [r4, #8]
{
	u8 pnum;
	struct mtd_device *dev;
	struct part_info *part;

	if (find_dev_and_part(id, &dev, &pnum, &part) == 0) {
34806fdc:	e28d1058 	add	r1, sp, #88	; 0x58
34806fe0:	e1a00004 	mov	r0, r4
34806fe4:	e28d205f 	add	r2, sp, #95	; 0x5f
34806fe8:	e28d3054 	add	r3, sp, #84	; 0x54
34806fec:	ebfffcee 	bl	348063ac <find_dev_and_part>
34806ff0:	e2506000 	subs	r6, r0, #0
34806ff4:	1a000039 	bne	348070e0 <do_mtdparts+0x580>

		debug("delete_partition: device = %s%d, partition %d = (%s) 0x%08x@0x%08x\n",
				MTD_DEV_TYPE(dev->id->type), dev->id->num, pnum,
				part->name, part->size, part->offset);

		if (part_del(dev, part) != 0)
34806ff8:	e59d5058 	ldr	r5, [sp, #88]	; 0x58
34806ffc:	e59d4054 	ldr	r4, [sp, #84]	; 0x54
static int part_del(struct mtd_device *dev, struct part_info *part)
{
	u8 current_save_needed = 0;

	/* if there is only one partition, remove whole device */
	if (dev->num_parts == 1)
34807000:	e1d570bc 	ldrh	r7, [r5, #12]
34807004:	e3570001 	cmp	r7, #1
34807008:	1a000005 	bne	34807024 <do_mtdparts+0x4c4>
		return device_del(dev);
3480700c:	e1a00005 	mov	r0, r5
34807010:	ebfff993 	bl	34805664 <device_del>

		debug("delete_partition: device = %s%d, partition %d = (%s) 0x%08x@0x%08x\n",
				MTD_DEV_TYPE(dev->id->type), dev->id->num, pnum,
				part->name, part->size, part->offset);

		if (part_del(dev, part) != 0)
34807014:	e3500000 	cmp	r0, #0
			return 1;
34807018:	11a00007 	movne	r0, r7

		debug("delete_partition: device = %s%d, partition %d = (%s) 0x%08x@0x%08x\n",
				MTD_DEV_TYPE(dev->id->type), dev->id->num, pnum,
				part->name, part->size, part->offset);

		if (part_del(dev, part) != 0)
3480701c:	1a000035 	bne	348070f8 <do_mtdparts+0x598>
34807020:	ea000028 	b	348070c8 <do_mtdparts+0x568>
	if (dev->num_parts == 1)
		return device_del(dev);

	/* otherwise just delete this partition */

	if (dev == current_mtd_dev) {
34807024:	e59f30f0 	ldr	r3, [pc, #240]	; 3480711c <do_mtdparts+0x5bc>
34807028:	e5932000 	ldr	r2, [r3]
3480702c:	e1550002 	cmp	r5, r2
34807030:	1a000014 	bne	34807088 <do_mtdparts+0x528>
		/* we are modyfing partitions for the current device,
		 * update current */
		struct part_info *curr_pi;
		curr_pi = mtd_part_info(current_mtd_dev, current_mtd_partnum);
34807034:	e1a00005 	mov	r0, r5
34807038:	e5d3100c 	ldrb	r1, [r3, #12]
3480703c:	ebfff897 	bl	348052a0 <mtd_part_info>

		if (curr_pi) {
34807040:	e2506000 	subs	r6, r0, #0
34807044:	0a00000f 	beq	34807088 <do_mtdparts+0x528>
			if (curr_pi == part) {
34807048:	e1560004 	cmp	r6, r4
3480704c:	1a000004 	bne	34807064 <do_mtdparts+0x504>
				printf("current partition deleted, resetting current to 0\n");
34807050:	e59f0120 	ldr	r0, [pc, #288]	; 34807178 <do_mtdparts+0x618>
34807054:	eb0007bc 	bl	34808f4c <printf>
				current_mtd_partnum = 0;
34807058:	e3a02000 	mov	r2, #0
3480705c:	e59f30b8 	ldr	r3, [pc, #184]	; 3480711c <do_mtdparts+0x5bc>
34807060:	ea000006 	b	34807080 <do_mtdparts+0x520>
			} else if (part->offset <= curr_pi->offset) {
34807064:	e5942014 	ldr	r2, [r4, #20]
34807068:	e5963014 	ldr	r3, [r6, #20]
3480706c:	e1520003 	cmp	r2, r3
34807070:	8a000003 	bhi	34807084 <do_mtdparts+0x524>
				current_mtd_partnum--;
34807074:	e59f30a0 	ldr	r3, [pc, #160]	; 3480711c <do_mtdparts+0x5bc>
34807078:	e5d3200c 	ldrb	r2, [r3, #12]
3480707c:	e2422001 	sub	r2, r2, #1
34807080:	e5c3200c 	strb	r2, [r3, #12]
			}
			current_save_needed = 1;
34807084:	e3a06001 	mov	r6, #1
 * Note: list_empty() on entry does not return true after this, the entry is
 * in an undefined state.
 */
static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
34807088:	e894000c 	ldm	r4, {r2, r3}
		}
	}

	list_del(&part->link);
	free(part);
3480708c:	e1a00004 	mov	r0, r4
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head *prev, struct list_head *next)
{
	next->prev = prev;
34807090:	e5823004 	str	r3, [r2, #4]
	prev->next = next;
34807094:	e5832000 	str	r2, [r3]
 * in an undefined state.
 */
static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
34807098:	e3a03000 	mov	r3, #0
3480709c:	e5843000 	str	r3, [r4]
	entry->prev = LIST_POISON2;
348070a0:	e5843004 	str	r3, [r4, #4]
348070a4:	eb0008e6 	bl	34809444 <free>
	dev->num_parts--;
348070a8:	e1d530bc 	ldrh	r3, [r5, #12]
348070ac:	e2433001 	sub	r3, r3, #1
348070b0:	e1c530bc 	strh	r3, [r5, #12]

	if (current_save_needed > 0)
348070b4:	e3560000 	cmp	r6, #0
348070b8:	0a000001 	beq	348070c4 <do_mtdparts+0x564>
		current_save();
348070bc:	ebfff8e0 	bl	34805444 <current_save>
348070c0:	ea000000 	b	348070c8 <do_mtdparts+0x568>
	else
		index_partitions();
348070c4:	ebfff89a 	bl	34805334 <index_partitions>
				part->name, part->size, part->offset);

		if (part_del(dev, part) != 0)
			return 1;

		if (generate_mtdparts_save(last_parts, MTDPARTS_MAXLEN) != 0) {
348070c8:	ebfffa4d 	bl	34805a04 <generate_mtdparts_save.clone.1>
348070cc:	e3500000 	cmp	r0, #0
348070d0:	0a000008 	beq	348070f8 <do_mtdparts+0x598>
			printf("generated mtdparts too long, reseting to null\n");
348070d4:	e59f00a0 	ldr	r0, [pc, #160]	; 3480717c <do_mtdparts+0x61c>
348070d8:	eb00079b 	bl	34808f4c <printf>
348070dc:	ea000002 	b	348070ec <do_mtdparts+0x58c>
			return 1;
		}
		return 0;
	}

	printf("partition %s not found\n", id);
348070e0:	e59f0098 	ldr	r0, [pc, #152]	; 34807180 <do_mtdparts+0x620>
348070e4:	e1a01004 	mov	r1, r4
348070e8:	eb000797 	bl	34808f4c <printf>
		sprintf(tmpbuf, "%s:%s(%s)%s",
				id->mtd_id, argv[3], argv[4], argv[5] ? argv[5] : "");
		debug("add tmpbuf: %s\n", tmpbuf);

		if ((device_parse(tmpbuf, NULL, &dev) != 0) || (!dev))
			return 1;
348070ec:	e3a00001 	mov	r0, #1
348070f0:	ea000000 	b	348070f8 <do_mtdparts+0x598>
#if defined(CONFIG_CMD_MTDPARTS_SPREAD)
	if ((argc == 2) && (strcmp(argv[1], "spread") == 0))
		return spread_partitions();
#endif /* CONFIG_CMD_MTDPARTS_SPREAD */

	return CMD_RET_USAGE;
348070f4:	e3e00000 	mvn	r0, #0
}
348070f8:	e28dd060 	add	sp, sp, #96	; 0x60
348070fc:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
34807100:	34824c70 	.word	0x34824c70
34807104:	34824ac6 	.word	0x34824ac6
34807108:	34824adf 	.word	0x34824adf
3480710c:	348204a0 	.word	0x348204a0
34807110:	34824855 	.word	0x34824855
34807114:	34824ea0 	.word	0x34824ea0
34807118:	34824c78 	.word	0x34824c78
3480711c:	34829224 	.word	0x34829224
34807120:	34824709 	.word	0x34824709
34807124:	34824ad7 	.word	0x34824ad7
34807128:	34824ada 	.word	0x34824ada
3480712c:	34824c7f 	.word	0x34824c7f
34807130:	34824ca0 	.word	0x34824ca0
34807134:	34824cc4 	.word	0x34824cc4
34807138:	34824ce0 	.word	0x34824ce0
3480713c:	34824cf7 	.word	0x34824cf7
34807140:	34824d2a 	.word	0x34824d2a
34807144:	34824d51 	.word	0x34824d51
34807148:	34824d5d 	.word	0x34824d5d
3480714c:	34824d6b 	.word	0x34824d6b
34807150:	348260f7 	.word	0x348260f7
34807154:	34824d76 	.word	0x34824d76
34807158:	34824d7a 	.word	0x34824d7a
3480715c:	34824da8 	.word	0x34824da8
34807160:	34824054 	.word	0x34824054
34807164:	34824dc8 	.word	0x34824dc8
34807168:	3482495b 	.word	0x3482495b
3480716c:	34824983 	.word	0x34824983
34807170:	348249a6 	.word	0x348249a6
34807174:	34824e03 	.word	0x34824e03
34807178:	34824e07 	.word	0x34824e07
3480717c:	34824dd4 	.word	0x34824dd4
34807180:	34824e3a 	.word	0x34824e3a

34807184 <do_chpart>:
 * @param argc number of arguments supplied to the command
 * @param argv arguments list
 * @return 0 on success, 1 otherwise
 */
int do_chpart(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
34807184:	e92d4030 	push	{r4, r5, lr}
34807188:	e24dd014 	sub	sp, sp, #20
3480718c:	e1a04002 	mov	r4, r2
34807190:	e1a05003 	mov	r5, r3
/* command line only */
	struct mtd_device *dev;
	struct part_info *part;
	u8 pnum;

	if (mtdparts_init() !=0)
34807194:	ebfffcf2 	bl	34806564 <mtdparts_init>
34807198:	e3500000 	cmp	r0, #0
3480719c:	1a000021 	bne	34807228 <do_chpart+0xa4>
		return 1;

	if (argc < 2) {
348071a0:	e3540001 	cmp	r4, #1
348071a4:	ca000002 	bgt	348071b4 <do_chpart+0x30>
		printf("no partition id specified\n");
348071a8:	e59f0084 	ldr	r0, [pc, #132]	; 34807234 <do_chpart+0xb0>
348071ac:	eb000766 	bl	34808f4c <printf>
348071b0:	ea00001c 	b	34807228 <do_chpart+0xa4>
		return 1;
	}

	if (find_dev_and_part(argv[1], &dev, &pnum, &part) != 0)
348071b4:	e5950004 	ldr	r0, [r5, #4]
348071b8:	e28d1008 	add	r1, sp, #8
348071bc:	e28d200f 	add	r2, sp, #15
348071c0:	e28d3004 	add	r3, sp, #4
348071c4:	ebfffc78 	bl	348063ac <find_dev_and_part>
348071c8:	e3500000 	cmp	r0, #0
348071cc:	1a000015 	bne	34807228 <do_chpart+0xa4>
		return 1;

	current_mtd_dev = dev;
348071d0:	e59f3060 	ldr	r3, [pc, #96]	; 34807238 <do_chpart+0xb4>
348071d4:	e59d2008 	ldr	r2, [sp, #8]
348071d8:	e5832000 	str	r2, [r3]
	current_mtd_partnum = pnum;
348071dc:	e5dd200f 	ldrb	r2, [sp, #15]
348071e0:	e5c3200c 	strb	r2, [r3, #12]
	current_save();
348071e4:	ebfff896 	bl	34805444 <current_save>

	printf("partition changed to %s%d,%d\n",
			MTD_DEV_TYPE(dev->id->type), dev->id->num, pnum);
348071e8:	e59d3008 	ldr	r3, [sp, #8]
348071ec:	e5933008 	ldr	r3, [r3, #8]
348071f0:	e5d32008 	ldrb	r2, [r3, #8]

	current_mtd_dev = dev;
	current_mtd_partnum = pnum;
	current_save();

	printf("partition changed to %s%d,%d\n",
348071f4:	e3520002 	cmp	r2, #2
348071f8:	059f103c 	ldreq	r1, [pc, #60]	; 3480723c <do_chpart+0xb8>
348071fc:	0a000003 	beq	34807210 <do_chpart+0x8c>
			MTD_DEV_TYPE(dev->id->type), dev->id->num, pnum);
34807200:	e59f0038 	ldr	r0, [pc, #56]	; 34807240 <do_chpart+0xbc>
34807204:	e3520004 	cmp	r2, #4
34807208:	e59f1034 	ldr	r1, [pc, #52]	; 34807244 <do_chpart+0xc0>
3480720c:	11a01000 	movne	r1, r0

	current_mtd_dev = dev;
	current_mtd_partnum = pnum;
	current_save();

	printf("partition changed to %s%d,%d\n",
34807210:	e5d32009 	ldrb	r2, [r3, #9]
34807214:	e59f002c 	ldr	r0, [pc, #44]	; 34807248 <do_chpart+0xc4>
34807218:	e5dd300f 	ldrb	r3, [sp, #15]
3480721c:	eb00074a 	bl	34808f4c <printf>
			MTD_DEV_TYPE(dev->id->type), dev->id->num, pnum);

	return 0;
34807220:	e3a00000 	mov	r0, #0
34807224:	ea000000 	b	3480722c <do_chpart+0xa8>
		printf("no partition id specified\n");
		return 1;
	}

	if (find_dev_and_part(argv[1], &dev, &pnum, &part) != 0)
		return 1;
34807228:	e3a00001 	mov	r0, #1

	printf("partition changed to %s%d,%d\n",
			MTD_DEV_TYPE(dev->id->type), dev->id->num, pnum);

	return 0;
}
3480722c:	e28dd014 	add	sp, sp, #20
34807230:	e8bd8030 	pop	{r4, r5, pc}
34807234:	34824e52 	.word	0x34824e52
34807238:	34829224 	.word	0x34829224
3480723c:	34824ada 	.word	0x34824ada
34807240:	34824709 	.word	0x34824709
34807244:	34824ad7 	.word	0x34824ad7
34807248:	34824e6d 	.word	0x34824e6d

3480724c <do_ping>:
}

#if defined(CONFIG_CMD_PING)
int do_ping (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	if (argc < 2)
3480724c:	e3520001 	cmp	r2, #1
	return rcode;
}

#if defined(CONFIG_CMD_PING)
int do_ping (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
34807250:	e92d4010 	push	{r4, lr}
	if (argc < 2)
		return -1;
34807254:	d3e00000 	mvnle	r0, #0
	return rcode;
}

#if defined(CONFIG_CMD_PING)
int do_ping (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
34807258:	e1a04003 	mov	r4, r3
	if (argc < 2)
3480725c:	d8bd8010 	pople	{r4, pc}
		return -1;

	NetPingIP = string_to_ip(argv[1]);
34807260:	e5930004 	ldr	r0, [r3, #4]
34807264:	eb004588 	bl	3481888c <string_to_ip>
34807268:	e59f3048 	ldr	r3, [pc, #72]	; 348072b8 <do_ping+0x6c>
	if (NetPingIP == 0)
3480726c:	e3500000 	cmp	r0, #0
int do_ping (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	if (argc < 2)
		return -1;

	NetPingIP = string_to_ip(argv[1]);
34807270:	e5830000 	str	r0, [r3]
	if (NetPingIP == 0)
34807274:	0a00000d 	beq	348072b0 <do_ping+0x64>
		return CMD_RET_USAGE;

	if (NetLoop(PING) < 0) {
34807278:	e3a00005 	mov	r0, #5
3480727c:	eb005c4d 	bl	3481e3b8 <NetLoop>
34807280:	e3500000 	cmp	r0, #0
34807284:	aa000004 	bge	3480729c <do_ping+0x50>
		printf("ping failed; host %s is not alive\n", argv[1]);
34807288:	e59f002c 	ldr	r0, [pc, #44]	; 348072bc <do_ping+0x70>
3480728c:	e5941004 	ldr	r1, [r4, #4]
34807290:	eb00072d 	bl	34808f4c <printf>
		return 1;
34807294:	e3a00001 	mov	r0, #1
34807298:	e8bd8010 	pop	{r4, pc}
	}

	printf("host %s is alive\n", argv[1]);
3480729c:	e59f001c 	ldr	r0, [pc, #28]	; 348072c0 <do_ping+0x74>
348072a0:	e5941004 	ldr	r1, [r4, #4]
348072a4:	eb000728 	bl	34808f4c <printf>

	return 0;
348072a8:	e3a00000 	mov	r0, #0
348072ac:	e8bd8010 	pop	{r4, pc}
	if (argc < 2)
		return -1;

	NetPingIP = string_to_ip(argv[1]);
	if (NetPingIP == 0)
		return CMD_RET_USAGE;
348072b0:	e3e00000 	mvn	r0, #0
	}

	printf("host %s is alive\n", argv[1]);

	return 0;
}
348072b4:	e8bd8010 	pop	{r4, pc}
348072b8:	3482e244 	.word	0x3482e244
348072bc:	348253d9 	.word	0x348253d9
348072c0:	348253fc 	.word	0x348253fc

348072c4 <netboot_common>:
#endif
}

static int netboot_common(enum proto_t proto, cmd_tbl_t *cmdtp, int argc,
		char * const argv[])
{
348072c4:	e92d46f0 	push	{r4, r5, r6, r7, r9, sl, lr}
348072c8:	e1a06000 	mov	r6, r0
348072cc:	e24dd024 	sub	sp, sp, #36	; 0x24
	int   rcode = 0;
	int   size;
	ulong addr;

	/* pre-set load_addr */
	if ((s = getenv("loadaddr")) != NULL) {
348072d0:	e59f0250 	ldr	r0, [pc, #592]	; 34807528 <netboot_common+0x264>
#endif
}

static int netboot_common(enum proto_t proto, cmd_tbl_t *cmdtp, int argc,
		char * const argv[])
{
348072d4:	e1a05001 	mov	r5, r1
348072d8:	e1a04002 	mov	r4, r2
348072dc:	e1a07003 	mov	r7, r3
	int   rcode = 0;
	int   size;
	ulong addr;

	/* pre-set load_addr */
	if ((s = getenv("loadaddr")) != NULL) {
348072e0:	eb0003d5 	bl	3480823c <getenv>
348072e4:	e3500000 	cmp	r0, #0
348072e8:	0a000004 	beq	34807300 <netboot_common+0x3c>
		load_addr = simple_strtoul(s, NULL, 16);
348072ec:	e3a01000 	mov	r1, #0
348072f0:	e3a02010 	mov	r2, #16
348072f4:	eb004a3f 	bl	34819bf8 <simple_strtoul>
348072f8:	e59f322c 	ldr	r3, [pc, #556]	; 3480752c <netboot_common+0x268>
348072fc:	e5830000 	str	r0, [r3]
	}

	switch (argc) {
34807300:	e3540002 	cmp	r4, #2
34807304:	0a000004 	beq	3480731c <netboot_common+0x58>
34807308:	e3540003 	cmp	r4, #3
3480730c:	0a000013 	beq	34807360 <netboot_common+0x9c>
34807310:	e3540001 	cmp	r4, #1
34807314:	1a00001c 	bne	3480738c <netboot_common+0xc8>
34807318:	ea00001f 	b	3480739c <netboot_common+0xd8>
		 * Only one arg - accept two forms:
		 * Just load address, or just boot file name. The latter
		 * form must be written in a format which can not be
		 * mis-interpreted as a valid number.
		 */
		addr = simple_strtoul(argv[1], &end, 16);
3480731c:	e28d101c 	add	r1, sp, #28
34807320:	e3a02010 	mov	r2, #16
34807324:	e5970004 	ldr	r0, [r7, #4]
34807328:	eb004a32 	bl	34819bf8 <simple_strtoul>
		if (end == (argv[1] + strlen(argv[1])))
3480732c:	e5974004 	ldr	r4, [r7, #4]
		 * Only one arg - accept two forms:
		 * Just load address, or just boot file name. The latter
		 * form must be written in a format which can not be
		 * mis-interpreted as a valid number.
		 */
		addr = simple_strtoul(argv[1], &end, 16);
34807330:	e1a0a000 	mov	sl, r0
		if (end == (argv[1] + strlen(argv[1])))
34807334:	e1a00004 	mov	r0, r4
34807338:	e59d901c 	ldr	r9, [sp, #28]
3480733c:	eb00460f 	bl	34818b80 <strlen>
34807340:	e0840000 	add	r0, r4, r0
34807344:	e1590000 	cmp	r9, r0
			load_addr = addr;
34807348:	059f31dc 	ldreq	r3, [pc, #476]	; 3480752c <netboot_common+0x268>
		else
			copy_filename(BootFile, argv[1], sizeof(BootFile));
3480734c:	159f01dc 	ldrne	r0, [pc, #476]	; 34807530 <netboot_common+0x26c>
		 * form must be written in a format which can not be
		 * mis-interpreted as a valid number.
		 */
		addr = simple_strtoul(argv[1], &end, 16);
		if (end == (argv[1] + strlen(argv[1])))
			load_addr = addr;
34807350:	0583a000 	streq	sl, [r3]
		else
			copy_filename(BootFile, argv[1], sizeof(BootFile));
34807354:	15971004 	ldrne	r1, [r7, #4]
		 * Just load address, or just boot file name. The latter
		 * form must be written in a format which can not be
		 * mis-interpreted as a valid number.
		 */
		addr = simple_strtoul(argv[1], &end, 16);
		if (end == (argv[1] + strlen(argv[1])))
34807358:	1a000008 	bne	34807380 <netboot_common+0xbc>
3480735c:	ea00000e 	b	3480739c <netboot_common+0xd8>
			load_addr = addr;
		else
			copy_filename(BootFile, argv[1], sizeof(BootFile));
		break;

	case 3:	load_addr = simple_strtoul(argv[1], NULL, 16);
34807360:	e3a01000 	mov	r1, #0
34807364:	e5970004 	ldr	r0, [r7, #4]
34807368:	e3a02010 	mov	r2, #16
3480736c:	eb004a21 	bl	34819bf8 <simple_strtoul>
34807370:	e59f31b4 	ldr	r3, [pc, #436]	; 3480752c <netboot_common+0x268>
		copy_filename (BootFile, argv[2], sizeof(BootFile));
34807374:	e5971008 	ldr	r1, [r7, #8]
			load_addr = addr;
		else
			copy_filename(BootFile, argv[1], sizeof(BootFile));
		break;

	case 3:	load_addr = simple_strtoul(argv[1], NULL, 16);
34807378:	e5830000 	str	r0, [r3]
		copy_filename (BootFile, argv[2], sizeof(BootFile));
3480737c:	e59f01ac 	ldr	r0, [pc, #428]	; 34807530 <netboot_common+0x26c>
34807380:	e3a02080 	mov	r2, #128	; 0x80
34807384:	eb005b75 	bl	3481e160 <copy_filename>

		break;
34807388:	ea000003 	b	3480739c <netboot_common+0xd8>
3480738c:	e3e0004f 	mvn	r0, #79	; 0x4f
34807390:	eb001764 	bl	3480d128 <__show_boot_progress>
		copy_filename(BootFile, argv[3], sizeof(BootFile));
		break;
#endif
	default:
		bootstage_error(BOOTSTAGE_ID_NET_START);
		return CMD_RET_USAGE;
34807394:	e3e04000 	mvn	r4, #0
34807398:	ea00005f 	b	3480751c <netboot_common+0x258>
 * and won't even do that unless CONFIG_SHOW_BOOT_PROGRESS is defined
 */

static inline ulong bootstage_mark(enum bootstage_id id)
{
	show_boot_progress(id);
3480739c:	e3a00050 	mov	r0, #80	; 0x50
348073a0:	eb001760 	bl	3480d128 <__show_boot_progress>
	}
	bootstage_mark(BOOTSTAGE_ID_NET_START);

	if ((size = NetLoop(proto)) < 0) {
348073a4:	e1a00006 	mov	r0, r6
348073a8:	eb005c02 	bl	3481e3b8 <NetLoop>
348073ac:	e2504000 	subs	r4, r0, #0
348073b0:	aa000003 	bge	348073c4 <netboot_common+0x100>
	return 0;
}

static inline ulong bootstage_error(enum bootstage_id id)
{
	show_boot_progress(-id);
348073b4:	e3e00050 	mvn	r0, #80	; 0x50
348073b8:	eb00175a 	bl	3480d128 <__show_boot_progress>
		bootstage_error(BOOTSTAGE_ID_NET_NETLOOP_OK);
		return 1;
348073bc:	e3a04001 	mov	r4, #1
348073c0:	ea000055 	b	3480751c <netboot_common+0x258>
 * and won't even do that unless CONFIG_SHOW_BOOT_PROGRESS is defined
 */

static inline ulong bootstage_mark(enum bootstage_id id)
{
	show_boot_progress(id);
348073c4:	e3a00051 	mov	r0, #81	; 0x51
348073c8:	eb001756 	bl	3480d128 <__show_boot_progress>

static void netboot_update_env (void)
{
	char tmp[22];

	if (NetOurGatewayIP) {
348073cc:	e59f3160 	ldr	r3, [pc, #352]	; 34807534 <netboot_common+0x270>
348073d0:	e5930000 	ldr	r0, [r3]
348073d4:	e3500000 	cmp	r0, #0
348073d8:	0a000005 	beq	348073f4 <netboot_common+0x130>
		ip_to_string (NetOurGatewayIP, tmp);
348073dc:	e28d6004 	add	r6, sp, #4
348073e0:	e1a01006 	mov	r1, r6
348073e4:	eb005b75 	bl	3481e1c0 <ip_to_string>
		setenv ("gatewayip", tmp);
348073e8:	e59f0148 	ldr	r0, [pc, #328]	; 34807538 <netboot_common+0x274>
348073ec:	e1a01006 	mov	r1, r6
348073f0:	eb000289 	bl	34807e1c <setenv>
	}

	if (NetOurSubnetMask) {
348073f4:	e59f3140 	ldr	r3, [pc, #320]	; 3480753c <netboot_common+0x278>
348073f8:	e5930000 	ldr	r0, [r3]
348073fc:	e3500000 	cmp	r0, #0
34807400:	0a000005 	beq	3480741c <netboot_common+0x158>
		ip_to_string (NetOurSubnetMask, tmp);
34807404:	e28d6004 	add	r6, sp, #4
34807408:	e1a01006 	mov	r1, r6
3480740c:	eb005b6b 	bl	3481e1c0 <ip_to_string>
		setenv ("netmask", tmp);
34807410:	e59f0128 	ldr	r0, [pc, #296]	; 34807540 <netboot_common+0x27c>
34807414:	e1a01006 	mov	r1, r6
34807418:	eb00027f 	bl	34807e1c <setenv>
	}

	if (NetOurHostName[0])
3480741c:	e59f1120 	ldr	r1, [pc, #288]	; 34807544 <netboot_common+0x280>
34807420:	e5d13000 	ldrb	r3, [r1]
34807424:	e3530000 	cmp	r3, #0
34807428:	0a000001 	beq	34807434 <netboot_common+0x170>
		setenv ("hostname", NetOurHostName);
3480742c:	e59f0114 	ldr	r0, [pc, #276]	; 34807548 <netboot_common+0x284>
34807430:	eb000279 	bl	34807e1c <setenv>

	if (NetOurRootPath[0])
34807434:	e59f1110 	ldr	r1, [pc, #272]	; 3480754c <netboot_common+0x288>
34807438:	e5d13000 	ldrb	r3, [r1]
3480743c:	e3530000 	cmp	r3, #0
34807440:	0a000001 	beq	3480744c <netboot_common+0x188>
		setenv ("rootpath", NetOurRootPath);
34807444:	e59f0104 	ldr	r0, [pc, #260]	; 34807550 <netboot_common+0x28c>
34807448:	eb000273 	bl	34807e1c <setenv>

	if (NetOurIP) {
3480744c:	e59f3100 	ldr	r3, [pc, #256]	; 34807554 <netboot_common+0x290>
34807450:	e5930000 	ldr	r0, [r3]
34807454:	e3500000 	cmp	r0, #0
34807458:	0a000005 	beq	34807474 <netboot_common+0x1b0>
		ip_to_string (NetOurIP, tmp);
3480745c:	e28d6004 	add	r6, sp, #4
34807460:	e1a01006 	mov	r1, r6
34807464:	eb005b55 	bl	3481e1c0 <ip_to_string>
		setenv ("ipaddr", tmp);
34807468:	e59f00e8 	ldr	r0, [pc, #232]	; 34807558 <netboot_common+0x294>
3480746c:	e1a01006 	mov	r1, r6
34807470:	eb000269 	bl	34807e1c <setenv>
#if !defined(CONFIG_BOOTP_SERVERIP)
	/*
	 * Only attempt to change serverip if net/bootp.c:BootpCopyNetParams()
	 * could have set it
	 */
	if (NetServerIP) {
34807474:	e59f30e0 	ldr	r3, [pc, #224]	; 3480755c <netboot_common+0x298>
34807478:	e5930000 	ldr	r0, [r3]
3480747c:	e3500000 	cmp	r0, #0
34807480:	0a000005 	beq	3480749c <netboot_common+0x1d8>
		ip_to_string (NetServerIP, tmp);
34807484:	e28d6004 	add	r6, sp, #4
34807488:	e1a01006 	mov	r1, r6
3480748c:	eb005b4b 	bl	3481e1c0 <ip_to_string>
		setenv ("serverip", tmp);
34807490:	e59f00c8 	ldr	r0, [pc, #200]	; 34807560 <netboot_common+0x29c>
34807494:	e1a01006 	mov	r1, r6
34807498:	eb00025f 	bl	34807e1c <setenv>
	}
#endif
	if (NetOurDNSIP) {
3480749c:	e59f30c0 	ldr	r3, [pc, #192]	; 34807564 <netboot_common+0x2a0>
348074a0:	e5930000 	ldr	r0, [r3]
348074a4:	e3500000 	cmp	r0, #0
348074a8:	0a000005 	beq	348074c4 <netboot_common+0x200>
		ip_to_string (NetOurDNSIP, tmp);
348074ac:	e28d6004 	add	r6, sp, #4
348074b0:	e1a01006 	mov	r1, r6
348074b4:	eb005b41 	bl	3481e1c0 <ip_to_string>
		setenv ("dnsip", tmp);
348074b8:	e59f00a8 	ldr	r0, [pc, #168]	; 34807568 <netboot_common+0x2a4>
348074bc:	e1a01006 	mov	r1, r6
348074c0:	eb000255 	bl	34807e1c <setenv>
	if (NetOurDNS2IP) {
		ip_to_string (NetOurDNS2IP, tmp);
		setenv ("dnsip2", tmp);
	}
#endif
	if (NetOurNISDomain[0])
348074c4:	e59f10a0 	ldr	r1, [pc, #160]	; 3480756c <netboot_common+0x2a8>
348074c8:	e5d13000 	ldrb	r3, [r1]
348074cc:	e3530000 	cmp	r3, #0
348074d0:	0a000001 	beq	348074dc <netboot_common+0x218>
		setenv ("domain", NetOurNISDomain);
348074d4:	e59f0094 	ldr	r0, [pc, #148]	; 34807570 <netboot_common+0x2ac>
348074d8:	eb00024f 	bl	34807e1c <setenv>

	/* NetLoop ok, update environment */
	netboot_update_env();

	/* done if no file was loaded (no errors though) */
	if (size == 0) {
348074dc:	e3540000 	cmp	r4, #0
	return 0;
}

static inline ulong bootstage_error(enum bootstage_id id)
{
	show_boot_progress(-id);
348074e0:	03e00051 	mvneq	r0, #81	; 0x51
348074e4:	0a00000b 	beq	34807518 <netboot_common+0x254>
		bootstage_error(BOOTSTAGE_ID_NET_LOADED);
		return 0;
	}

	/* flush cache */
	flush_cache(load_addr, size);
348074e8:	e59f303c 	ldr	r3, [pc, #60]	; 3480752c <netboot_common+0x268>
348074ec:	e1a01004 	mov	r1, r4
348074f0:	e5930000 	ldr	r0, [r3]
348074f4:	ebffe6c9 	bl	34801020 <flush_cache>
 * and won't even do that unless CONFIG_SHOW_BOOT_PROGRESS is defined
 */

static inline ulong bootstage_mark(enum bootstage_id id)
{
	show_boot_progress(id);
348074f8:	e3a00052 	mov	r0, #82	; 0x52
348074fc:	eb001709 	bl	3480d128 <__show_boot_progress>

	bootstage_mark(BOOTSTAGE_ID_NET_LOADED);

	rcode = bootm_maybe_autostart(cmdtp, argv[0]);
34807500:	e1a00005 	mov	r0, r5
34807504:	e5971000 	ldr	r1, [r7]
34807508:	ebffef0e 	bl	34803148 <bootm_maybe_autostart>

	if (rcode < 0)
3480750c:	e2504000 	subs	r4, r0, #0
	return 0;
}

static inline ulong bootstage_error(enum bootstage_id id)
{
	show_boot_progress(-id);
34807510:	b3e00052 	mvnlt	r0, #82	; 0x52
 * and won't even do that unless CONFIG_SHOW_BOOT_PROGRESS is defined
 */

static inline ulong bootstage_mark(enum bootstage_id id)
{
	show_boot_progress(id);
34807514:	a3a00054 	movge	r0, #84	; 0x54
34807518:	eb001702 	bl	3480d128 <__show_boot_progress>
		bootstage_error(BOOTSTAGE_ID_NET_DONE_ERR);
	else
		bootstage_mark(BOOTSTAGE_ID_NET_DONE);
	return rcode;
}
3480751c:	e1a00004 	mov	r0, r4
34807520:	e28dd024 	add	sp, sp, #36	; 0x24
34807524:	e8bd86f0 	pop	{r4, r5, r6, r7, r9, sl, pc}
34807528:	34822bcc 	.word	0x34822bcc
3480752c:	348283c4 	.word	0x348283c4
34807530:	3482d914 	.word	0x3482d914
34807534:	3482ba24 	.word	0x3482ba24
34807538:	3482540e 	.word	0x3482540e
3480753c:	3482ba28 	.word	0x3482ba28
34807540:	34825418 	.word	0x34825418
34807544:	3482d8a4 	.word	0x3482d8a4
34807548:	34825420 	.word	0x34825420
3480754c:	3482d8c4 	.word	0x3482d8c4
34807550:	34825429 	.word	0x34825429
34807554:	3482ba04 	.word	0x3482ba04
34807558:	34822f56 	.word	0x34822f56
3480755c:	3482ba2c 	.word	0x3482ba2c
34807560:	34825432 	.word	0x34825432
34807564:	3482d904 	.word	0x3482d904
34807568:	3482543b 	.word	0x3482543b
3480756c:	3482d884 	.word	0x3482d884
34807570:	34825441 	.word	0x34825441

34807574 <do_nfs>:
);
#endif

#if defined(CONFIG_CMD_NFS)
int do_nfs (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
34807574:	e1a01000 	mov	r1, r0
	return netboot_common(NFS, cmdtp, argc, argv);
34807578:	e3a00007 	mov	r0, #7
3480757c:	eaffff50 	b	348072c4 <netboot_common>

34807580 <do_tftpb>:
	"boot image via network using BOOTP/TFTP protocol",
	"[loadAddress] [[hostIPaddr:]bootfilename]"
);

int do_tftpb (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
34807580:	e1a01000 	mov	r1, r0
	int ret;

	bootstage_mark_name(BOOTSTAGE_KERNELREAD_START, "tftp_start");
	ret = netboot_common(TFTPGET, cmdtp, argc, argv);
34807584:	e3a00003 	mov	r0, #3
34807588:	eaffff4d 	b	348072c4 <netboot_common>

3480758c <do_bootp>:
#include <net.h>

static int netboot_common(enum proto_t, cmd_tbl_t *, int, char * const []);

int do_bootp (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
3480758c:	e1a01000 	mov	r1, r0
	return netboot_common (BOOTP, cmdtp, argc, argv);
34807590:	e3a00000 	mov	r0, #0
34807594:	eaffff4a 	b	348072c4 <netboot_common>

34807598 <do_env>:

static int do_env(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	cmd_tbl_t *cp;

	if (argc < 2)
34807598:	e3520001 	cmp	r2, #1
	fixup_cmdtable(cmd_env_sub, ARRAY_SIZE(cmd_env_sub));
}
#endif

static int do_env(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
3480759c:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
348075a0:	e1a05000 	mov	r5, r0
348075a4:	e1a06001 	mov	r6, r1
348075a8:	e1a04002 	mov	r4, r2
	cmd_tbl_t *cp;

	if (argc < 2)
		return CMD_RET_USAGE;
348075ac:	d3e00000 	mvnle	r0, #0

static int do_env(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	cmd_tbl_t *cp;

	if (argc < 2)
348075b0:	d8bd80f8 	pople	{r3, r4, r5, r6, r7, pc}

	/* drop initial "env" arg */
	argc--;
	argv++;

	cp = find_cmd_tbl(argv[0], cmd_env_sub, ARRAY_SIZE(cmd_env_sub));
348075b4:	e5930004 	ldr	r0, [r3, #4]
348075b8:	e59f1034 	ldr	r1, [pc, #52]	; 348075f4 <do_env+0x5c>
348075bc:	e3a02008 	mov	r2, #8
	if (argc < 2)
		return CMD_RET_USAGE;

	/* drop initial "env" arg */
	argc--;
	argv++;
348075c0:	e2837004 	add	r7, r3, #4

	cp = find_cmd_tbl(argv[0], cmd_env_sub, ARRAY_SIZE(cmd_env_sub));
348075c4:	eb0004d8 	bl	3480892c <find_cmd_tbl>

	if (cp)
348075c8:	e3500000 	cmp	r0, #0
348075cc:	0a000006 	beq	348075ec <do_env+0x54>
		return cp->cmd(cmdtp, flag, argc, argv);
348075d0:	e590c00c 	ldr	ip, [r0, #12]
348075d4:	e1a01006 	mov	r1, r6
348075d8:	e1a00005 	mov	r0, r5
348075dc:	e2442001 	sub	r2, r4, #1
348075e0:	e1a03007 	mov	r3, r7
348075e4:	e12fff3c 	blx	ip
348075e8:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}

	return CMD_RET_USAGE;
348075ec:	e3e00000 	mvn	r0, #0
}
348075f0:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
348075f4:	34828300 	.word	0x34828300

348075f8 <do_env_delete>:
	return cmd_usage(cmdtp);
}

static int do_env_delete(cmd_tbl_t *cmdtp, int flag,
			 int argc, char * const argv[])
{
348075f8:	e92d4008 	push	{r3, lr}
	printf("Not implemented yet\n");
348075fc:	e59f0008 	ldr	r0, [pc, #8]	; 3480760c <do_env_delete+0x14>
34807600:	eb000651 	bl	34808f4c <printf>
	return 0;
}
34807604:	e3a00000 	mov	r0, #0
34807608:	e8bd8008 	pop	{r3, pc}
3480760c:	34825543 	.word	0x34825543

34807610 <do_env_import>:
 *	size:	length of input data; if missing, proper '\0'
 *		termination is mandatory
 */
static int do_env_import(cmd_tbl_t *cmdtp, int flag,
			 int argc, char * const argv[])
{
34807610:	e92d46f0 	push	{r4, r5, r6, r7, r9, sl, lr}
	char	*cmd, *addr;
	char	sep = '\n';
	int	chk = 0;
	int	fmt = 0;
	int	del = 0;
34807614:	e3a0a000 	mov	sl, #0
 *	size:	length of input data; if missing, proper '\0'
 *		termination is mandatory
 */
static int do_env_import(cmd_tbl_t *cmdtp, int flag,
			 int argc, char * const argv[])
{
34807618:	e1a04002 	mov	r4, r2
3480761c:	e24dd01c 	sub	sp, sp, #28
	int	chk = 0;
	int	fmt = 0;
	int	del = 0;
	size_t	size;

	cmd = *argv;
34807620:	e4931004 	ldr	r1, [r3], #4
			 int argc, char * const argv[])
{
	char	*cmd, *addr;
	char	sep = '\n';
	int	chk = 0;
	int	fmt = 0;
34807624:	e1a0200a 	mov	r2, sl
static int do_env_import(cmd_tbl_t *cmdtp, int flag,
			 int argc, char * const argv[])
{
	char	*cmd, *addr;
	char	sep = '\n';
	int	chk = 0;
34807628:	e1a0900a 	mov	r9, sl
 */
static int do_env_import(cmd_tbl_t *cmdtp, int flag,
			 int argc, char * const argv[])
{
	char	*cmd, *addr;
	char	sep = '\n';
3480762c:	e3a0700a 	mov	r7, #10
	int	del = 0;
	size_t	size;

	cmd = *argv;

	while (--argc > 0 && **++argv == '-') {
34807630:	ea00001d 	b	348076ac <do_env_import+0x9c>
		char *arg = *argv;
		while (*++arg) {
			switch (*arg) {
34807634:	e3500063 	cmp	r0, #99	; 0x63
34807638:	0a00000c 	beq	34807670 <do_env_import+0x60>
3480763c:	8a000002 	bhi	3480764c <do_env_import+0x3c>
34807640:	e3500062 	cmp	r0, #98	; 0x62
34807644:	1a000077 	bne	34807828 <do_env_import+0x218>
34807648:	ea000004 	b	34807660 <do_env_import+0x50>
3480764c:	e3500064 	cmp	r0, #100	; 0x64
34807650:	0a000011 	beq	3480769c <do_env_import+0x8c>
34807654:	e3500074 	cmp	r0, #116	; 0x74
34807658:	1a000072 	bne	34807828 <do_env_import+0x218>
3480765c:	ea000009 	b	34807688 <do_env_import+0x78>
			case 'b':		/* raw binary format */
				if (fmt++)
34807660:	e3520000 	cmp	r2, #0
34807664:	1a00006b 	bne	34807818 <do_env_import+0x208>
34807668:	e2822001 	add	r2, r2, #1
3480766c:	ea000003 	b	34807680 <do_env_import+0x70>
					goto sep_err;
				sep = '\0';
				break;
			case 'c':		/* external checksum format */
				if (fmt++)
34807670:	e3520000 	cmp	r2, #0
34807674:	1a000067 	bne	34807818 <do_env_import+0x208>
34807678:	e2822001 	add	r2, r2, #1
					goto sep_err;
				sep = '\0';
				chk = 1;
3480767c:	e1a09002 	mov	r9, r2
				sep = '\0';
				break;
			case 'c':		/* external checksum format */
				if (fmt++)
					goto sep_err;
				sep = '\0';
34807680:	e3a07000 	mov	r7, #0
34807684:	ea000005 	b	348076a0 <do_env_import+0x90>
				chk = 1;
				break;
			case 't':		/* text format */
				if (fmt++)
34807688:	e3520000 	cmp	r2, #0
3480768c:	1a000061 	bne	34807818 <do_env_import+0x208>
34807690:	e2822001 	add	r2, r2, #1
					goto sep_err;
				sep = '\n';
34807694:	e3a0700a 	mov	r7, #10
34807698:	ea000000 	b	348076a0 <do_env_import+0x90>
				break;
			case 'd':
				del = 1;
3480769c:	e3a0a001 	mov	sl, #1

	cmd = *argv;

	while (--argc > 0 && **++argv == '-') {
		char *arg = *argv;
		while (*++arg) {
348076a0:	e5fc0001 	ldrb	r0, [ip, #1]!
348076a4:	e3500000 	cmp	r0, #0
348076a8:	1affffe1 	bne	34807634 <do_env_import+0x24>
	int	del = 0;
	size_t	size;

	cmd = *argv;

	while (--argc > 0 && **++argv == '-') {
348076ac:	e2444001 	sub	r4, r4, #1
348076b0:	e3540000 	cmp	r4, #0
348076b4:	da00005b 	ble	34807828 <do_env_import+0x218>
348076b8:	e1a05003 	mov	r5, r3
348076bc:	e493c004 	ldr	ip, [r3], #4
348076c0:	e5dc0000 	ldrb	r0, [ip]
348076c4:	e350002d 	cmp	r0, #45	; 0x2d
348076c8:	0afffff4 	beq	348076a0 <do_env_import+0x90>
348076cc:	ea000058 	b	34807834 <do_env_import+0x224>

	if (argc < 1)
		return CMD_RET_USAGE;

	if (!fmt)
		printf("## Warning: defaulting to text format\n");
348076d0:	e59f0168 	ldr	r0, [pc, #360]	; 34807840 <do_env_import+0x230>
348076d4:	eb00061c 	bl	34808f4c <printf>

	addr = (char *)simple_strtoul(argv[0], NULL, 16);
348076d8:	e3a02010 	mov	r2, #16
348076dc:	e5950000 	ldr	r0, [r5]
348076e0:	e3a01000 	mov	r1, #0
348076e4:	eb004943 	bl	34819bf8 <simple_strtoul>

	if (argc == 2) {
348076e8:	e3540002 	cmp	r4, #2
		return CMD_RET_USAGE;

	if (!fmt)
		printf("## Warning: defaulting to text format\n");

	addr = (char *)simple_strtoul(argv[0], NULL, 16);
348076ec:	e1a06000 	mov	r6, r0

	if (argc == 2) {
348076f0:	11a02000 	movne	r2, r0
348076f4:	13a03000 	movne	r3, #0
348076f8:	1a000006 	bne	34807718 <do_env_import+0x108>
		size = simple_strtoul(argv[1], NULL, 16);
348076fc:	e5950004 	ldr	r0, [r5, #4]
34807700:	e3a01000 	mov	r1, #0
34807704:	e3a02010 	mov	r2, #16
34807708:	eb00493a 	bl	34819bf8 <simple_strtoul>
3480770c:	e1a05000 	mov	r5, r0
34807710:	ea000013 	b	34807764 <do_env_import+0x154>
	} else {
		char *s = addr;

		size = 0;

		while (size < MAX_ENV_SIZE) {
34807714:	e1a03005 	mov	r3, r5
			if ((*s == sep) && (*(s+1) == '\0'))
34807718:	e4d21001 	ldrb	r1, [r2], #1
3480771c:	e2835001 	add	r5, r3, #1
34807720:	e1510007 	cmp	r1, r7
34807724:	1a000002 	bne	34807734 <do_env_import+0x124>
34807728:	e7d61005 	ldrb	r1, [r6, r5]
3480772c:	e3510000 	cmp	r1, #0
34807730:	0a000005 	beq	3480774c <do_env_import+0x13c>
	} else {
		char *s = addr;

		size = 0;

		while (size < MAX_ENV_SIZE) {
34807734:	e3550601 	cmp	r5, #1048576	; 0x100000
34807738:	1afffff5 	bne	34807714 <do_env_import+0x104>
				break;
			++s;
			++size;
		}
		if (size == MAX_ENV_SIZE) {
			printf("## Warning: Input data exceeds %d bytes"
3480773c:	e1a01005 	mov	r1, r5
34807740:	e59f00fc 	ldr	r0, [pc, #252]	; 34807844 <do_env_import+0x234>
34807744:	eb000600 	bl	34808f4c <printf>
34807748:	ea000000 	b	34807750 <do_env_import+0x140>
		char *s = addr;

		size = 0;

		while (size < MAX_ENV_SIZE) {
			if ((*s == sep) && (*(s+1) == '\0'))
3480774c:	e1a05003 	mov	r5, r3
		}
		if (size == MAX_ENV_SIZE) {
			printf("## Warning: Input data exceeds %d bytes"
				" - truncated\n", MAX_ENV_SIZE);
		}
		size += 2;
34807750:	e2855002 	add	r5, r5, #2
		printf("## Info: input data size = %zu = 0x%zX\n", size, size);
34807754:	e59f00ec 	ldr	r0, [pc, #236]	; 34807848 <do_env_import+0x238>
34807758:	e1a01005 	mov	r1, r5
3480775c:	e1a02005 	mov	r2, r5
34807760:	eb0005f9 	bl	34808f4c <printf>
	}

	if (chk) {
34807764:	e3590000 	cmp	r9, #0
34807768:	0a00000f 	beq	348077ac <do_env_import+0x19c>
		uint32_t crc;
		env_t *ep = (env_t *)addr;

		size -= offsetof(env_t, data);
		memcpy(&crc, &ep->crc, sizeof(crc));
3480776c:	e1a01006 	mov	r1, r6
34807770:	e3a02004 	mov	r2, #4

	if (chk) {
		uint32_t crc;
		env_t *ep = (env_t *)addr;

		size -= offsetof(env_t, data);
34807774:	e2455004 	sub	r5, r5, #4
		memcpy(&crc, &ep->crc, sizeof(crc));
34807778:	e28d0014 	add	r0, sp, #20

		if (crc32(0, ep->data, size) != crc) {
3480777c:	e2866004 	add	r6, r6, #4
	if (chk) {
		uint32_t crc;
		env_t *ep = (env_t *)addr;

		size -= offsetof(env_t, data);
		memcpy(&crc, &ep->crc, sizeof(crc));
34807780:	eb0045c2 	bl	34818e90 <memcpy>

		if (crc32(0, ep->data, size) != crc) {
34807784:	e3a00000 	mov	r0, #0
34807788:	e1a01006 	mov	r1, r6
3480778c:	e1a02005 	mov	r2, r5
34807790:	eb003e3c 	bl	34817088 <crc32>
34807794:	e59d3014 	ldr	r3, [sp, #20]
34807798:	e1500003 	cmp	r0, r3
3480779c:	0a000002 	beq	348077ac <do_env_import+0x19c>
			puts("## Error: bad CRC, import failed\n");
348077a0:	e59f00a4 	ldr	r0, [pc, #164]	; 3480784c <do_env_import+0x23c>
348077a4:	eb0005de 	bl	34808f24 <puts>
348077a8:	ea00001c 	b	34807820 <do_env_import+0x210>
			return 1;
		}
		addr = (char *)ep->data;
	}

	if (himport_r(&env_htab, addr, size, sep, del ? 0 : H_NOCLEAR,
348077ac:	e3a04000 	mov	r4, #0
348077b0:	e22aa001 	eor	sl, sl, #1
348077b4:	e59f0094 	ldr	r0, [pc, #148]	; 34807850 <do_env_import+0x240>
348077b8:	e1a01006 	mov	r1, r6
348077bc:	e1a02005 	mov	r2, r5
348077c0:	e1a03007 	mov	r3, r7
348077c4:	e58da000 	str	sl, [sp]
348077c8:	e58d4004 	str	r4, [sp, #4]
348077cc:	e58d4008 	str	r4, [sp, #8]
348077d0:	e58d400c 	str	r4, [sp, #12]
348077d4:	eb0041ee 	bl	34817f94 <himport_r>
348077d8:	e1500004 	cmp	r0, r4
348077dc:	1a000008 	bne	34807804 <do_env_import+0x1f4>
			0, NULL, 0 /* do_apply */) == 0) {
		error("Environment import failed: errno = %d\n", errno);
348077e0:	e59f306c 	ldr	r3, [pc, #108]	; 34807854 <do_env_import+0x244>
348077e4:	e59f206c 	ldr	r2, [pc, #108]	; 34807858 <do_env_import+0x248>
348077e8:	e58d3000 	str	r3, [sp]
348077ec:	e59f3068 	ldr	r3, [pc, #104]	; 3480785c <do_env_import+0x24c>
348077f0:	e59f0068 	ldr	r0, [pc, #104]	; 34807860 <do_env_import+0x250>
348077f4:	e5931000 	ldr	r1, [r3]
348077f8:	e30033bd 	movw	r3, #957	; 0x3bd
348077fc:	eb0005d2 	bl	34808f4c <printf>
34807800:	ea000006 	b	34807820 <do_env_import+0x210>
		return 1;
	}
	gd->flags |= GD_FLG_ENV_READY;
34807804:	e5982004 	ldr	r2, [r8, #4]

	return 0;
34807808:	e1a00004 	mov	r0, r4
	if (himport_r(&env_htab, addr, size, sep, del ? 0 : H_NOCLEAR,
			0, NULL, 0 /* do_apply */) == 0) {
		error("Environment import failed: errno = %d\n", errno);
		return 1;
	}
	gd->flags |= GD_FLG_ENV_READY;
3480780c:	e3822080 	orr	r2, r2, #128	; 0x80
34807810:	e5882004 	str	r2, [r8, #4]

	return 0;
34807814:	ea000004 	b	3480782c <do_env_import+0x21c>

sep_err:
	printf("## %s: only one of \"-b\", \"-c\" or \"-t\" allowed\n",
34807818:	e59f0044 	ldr	r0, [pc, #68]	; 34807864 <do_env_import+0x254>
3480781c:	eb0005ca 	bl	34808f4c <printf>
		cmd);
	return 1;
34807820:	e3a00001 	mov	r0, #1
34807824:	ea000000 	b	3480782c <do_env_import+0x21c>
			}
		}
	}

	if (argc < 1)
		return CMD_RET_USAGE;
34807828:	e3e00000 	mvn	r0, #0

sep_err:
	printf("## %s: only one of \"-b\", \"-c\" or \"-t\" allowed\n",
		cmd);
	return 1;
}
3480782c:	e28dd01c 	add	sp, sp, #28
34807830:	e8bd86f0 	pop	{r4, r5, r6, r7, r9, sl, pc}
	}

	if (argc < 1)
		return CMD_RET_USAGE;

	if (!fmt)
34807834:	e3520000 	cmp	r2, #0
34807838:	1affffa6 	bne	348076d8 <do_env_import+0xc8>
3480783c:	eaffffa3 	b	348076d0 <do_env_import+0xc0>
34807840:	34825558 	.word	0x34825558
34807844:	3482557f 	.word	0x3482557f
34807848:	348255b4 	.word	0x348255b4
3480784c:	348255dc 	.word	0x348255dc
34807850:	348287dc 	.word	0x348287dc
34807854:	3482051c 	.word	0x3482051c
34807858:	3482563b 	.word	0x3482563b
3480785c:	3482b338 	.word	0x3482b338
34807860:	348255fe 	.word	0x348255fe
34807864:	34825648 	.word	0x34825648

34807868 <do_env_default>:
}

#ifndef CONFIG_SPL_BUILD
static int do_env_default(cmd_tbl_t *cmdtp, int __flag,
			  int argc, char * const argv[])
{
34807868:	e92d4070 	push	{r4, r5, r6, lr}
	int all = 0, flag = 0;
3480786c:	e3a0c000 	mov	ip, #0

	debug("Initial value for argc=%d\n", argc);
	while (--argc > 0 && **++argv == '-') {
34807870:	ea000009 	b	3480789c <do_env_default+0x34>
		char *arg = *argv;

		while (*++arg) {
			switch (*arg) {
34807874:	e3530061 	cmp	r3, #97	; 0x61
34807878:	0a000002 	beq	34807888 <do_env_default+0x20>
3480787c:	e3530066 	cmp	r3, #102	; 0x66
34807880:	1a000021 	bne	3480790c <do_env_default+0xa4>
34807884:	ea000000 	b	3480788c <do_env_default+0x24>
			case 'a':		/* default all */
				all = 1;
34807888:	e3a0c001 	mov	ip, #1

	debug("Initial value for argc=%d\n", argc);
	while (--argc > 0 && **++argv == '-') {
		char *arg = *argv;

		while (*++arg) {
3480788c:	e5f13001 	ldrb	r3, [r1, #1]!
34807890:	e3530000 	cmp	r3, #0
34807894:	1afffff6 	bne	34807874 <do_env_default+0xc>
34807898:	e1a03004 	mov	r3, r4
			  int argc, char * const argv[])
{
	int all = 0, flag = 0;

	debug("Initial value for argc=%d\n", argc);
	while (--argc > 0 && **++argv == '-') {
3480789c:	e2422001 	sub	r2, r2, #1
348078a0:	e3520000 	cmp	r2, #0
		char *arg = *argv;

		while (*++arg) {
348078a4:	e1a01003 	mov	r1, r3
			  int argc, char * const argv[])
{
	int all = 0, flag = 0;

	debug("Initial value for argc=%d\n", argc);
	while (--argc > 0 && **++argv == '-') {
348078a8:	da000006 	ble	348078c8 <do_env_default+0x60>

	return -1;
}

#ifndef CONFIG_SPL_BUILD
static int do_env_default(cmd_tbl_t *cmdtp, int __flag,
348078ac:	e2834004 	add	r4, r3, #4
			  int argc, char * const argv[])
{
	int all = 0, flag = 0;

	debug("Initial value for argc=%d\n", argc);
	while (--argc > 0 && **++argv == '-') {
348078b0:	e5933004 	ldr	r3, [r3, #4]

	return -1;
}

#ifndef CONFIG_SPL_BUILD
static int do_env_default(cmd_tbl_t *cmdtp, int __flag,
348078b4:	e1a01004 	mov	r1, r4
			  int argc, char * const argv[])
{
	int all = 0, flag = 0;

	debug("Initial value for argc=%d\n", argc);
	while (--argc > 0 && **++argv == '-') {
348078b8:	e5d35000 	ldrb	r5, [r3]
348078bc:	e355002d 	cmp	r5, #45	; 0x2d
348078c0:	01a01003 	moveq	r1, r3
348078c4:	0afffff0 	beq	3480788c <do_env_default+0x24>
				return cmd_usage(cmdtp);
			}
		}
	}
	debug("Final value for argc=%d\n", argc);
	if (all && (argc == 0)) {
348078c8:	e3520000 	cmp	r2, #0
348078cc:	13a03000 	movne	r3, #0
348078d0:	020c3001 	andeq	r3, ip, #1
348078d4:	e3530000 	cmp	r3, #0
348078d8:	0a000002 	beq	348078e8 <do_env_default+0x80>
		/* Reset the whole environment */
		set_default_env("## Resetting to default environment\n");
348078dc:	e59f0038 	ldr	r0, [pc, #56]	; 3480791c <do_env_default+0xb4>
348078e0:	eb000ab0 	bl	3480a3a8 <set_default_env>
		return 0;
348078e4:	ea00000a 	b	34807914 <do_env_default+0xac>
	}
	if (!all && (argc > 0)) {
348078e8:	e22cc001 	eor	ip, ip, #1
348078ec:	e3520000 	cmp	r2, #0
348078f0:	d3a0c000 	movle	ip, #0
348078f4:	c20cc001 	andgt	ip, ip, #1
348078f8:	e35c0000 	cmp	ip, #0
348078fc:	0a000002 	beq	3480790c <do_env_default+0xa4>
		/* Reset individual variables */
		set_default_vars(argc, argv);
34807900:	e1a00002 	mov	r0, r2
34807904:	eb000ad6 	bl	3480a464 <set_default_vars>
		return 0;
34807908:	ea000001 	b	34807914 <do_env_default+0xac>
	}

	return cmd_usage(cmdtp);
}
3480790c:	e8bd4070 	pop	{r4, r5, r6, lr}
		/* Reset individual variables */
		set_default_vars(argc, argv);
		return 0;
	}

	return cmd_usage(cmdtp);
34807910:	ea000436 	b	348089f0 <cmd_usage>
}
34807914:	e3a00000 	mov	r0, #0
34807918:	e8bd8070 	pop	{r4, r5, r6, pc}
3480791c:	34825677 	.word	0x34825677

34807920 <env_print>:
 * Command interface: print one or all environment variables
 *
 * Returns 0 in case of error, or length of printed string
 */
static int env_print(char *name)
{
34807920:	e92d4010 	push	{r4, lr}
	char *res = NULL;
34807924:	e3a02000 	mov	r2, #0
 * Command interface: print one or all environment variables
 *
 * Returns 0 in case of error, or length of printed string
 */
static int env_print(char *name)
{
34807928:	e24dd018 	sub	sp, sp, #24
	char *res = NULL;
	size_t len;

	if (name) {		/* print a single name */
3480792c:	e2503000 	subs	r3, r0, #0
 *
 * Returns 0 in case of error, or length of printed string
 */
static int env_print(char *name)
{
	char *res = NULL;
34807930:	e58d2014 	str	r2, [sp, #20]
	size_t len;

	if (name) {		/* print a single name */
34807934:	0a000010 	beq	3480797c <env_print+0x5c>
		ENTRY e, *ep;

		e.key = name;
34807938:	e58d3008 	str	r3, [sp, #8]
		e.data = NULL;
		hsearch_r(e, FIND, &ep, &env_htab);
3480793c:	e59f3074 	ldr	r3, [pc, #116]	; 348079b8 <env_print+0x98>

	if (name) {		/* print a single name */
		ENTRY e, *ep;

		e.key = name;
		e.data = NULL;
34807940:	e58d200c 	str	r2, [sp, #12]
		hsearch_r(e, FIND, &ep, &env_htab);
34807944:	e58d3000 	str	r3, [sp]
34807948:	e28d3008 	add	r3, sp, #8
3480794c:	e8930003 	ldm	r3, {r0, r1}
34807950:	e28d3010 	add	r3, sp, #16
34807954:	eb003ffd 	bl	34817950 <hsearch_r>
		if (ep == NULL)
34807958:	e59d3010 	ldr	r3, [sp, #16]
3480795c:	e3530000 	cmp	r3, #0
			return 0;
34807960:	01a04003 	moveq	r4, r3
		ENTRY e, *ep;

		e.key = name;
		e.data = NULL;
		hsearch_r(e, FIND, &ep, &env_htab);
		if (ep == NULL)
34807964:	0a000010 	beq	348079ac <env_print+0x8c>
			return 0;
		len = printf("%s=%s\n", ep->key, ep->data);
34807968:	e59f004c 	ldr	r0, [pc, #76]	; 348079bc <env_print+0x9c>
3480796c:	e8930006 	ldm	r3, {r1, r2}
34807970:	eb000575 	bl	34808f4c <printf>
34807974:	e1a04000 	mov	r4, r0
		return len;
34807978:	ea00000b 	b	348079ac <env_print+0x8c>
	}

	/* print whole list */
	len = hexport_r(&env_htab, '\n', &res, 0, 0, NULL);
3480797c:	e59f0034 	ldr	r0, [pc, #52]	; 348079b8 <env_print+0x98>
34807980:	e3a0100a 	mov	r1, #10
34807984:	e28d2014 	add	r2, sp, #20
34807988:	e58d3000 	str	r3, [sp]
3480798c:	e58d3004 	str	r3, [sp, #4]
34807990:	eb0040d4 	bl	34817ce8 <hexport_r>

	if (len > 0) {
34807994:	e2504000 	subs	r4, r0, #0
34807998:	0a000003 	beq	348079ac <env_print+0x8c>
		puts(res);
3480799c:	e59d0014 	ldr	r0, [sp, #20]
348079a0:	eb00055f 	bl	34808f24 <puts>
		free(res);
348079a4:	e59d0014 	ldr	r0, [sp, #20]
348079a8:	eb0006a5 	bl	34809444 <free>
		return len;
	}

	/* should never happen */
	return 0;
}
348079ac:	e1a00004 	mov	r0, r4
348079b0:	e28dd018 	add	sp, sp, #24
348079b4:	e8bd8010 	pop	{r4, pc}
348079b8:	348287dc 	.word	0x348287dc
348079bc:	3482569c 	.word	0x3482569c

348079c0 <do_env_print>:
int do_env_print (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	int i;
	int rcode = 0;

	if (argc == 1) {
348079c0:	e3520001 	cmp	r2, #1
	/* should never happen */
	return 0;
}

int do_env_print (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
348079c4:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
348079c8:	e1a04002 	mov	r4, r2
	int i;
	int rcode = 0;

	if (argc == 1) {
348079cc:	11a07003 	movne	r7, r3
348079d0:	13a05000 	movne	r5, #0
348079d4:	13a06001 	movne	r6, #1
348079d8:	1a000012 	bne	34807a28 <do_env_print+0x68>
		/* print all env vars */
		rcode = env_print(NULL);
348079dc:	e3a00000 	mov	r0, #0
348079e0:	ebffffce 	bl	34807920 <env_print>
		if (!rcode)
348079e4:	e2501000 	subs	r1, r0, #0
			return 1;
348079e8:	01a05004 	moveq	r5, r4
	int rcode = 0;

	if (argc == 1) {
		/* print all env vars */
		rcode = env_print(NULL);
		if (!rcode)
348079ec:	0a00000f 	beq	34807a30 <do_env_print+0x70>
			return 1;
		printf("\nEnvironment size: %d/%ld bytes\n",
348079f0:	e59f0040 	ldr	r0, [pc, #64]	; 34807a38 <do_env_print+0x78>
348079f4:	e59f2040 	ldr	r2, [pc, #64]	; 34807a3c <do_env_print+0x7c>
348079f8:	eb000553 	bl	34808f4c <printf>
			rcode, (ulong)ENV_SIZE);
		return 0;
348079fc:	e3a05000 	mov	r5, #0
34807a00:	ea00000a 	b	34807a30 <do_env_print+0x70>
	}

	/* print selected env vars */
	for (i = 1; i < argc; ++i) {
		int rc = env_print(argv[i]);
34807a04:	e5b70004 	ldr	r0, [r7, #4]!
34807a08:	ebffffc4 	bl	34807920 <env_print>
		if (!rc) {
34807a0c:	e3500000 	cmp	r0, #0
34807a10:	1a000003 	bne	34807a24 <do_env_print+0x64>
			printf("## Error: \"%s\" not defined\n", argv[i]);
34807a14:	e59f0024 	ldr	r0, [pc, #36]	; 34807a40 <do_env_print+0x80>
34807a18:	e5971000 	ldr	r1, [r7]
34807a1c:	eb00054a 	bl	34808f4c <printf>
			++rcode;
34807a20:	e2855001 	add	r5, r5, #1
			rcode, (ulong)ENV_SIZE);
		return 0;
	}

	/* print selected env vars */
	for (i = 1; i < argc; ++i) {
34807a24:	e2866001 	add	r6, r6, #1
34807a28:	e1560004 	cmp	r6, r4
34807a2c:	bafffff4 	blt	34807a04 <do_env_print+0x44>
			++rcode;
		}
	}

	return rcode;
}
34807a30:	e1a00005 	mov	r0, r5
34807a34:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
34807a38:	348256a3 	.word	0x348256a3
34807a3c:	0003fffc 	.word	0x0003fffc
34807a40:	348256c4 	.word	0x348256c4

34807a44 <get_env_id>:
static int env_id = 1;

int get_env_id(void)
{
	return env_id;
}
34807a44:	e59f3004 	ldr	r3, [pc, #4]	; 34807a50 <get_env_id+0xc>
34807a48:	e59300c0 	ldr	r0, [r3, #192]	; 0xc0
34807a4c:	e12fff1e 	bx	lr
34807a50:	34828300 	.word	0x34828300

34807a54 <env_check_apply>:
 * overwriting of write-once variables.
 */

int env_check_apply(const char *name, const char *oldval,
			const char *newval, int flag)
{
34807a54:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
	int   console = -1;

	/* Default value for NULL to protect string-manipulating functions */
	newval = newval ? : "";
34807a58:	e3520000 	cmp	r2, #0
 * overwriting of write-once variables.
 */

int env_check_apply(const char *name, const char *oldval,
			const char *newval, int flag)
{
34807a5c:	e1a05001 	mov	r5, r1

	/* Default value for NULL to protect string-manipulating functions */
	newval = newval ? : "";

	/* Check for console redirection */
	if (strcmp(name, "stdin") == 0)
34807a60:	e59f11ac 	ldr	r1, [pc, #428]	; 34807c14 <env_check_apply+0x1c0>
 * overwriting of write-once variables.
 */

int env_check_apply(const char *name, const char *oldval,
			const char *newval, int flag)
{
34807a64:	e1a04000 	mov	r4, r0
34807a68:	e1a07003 	mov	r7, r3
	int   console = -1;

	/* Default value for NULL to protect string-manipulating functions */
	newval = newval ? : "";
34807a6c:	e59f61a4 	ldr	r6, [pc, #420]	; 34807c18 <env_check_apply+0x1c4>
34807a70:	11a06002 	movne	r6, r2

	/* Check for console redirection */
	if (strcmp(name, "stdin") == 0)
34807a74:	eb00440d 	bl	34818ab0 <strcmp>
34807a78:	e3500000 	cmp	r0, #0
34807a7c:	0a00000b 	beq	34807ab0 <env_check_apply+0x5c>
		console = stdin;
	else if (strcmp(name, "stdout") == 0)
34807a80:	e1a00004 	mov	r0, r4
34807a84:	e59f1190 	ldr	r1, [pc, #400]	; 34807c1c <env_check_apply+0x1c8>
34807a88:	eb004408 	bl	34818ab0 <strcmp>
34807a8c:	e3500000 	cmp	r0, #0
		console = stdout;
34807a90:	03a00001 	moveq	r0, #1
	newval = newval ? : "";

	/* Check for console redirection */
	if (strcmp(name, "stdin") == 0)
		console = stdin;
	else if (strcmp(name, "stdout") == 0)
34807a94:	0a000005 	beq	34807ab0 <env_check_apply+0x5c>
		console = stdout;
	else if (strcmp(name, "stderr") == 0)
34807a98:	e1a00004 	mov	r0, r4
34807a9c:	e59f117c 	ldr	r1, [pc, #380]	; 34807c20 <env_check_apply+0x1cc>
34807aa0:	eb004402 	bl	34818ab0 <strcmp>
34807aa4:	e3500000 	cmp	r0, #0
		console = stderr;
34807aa8:	02800002 	addeq	r0, r0, #2
	/* Check for console redirection */
	if (strcmp(name, "stdin") == 0)
		console = stdin;
	else if (strcmp(name, "stdout") == 0)
		console = stdout;
	else if (strcmp(name, "stderr") == 0)
34807aac:	1a00000f 	bne	34807af0 <env_check_apply+0x9c>
		console = stderr;

	if (console != -1) {
		if ((newval == NULL) || (*newval == '\0')) {
34807ab0:	e5d63000 	ldrb	r3, [r6]
34807ab4:	e3530000 	cmp	r3, #0
34807ab8:	1a000004 	bne	34807ad0 <env_check_apply+0x7c>
			/* We cannot delete stdin/stdout/stderr */
			if ((flag & H_FORCE) == 0)
34807abc:	e3170002 	tst	r7, #2
				printf("Can't delete \"%s\"\n", name);
34807ac0:	059f015c 	ldreq	r0, [pc, #348]	; 34807c24 <env_check_apply+0x1d0>
34807ac4:	01a01004 	moveq	r1, r4
		console = stderr;

	if (console != -1) {
		if ((newval == NULL) || (*newval == '\0')) {
			/* We cannot delete stdin/stdout/stderr */
			if ((flag & H_FORCE) == 0)
34807ac8:	1a00004f 	bne	34807c0c <env_check_apply+0x1b8>
34807acc:	ea000025 	b	34807b68 <env_check_apply+0x114>
#ifdef CONFIG_CONSOLE_MUX
		if (iomux_doenv(console, newval))
			return 1;
#else
		/* Try assigning specified device */
		if (console_assign(console, newval) < 0)
34807ad0:	e1a01006 	mov	r1, r6
34807ad4:	eb000570 	bl	3480909c <console_assign>
34807ad8:	e3500000 	cmp	r0, #0
34807adc:	ba00004a 	blt	34807c0c <env_check_apply+0x1b8>
			return 1;

#ifdef CONFIG_SERIAL_MULTI
		if (serial_assign(newval) < 0)
34807ae0:	e1a00006 	mov	r0, r6
34807ae4:	eb0019a2 	bl	3480e174 <serial_assign>
34807ae8:	e3500000 	cmp	r0, #0
34807aec:	ba000046 	blt	34807c0c <env_check_apply+0x1b8>
	/*
	 * When we change baudrate, or we are doing an env default -a
	 * (which will erase all variables prior to calling this),
	 * we want the baudrate to actually change - for real.
	 */
	if (oldval != NULL ||			/* variable exists */
34807af0:	e3550000 	cmp	r5, #0
34807af4:	1a000001 	bne	34807b00 <env_check_apply+0xac>
34807af8:	e3170001 	tst	r7, #1
34807afc:	1a000027 	bne	34807ba0 <env_check_apply+0x14c>
		(flag & H_NOCLEAR) == 0) {	/* or env is clear */
		/*
		 * Switch to new baudrate if new baudrate is supported
		 */
		if (strcmp(name, "baudrate") == 0) {
34807b00:	e59f1120 	ldr	r1, [pc, #288]	; 34807c28 <env_check_apply+0x1d4>
34807b04:	e1a00004 	mov	r0, r4
34807b08:	eb0043e8 	bl	34818ab0 <strcmp>
34807b0c:	e2501000 	subs	r1, r0, #0
34807b10:	1a000022 	bne	34807ba0 <env_check_apply+0x14c>
			int baudrate = simple_strtoul(newval, NULL, 10);
34807b14:	e1a00006 	mov	r0, r6
34807b18:	e3a0200a 	mov	r2, #10
34807b1c:	eb004835 	bl	34819bf8 <simple_strtoul>
			int i;
			for (i = 0; i < N_BAUDRATES; ++i) {
				if (baudrate == baudrate_table[i])
34807b20:	e3500d96 	cmp	r0, #9600	; 0x2580
		(flag & H_NOCLEAR) == 0) {	/* or env is clear */
		/*
		 * Switch to new baudrate if new baudrate is supported
		 */
		if (strcmp(name, "baudrate") == 0) {
			int baudrate = simple_strtoul(newval, NULL, 10);
34807b24:	e1a05000 	mov	r5, r0
			int i;
			for (i = 0; i < N_BAUDRATES; ++i) {
				if (baudrate == baudrate_table[i])
34807b28:	0a000008 	beq	34807b50 <env_check_apply+0xfc>
34807b2c:	e3500c4b 	cmp	r0, #19200	; 0x4b00
34807b30:	0a000006 	beq	34807b50 <env_check_apply+0xfc>
34807b34:	e3500c96 	cmp	r0, #38400	; 0x9600
34807b38:	0a000004 	beq	34807b50 <env_check_apply+0xfc>
34807b3c:	e3500ce1 	cmp	r0, #57600	; 0xe100
34807b40:	0a000002 	beq	34807b50 <env_check_apply+0xfc>
34807b44:	e59f30e0 	ldr	r3, [pc, #224]	; 34807c2c <env_check_apply+0x1d8>
34807b48:	e1500003 	cmp	r0, r3
34807b4c:	1a00002c 	bne	34807c04 <env_check_apply+0x1b0>
				if ((flag & H_FORCE) == 0)
					printf("## Baudrate %d bps not "
						"supported\n", baudrate);
				return 1;
			}
			if (gd->baudrate == baudrate) {
34807b50:	e5983008 	ldr	r3, [r8, #8]
34807b54:	e1530005 	cmp	r3, r5
34807b58:	1a000004 	bne	34807b70 <env_check_apply+0x11c>
34807b5c:	ea000025 	b	34807bf8 <env_check_apply+0x1a4>
				if (baudrate == baudrate_table[i])
					break;
			}
			if (i == N_BAUDRATES) {
				if ((flag & H_FORCE) == 0)
					printf("## Baudrate %d bps not "
34807b60:	e59f00c8 	ldr	r0, [pc, #200]	; 34807c30 <env_check_apply+0x1dc>
34807b64:	e1a01005 	mov	r1, r5
34807b68:	eb0004f7 	bl	34808f4c <printf>
34807b6c:	ea000026 	b	34807c0c <env_check_apply+0x1b8>
			}
			if (gd->baudrate == baudrate) {
				/* If unchanged, we just say it's OK */
				return 0;
			}
			printf("## Switch baudrate to %d bps and"
34807b70:	e1a01005 	mov	r1, r5
34807b74:	e59f00b8 	ldr	r0, [pc, #184]	; 34807c34 <env_check_apply+0x1e0>
34807b78:	eb0004f3 	bl	34808f4c <printf>
				"press ENTER ...\n", baudrate);
			udelay(50000);
34807b7c:	e30c0350 	movw	r0, #50000	; 0xc350
34807b80:	eb00454d 	bl	348190bc <udelay>
			gd->baudrate = baudrate;
34807b84:	e5885008 	str	r5, [r8, #8]
#if defined(CONFIG_PPC) || defined(CONFIG_MCF52x2)
			gd->bd->bi_baudrate = baudrate;
#endif

			serial_setbrg();
34807b88:	eb0019b0 	bl	3480e250 <serial_setbrg>
			udelay(50000);
34807b8c:	e30c0350 	movw	r0, #50000	; 0xc350
34807b90:	eb004549 	bl	348190bc <udelay>
			while (getc() != '\r')
34807b94:	eb0004c6 	bl	34808eb4 <getc>
34807b98:	e350000d 	cmp	r0, #13
34807b9c:	1afffffc 	bne	34807b94 <env_check_apply+0x140>

	/*
	 * Some variables should be updated when the corresponding
	 * entry in the environment is changed
	 */
	if (strcmp(name, "loadaddr") == 0) {
34807ba0:	e1a00004 	mov	r0, r4
34807ba4:	e59f108c 	ldr	r1, [pc, #140]	; 34807c38 <env_check_apply+0x1e4>
34807ba8:	eb0043c0 	bl	34818ab0 <strcmp>
34807bac:	e2505000 	subs	r5, r0, #0
34807bb0:	1a000006 	bne	34807bd0 <env_check_apply+0x17c>
		load_addr = simple_strtoul(newval, NULL, 16);
34807bb4:	e1a00006 	mov	r0, r6
34807bb8:	e1a01005 	mov	r1, r5
34807bbc:	e3a02010 	mov	r2, #16
34807bc0:	eb00480c 	bl	34819bf8 <simple_strtoul>
34807bc4:	e59f3070 	ldr	r3, [pc, #112]	; 34807c3c <env_check_apply+0x1e8>
34807bc8:	e58300c4 	str	r0, [r3, #196]	; 0xc4
		return 0;
34807bcc:	ea00000a 	b	34807bfc <env_check_apply+0x1a8>
	}
#if defined(CONFIG_CMD_NET)
	else if (strcmp(name, "bootfile") == 0) {
34807bd0:	e1a00004 	mov	r0, r4
34807bd4:	e59f1064 	ldr	r1, [pc, #100]	; 34807c40 <env_check_apply+0x1ec>
34807bd8:	eb0043b4 	bl	34818ab0 <strcmp>
34807bdc:	e2505000 	subs	r5, r0, #0
34807be0:	1a000004 	bne	34807bf8 <env_check_apply+0x1a4>
		copy_filename(BootFile, newval, sizeof(BootFile));
34807be4:	e59f0058 	ldr	r0, [pc, #88]	; 34807c44 <env_check_apply+0x1f0>
34807be8:	e1a01006 	mov	r1, r6
34807bec:	e3a02080 	mov	r2, #128	; 0x80
34807bf0:	eb00595a 	bl	3481e160 <copy_filename>
		return 0;
34807bf4:	ea000000 	b	34807bfc <env_check_apply+0x1a8>
	}
#endif
	return 0;
34807bf8:	e3a05000 	mov	r5, #0
}
34807bfc:	e1a00005 	mov	r0, r5
34807c00:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
			for (i = 0; i < N_BAUDRATES; ++i) {
				if (baudrate == baudrate_table[i])
					break;
			}
			if (i == N_BAUDRATES) {
				if ((flag & H_FORCE) == 0)
34807c04:	e3170002 	tst	r7, #2
34807c08:	0affffd4 	beq	34807b60 <env_check_apply+0x10c>
					printf("## Baudrate %d bps not "
						"supported\n", baudrate);
				return 1;
34807c0c:	e3a05001 	mov	r5, #1
34807c10:	eafffff9 	b	34807bfc <env_check_apply+0x1a8>
34807c14:	348256e0 	.word	0x348256e0
34807c18:	34824054 	.word	0x34824054
34807c1c:	348256e6 	.word	0x348256e6
34807c20:	348256ed 	.word	0x348256ed
34807c24:	348256f4 	.word	0x348256f4
34807c28:	34822bbb 	.word	0x34822bbb
34807c2c:	0001c200 	.word	0x0001c200
34807c30:	34825707 	.word	0x34825707
34807c34:	34825729 	.word	0x34825729
34807c38:	34822bcc 	.word	0x34822bcc
34807c3c:	34828300 	.word	0x34828300
34807c40:	3482575a 	.word	0x3482575a
34807c44:	3482d914 	.word	0x3482d914

34807c48 <_do_env_set>:
/*
 * Set a new environment variable,
 * or replace or delete an existing one.
*/
int _do_env_set(int flag, int argc, char * const argv[])
{
34807c48:	e92d46f0 	push	{r4, r5, r6, r7, r9, sl, lr}
	int   i, len;
	char  *name, *value, *s;
	ENTRY e, *ep;

	name = argv[1];
34807c4c:	e5924004 	ldr	r4, [r2, #4]
/*
 * Set a new environment variable,
 * or replace or delete an existing one.
*/
int _do_env_set(int flag, int argc, char * const argv[])
{
34807c50:	e24dd01c 	sub	sp, sp, #28
34807c54:	e1a06001 	mov	r6, r1
	ENTRY e, *ep;

	name = argv[1];
	value = argv[2];

	if (strchr(name, '=')) {
34807c58:	e1a00004 	mov	r0, r4
34807c5c:	e3a0103d 	mov	r1, #61	; 0x3d
/*
 * Set a new environment variable,
 * or replace or delete an existing one.
*/
int _do_env_set(int flag, int argc, char * const argv[])
{
34807c60:	e1a05002 	mov	r5, r2
	int   i, len;
	char  *name, *value, *s;
	ENTRY e, *ep;

	name = argv[1];
34807c64:	e282a004 	add	sl, r2, #4
	value = argv[2];
34807c68:	e5927008 	ldr	r7, [r2, #8]

	if (strchr(name, '=')) {
34807c6c:	eb0043ad 	bl	34818b28 <strchr>
34807c70:	e2502000 	subs	r2, r0, #0
		printf("## Error: illegal character '='"
34807c74:	159f0168 	ldrne	r0, [pc, #360]	; 34807de4 <_do_env_set+0x19c>
34807c78:	11a01004 	movne	r1, r4
	ENTRY e, *ep;

	name = argv[1];
	value = argv[2];

	if (strchr(name, '=')) {
34807c7c:	1a000032 	bne	34807d4c <_do_env_set+0x104>
		printf("## Error: illegal character '='"
		       "in variable name \"%s\"\n", name);
		return 1;
	}

	env_id++;
34807c80:	e59f3160 	ldr	r3, [pc, #352]	; 34807de8 <_do_env_set+0x1a0>
	/*
	 * search if variable with this name already exists
	 */
	e.key = name;
	e.data = NULL;
34807c84:	e58d2010 	str	r2, [sp, #16]
		printf("## Error: illegal character '='"
		       "in variable name \"%s\"\n", name);
		return 1;
	}

	env_id++;
34807c88:	e59310c0 	ldr	r1, [r3, #192]	; 0xc0
	/*
	 * search if variable with this name already exists
	 */
	e.key = name;
34807c8c:	e58d400c 	str	r4, [sp, #12]
		printf("## Error: illegal character '='"
		       "in variable name \"%s\"\n", name);
		return 1;
	}

	env_id++;
34807c90:	e2811001 	add	r1, r1, #1
34807c94:	e58310c0 	str	r1, [r3, #192]	; 0xc0
	/*
	 * search if variable with this name already exists
	 */
	e.key = name;
	e.data = NULL;
	hsearch_r(e, FIND, &ep, &env_htab);
34807c98:	e59f314c 	ldr	r3, [pc, #332]	; 34807dec <_do_env_set+0x1a4>
34807c9c:	e58d3000 	str	r3, [sp]
34807ca0:	e28d300c 	add	r3, sp, #12
34807ca4:	e8930003 	ldm	r3, {r0, r1}
34807ca8:	e28d3014 	add	r3, sp, #20
34807cac:	eb003f27 	bl	34817950 <hsearch_r>

	/*
	 * Perform requested checks. Notice how since we are overwriting
	 * a single variable, we need to set H_NOCLEAR
	 */
	if (env_check_apply(name, ep ? ep->data : NULL, value, H_NOCLEAR)) {
34807cb0:	e59d1014 	ldr	r1, [sp, #20]
34807cb4:	e1a02007 	mov	r2, r7
34807cb8:	e3510000 	cmp	r1, #0
34807cbc:	15911004 	ldrne	r1, [r1, #4]
34807cc0:	e1a00004 	mov	r0, r4
34807cc4:	e3a03001 	mov	r3, #1
34807cc8:	ebffff61 	bl	34807a54 <env_check_apply>
34807ccc:	e2507000 	subs	r7, r0, #0
34807cd0:	1a000040 	bne	34807dd8 <_do_env_set+0x190>
		debug("check function did not approve, refusing\n");
		return 1;
	}

	/* Delete only ? */
	if (argc < 3 || argv[2] == NULL) {
34807cd4:	e3560002 	cmp	r6, #2
34807cd8:	da000004 	ble	34807cf0 <_do_env_set+0xa8>
34807cdc:	e5953008 	ldr	r3, [r5, #8]
34807ce0:	e3530000 	cmp	r3, #0
34807ce4:	11a0900a 	movne	r9, sl
34807ce8:	13a05002 	movne	r5, #2
34807cec:	1a000006 	bne	34807d0c <_do_env_set+0xc4>
		int rc = hdelete_r(name, &env_htab, 0);
34807cf0:	e1a00004 	mov	r0, r4
34807cf4:	e59f10f0 	ldr	r1, [pc, #240]	; 34807dec <_do_env_set+0x1a4>
34807cf8:	e3a02000 	mov	r2, #0
34807cfc:	eb003fcc 	bl	34817c34 <hdelete_r>
		return !rc;
34807d00:	e2700001 	rsbs	r0, r0, #1
34807d04:	33a00000 	movcc	r0, #0
34807d08:	ea000033 	b	34807ddc <_do_env_set+0x194>

	/*
	 * Insert / replace new value
	 */
	for (i = 2, len = 0; i < argc; ++i)
		len += strlen(argv[i]) + 1;
34807d0c:	e5b90004 	ldr	r0, [r9, #4]!
34807d10:	eb00439a 	bl	34818b80 <strlen>
	}

	/*
	 * Insert / replace new value
	 */
	for (i = 2, len = 0; i < argc; ++i)
34807d14:	e2855001 	add	r5, r5, #1
		len += strlen(argv[i]) + 1;
34807d18:	e2800001 	add	r0, r0, #1
	}

	/*
	 * Insert / replace new value
	 */
	for (i = 2, len = 0; i < argc; ++i)
34807d1c:	e1550006 	cmp	r5, r6
		len += strlen(argv[i]) + 1;
34807d20:	e0807007 	add	r7, r0, r7
	}

	/*
	 * Insert / replace new value
	 */
	for (i = 2, len = 0; i < argc; ++i)
34807d24:	bafffff8 	blt	34807d0c <_do_env_set+0xc4>
		len += strlen(argv[i]) + 1;

	value = malloc(len);
34807d28:	e1a00007 	mov	r0, r7
34807d2c:	eb00064d 	bl	34809668 <malloc>
	if (value == NULL) {
34807d30:	e2505000 	subs	r5, r0, #0
34807d34:	11a0c005 	movne	ip, r5
34807d38:	13a01002 	movne	r1, #2
	for (i = 2, s = value; i < argc; ++i) {
		char *v = argv[i];

		while ((*s++ = *v++) != '\0')
			;
		*(s - 1) = ' ';
34807d3c:	13a07020 	movne	r7, #32
	 */
	for (i = 2, len = 0; i < argc; ++i)
		len += strlen(argv[i]) + 1;

	value = malloc(len);
	if (value == NULL) {
34807d40:	1a000003 	bne	34807d54 <_do_env_set+0x10c>
		printf("## Can't malloc %d bytes\n", len);
34807d44:	e59f00a4 	ldr	r0, [pc, #164]	; 34807df0 <_do_env_set+0x1a8>
34807d48:	e1a01007 	mov	r1, r7
34807d4c:	eb00047e 	bl	34808f4c <printf>
34807d50:	ea000020 	b	34807dd8 <_do_env_set+0x190>
		return 1;
34807d54:	e5bae004 	ldr	lr, [sl, #4]!
34807d58:	e1a0300c 	mov	r3, ip
	}
	for (i = 2, s = value; i < argc; ++i) {
		char *v = argv[i];

		while ((*s++ = *v++) != '\0')
34807d5c:	e4de2001 	ldrb	r2, [lr], #1
34807d60:	e1a00003 	mov	r0, r3
34807d64:	e3520000 	cmp	r2, #0
34807d68:	e4c32001 	strb	r2, [r3], #1
34807d6c:	e1a0c003 	mov	ip, r3
34807d70:	1afffff9 	bne	34807d5c <_do_env_set+0x114>
	value = malloc(len);
	if (value == NULL) {
		printf("## Can't malloc %d bytes\n", len);
		return 1;
	}
	for (i = 2, s = value; i < argc; ++i) {
34807d74:	e2811001 	add	r1, r1, #1
34807d78:	e1510006 	cmp	r1, r6
		char *v = argv[i];

		while ((*s++ = *v++) != '\0')
			;
		*(s - 1) = ' ';
34807d7c:	e5c07000 	strb	r7, [r0]
	value = malloc(len);
	if (value == NULL) {
		printf("## Can't malloc %d bytes\n", len);
		return 1;
	}
	for (i = 2, s = value; i < argc; ++i) {
34807d80:	1afffff3 	bne	34807d54 <_do_env_set+0x10c>

		while ((*s++ = *v++) != '\0')
			;
		*(s - 1) = ' ';
	}
	if (s != value)
34807d84:	e1530005 	cmp	r3, r5
		*--s = '\0';

	e.key	= name;
	e.data	= value;
	hsearch_r(e, ENTER, &ep, &env_htab);
34807d88:	e59f305c 	ldr	r3, [pc, #92]	; 34807dec <_do_env_set+0x1a4>
		while ((*s++ = *v++) != '\0')
			;
		*(s - 1) = ' ';
	}
	if (s != value)
		*--s = '\0';
34807d8c:	15c02000 	strbne	r2, [r0]

	e.key	= name;
	e.data	= value;
	hsearch_r(e, ENTER, &ep, &env_htab);
34807d90:	e58d3000 	str	r3, [sp]
	}
	if (s != value)
		*--s = '\0';

	e.key	= name;
	e.data	= value;
34807d94:	e58d5010 	str	r5, [sp, #16]
	hsearch_r(e, ENTER, &ep, &env_htab);
34807d98:	e28d300c 	add	r3, sp, #12
34807d9c:	e8930003 	ldm	r3, {r0, r1}
34807da0:	e3a02001 	mov	r2, #1
34807da4:	e28d3014 	add	r3, sp, #20
34807da8:	eb003ee8 	bl	34817950 <hsearch_r>
	free(value);
34807dac:	e1a00005 	mov	r0, r5
34807db0:	eb0005a3 	bl	34809444 <free>
	if (!ep) {
34807db4:	e59d3014 	ldr	r3, [sp, #20]
34807db8:	e3530000 	cmp	r3, #0
		printf("## Error inserting \"%s\" variable, errno=%d\n",
			name, errno);
		return 1;
	}

	return 0;
34807dbc:	13a00000 	movne	r0, #0

	e.key	= name;
	e.data	= value;
	hsearch_r(e, ENTER, &ep, &env_htab);
	free(value);
	if (!ep) {
34807dc0:	1a000005 	bne	34807ddc <_do_env_set+0x194>
		printf("## Error inserting \"%s\" variable, errno=%d\n",
34807dc4:	e59f3028 	ldr	r3, [pc, #40]	; 34807df4 <_do_env_set+0x1ac>
34807dc8:	e59f0028 	ldr	r0, [pc, #40]	; 34807df8 <_do_env_set+0x1b0>
34807dcc:	e1a01004 	mov	r1, r4
34807dd0:	e5932000 	ldr	r2, [r3]
34807dd4:	eb00045c 	bl	34808f4c <printf>
	 * Perform requested checks. Notice how since we are overwriting
	 * a single variable, we need to set H_NOCLEAR
	 */
	if (env_check_apply(name, ep ? ep->data : NULL, value, H_NOCLEAR)) {
		debug("check function did not approve, refusing\n");
		return 1;
34807dd8:	e3a00001 	mov	r0, #1
			name, errno);
		return 1;
	}

	return 0;
}
34807ddc:	e28dd01c 	add	sp, sp, #28
34807de0:	e8bd86f0 	pop	{r4, r5, r6, r7, r9, sl, pc}
34807de4:	34825763 	.word	0x34825763
34807de8:	34828300 	.word	0x34828300
34807dec:	348287dc 	.word	0x348287dc
34807df0:	34825799 	.word	0x34825799
34807df4:	3482b338 	.word	0x3482b338
34807df8:	348257b3 	.word	0x348257b3

34807dfc <do_env_set>:
}

#ifndef CONFIG_SPL_BUILD
int do_env_set(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	if (argc < 2)
34807dfc:	e3520001 	cmp	r2, #1
34807e00:	da000003 	ble	34807e14 <do_env_set+0x18>
		return CMD_RET_USAGE;

	return _do_env_set(flag, argc, argv);
34807e04:	e1a00001 	mov	r0, r1
34807e08:	e1a01002 	mov	r1, r2
34807e0c:	e1a02003 	mov	r2, r3
34807e10:	eaffff8c 	b	34807c48 <_do_env_set>
}
34807e14:	e3e00000 	mvn	r0, #0
34807e18:	e12fff1e 	bx	lr

34807e1c <setenv>:

	return 0;
}

int setenv(const char *varname, const char *varvalue)
{
34807e1c:	e92d401f 	push	{r0, r1, r2, r3, r4, lr}
	const char * const argv[4] = { "setenv", varname, varvalue, NULL };
34807e20:	e59f3040 	ldr	r3, [pc, #64]	; 34807e68 <setenv+0x4c>
34807e24:	e58d0004 	str	r0, [sp, #4]
34807e28:	e3a00000 	mov	r0, #0

	if (varvalue == NULL || varvalue[0] == '\0')
34807e2c:	e1510000 	cmp	r1, r0
	return 0;
}

int setenv(const char *varname, const char *varvalue)
{
	const char * const argv[4] = { "setenv", varname, varvalue, NULL };
34807e30:	e58d3000 	str	r3, [sp]
34807e34:	e58d1008 	str	r1, [sp, #8]
34807e38:	e58d000c 	str	r0, [sp, #12]

	if (varvalue == NULL || varvalue[0] == '\0')
34807e3c:	0a000003 	beq	34807e50 <setenv+0x34>
34807e40:	e5d13000 	ldrb	r3, [r1]
34807e44:	e1530000 	cmp	r3, r0
		return _do_env_set(0, 2, (char * const *)argv);
	else
		return _do_env_set(0, 3, (char * const *)argv);
34807e48:	13a01003 	movne	r1, #3

int setenv(const char *varname, const char *varvalue)
{
	const char * const argv[4] = { "setenv", varname, varvalue, NULL };

	if (varvalue == NULL || varvalue[0] == '\0')
34807e4c:	1a000001 	bne	34807e58 <setenv+0x3c>
		return _do_env_set(0, 2, (char * const *)argv);
34807e50:	e3a00000 	mov	r0, #0
34807e54:	e3a01002 	mov	r1, #2
	else
		return _do_env_set(0, 3, (char * const *)argv);
34807e58:	e1a0200d 	mov	r2, sp
34807e5c:	ebffff79 	bl	34807c48 <_do_env_set>
}
34807e60:	e28dd014 	add	sp, sp, #20
34807e64:	e8bd8000 	pop	{pc}
34807e68:	348257df 	.word	0x348257df

34807e6c <do_env_export>:
 *
 *	=> env import -d -t ${backup_addr}
 */
static int do_env_export(cmd_tbl_t *cmdtp, int flag,
			 int argc, char * const argv[])
{
34807e6c:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	size_t	size = 0;
	ssize_t	len;
	env_t	*envp;
	char	sep = '\n';
	int	chk = 0;
	int	fmt = 0;
34807e70:	e3a0a000 	mov	sl, #0
 *
 *	=> env import -d -t ${backup_addr}
 */
static int do_env_export(cmd_tbl_t *cmdtp, int flag,
			 int argc, char * const argv[])
{
34807e74:	e24dd038 	sub	sp, sp, #56	; 0x38
34807e78:	e1a0c000 	mov	ip, r0
34807e7c:	e1a04002 	mov	r4, r2
34807e80:	e1a05003 	mov	r5, r3
	env_t	*envp;
	char	sep = '\n';
	int	chk = 0;
	int	fmt = 0;

	cmd = *argv;
34807e84:	e593b000 	ldr	fp, [r3]
	char	*addr, *cmd, *res;
	size_t	size = 0;
	ssize_t	len;
	env_t	*envp;
	char	sep = '\n';
	int	chk = 0;
34807e88:	e1a0900a 	mov	r9, sl
	char	buf[32];
	char	*addr, *cmd, *res;
	size_t	size = 0;
	ssize_t	len;
	env_t	*envp;
	char	sep = '\n';
34807e8c:	e3a0600a 	mov	r6, #10
static int do_env_export(cmd_tbl_t *cmdtp, int flag,
			 int argc, char * const argv[])
{
	char	buf[32];
	char	*addr, *cmd, *res;
	size_t	size = 0;
34807e90:	e1a0700a 	mov	r7, sl
	int	chk = 0;
	int	fmt = 0;

	cmd = *argv;

	while (--argc > 0 && **++argv == '-') {
34807e94:	ea000027 	b	34807f38 <do_env_export+0xcc>
		char *arg = *argv;
		while (*++arg) {
			switch (*arg) {
34807e98:	e3520063 	cmp	r2, #99	; 0x63
34807e9c:	0a00000b 	beq	34807ed0 <do_env_export+0x64>
34807ea0:	8a000002 	bhi	34807eb0 <do_env_export+0x44>
34807ea4:	e3520062 	cmp	r2, #98	; 0x62
34807ea8:	1a000072 	bne	34808078 <do_env_export+0x20c>
34807eac:	ea000004 	b	34807ec4 <do_env_export+0x58>
34807eb0:	e3520073 	cmp	r2, #115	; 0x73
34807eb4:	0a00000a 	beq	34807ee4 <do_env_export+0x78>
34807eb8:	e3520074 	cmp	r2, #116	; 0x74
34807ebc:	1a00006d 	bne	34808078 <do_env_export+0x20c>
34807ec0:	ea000014 	b	34807f18 <do_env_export+0xac>
			case 'b':		/* raw binary format */
				if (fmt++)
34807ec4:	e3530000 	cmp	r3, #0
34807ec8:	0a000003 	beq	34807edc <do_env_export+0x70>
34807ecc:	ea000064 	b	34808064 <do_env_export+0x1f8>
					goto sep_err;
				sep = '\0';
				break;
			case 'c':		/* external checksum format */
				if (fmt++)
34807ed0:	e3530000 	cmp	r3, #0
34807ed4:	1a000062 	bne	34808064 <do_env_export+0x1f8>
					goto sep_err;
				sep = '\0';
				chk = 1;
34807ed8:	e3a09001 	mov	r9, #1
				sep = '\0';
				break;
			case 'c':		/* external checksum format */
				if (fmt++)
					goto sep_err;
				sep = '\0';
34807edc:	e1a06003 	mov	r6, r3
34807ee0:	ea00000f 	b	34807f24 <do_env_export+0xb8>
				chk = 1;
				break;
			case 's':		/* size given */
				if (--argc <= 0)
34807ee4:	e2544001 	subs	r4, r4, #1
34807ee8:	1a000002 	bne	34807ef8 <do_env_export+0x8c>
					return cmd_usage(cmdtp);
34807eec:	e1a0000c 	mov	r0, ip
34807ef0:	eb0002be 	bl	348089f0 <cmd_usage>
34807ef4:	ea000060 	b	3480807c <do_env_export+0x210>
				size = simple_strtoul(*++argv, NULL, 16);
34807ef8:	e5b50004 	ldr	r0, [r5, #4]!
34807efc:	e3a01000 	mov	r1, #0
34807f00:	e3a02010 	mov	r2, #16
34807f04:	e58dc00c 	str	ip, [sp, #12]
34807f08:	eb00473a 	bl	34819bf8 <simple_strtoul>
				goto NXTARG;
34807f0c:	e59dc00c 	ldr	ip, [sp, #12]
				chk = 1;
				break;
			case 's':		/* size given */
				if (--argc <= 0)
					return cmd_usage(cmdtp);
				size = simple_strtoul(*++argv, NULL, 16);
34807f10:	e1a07000 	mov	r7, r0
				goto NXTARG;
34807f14:	ea000007 	b	34807f38 <do_env_export+0xcc>
			case 't':		/* text format */
				if (fmt++)
34807f18:	e3530000 	cmp	r3, #0
34807f1c:	1a000050 	bne	34808064 <do_env_export+0x1f8>
					goto sep_err;
				sep = '\n';
34807f20:	e3a0600a 	mov	r6, #10
				if (--argc <= 0)
					return cmd_usage(cmdtp);
				size = simple_strtoul(*++argv, NULL, 16);
				goto NXTARG;
			case 't':		/* text format */
				if (fmt++)
34807f24:	e3a03001 	mov	r3, #1

	cmd = *argv;

	while (--argc > 0 && **++argv == '-') {
		char *arg = *argv;
		while (*++arg) {
34807f28:	e5f02001 	ldrb	r2, [r0, #1]!
				if (--argc <= 0)
					return cmd_usage(cmdtp);
				size = simple_strtoul(*++argv, NULL, 16);
				goto NXTARG;
			case 't':		/* text format */
				if (fmt++)
34807f2c:	e1a0a003 	mov	sl, r3

	cmd = *argv;

	while (--argc > 0 && **++argv == '-') {
		char *arg = *argv;
		while (*++arg) {
34807f30:	e3520000 	cmp	r2, #0
34807f34:	1affffd7 	bne	34807e98 <do_env_export+0x2c>
	int	chk = 0;
	int	fmt = 0;

	cmd = *argv;

	while (--argc > 0 && **++argv == '-') {
34807f38:	e2444001 	sub	r4, r4, #1
34807f3c:	e3540000 	cmp	r4, #0
34807f40:	da00004c 	ble	34808078 <do_env_export+0x20c>
34807f44:	e5b50004 	ldr	r0, [r5, #4]!
34807f48:	e5d03000 	ldrb	r3, [r0]
34807f4c:	e353002d 	cmp	r3, #45	; 0x2d
34807f50:	1a00004b 	bne	34808084 <do_env_export+0x218>
34807f54:	e1a0300a 	mov	r3, sl
34807f58:	eafffff2 	b	34807f28 <do_env_export+0xbc>
		return CMD_RET_USAGE;

	addr = (char *)simple_strtoul(argv[0], NULL, 16);

	if (size)
		memset(addr, '\0', size);
34807f5c:	e3a01000 	mov	r1, #0
34807f60:	e1a02007 	mov	r2, r7
34807f64:	eb0043a5 	bl	34818e00 <memset>

	argc--;
	argv++;

	if (sep) {		/* export as text file */
34807f68:	e3560000 	cmp	r6, #0
	addr = (char *)simple_strtoul(argv[0], NULL, 16);

	if (size)
		memset(addr, '\0', size);

	argc--;
34807f6c:	e2444001 	sub	r4, r4, #1
	argv++;
34807f70:	e2855004 	add	r5, r5, #4

	if (sep) {		/* export as text file */
34807f74:	0a000013 	beq	34807fc8 <do_env_export+0x15c>
		len = hexport_r(&env_htab, sep, &addr, size, argc, argv);
34807f78:	e28d2034 	add	r2, sp, #52	; 0x34
34807f7c:	e59f011c 	ldr	r0, [pc, #284]	; 348080a0 <do_env_export+0x234>
34807f80:	e1a01006 	mov	r1, r6
34807f84:	e1a03007 	mov	r3, r7
34807f88:	e88d0030 	stm	sp, {r4, r5}
34807f8c:	eb003f55 	bl	34817ce8 <hexport_r>
		if (len < 0) {
34807f90:	e2502000 	subs	r2, r0, #0
34807f94:	aa000007 	bge	34807fb8 <do_env_export+0x14c>
			error("Cannot export environment: errno = %d\n", errno);
34807f98:	e59f3104 	ldr	r3, [pc, #260]	; 348080a4 <do_env_export+0x238>
34807f9c:	e59f0104 	ldr	r0, [pc, #260]	; 348080a8 <do_env_export+0x23c>
34807fa0:	e58d3000 	str	r3, [sp]
34807fa4:	e59f3100 	ldr	r3, [pc, #256]	; 348080ac <do_env_export+0x240>
34807fa8:	e59f2100 	ldr	r2, [pc, #256]	; 348080b0 <do_env_export+0x244>
34807fac:	e5931000 	ldr	r1, [r3]
34807fb0:	e3003333 	movw	r3, #819	; 0x333
34807fb4:	ea000017 	b	34808018 <do_env_export+0x1ac>
			return 1;
		}
		sprintf(buf, "%zX", (size_t)len);
34807fb8:	e28d4010 	add	r4, sp, #16
34807fbc:	e1a00004 	mov	r0, r4
34807fc0:	e59f10ec 	ldr	r1, [pc, #236]	; 348080b4 <do_env_export+0x248>
34807fc4:	ea000020 	b	3480804c <do_env_export+0x1e0>
		setenv("filesize", buf);

		return 0;
	}

	envp = (env_t *)addr;
34807fc8:	e59d6034 	ldr	r6, [sp, #52]	; 0x34

	if (chk)		/* export as checksum protected block */
34807fcc:	e3590000 	cmp	r9, #0
		res = (char *)envp->data;
34807fd0:	12863004 	addne	r3, r6, #4
34807fd4:	158d3030 	strne	r3, [sp, #48]	; 0x30
	else			/* export as raw binary data */
		res = addr;

	len = hexport_r(&env_htab, '\0', &res, ENV_SIZE, argc, argv);
34807fd8:	e59f00c0 	ldr	r0, [pc, #192]	; 348080a0 <do_env_export+0x234>
34807fdc:	e3a01000 	mov	r1, #0
34807fe0:	e28d2030 	add	r2, sp, #48	; 0x30
34807fe4:	e59f30cc 	ldr	r3, [pc, #204]	; 348080b8 <do_env_export+0x24c>
	envp = (env_t *)addr;

	if (chk)		/* export as checksum protected block */
		res = (char *)envp->data;
	else			/* export as raw binary data */
		res = addr;
34807fe8:	058d6030 	streq	r6, [sp, #48]	; 0x30

	len = hexport_r(&env_htab, '\0', &res, ENV_SIZE, argc, argv);
34807fec:	e88d0030 	stm	sp, {r4, r5}
34807ff0:	eb003f3c 	bl	34817ce8 <hexport_r>
	if (len < 0) {
34807ff4:	e2505000 	subs	r5, r0, #0
34807ff8:	aa000008 	bge	34808020 <do_env_export+0x1b4>
		error("Cannot export environment: errno = %d\n", errno);
34807ffc:	e59f30a0 	ldr	r3, [pc, #160]	; 348080a4 <do_env_export+0x238>
34808000:	e59f00a0 	ldr	r0, [pc, #160]	; 348080a8 <do_env_export+0x23c>
34808004:	e58d3000 	str	r3, [sp]
34808008:	e59f309c 	ldr	r3, [pc, #156]	; 348080ac <do_env_export+0x240>
3480800c:	e59f209c 	ldr	r2, [pc, #156]	; 348080b0 <do_env_export+0x244>
34808010:	e5931000 	ldr	r1, [r3]
34808014:	e3003345 	movw	r3, #837	; 0x345
34808018:	eb0003cb 	bl	34808f4c <printf>
3480801c:	ea000013 	b	34808070 <do_env_export+0x204>
		return 1;
	}

	if (chk) {
34808020:	e3590000 	cmp	r9, #0
34808024:	0a000004 	beq	3480803c <do_env_export+0x1d0>
		envp->crc = crc32(0, envp->data, ENV_SIZE);
34808028:	e3a00000 	mov	r0, #0
3480802c:	e2861004 	add	r1, r6, #4
34808030:	e59f2080 	ldr	r2, [pc, #128]	; 348080b8 <do_env_export+0x24c>
34808034:	eb003c13 	bl	34817088 <crc32>
34808038:	e5860000 	str	r0, [r6]
#ifdef CONFIG_ENV_ADDR_REDUND
		envp->flags = ACTIVE_FLAG;
#endif
	}
	sprintf(buf, "%zX", (size_t)(len + offsetof(env_t, data)));
3480803c:	e28d4010 	add	r4, sp, #16
34808040:	e59f106c 	ldr	r1, [pc, #108]	; 348080b4 <do_env_export+0x248>
34808044:	e1a00004 	mov	r0, r4
34808048:	e2852004 	add	r2, r5, #4
3480804c:	eb00478f 	bl	34819e90 <sprintf>
	setenv("filesize", buf);
34808050:	e59f0064 	ldr	r0, [pc, #100]	; 348080bc <do_env_export+0x250>
34808054:	e1a01004 	mov	r1, r4
34808058:	ebffff6f 	bl	34807e1c <setenv>

	return 0;
3480805c:	e3a00000 	mov	r0, #0
34808060:	ea000005 	b	3480807c <do_env_export+0x210>

sep_err:
	printf("## %s: only one of \"-b\", \"-c\" or \"-t\" allowed\n",	cmd);
34808064:	e59f0054 	ldr	r0, [pc, #84]	; 348080c0 <do_env_export+0x254>
34808068:	e1a0100b 	mov	r1, fp
3480806c:	eb0003b6 	bl	34808f4c <printf>
	return 1;
34808070:	e3a00001 	mov	r0, #1
34808074:	ea000000 	b	3480807c <do_env_export+0x210>
		}
NXTARG:		;
	}

	if (argc < 1)
		return CMD_RET_USAGE;
34808078:	e3e00000 	mvn	r0, #0
	return 0;

sep_err:
	printf("## %s: only one of \"-b\", \"-c\" or \"-t\" allowed\n",	cmd);
	return 1;
}
3480807c:	e28dd038 	add	sp, sp, #56	; 0x38
34808080:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
	}

	if (argc < 1)
		return CMD_RET_USAGE;

	addr = (char *)simple_strtoul(argv[0], NULL, 16);
34808084:	e3a01000 	mov	r1, #0
34808088:	e3a02010 	mov	r2, #16
3480808c:	eb0046d9 	bl	34819bf8 <simple_strtoul>

	if (size)
34808090:	e3570000 	cmp	r7, #0
	}

	if (argc < 1)
		return CMD_RET_USAGE;

	addr = (char *)simple_strtoul(argv[0], NULL, 16);
34808094:	e58d0034 	str	r0, [sp, #52]	; 0x34

	if (size)
34808098:	0affffb2 	beq	34807f68 <do_env_export+0xfc>
3480809c:	eaffffae 	b	34807f5c <do_env_export+0xf0>
348080a0:	348287dc 	.word	0x348287dc
348080a4:	3482052c 	.word	0x3482052c
348080a8:	348257e6 	.word	0x348257e6
348080ac:	3482b338 	.word	0x3482b338
348080b0:	3482563b 	.word	0x3482563b
348080b4:	34825823 	.word	0x34825823
348080b8:	0003fffc 	.word	0x0003fffc
348080bc:	34823512 	.word	0x34823512
348080c0:	34825648 	.word	0x34825648

348080c4 <setenv_ulong>:
 * @param varname	Environmet variable to set
 * @param value		Value to set it to
 * @return 0 if ok, 1 on error
 */
int setenv_ulong(const char *varname, ulong value)
{
348080c4:	e92d4010 	push	{r4, lr}
348080c8:	e1a04000 	mov	r4, r0
	/* TODO: this should be unsigned */
	char *str = simple_itoa(value);
348080cc:	e1a00001 	mov	r0, r1
348080d0:	eb00478d 	bl	34819f0c <simple_itoa>
348080d4:	e1a01000 	mov	r1, r0

	return setenv(varname, str);
348080d8:	e1a00004 	mov	r0, r4
}
348080dc:	e8bd4010 	pop	{r4, lr}
int setenv_ulong(const char *varname, ulong value)
{
	/* TODO: this should be unsigned */
	char *str = simple_itoa(value);

	return setenv(varname, str);
348080e0:	eaffff4d 	b	34807e1c <setenv>

348080e4 <setenv_addr>:
 * @param varname	Environmet variable to set
 * @param addr		Value to set it to
 * @return 0 if ok, 1 on error
 */
int setenv_addr(const char *varname, const void *addr)
{
348080e4:	e92d4030 	push	{r4, r5, lr}
348080e8:	e24dd01c 	sub	sp, sp, #28
	char str[17];

	sprintf(str, "%lx", (uintptr_t)addr);
348080ec:	e28d4004 	add	r4, sp, #4
 * @param varname	Environmet variable to set
 * @param addr		Value to set it to
 * @return 0 if ok, 1 on error
 */
int setenv_addr(const char *varname, const void *addr)
{
348080f0:	e1a05000 	mov	r5, r0
348080f4:	e1a02001 	mov	r2, r1
	char str[17];

	sprintf(str, "%lx", (uintptr_t)addr);
348080f8:	e1a00004 	mov	r0, r4
348080fc:	e59f1014 	ldr	r1, [pc, #20]	; 34808118 <setenv_addr+0x34>
34808100:	eb004762 	bl	34819e90 <sprintf>
	return setenv(varname, str);
34808104:	e1a00005 	mov	r0, r5
34808108:	e1a01004 	mov	r1, r4
3480810c:	ebffff42 	bl	34807e1c <setenv>
}
34808110:	e28dd01c 	add	sp, sp, #28
34808114:	e8bd8030 	pop	{r4, r5, pc}
34808118:	34823405 	.word	0x34823405

3480811c <envmatch>:
 * s1 is either a simple 'name', or a 'name=value' pair.
 * i2 is the environment index for a 'name2=value2' pair.
 * If the names match, return the index for the value2, else -1.
 */
int envmatch(uchar *s1, int i2)
{
3480811c:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
34808120:	e1a05001 	mov	r5, r1
			return i2;

	if (*s1 == '\0' && env_get_char(i2-1) == '=')
		return i2;

	return -1;
34808124:	e1a06000 	mov	r6, r0
 * i2 is the environment index for a 'name2=value2' pair.
 * If the names match, return the index for the value2, else -1.
 */
int envmatch(uchar *s1, int i2)
{
	while (*s1 == env_get_char(i2++))
34808128:	ea000003 	b	3480813c <envmatch+0x20>
		if (*s1++ == '=')
3480812c:	e5563001 	ldrb	r3, [r6, #-1]
34808130:	e353003d 	cmp	r3, #61	; 0x3d
34808134:	0a00000f 	beq	34808178 <envmatch+0x5c>
 * i2 is the environment index for a 'name2=value2' pair.
 * If the names match, return the index for the value2, else -1.
 */
int envmatch(uchar *s1, int i2)
{
	while (*s1 == env_get_char(i2++))
34808138:	e1a05004 	mov	r5, r4
3480813c:	e1a00005 	mov	r0, r5
		if (*s1++ == '=')
34808140:	e1a07006 	mov	r7, r6
 * i2 is the environment index for a 'name2=value2' pair.
 * If the names match, return the index for the value2, else -1.
 */
int envmatch(uchar *s1, int i2)
{
	while (*s1 == env_get_char(i2++))
34808144:	e4d6a001 	ldrb	sl, [r6], #1
34808148:	eb000889 	bl	3480a374 <env_get_char>
3480814c:	e15a0000 	cmp	sl, r0
34808150:	e2854001 	add	r4, r5, #1
34808154:	0afffff4 	beq	3480812c <envmatch+0x10>
		if (*s1++ == '=')
			return i2;

	if (*s1 == '\0' && env_get_char(i2-1) == '=')
34808158:	e5d73000 	ldrb	r3, [r7]
3480815c:	e3530000 	cmp	r3, #0
		return i2;

	return -1;
34808160:	13e04000 	mvnne	r4, #0
{
	while (*s1 == env_get_char(i2++))
		if (*s1++ == '=')
			return i2;

	if (*s1 == '\0' && env_get_char(i2-1) == '=')
34808164:	1a000003 	bne	34808178 <envmatch+0x5c>
34808168:	e1a00005 	mov	r0, r5
3480816c:	eb000880 	bl	3480a374 <env_get_char>
		return i2;

	return -1;
34808170:	e350003d 	cmp	r0, #61	; 0x3d
34808174:	13e04000 	mvnne	r4, #0
}
34808178:	e1a00004 	mov	r0, r4
3480817c:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}

34808180 <getenv_f>:

/*
 * Look up variable from environment for restricted C runtime env.
 */
int getenv_f(const char *name, char *buf, unsigned len)
{
34808180:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
34808184:	e1a05000 	mov	r5, r0
34808188:	e1a06001 	mov	r6, r1
3480818c:	e1a0a002 	mov	sl, r2
	int i, nxt;

	for (i = 0; env_get_char(i) != '\0'; i = nxt + 1) {
34808190:	e3a0b000 	mov	fp, #0
		int val, n;

		for (nxt = i; env_get_char(nxt) != '\0'; ++nxt) {
			if (nxt >= CONFIG_ENV_SIZE)
34808194:	e59f9098 	ldr	r9, [pc, #152]	; 34808234 <getenv_f+0xb4>
 */
int getenv_f(const char *name, char *buf, unsigned len)
{
	int i, nxt;

	for (i = 0; env_get_char(i) != '\0'; i = nxt + 1) {
34808198:	ea00001d 	b	34808214 <getenv_f+0x94>
		int val, n;

		for (nxt = i; env_get_char(nxt) != '\0'; ++nxt) {
			if (nxt >= CONFIG_ENV_SIZE)
3480819c:	e1570009 	cmp	r7, r9
348081a0:	ca000020 	bgt	34808228 <getenv_f+0xa8>
	int i, nxt;

	for (i = 0; env_get_char(i) != '\0'; i = nxt + 1) {
		int val, n;

		for (nxt = i; env_get_char(nxt) != '\0'; ++nxt) {
348081a4:	e2877001 	add	r7, r7, #1
348081a8:	e1a00007 	mov	r0, r7
348081ac:	eb000870 	bl	3480a374 <env_get_char>
348081b0:	e2504000 	subs	r4, r0, #0
348081b4:	1afffff8 	bne	3480819c <getenv_f+0x1c>
			if (nxt >= CONFIG_ENV_SIZE)
				return -1;
		}

		val = envmatch((uchar *)name, i);
348081b8:	e1a0100b 	mov	r1, fp
348081bc:	e1a00005 	mov	r0, r5
348081c0:	ebffffd5 	bl	3480811c <envmatch>
		if (val < 0)
348081c4:	e250b000 	subs	fp, r0, #0
348081c8:	aa000006 	bge	348081e8 <getenv_f+0x68>
 */
int getenv_f(const char *name, char *buf, unsigned len)
{
	int i, nxt;

	for (i = 0; env_get_char(i) != '\0'; i = nxt + 1) {
348081cc:	e287b001 	add	fp, r7, #1
348081d0:	ea00000f 	b	34808214 <getenv_f+0x94>
		if (val < 0)
			continue;

		/* found; copy out */
		for (n = 0; n < len; ++n, ++buf) {
			*buf = env_get_char(val++);
348081d4:	eb000866 	bl	3480a374 <env_get_char>
			if (*buf == '\0')
348081d8:	e3500000 	cmp	r0, #0
		if (val < 0)
			continue;

		/* found; copy out */
		for (n = 0; n < len; ++n, ++buf) {
			*buf = env_get_char(val++);
348081dc:	e4c60001 	strb	r0, [r6], #1
			if (*buf == '\0')
348081e0:	0a000011 	beq	3480822c <getenv_f+0xac>
		val = envmatch((uchar *)name, i);
		if (val < 0)
			continue;

		/* found; copy out */
		for (n = 0; n < len; ++n, ++buf) {
348081e4:	e2844001 	add	r4, r4, #1
348081e8:	e154000a 	cmp	r4, sl
}

/*
 * Look up variable from environment for restricted C runtime env.
 */
int getenv_f(const char *name, char *buf, unsigned len)
348081ec:	e084000b 	add	r0, r4, fp
		val = envmatch((uchar *)name, i);
		if (val < 0)
			continue;

		/* found; copy out */
		for (n = 0; n < len; ++n, ++buf) {
348081f0:	3afffff7 	bcc	348081d4 <getenv_f+0x54>
			*buf = env_get_char(val++);
			if (*buf == '\0')
				return n;
		}

		if (n)
348081f4:	e3540000 	cmp	r4, #0
			*--buf = '\0';
348081f8:	13a03000 	movne	r3, #0
348081fc:	15463001 	strbne	r3, [r6, #-1]

		printf("env_buf [%d bytes] too small for value of \"%s\"\n",
34808200:	e1a0100a 	mov	r1, sl
34808204:	e1a02005 	mov	r2, r5
34808208:	e59f0028 	ldr	r0, [pc, #40]	; 34808238 <getenv_f+0xb8>
3480820c:	eb00034e 	bl	34808f4c <printf>
			len, name);

		return n;
34808210:	ea000005 	b	3480822c <getenv_f+0xac>
 */
int getenv_f(const char *name, char *buf, unsigned len)
{
	int i, nxt;

	for (i = 0; env_get_char(i) != '\0'; i = nxt + 1) {
34808214:	e1a0000b 	mov	r0, fp
34808218:	eb000855 	bl	3480a374 <env_get_char>
3480821c:	e3500000 	cmp	r0, #0
34808220:	11a0700b 	movne	r7, fp
34808224:	1affffdf 	bne	348081a8 <getenv_f+0x28>
			len, name);

		return n;
	}

	return -1;
34808228:	e3e04000 	mvn	r4, #0
}
3480822c:	e1a00004 	mov	r0, r4
34808230:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
34808234:	0003ffff 	.word	0x0003ffff
34808238:	34825827 	.word	0x34825827

3480823c <getenv>:
 * Look up variable from environment,
 * return address of storage for that variable,
 * or NULL if not found
 */
char *getenv(const char *name)
{
3480823c:	e92d4010 	push	{r4, lr}
	if (gd->flags & GD_FLG_ENV_READY) { /* after import into hashtable */
34808240:	e5984004 	ldr	r4, [r8, #4]
 * Look up variable from environment,
 * return address of storage for that variable,
 * or NULL if not found
 */
char *getenv(const char *name)
{
34808244:	e24dd018 	sub	sp, sp, #24
	if (gd->flags & GD_FLG_ENV_READY) { /* after import into hashtable */
34808248:	e2144080 	ands	r4, r4, #128	; 0x80
3480824c:	0a00000c 	beq	34808284 <getenv+0x48>

		WATCHDOG_RESET();

		e.key	= name;
		e.data	= NULL;
		hsearch_r(e, FIND, &ep, &env_htab);
34808250:	e59f304c 	ldr	r3, [pc, #76]	; 348082a4 <getenv+0x68>
		ENTRY e, *ep;

		WATCHDOG_RESET();

		e.key	= name;
		e.data	= NULL;
34808254:	e3a02000 	mov	r2, #0
		hsearch_r(e, FIND, &ep, &env_htab);
34808258:	e58d3000 	str	r3, [sp]
	if (gd->flags & GD_FLG_ENV_READY) { /* after import into hashtable */
		ENTRY e, *ep;

		WATCHDOG_RESET();

		e.key	= name;
3480825c:	e58d000c 	str	r0, [sp, #12]
		e.data	= NULL;
34808260:	e58d2010 	str	r2, [sp, #16]
		hsearch_r(e, FIND, &ep, &env_htab);
34808264:	e28d300c 	add	r3, sp, #12
34808268:	e8930003 	ldm	r3, {r0, r1}
3480826c:	e28d3014 	add	r3, sp, #20
34808270:	eb003db6 	bl	34817950 <hsearch_r>

		return ep ? ep->data : NULL;
34808274:	e59d0014 	ldr	r0, [sp, #20]
34808278:	e3500000 	cmp	r0, #0
3480827c:	15900004 	ldrne	r0, [r0, #4]
34808280:	ea000005 	b	3480829c <getenv+0x60>
	}

	/* restricted capabilities before import */
	if (getenv_f(name, (char *)(gd->env_buf), sizeof(gd->env_buf)) > 0)
34808284:	e2881058 	add	r1, r8, #88	; 0x58
34808288:	e3a02020 	mov	r2, #32
3480828c:	ebffffbb 	bl	34808180 <getenv_f>
34808290:	e3500000 	cmp	r0, #0
		return (char *)(gd->env_buf);
34808294:	c2880058 	addgt	r0, r8, #88	; 0x58

	return NULL;
34808298:	d1a00004 	movle	r0, r4
}
3480829c:	e28dd018 	add	sp, sp, #24
348082a0:	e8bd8010 	pop	{r4, pc}
348082a4:	348287dc 	.word	0x348287dc

348082a8 <getenv_ulong>:
 * @param default_val	Default value to return if the variable is not
 *			found
 * @return the decoded value, or default_val if not found
 */
ulong getenv_ulong(const char *name, int base, ulong default_val)
{
348082a8:	e92d4070 	push	{r4, r5, r6, lr}
348082ac:	e1a04001 	mov	r4, r1
348082b0:	e1a05002 	mov	r5, r2
	/*
	 * We can use getenv() here, even before relocation, since the
	 * environment variable value is an integer and thus short.
	 */
	const char *str = getenv(name);
348082b4:	ebffffe0 	bl	3480823c <getenv>

	return str ? simple_strtoul(str, NULL, base) : default_val;
348082b8:	e3500000 	cmp	r0, #0
348082bc:	0a000003 	beq	348082d0 <getenv_ulong+0x28>
348082c0:	e3a01000 	mov	r1, #0
348082c4:	e1a02004 	mov	r2, r4
}
348082c8:	e8bd4070 	pop	{r4, r5, r6, lr}
	 * We can use getenv() here, even before relocation, since the
	 * environment variable value is an integer and thus short.
	 */
	const char *str = getenv(name);

	return str ? simple_strtoul(str, NULL, base) : default_val;
348082cc:	ea004649 	b	34819bf8 <simple_strtoul>
}
348082d0:	e1a00005 	mov	r0, r5
348082d4:	e8bd8070 	pop	{r4, r5, r6, pc}

348082d8 <do_env_edit>:
/*
 * Interactively edit an environment variable
 */
#if defined(CONFIG_CMD_EDITENV)
int do_env_edit(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
348082d8:	e92d4030 	push	{r4, r5, lr}
	char buffer[CONFIG_SYS_CBSIZE];
	char *init_val;

	if (argc < 2)
348082dc:	e3520001 	cmp	r2, #1
/*
 * Interactively edit an environment variable
 */
#if defined(CONFIG_CMD_EDITENV)
int do_env_edit(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
348082e0:	e24ddf41 	sub	sp, sp, #260	; 0x104
348082e4:	e1a05003 	mov	r5, r3
	char buffer[CONFIG_SYS_CBSIZE];
	char *init_val;

	if (argc < 2)
		return CMD_RET_USAGE;
348082e8:	d3e00000 	mvnle	r0, #0
int do_env_edit(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	char buffer[CONFIG_SYS_CBSIZE];
	char *init_val;

	if (argc < 2)
348082ec:	da00000f 	ble	34808330 <do_env_edit+0x58>
		return CMD_RET_USAGE;

	/* Set read buffer to initial value or empty sting */
	init_val = getenv(argv[1]);
348082f0:	e5930004 	ldr	r0, [r3, #4]
348082f4:	ebffffd0 	bl	3480823c <getenv>
	if (init_val)
348082f8:	e2502000 	subs	r2, r0, #0
		sprintf(buffer, "%s", init_val);
	else
		buffer[0] = '\0';
348082fc:	05cd2000 	strbeq	r2, [sp]
	if (argc < 2)
		return CMD_RET_USAGE;

	/* Set read buffer to initial value or empty sting */
	init_val = getenv(argv[1]);
	if (init_val)
34808300:	0a000002 	beq	34808310 <do_env_edit+0x38>
		sprintf(buffer, "%s", init_val);
34808304:	e1a0000d 	mov	r0, sp
34808308:	e59f1028 	ldr	r1, [pc, #40]	; 34808338 <do_env_edit+0x60>
3480830c:	eb0046df 	bl	34819e90 <sprintf>
	else
		buffer[0] = '\0';

	readline_into_buffer("edit: ", buffer, 0);
34808310:	e1a0100d 	mov	r1, sp
34808314:	e59f0020 	ldr	r0, [pc, #32]	; 3480833c <do_env_edit+0x64>
34808318:	e3a02000 	mov	r2, #0
3480831c:	eb001382 	bl	3480d12c <readline_into_buffer>

	return setenv(argv[1], buffer);
34808320:	e5950004 	ldr	r0, [r5, #4]
34808324:	e1a0100d 	mov	r1, sp
	if (init_val)
		sprintf(buffer, "%s", init_val);
	else
		buffer[0] = '\0';

	readline_into_buffer("edit: ", buffer, 0);
34808328:	e1a0400d 	mov	r4, sp

	return setenv(argv[1], buffer);
3480832c:	ebfffeba 	bl	34807e1c <setenv>
}
34808330:	e28ddf41 	add	sp, sp, #260	; 0x104
34808334:	e8bd8030 	pop	{r4, r5, pc}
34808338:	34824dd1 	.word	0x34824dd1
3480833c:	34825857 	.word	0x34825857

34808340 <do_reginfo>:
# endif

#endif /* CONFIG_BLACKFIN */

	return 0;
}
34808340:	e3a00000 	mov	r0, #0
34808344:	e12fff1e 	bx	lr

34808348 <__fswab32>:
34808348:	e6bf0f30 	rev	r0, r0
3480834c:	e12fff1e 	bx	lr

34808350 <source>:
#include <mpc8xx.h>
#endif

int
source (ulong addr, const char *fit_uname)
{
34808350:	e92d4070 	push	{r4, r5, r6, lr}
34808354:	e1a04000 	mov	r4, r0
	int		noffset;
	const void	*fit_data;
	size_t		fit_len;
#endif

	verify = getenv_yesno ("verify");
34808358:	e59f00b0 	ldr	r0, [pc, #176]	; 34808410 <source+0xc0>
3480835c:	eb00112c 	bl	3480c814 <getenv_yesno>
34808360:	e1a05000 	mov	r5, r0

	switch (genimg_get_format ((void *)addr)) {
34808364:	e1a00004 	mov	r0, r4
34808368:	eb00121d 	bl	3480cbe4 <genimg_get_format>
3480836c:	e3500001 	cmp	r0, #1
		data = (ulong *)fit_data;
		len = (ulong)fit_len;
		break;
#endif
	default:
		puts ("Wrong image format for \"source\" command\n");
34808370:	159f009c 	ldrne	r0, [pc, #156]	; 34808414 <source+0xc4>
	size_t		fit_len;
#endif

	verify = getenv_yesno ("verify");

	switch (genimg_get_format ((void *)addr)) {
34808374:	1a00001f 	bne	348083f8 <source+0xa8>
#define image_get_hdr_l(f) \
	static inline uint32_t image_get_##f(const image_header_t *hdr) \
	{ \
		return uimage_to_cpu(hdr->ih_##f); \
	}
image_get_hdr_l(magic)		/* image_get_magic */
34808378:	e5940000 	ldr	r0, [r4]
3480837c:	ebfffff1 	bl	34808348 <__fswab32>
	case IMAGE_FORMAT_LEGACY:
		hdr = (image_header_t *)addr;

		if (!image_check_magic (hdr)) {
34808380:	e59f3090 	ldr	r3, [pc, #144]	; 34808418 <source+0xc8>
34808384:	e1500003 	cmp	r0, r3
			puts ("Bad magic number\n");
34808388:	159f008c 	ldrne	r0, [pc, #140]	; 3480841c <source+0xcc>

	switch (genimg_get_format ((void *)addr)) {
	case IMAGE_FORMAT_LEGACY:
		hdr = (image_header_t *)addr;

		if (!image_check_magic (hdr)) {
3480838c:	1a000019 	bne	348083f8 <source+0xa8>
			puts ("Bad magic number\n");
			return 1;
		}

		if (!image_check_hcrc (hdr)) {
34808390:	e1a00004 	mov	r0, r4
34808394:	eb0010d1 	bl	3480c6e0 <image_check_hcrc>
34808398:	e3500000 	cmp	r0, #0
			puts ("Bad header crc\n");
3480839c:	059f007c 	ldreq	r0, [pc, #124]	; 34808420 <source+0xd0>
		if (!image_check_magic (hdr)) {
			puts ("Bad magic number\n");
			return 1;
		}

		if (!image_check_hcrc (hdr)) {
348083a0:	0a000014 	beq	348083f8 <source+0xa8>
			puts ("Bad header crc\n");
			return 1;
		}

		if (verify) {
348083a4:	e3550000 	cmp	r5, #0
348083a8:	0a000004 	beq	348083c0 <source+0x70>
			if (!image_check_dcrc (hdr)) {
348083ac:	e1a00004 	mov	r0, r4
348083b0:	eb0010de 	bl	3480c730 <image_check_dcrc>
348083b4:	e3500000 	cmp	r0, #0
				puts ("Bad data crc\n");
348083b8:	059f0064 	ldreq	r0, [pc, #100]	; 34808424 <source+0xd4>
			puts ("Bad header crc\n");
			return 1;
		}

		if (verify) {
			if (!image_check_dcrc (hdr)) {
348083bc:	0a00000d 	beq	348083f8 <source+0xa8>
				puts ("Bad data crc\n");
				return 1;
			}
		}

		if (!image_check_type (hdr, IH_TYPE_SCRIPT)) {
348083c0:	e5d4301e 	ldrb	r3, [r4, #30]
348083c4:	e3530006 	cmp	r3, #6
			puts ("Bad image type\n");
348083c8:	159f0058 	ldrne	r0, [pc, #88]	; 34808428 <source+0xd8>
				puts ("Bad data crc\n");
				return 1;
			}
		}

		if (!image_check_type (hdr, IH_TYPE_SCRIPT)) {
348083cc:	1a000009 	bne	348083f8 <source+0xa8>
		}

		/* get length of script */
		data = (ulong *)image_get_data (hdr);

		if ((len = uimage_to_cpu (*data)) == 0) {
348083d0:	e5940040 	ldr	r0, [r4, #64]	; 0x40
348083d4:	ebffffdb 	bl	34808348 <__fswab32>
348083d8:	e2501000 	subs	r1, r0, #0
 * returns:
 *     image payload data start address
 */
static inline ulong image_get_data(const image_header_t *hdr)
{
	return ((ulong)hdr + image_get_header_size());
348083dc:	e2845040 	add	r5, r4, #64	; 0x40
			puts ("Empty Script\n");
348083e0:	059f0044 	ldreq	r0, [pc, #68]	; 3480842c <source+0xdc>
		}

		/* get length of script */
		data = (ulong *)image_get_data (hdr);

		if ((len = uimage_to_cpu (*data)) == 0) {
348083e4:	0a000003 	beq	348083f8 <source+0xa8>
		/*
		 * scripts are just multi-image files with one component, seek
		 * past the zero-terminated sequence of image lengths to get
		 * to the actual image data
		 */
		while (*data++);
348083e8:	e4952004 	ldr	r2, [r5], #4
348083ec:	e3520000 	cmp	r2, #0
348083f0:	1afffffc 	bne	348083e8 <source+0x98>
348083f4:	ea000002 	b	34808404 <source+0xb4>
		data = (ulong *)fit_data;
		len = (ulong)fit_len;
		break;
#endif
	default:
		puts ("Wrong image format for \"source\" command\n");
348083f8:	eb0002c9 	bl	34808f24 <puts>
		return 1;
	}

	debug ("** Script length: %ld\n", len);
	return run_command_list((char *)data, len, 0);
}
348083fc:	e3a00001 	mov	r0, #1
34808400:	e8bd8070 	pop	{r4, r5, r6, pc}
		puts ("Wrong image format for \"source\" command\n");
		return 1;
	}

	debug ("** Script length: %ld\n", len);
	return run_command_list((char *)data, len, 0);
34808404:	e1a00005 	mov	r0, r5
}
34808408:	e8bd4070 	pop	{r4, r5, r6, lr}
		puts ("Wrong image format for \"source\" command\n");
		return 1;
	}

	debug ("** Script length: %ld\n", len);
	return run_command_list((char *)data, len, 0);
3480840c:	ea0015ad 	b	3480dac8 <run_command_list>
34808410:	348232b3 	.word	0x348232b3
34808414:	34825cb6 	.word	0x34825cb6
34808418:	27051956 	.word	0x27051956
3480841c:	34825c68 	.word	0x34825c68
34808420:	34825c7a 	.word	0x34825c7a
34808424:	34825c8a 	.word	0x34825c8a
34808428:	34825c98 	.word	0x34825c98
3480842c:	34825ca8 	.word	0x34825ca8

34808430 <do_source>:
	ulong addr;
	int rcode;
	const char *fit_uname = NULL;

	/* Find script image */
	if (argc < 2) {
34808430:	e3520001 	cmp	r2, #1

/**************************************************/
#if defined(CONFIG_CMD_SOURCE)
int
do_source (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
34808434:	e92d4010 	push	{r4, lr}
	int rcode;
	const char *fit_uname = NULL;

	/* Find script image */
	if (argc < 2) {
		addr = CONFIG_SYS_LOAD_ADDR;
34808438:	d3a04309 	movle	r4, #603979776	; 0x24000000
	ulong addr;
	int rcode;
	const char *fit_uname = NULL;

	/* Find script image */
	if (argc < 2) {
3480843c:	da000004 	ble	34808454 <do_source+0x24>
	} else if (fit_parse_subimage (argv[1], load_addr, &addr, &fit_uname)) {
		debug ("*  source: subimage '%s' from FIT image at 0x%08lx\n",
				fit_uname, addr);
#endif
	} else {
		addr = simple_strtoul(argv[1], NULL, 16);
34808440:	e5930004 	ldr	r0, [r3, #4]
34808444:	e3a01000 	mov	r1, #0
34808448:	e3a02010 	mov	r2, #16
3480844c:	eb0045e9 	bl	34819bf8 <simple_strtoul>
34808450:	e1a04000 	mov	r4, r0
		debug ("*  source: cmdline image address = 0x%08lx\n", addr);
	}

	printf ("## Executing script at %08lx\n", addr);
34808454:	e1a01004 	mov	r1, r4
34808458:	e59f0010 	ldr	r0, [pc, #16]	; 34808470 <do_source+0x40>
3480845c:	eb0002ba 	bl	34808f4c <printf>
	rcode = source (addr, fit_uname);
34808460:	e1a00004 	mov	r0, r4
34808464:	e3a01000 	mov	r1, #0
	return rcode;
}
34808468:	e8bd4010 	pop	{r4, lr}
		addr = simple_strtoul(argv[1], NULL, 16);
		debug ("*  source: cmdline image address = 0x%08lx\n", addr);
	}

	printf ("## Executing script at %08lx\n", addr);
	rcode = source (addr, fit_uname);
3480846c:	eaffffb7 	b	34808350 <source>
34808470:	34825cdf 	.word	0x34825cdf

34808474 <do_false>:
);

int do_false(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	return 1;
}
34808474:	e3a00001 	mov	r0, #1
34808478:	e12fff1e 	bx	lr

3480847c <do_true>:
);

int do_true(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	return 0;
}
3480847c:	e3a00000 	mov	r0, #0
34808480:	e12fff1e 	bx	lr

34808484 <do_test>:
{
	char * const *ap;
	int left, adv, expr, last_expr, neg, last_cmp;

	/* args? */
	if (argc < 3)
34808484:	e3520002 	cmp	r2, #2

#include <common.h>
#include <command.h>

int do_test(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
34808488:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	char * const *ap;
	int left, adv, expr, last_expr, neg, last_cmp;

	/* args? */
	if (argc < 3)
3480848c:	da0000fd 	ble	34808888 <do_test+0x404>
	}
#endif

	last_expr = 0;
	left = argc - 1; ap = argv + 1;
	if (left > 0 && strcmp(ap[0], "!") == 0) {
34808490:	e5930004 	ldr	r0, [r3, #4]
34808494:	e59f141c 	ldr	r1, [pc, #1052]	; 348088b8 <do_test+0x434>
			debug(" '%s'", argv[left++]);
	}
#endif

	last_expr = 0;
	left = argc - 1; ap = argv + 1;
34808498:	e2426001 	sub	r6, r2, #1
3480849c:	e2834004 	add	r4, r3, #4
	if (left > 0 && strcmp(ap[0], "!") == 0) {
348084a0:	eb004182 	bl	34818ab0 <strcmp>
		left--;
	} else
		neg = 0;

	expr = -1;
	last_cmp = -1;
348084a4:	e3e05000 	mvn	r5, #0
	}
#endif

	last_expr = 0;
	left = argc - 1; ap = argv + 1;
	if (left > 0 && strcmp(ap[0], "!") == 0) {
348084a8:	e3500000 	cmp	r0, #0
		neg = 1;
		ap++;
348084ac:	02844004 	addeq	r4, r4, #4
		left--;
348084b0:	02466001 	subeq	r6, r6, #1
#endif

	last_expr = 0;
	left = argc - 1; ap = argv + 1;
	if (left > 0 && strcmp(ap[0], "!") == 0) {
		neg = 1;
348084b4:	03a0b001 	moveq	fp, #1
		ap++;
		left--;
	} else
		neg = 0;
348084b8:	13a0b000 	movne	fp, #0

	expr = -1;
	last_cmp = -1;
	last_expr = -1;
348084bc:	e1a07005 	mov	r7, r5
		ap++;
		left--;
	} else
		neg = 0;

	expr = -1;
348084c0:	e1a0a005 	mov	sl, r5
	last_cmp = -1;
	last_expr = -1;
	while (left > 0) {

		if (strcmp(ap[0], "-o") == 0 || strcmp(ap[0], "-a") == 0)
348084c4:	e5940000 	ldr	r0, [r4]
348084c8:	e59f13ec 	ldr	r1, [pc, #1004]	; 348088bc <do_test+0x438>
348084cc:	eb004177 	bl	34818ab0 <strcmp>
348084d0:	e3500000 	cmp	r0, #0
348084d4:	0a0000ed 	beq	34808890 <do_test+0x40c>
348084d8:	e5940000 	ldr	r0, [r4]
348084dc:	e59f13dc 	ldr	r1, [pc, #988]	; 348088c0 <do_test+0x43c>
348084e0:	eb004172 	bl	34818ab0 <strcmp>
348084e4:	e3500000 	cmp	r0, #0
348084e8:	0a0000e8 	beq	34808890 <do_test+0x40c>
			adv = 1;
		else if (strcmp(ap[0], "-z") == 0 || strcmp(ap[0], "-n") == 0)
348084ec:	e5940000 	ldr	r0, [r4]
348084f0:	e59f13cc 	ldr	r1, [pc, #972]	; 348088c4 <do_test+0x440>
348084f4:	eb00416d 	bl	34818ab0 <strcmp>
348084f8:	e3500000 	cmp	r0, #0
			adv = 2;
348084fc:	03a09002 	moveq	r9, #2
	last_expr = -1;
	while (left > 0) {

		if (strcmp(ap[0], "-o") == 0 || strcmp(ap[0], "-a") == 0)
			adv = 1;
		else if (strcmp(ap[0], "-z") == 0 || strcmp(ap[0], "-n") == 0)
34808500:	0a000005 	beq	3480851c <do_test+0x98>
34808504:	e5940000 	ldr	r0, [r4]
34808508:	e59f13b8 	ldr	r1, [pc, #952]	; 348088c8 <do_test+0x444>
3480850c:	eb004167 	bl	34818ab0 <strcmp>
			adv = 2;
		else
			adv = 3;
34808510:	e3500000 	cmp	r0, #0
34808514:	03a09002 	moveq	r9, #2
34808518:	13a09003 	movne	r9, #3

		if (left < adv) {
3480851c:	e1560009 	cmp	r6, r9
34808520:	aa000006 	bge	34808540 <do_test+0xbc>
34808524:	ea0000cf 	b	34808868 <do_test+0x3e4>

		if (adv == 1) {
			if (strcmp(ap[0], "-o") == 0) {
				last_expr = expr;
				last_cmp = 0;
			} else if (strcmp(ap[0], "-a") == 0) {
34808528:	e5940000 	ldr	r0, [r4]
3480852c:	e59f138c 	ldr	r1, [pc, #908]	; 348088c0 <do_test+0x43c>
34808530:	eb00415e 	bl	34818ab0 <strcmp>
34808534:	e3500000 	cmp	r0, #0
34808538:	0a0000da 	beq	348088a8 <do_test+0x424>
3480853c:	ea0000c9 	b	34808868 <do_test+0x3e4>
				expr = 1;
				break;
			}
		}

		if (adv == 2) {
34808540:	e3590002 	cmp	r9, #2
34808544:	1a00001e 	bne	348085c4 <do_test+0x140>
			if (strcmp(ap[0], "-z") == 0)
34808548:	e5940000 	ldr	r0, [r4]
3480854c:	e59f1370 	ldr	r1, [pc, #880]	; 348088c4 <do_test+0x440>
34808550:	eb004156 	bl	34818ab0 <strcmp>
34808554:	e3500000 	cmp	r0, #0
34808558:	1a000004 	bne	34808570 <do_test+0xec>
				expr = strlen(ap[1]) == 0 ? 1 : 0;
3480855c:	e5940004 	ldr	r0, [r4, #4]
34808560:	eb004186 	bl	34818b80 <strlen>
34808564:	e270a001 	rsbs	sl, r0, #1
34808568:	33a0a000 	movcc	sl, #0
3480856c:	ea000008 	b	34808594 <do_test+0x110>
			else if (strcmp(ap[0], "-n") == 0)
34808570:	e5940000 	ldr	r0, [r4]
34808574:	e59f134c 	ldr	r1, [pc, #844]	; 348088c8 <do_test+0x444>
34808578:	eb00414c 	bl	34818ab0 <strcmp>
3480857c:	e3500000 	cmp	r0, #0
34808580:	1a0000b8 	bne	34808868 <do_test+0x3e4>
				expr = strlen(ap[1]) == 0 ? 0 : 1;
34808584:	e5940004 	ldr	r0, [r4, #4]
34808588:	eb00417c 	bl	34818b80 <strlen>
3480858c:	e250a000 	subs	sl, r0, #0
34808590:	13a0a001 	movne	sl, #1
			else {
				expr = 1;
				break;
			}

			if (last_cmp == 0)
34808594:	e3550000 	cmp	r5, #0
34808598:	1a000003 	bne	348085ac <do_test+0x128>
				expr = last_expr || expr;
3480859c:	e19aa007 	orrs	sl, sl, r7
348085a0:	03a0a000 	moveq	sl, #0
348085a4:	13a0a001 	movne	sl, #1
348085a8:	ea0000a8 	b	34808850 <do_test+0x3cc>
			else if (last_cmp == 1)
348085ac:	e3550001 	cmp	r5, #1
348085b0:	1a0000a6 	bne	34808850 <do_test+0x3cc>
				expr = last_expr && expr;
348085b4:	e3570000 	cmp	r7, #0
348085b8:	03a0a000 	moveq	sl, #0
348085bc:	120aa001 	andne	sl, sl, #1
348085c0:	ea0000a2 	b	34808850 <do_test+0x3cc>
			last_cmp = -1;
		}

		if (adv == 3) {
			if (strcmp(ap[1], "=") == 0)
348085c4:	e5940004 	ldr	r0, [r4, #4]
348085c8:	e59f12fc 	ldr	r1, [pc, #764]	; 348088cc <do_test+0x448>
348085cc:	eb004137 	bl	34818ab0 <strcmp>
348085d0:	e3500000 	cmp	r0, #0
348085d4:	e284a004 	add	sl, r4, #4
348085d8:	1a000005 	bne	348085f4 <do_test+0x170>
				expr = strcmp(ap[0], ap[2]) == 0;
348085dc:	e5940000 	ldr	r0, [r4]
348085e0:	e5941008 	ldr	r1, [r4, #8]
348085e4:	eb004131 	bl	34818ab0 <strcmp>
348085e8:	e270a001 	rsbs	sl, r0, #1
348085ec:	33a0a000 	movcc	sl, #0
348085f0:	ea00008a 	b	34808820 <do_test+0x39c>
			else if (strcmp(ap[1], "!=") == 0)
348085f4:	e5940004 	ldr	r0, [r4, #4]
348085f8:	e59f12d0 	ldr	r1, [pc, #720]	; 348088d0 <do_test+0x44c>
348085fc:	eb00412b 	bl	34818ab0 <strcmp>
34808600:	e3500000 	cmp	r0, #0
34808604:	1a000005 	bne	34808620 <do_test+0x19c>
				expr = strcmp(ap[0], ap[2]) != 0;
34808608:	e5940000 	ldr	r0, [r4]
3480860c:	e5941008 	ldr	r1, [r4, #8]
34808610:	eb004126 	bl	34818ab0 <strcmp>
34808614:	e250a000 	subs	sl, r0, #0
34808618:	13a0a001 	movne	sl, #1
3480861c:	ea00007f 	b	34808820 <do_test+0x39c>
			else if (strcmp(ap[1], ">") == 0)
34808620:	e59a0000 	ldr	r0, [sl]
34808624:	e59f12a8 	ldr	r1, [pc, #680]	; 348088d4 <do_test+0x450>
34808628:	eb004120 	bl	34818ab0 <strcmp>
3480862c:	e3500000 	cmp	r0, #0
34808630:	1a000006 	bne	34808650 <do_test+0x1cc>
				expr = strcmp(ap[0], ap[2]) > 0;
34808634:	e5940000 	ldr	r0, [r4]
34808638:	e5941008 	ldr	r1, [r4, #8]
3480863c:	eb00411b 	bl	34818ab0 <strcmp>
34808640:	e3500000 	cmp	r0, #0
34808644:	d3a0a000 	movle	sl, #0
34808648:	c3a0a001 	movgt	sl, #1
3480864c:	ea000073 	b	34808820 <do_test+0x39c>
			else if (strcmp(ap[1], "<") == 0)
34808650:	e59a0000 	ldr	r0, [sl]
34808654:	e59f127c 	ldr	r1, [pc, #636]	; 348088d8 <do_test+0x454>
34808658:	eb004114 	bl	34818ab0 <strcmp>
3480865c:	e3500000 	cmp	r0, #0
34808660:	1a000004 	bne	34808678 <do_test+0x1f4>
				expr = strcmp(ap[0], ap[2]) < 0;
34808664:	e5940000 	ldr	r0, [r4]
34808668:	e5941008 	ldr	r1, [r4, #8]
3480866c:	eb00410f 	bl	34818ab0 <strcmp>
34808670:	e1a0afa0 	lsr	sl, r0, #31
34808674:	ea000069 	b	34808820 <do_test+0x39c>
			else if (strcmp(ap[1], "-eq") == 0)
34808678:	e59a0000 	ldr	r0, [sl]
3480867c:	e59f1258 	ldr	r1, [pc, #600]	; 348088dc <do_test+0x458>
34808680:	eb00410a 	bl	34818ab0 <strcmp>
34808684:	e2509000 	subs	r9, r0, #0
34808688:	1a00000c 	bne	348086c0 <do_test+0x23c>
				expr = simple_strtol(ap[0], NULL, 10) == simple_strtol(ap[2], NULL, 10);
3480868c:	e1a01009 	mov	r1, r9
34808690:	e3a0200a 	mov	r2, #10
34808694:	e5940000 	ldr	r0, [r4]
34808698:	eb00459f 	bl	34819d1c <simple_strtol>
3480869c:	e1a01009 	mov	r1, r9
348086a0:	e1a0a000 	mov	sl, r0
348086a4:	e3a0200a 	mov	r2, #10
348086a8:	e5940008 	ldr	r0, [r4, #8]
348086ac:	eb00459a 	bl	34819d1c <simple_strtol>
348086b0:	e15a0000 	cmp	sl, r0
348086b4:	13a0a000 	movne	sl, #0
348086b8:	03a0a001 	moveq	sl, #1
348086bc:	ea000057 	b	34808820 <do_test+0x39c>
			else if (strcmp(ap[1], "-ne") == 0)
348086c0:	e59a0000 	ldr	r0, [sl]
348086c4:	e59f1214 	ldr	r1, [pc, #532]	; 348088e0 <do_test+0x45c>
348086c8:	eb0040f8 	bl	34818ab0 <strcmp>
348086cc:	e2509000 	subs	r9, r0, #0
348086d0:	1a00000b 	bne	34808704 <do_test+0x280>
				expr = simple_strtol(ap[0], NULL, 10) != simple_strtol(ap[2], NULL, 10);
348086d4:	e1a01009 	mov	r1, r9
348086d8:	e3a0200a 	mov	r2, #10
348086dc:	e5940000 	ldr	r0, [r4]
348086e0:	eb00458d 	bl	34819d1c <simple_strtol>
348086e4:	e1a01009 	mov	r1, r9
348086e8:	e1a0a000 	mov	sl, r0
348086ec:	e3a0200a 	mov	r2, #10
348086f0:	e5940008 	ldr	r0, [r4, #8]
348086f4:	eb004588 	bl	34819d1c <simple_strtol>
348086f8:	e05aa000 	subs	sl, sl, r0
348086fc:	13a0a001 	movne	sl, #1
34808700:	ea000046 	b	34808820 <do_test+0x39c>
			else if (strcmp(ap[1], "-lt") == 0)
34808704:	e59a0000 	ldr	r0, [sl]
34808708:	e59f11d4 	ldr	r1, [pc, #468]	; 348088e4 <do_test+0x460>
3480870c:	eb0040e7 	bl	34818ab0 <strcmp>
34808710:	e2509000 	subs	r9, r0, #0
34808714:	1a00000c 	bne	3480874c <do_test+0x2c8>
				expr = simple_strtol(ap[0], NULL, 10) < simple_strtol(ap[2], NULL, 10);
34808718:	e1a01009 	mov	r1, r9
3480871c:	e3a0200a 	mov	r2, #10
34808720:	e5940000 	ldr	r0, [r4]
34808724:	eb00457c 	bl	34819d1c <simple_strtol>
34808728:	e1a01009 	mov	r1, r9
3480872c:	e1a0a000 	mov	sl, r0
34808730:	e3a0200a 	mov	r2, #10
34808734:	e5940008 	ldr	r0, [r4, #8]
34808738:	eb004577 	bl	34819d1c <simple_strtol>
3480873c:	e15a0000 	cmp	sl, r0
34808740:	a3a0a000 	movge	sl, #0
34808744:	b3a0a001 	movlt	sl, #1
34808748:	ea000034 	b	34808820 <do_test+0x39c>
			else if (strcmp(ap[1], "-le") == 0)
3480874c:	e59a0000 	ldr	r0, [sl]
34808750:	e59f1190 	ldr	r1, [pc, #400]	; 348088e8 <do_test+0x464>
34808754:	eb0040d5 	bl	34818ab0 <strcmp>
34808758:	e3500000 	cmp	r0, #0
3480875c:	1a00000c 	bne	34808794 <do_test+0x310>
				expr = simple_strtol(ap[0], NULL, 10) <= simple_strtol(ap[2], NULL, 10);
34808760:	e3a01000 	mov	r1, #0
34808764:	e3a0200a 	mov	r2, #10
34808768:	e5940000 	ldr	r0, [r4]
3480876c:	eb00456a 	bl	34819d1c <simple_strtol>
34808770:	e3a01000 	mov	r1, #0
34808774:	e1a0a000 	mov	sl, r0
34808778:	e3a0200a 	mov	r2, #10
3480877c:	e5940008 	ldr	r0, [r4, #8]
34808780:	eb004565 	bl	34819d1c <simple_strtol>
34808784:	e15a0000 	cmp	sl, r0
34808788:	c3a0a000 	movgt	sl, #0
3480878c:	d3a0a001 	movle	sl, #1
34808790:	ea000022 	b	34808820 <do_test+0x39c>
			else if (strcmp(ap[1], "-gt") == 0)
34808794:	e59a0000 	ldr	r0, [sl]
34808798:	e59f114c 	ldr	r1, [pc, #332]	; 348088ec <do_test+0x468>
3480879c:	eb0040c3 	bl	34818ab0 <strcmp>
348087a0:	e2509000 	subs	r9, r0, #0
348087a4:	1a00000c 	bne	348087dc <do_test+0x358>
				expr = simple_strtol(ap[0], NULL, 10) > simple_strtol(ap[2], NULL, 10);
348087a8:	e1a01009 	mov	r1, r9
348087ac:	e3a0200a 	mov	r2, #10
348087b0:	e5940000 	ldr	r0, [r4]
348087b4:	eb004558 	bl	34819d1c <simple_strtol>
348087b8:	e1a01009 	mov	r1, r9
348087bc:	e1a0a000 	mov	sl, r0
348087c0:	e3a0200a 	mov	r2, #10
348087c4:	e5940008 	ldr	r0, [r4, #8]
348087c8:	eb004553 	bl	34819d1c <simple_strtol>
348087cc:	e15a0000 	cmp	sl, r0
348087d0:	d3a0a000 	movle	sl, #0
348087d4:	c3a0a001 	movgt	sl, #1
348087d8:	ea000010 	b	34808820 <do_test+0x39c>
			else if (strcmp(ap[1], "-ge") == 0)
348087dc:	e59a0000 	ldr	r0, [sl]
348087e0:	e59f1108 	ldr	r1, [pc, #264]	; 348088f0 <do_test+0x46c>
348087e4:	eb0040b1 	bl	34818ab0 <strcmp>
348087e8:	e2509000 	subs	r9, r0, #0
348087ec:	1a00001d 	bne	34808868 <do_test+0x3e4>
				expr = simple_strtol(ap[0], NULL, 10) >= simple_strtol(ap[2], NULL, 10);
348087f0:	e1a01009 	mov	r1, r9
348087f4:	e3a0200a 	mov	r2, #10
348087f8:	e5940000 	ldr	r0, [r4]
348087fc:	eb004546 	bl	34819d1c <simple_strtol>
34808800:	e1a01009 	mov	r1, r9
34808804:	e1a0a000 	mov	sl, r0
34808808:	e3a0200a 	mov	r2, #10
3480880c:	e5940008 	ldr	r0, [r4, #8]
34808810:	eb004541 	bl	34819d1c <simple_strtol>
34808814:	e15a0000 	cmp	sl, r0
34808818:	b3a0a000 	movlt	sl, #0
3480881c:	a3a0a001 	movge	sl, #1
			else {
				expr = 1;
				break;
			}

			if (last_cmp == 0)
34808820:	e3550000 	cmp	r5, #0
34808824:	1a000003 	bne	34808838 <do_test+0x3b4>
				expr = last_expr || expr;
34808828:	e19aa007 	orrs	sl, sl, r7
3480882c:	03a0a000 	moveq	sl, #0
34808830:	13a0a001 	movne	sl, #1
34808834:	ea000004 	b	3480884c <do_test+0x3c8>
			else if (last_cmp == 1)
34808838:	e3550001 	cmp	r5, #1
3480883c:	1a000002 	bne	3480884c <do_test+0x3c8>
				expr = last_expr && expr;
34808840:	e3570000 	cmp	r7, #0
34808844:	03a0a000 	moveq	sl, #0
34808848:	120aa001 	andne	sl, sl, #1
				break;
			}

			if (last_cmp == 0)
				expr = last_expr || expr;
			else if (last_cmp == 1)
3480884c:	e3a09003 	mov	r9, #3
				expr = last_expr && expr;
			last_cmp = -1;
34808850:	e3e05000 	mvn	r5, #0
		}

		ap += adv; left -= adv;
34808854:	e0696006 	rsb	r6, r9, r6
		neg = 0;

	expr = -1;
	last_cmp = -1;
	last_expr = -1;
	while (left > 0) {
34808858:	e3560000 	cmp	r6, #0
3480885c:	da000002 	ble	3480886c <do_test+0x3e8>
			else if (last_cmp == 1)
				expr = last_expr && expr;
			last_cmp = -1;
		}

		ap += adv; left -= adv;
34808860:	e0844109 	add	r4, r4, r9, lsl #2
34808864:	eaffff16 	b	348084c4 <do_test+0x40>
			else if (strcmp(ap[1], "-gt") == 0)
				expr = simple_strtol(ap[0], NULL, 10) > simple_strtol(ap[2], NULL, 10);
			else if (strcmp(ap[1], "-ge") == 0)
				expr = simple_strtol(ap[0], NULL, 10) >= simple_strtol(ap[2], NULL, 10);
			else {
				expr = 1;
34808868:	e3a0a001 	mov	sl, #1
		}

		ap += adv; left -= adv;
	}

	if (neg)
3480886c:	e35b0000 	cmp	fp, #0
34808870:	0a000001 	beq	3480887c <do_test+0x3f8>
		expr = !expr;
34808874:	e27aa001 	rsbs	sl, sl, #1
34808878:	33a0a000 	movcc	sl, #0

	expr = !expr;
3480887c:	e27a0001 	rsbs	r0, sl, #1
34808880:	33a00000 	movcc	r0, #0

	debug (": returns %d\n", expr);

	return expr;
34808884:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
	char * const *ap;
	int left, adv, expr, last_expr, neg, last_cmp;

	/* args? */
	if (argc < 3)
		return 1;
34808888:	e3a00001 	mov	r0, #1
	expr = !expr;

	debug (": returns %d\n", expr);

	return expr;
}
3480888c:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
			expr = 1;
			break;
		}

		if (adv == 1) {
			if (strcmp(ap[0], "-o") == 0) {
34808890:	e5940000 	ldr	r0, [r4]
34808894:	e59f1020 	ldr	r1, [pc, #32]	; 348088bc <do_test+0x438>
34808898:	eb004084 	bl	34818ab0 <strcmp>
3480889c:	e2505000 	subs	r5, r0, #0
348088a0:	0a000001 	beq	348088ac <do_test+0x428>
348088a4:	eaffff1f 	b	34808528 <do_test+0xa4>
				last_expr = expr;
				last_cmp = 0;
			} else if (strcmp(ap[0], "-a") == 0) {
				last_expr = expr;
				last_cmp = 1;
348088a8:	e3a05001 	mov	r5, #1

			if (last_cmp == 0)
				expr = last_expr || expr;
			else if (last_cmp == 1)
				expr = last_expr && expr;
			last_cmp = -1;
348088ac:	e1a0700a 	mov	r7, sl
348088b0:	e3a09001 	mov	r9, #1
348088b4:	eaffffe6 	b	34808854 <do_test+0x3d0>
348088b8:	34827016 	.word	0x34827016
348088bc:	34825d69 	.word	0x34825d69
348088c0:	34825d6c 	.word	0x34825d6c
348088c4:	34825d6f 	.word	0x34825d6f
348088c8:	34825d72 	.word	0x34825d72
348088cc:	34823c7b 	.word	0x34823c7b
348088d0:	34823c7a 	.word	0x34823c7a
348088d4:	34823c7e 	.word	0x34823c7e
348088d8:	34823c69 	.word	0x34823c69
348088dc:	34823c6f 	.word	0x34823c6f
348088e0:	34823c76 	.word	0x34823c76
348088e4:	34823c65 	.word	0x34823c65
348088e8:	34823c87 	.word	0x34823c87
348088ec:	34823c6b 	.word	0x34823c6b
348088f0:	34823c80 	.word	0x34823c80

348088f4 <do_version>:
#include <linux/compiler.h>

const char __weak version_string[] = U_BOOT_VERSION_STRING;

int do_version(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
348088f4:	e92d4008 	push	{r3, lr}
	printf("\n%s\n", version_string);
348088f8:	e59f101c 	ldr	r1, [pc, #28]	; 3480891c <do_version+0x28>
348088fc:	e59f001c 	ldr	r0, [pc, #28]	; 34808920 <do_version+0x2c>
34808900:	eb000191 	bl	34808f4c <printf>
#ifdef CC_VERSION_STRING
	puts(CC_VERSION_STRING "\n");
34808904:	e59f0018 	ldr	r0, [pc, #24]	; 34808924 <do_version+0x30>
34808908:	eb000185 	bl	34808f24 <puts>
#endif
#ifdef LD_VERSION_STRING
	puts(LD_VERSION_STRING "\n");
3480890c:	e59f0014 	ldr	r0, [pc, #20]	; 34808928 <do_version+0x34>
34808910:	eb000183 	bl	34808f24 <puts>
#endif

	return 0;
}
34808914:	e3a00000 	mov	r0, #0
34808918:	e8bd8008 	pop	{r3, pc}
3480891c:	3482053c 	.word	0x3482053c
34808920:	34825dd7 	.word	0x34825dd7
34808924:	34825ddc 	.word	0x34825ddc
34808928:	34825e01 	.word	0x34825e01

3480892c <find_cmd_tbl>:

/***************************************************************************
 * find command table entry for a command
 */
cmd_tbl_t *find_cmd_tbl (const char *cmd, cmd_tbl_t *table, int table_len)
{
3480892c:	e92d46f8 	push	{r3, r4, r5, r6, r7, r9, sl, lr}
	cmd_tbl_t *cmdtp_temp = table;	/*Init value */
	const char *p;
	int len;
	int n_found = 0;

	if (!cmd)
34808930:	e2505000 	subs	r5, r0, #0

/***************************************************************************
 * find command table entry for a command
 */
cmd_tbl_t *find_cmd_tbl (const char *cmd, cmd_tbl_t *table, int table_len)
{
34808934:	e1a04002 	mov	r4, r2
34808938:	e1a06001 	mov	r6, r1
	const char *p;
	int len;
	int n_found = 0;

	if (!cmd)
		return NULL;
3480893c:	01a04005 	moveq	r4, r5
	cmd_tbl_t *cmdtp_temp = table;	/*Init value */
	const char *p;
	int len;
	int n_found = 0;

	if (!cmd)
34808940:	0a00001e 	beq	348089c0 <find_cmd_tbl+0x94>
		return NULL;
	/*
	 * Some commands allow length modifiers (like "cp.b");
	 * compare command name only until first dot.
	 */
	len = ((p = strchr(cmd, '.')) == NULL) ? strlen (cmd) : (p - cmd);
34808944:	e3a0102e 	mov	r1, #46	; 0x2e
34808948:	eb004076 	bl	34818b28 <strchr>
3480894c:	e3500000 	cmp	r0, #0
34808950:	1065a000 	rsbne	sl, r5, r0
34808954:	1a000002 	bne	34808964 <find_cmd_tbl+0x38>
34808958:	e1a00005 	mov	r0, r5
3480895c:	eb004087 	bl	34818b80 <strlen>
34808960:	e1a0a000 	mov	sl, r0

	for (cmdtp = table;
	     cmdtp != table + table_len;
34808964:	e3a09018 	mov	r9, #24
34808968:	e0296499 	mla	r9, r9, r4, r6
{
	cmd_tbl_t *cmdtp;
	cmd_tbl_t *cmdtp_temp = table;	/*Init value */
	const char *p;
	int len;
	int n_found = 0;
3480896c:	e3a07000 	mov	r7, #0
	 * Some commands allow length modifiers (like "cp.b");
	 * compare command name only until first dot.
	 */
	len = ((p = strchr(cmd, '.')) == NULL) ? strlen (cmd) : (p - cmd);

	for (cmdtp = table;
34808970:	e1a04006 	mov	r4, r6
34808974:	ea00000c 	b	348089ac <find_cmd_tbl+0x80>
	     cmdtp != table + table_len;
	     cmdtp++) {
		if (strncmp (cmd, cmdtp->name, len) == 0) {
34808978:	e1a00005 	mov	r0, r5
3480897c:	e5941000 	ldr	r1, [r4]
34808980:	e1a0200a 	mov	r2, sl
34808984:	eb004055 	bl	34818ae0 <strncmp>
34808988:	e3500000 	cmp	r0, #0
3480898c:	1a000005 	bne	348089a8 <find_cmd_tbl+0x7c>
			if (len == strlen (cmdtp->name))
34808990:	e5940000 	ldr	r0, [r4]
34808994:	eb004079 	bl	34818b80 <strlen>
34808998:	e15a0000 	cmp	sl, r0
3480899c:	0a000007 	beq	348089c0 <find_cmd_tbl+0x94>
				return cmdtp;	/* full match */

			cmdtp_temp = cmdtp;	/* abbreviated command ? */
			n_found++;
348089a0:	e2877001 	add	r7, r7, #1
348089a4:	e1a06004 	mov	r6, r4
	 */
	len = ((p = strchr(cmd, '.')) == NULL) ? strlen (cmd) : (p - cmd);

	for (cmdtp = table;
	     cmdtp != table + table_len;
	     cmdtp++) {
348089a8:	e2844018 	add	r4, r4, #24
	 * Some commands allow length modifiers (like "cp.b");
	 * compare command name only until first dot.
	 */
	len = ((p = strchr(cmd, '.')) == NULL) ? strlen (cmd) : (p - cmd);

	for (cmdtp = table;
348089ac:	e1540009 	cmp	r4, r9
348089b0:	1afffff0 	bne	34808978 <find_cmd_tbl+0x4c>
	}
	if (n_found == 1) {			/* exactly one match */
		return cmdtp_temp;
	}

	return NULL;	/* not found or ambiguous command */
348089b4:	e3570001 	cmp	r7, #1
348089b8:	01a04006 	moveq	r4, r6
348089bc:	13a04000 	movne	r4, #0
}
348089c0:	e1a00004 	mov	r0, r4
348089c4:	e8bd86f8 	pop	{r3, r4, r5, r6, r7, r9, sl, pc}

348089c8 <find_cmd>:

cmd_tbl_t *find_cmd (const char *cmd)
{
	int len = &__u_boot_cmd_end - &__u_boot_cmd_start;
	return find_cmd_tbl(cmd, &__u_boot_cmd_start, len);
348089c8:	e59f1014 	ldr	r1, [pc, #20]	; 348089e4 <find_cmd+0x1c>
	return NULL;	/* not found or ambiguous command */
}

cmd_tbl_t *find_cmd (const char *cmd)
{
	int len = &__u_boot_cmd_end - &__u_boot_cmd_start;
348089cc:	e59f3014 	ldr	r3, [pc, #20]	; 348089e8 <find_cmd+0x20>
	return find_cmd_tbl(cmd, &__u_boot_cmd_start, len);
348089d0:	e59f2014 	ldr	r2, [pc, #20]	; 348089ec <find_cmd+0x24>
	return NULL;	/* not found or ambiguous command */
}

cmd_tbl_t *find_cmd (const char *cmd)
{
	int len = &__u_boot_cmd_end - &__u_boot_cmd_start;
348089d4:	e0613003 	rsb	r3, r1, r3
348089d8:	e1a031c3 	asr	r3, r3, #3
	return find_cmd_tbl(cmd, &__u_boot_cmd_start, len);
348089dc:	e0020392 	mul	r2, r2, r3
348089e0:	eaffffd1 	b	3480892c <find_cmd_tbl>
	...
348089ec:	aaaaaaab 	.word	0xaaaaaaab

348089f0 <cmd_usage>:
}

int cmd_usage(const cmd_tbl_t *cmdtp)
{
348089f0:	e92d4010 	push	{r4, lr}
348089f4:	e1a04000 	mov	r4, r0
	printf("%s - %s\n\n", cmdtp->name, cmdtp->usage);
348089f8:	e5941000 	ldr	r1, [r4]
348089fc:	e5942010 	ldr	r2, [r4, #16]
34808a00:	e59f0038 	ldr	r0, [pc, #56]	; 34808a40 <cmd_usage+0x50>
34808a04:	eb000150 	bl	34808f4c <printf>

#ifdef	CONFIG_SYS_LONGHELP
	printf("Usage:\n%s ", cmdtp->name);
34808a08:	e59f0034 	ldr	r0, [pc, #52]	; 34808a44 <cmd_usage+0x54>
34808a0c:	e5941000 	ldr	r1, [r4]
34808a10:	eb00014d 	bl	34808f4c <printf>

	if (!cmdtp->help) {
34808a14:	e5940014 	ldr	r0, [r4, #20]
34808a18:	e3500000 	cmp	r0, #0
34808a1c:	1a000002 	bne	34808a2c <cmd_usage+0x3c>
		puts ("- No additional help available.\n");
34808a20:	e59f0020 	ldr	r0, [pc, #32]	; 34808a48 <cmd_usage+0x58>
34808a24:	eb00013e 	bl	34808f24 <puts>
		return 1;
34808a28:	ea000002 	b	34808a38 <cmd_usage+0x48>
	}

	puts (cmdtp->help);
34808a2c:	eb00013c 	bl	34808f24 <puts>
	putc ('\n');
34808a30:	e3a0000a 	mov	r0, #10
34808a34:	eb000130 	bl	34808efc <putc>
#endif	/* CONFIG_SYS_LONGHELP */
	return 1;
}
34808a38:	e3a00001 	mov	r0, #1
34808a3c:	e8bd8010 	pop	{r4, pc}
34808a40:	34825e53 	.word	0x34825e53
34808a44:	34825e5d 	.word	0x34825e5d
34808a48:	34825e68 	.word	0x34825e68

34808a4c <_do_help>:
 * for long help messages
 */

int _do_help (cmd_tbl_t *cmd_start, int cmd_items, cmd_tbl_t * cmdtp, int
	      flag, int argc, char * const argv[])
{
34808a4c:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
34808a50:	e28db01c 	add	fp, sp, #28
34808a54:	e24dd010 	sub	sp, sp, #16
34808a58:	e59b9004 	ldr	r9, [fp, #4]
34808a5c:	e1a0a000 	mov	sl, r0
	int i;
	int rcode = 0;

	if (argc == 1) {	/*show list of commands */
34808a60:	e3590001 	cmp	r9, #1
 * for long help messages
 */

int _do_help (cmd_tbl_t *cmd_start, int cmd_items, cmd_tbl_t * cmdtp, int
	      flag, int argc, char * const argv[])
{
34808a64:	e1a04001 	mov	r4, r1
	int i;
	int rcode = 0;

	if (argc == 1) {	/*show list of commands */
34808a68:	159b7008 	ldrne	r7, [fp, #8]
34808a6c:	13a05000 	movne	r5, #0
34808a70:	13a06001 	movne	r6, #1
34808a74:	1a00004f 	bne	34808bb8 <_do_help+0x16c>
		cmd_tbl_t *cmd_array[cmd_items];
34808a78:	e1a03101 	lsl	r3, r1, #2
34808a7c:	e283300e 	add	r3, r3, #14
34808a80:	e3c33007 	bic	r3, r3, #7
	      flag, int argc, char * const argv[])
{
	int i;
	int rcode = 0;

	if (argc == 1) {	/*show list of commands */
34808a84:	e50bd024 	str	sp, [fp, #-36]	; 0x24
		cmd_tbl_t *cmd_array[cmd_items];
34808a88:	e04dd003 	sub	sp, sp, r3
34808a8c:	e1a0300d 	mov	r3, sp
34808a90:	e50bd020 	str	sp, [fp, #-32]
		int i, j, swaps;

		/* Make array of commands from .uboot_cmd section */
		cmdtp = cmd_start;
		for (i = 0; i < cmd_items; i++) {
34808a94:	e1a0100d 	mov	r1, sp
34808a98:	e3a02000 	mov	r2, #0
34808a9c:	ea000002 	b	34808aac <_do_help+0x60>
			cmd_array[i] = cmdtp++;
34808aa0:	e481a004 	str	sl, [r1], #4
		cmd_tbl_t *cmd_array[cmd_items];
		int i, j, swaps;

		/* Make array of commands from .uboot_cmd section */
		cmdtp = cmd_start;
		for (i = 0; i < cmd_items; i++) {
34808aa4:	e2822001 	add	r2, r2, #1
			cmd_array[i] = cmdtp++;
34808aa8:	e28aa018 	add	sl, sl, #24
		cmd_tbl_t *cmd_array[cmd_items];
		int i, j, swaps;

		/* Make array of commands from .uboot_cmd section */
		cmdtp = cmd_start;
		for (i = 0; i < cmd_items; i++) {
34808aac:	e1520004 	cmp	r2, r4
34808ab0:	bafffffa 	blt	34808aa0 <_do_help+0x54>
			cmd_array[i] = cmdtp++;
		}

		/* Sort command list (trivial bubble sort) */
		for (i = cmd_items - 1; i > 0; --i) {
34808ab4:	e2446001 	sub	r6, r4, #1
34808ab8:	ea000017 	b	34808b1c <_do_help+0xd0>
34808abc:	e3a07000 	mov	r7, #0
34808ac0:	e1a05003 	mov	r5, r3
34808ac4:	e1a0a007 	mov	sl, r7
			swaps = 0;
			for (j = 0; j < i; ++j) {
				if (strcmp (cmd_array[j]->name,
34808ac8:	e5952000 	ldr	r2, [r5]
					    cmd_array[j + 1]->name) > 0) {
34808acc:	e5b59004 	ldr	r9, [r5, #4]!

		/* Sort command list (trivial bubble sort) */
		for (i = cmd_items - 1; i > 0; --i) {
			swaps = 0;
			for (j = 0; j < i; ++j) {
				if (strcmp (cmd_array[j]->name,
34808ad0:	e5920000 	ldr	r0, [r2]
34808ad4:	e5991000 	ldr	r1, [r9]
34808ad8:	e50b2028 	str	r2, [fp, #-40]	; 0x28
34808adc:	e50b302c 	str	r3, [fp, #-44]	; 0x2c
34808ae0:	eb003ff2 	bl	34818ab0 <strcmp>
34808ae4:	e51b2028 	ldr	r2, [fp, #-40]	; 0x28
34808ae8:	e3500000 	cmp	r0, #0
					    cmd_array[j + 1]->name) > 0) {
34808aec:	e28aa001 	add	sl, sl, #1

		/* Sort command list (trivial bubble sort) */
		for (i = cmd_items - 1; i > 0; --i) {
			swaps = 0;
			for (j = 0; j < i; ++j) {
				if (strcmp (cmd_array[j]->name,
34808af0:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
					    cmd_array[j + 1]->name) > 0) {
					cmd_tbl_t *tmp;
					tmp = cmd_array[j];
					cmd_array[j] = cmd_array[j + 1];
					cmd_array[j + 1] = tmp;
					++swaps;
34808af4:	c2877001 	addgt	r7, r7, #1
			for (j = 0; j < i; ++j) {
				if (strcmp (cmd_array[j]->name,
					    cmd_array[j + 1]->name) > 0) {
					cmd_tbl_t *tmp;
					tmp = cmd_array[j];
					cmd_array[j] = cmd_array[j + 1];
34808af8:	c5059004 	strgt	r9, [r5, #-4]
					cmd_array[j + 1] = tmp;
34808afc:	c5852000 	strgt	r2, [r5]
		}

		/* Sort command list (trivial bubble sort) */
		for (i = cmd_items - 1; i > 0; --i) {
			swaps = 0;
			for (j = 0; j < i; ++j) {
34808b00:	e15a0006 	cmp	sl, r6
34808b04:	baffffef 	blt	34808ac8 <_do_help+0x7c>
					cmd_array[j] = cmd_array[j + 1];
					cmd_array[j + 1] = tmp;
					++swaps;
				}
			}
			if (!swaps)
34808b08:	e3570000 	cmp	r7, #0
34808b0c:	1a000001 	bne	34808b18 <_do_help+0xcc>
		for (i = 0; i < cmd_items; i++) {
			cmd_array[i] = cmdtp++;
		}

		/* Sort command list (trivial bubble sort) */
		for (i = cmd_items - 1; i > 0; --i) {
34808b10:	e3a05000 	mov	r5, #0
34808b14:	ea000012 	b	34808b64 <_do_help+0x118>
34808b18:	e2466001 	sub	r6, r6, #1
34808b1c:	e3560000 	cmp	r6, #0
34808b20:	caffffe5 	bgt	34808abc <_do_help+0x70>
34808b24:	eafffff9 	b	34808b10 <_do_help+0xc4>
				break;
		}

		/* print short help (usage) */
		for (i = 0; i < cmd_items; i++) {
			const char *usage = cmd_array[i]->usage;
34808b28:	e51b3020 	ldr	r3, [fp, #-32]
34808b2c:	e4937004 	ldr	r7, [r3], #4
34808b30:	e50b3020 	str	r3, [fp, #-32]
34808b34:	e5976010 	ldr	r6, [r7, #16]

			/* allow user abort */
			if (ctrlc ())
34808b38:	eb000128 	bl	34808fe0 <ctrlc>
34808b3c:	e3500000 	cmp	r0, #0
34808b40:	1a00000b 	bne	34808b74 <_do_help+0x128>
				return 1;
			if (usage == NULL)
34808b44:	e3560000 	cmp	r6, #0
34808b48:	0a000004 	beq	34808b60 <_do_help+0x114>
				continue;
			printf("%-*s- %s\n", CONFIG_SYS_HELP_CMD_WIDTH,
34808b4c:	e59f0078 	ldr	r0, [pc, #120]	; 34808bcc <_do_help+0x180>
34808b50:	e3a01008 	mov	r1, #8
34808b54:	e5972000 	ldr	r2, [r7]
34808b58:	e1a03006 	mov	r3, r6
34808b5c:	eb0000fa 	bl	34808f4c <printf>
			if (!swaps)
				break;
		}

		/* print short help (usage) */
		for (i = 0; i < cmd_items; i++) {
34808b60:	e2855001 	add	r5, r5, #1
34808b64:	e1550004 	cmp	r5, r4
34808b68:	baffffee 	blt	34808b28 <_do_help+0xdc>
			if (usage == NULL)
				continue;
			printf("%-*s- %s\n", CONFIG_SYS_HELP_CMD_WIDTH,
			       cmd_array[i]->name, usage);
		}
		return 0;
34808b6c:	e3a05000 	mov	r5, #0
34808b70:	ea000000 	b	34808b78 <_do_help+0x12c>
		for (i = 0; i < cmd_items; i++) {
			const char *usage = cmd_array[i]->usage;

			/* allow user abort */
			if (ctrlc ())
				return 1;
34808b74:	e3a05001 	mov	r5, #1
			if (!swaps)
				break;
		}

		/* print short help (usage) */
		for (i = 0; i < cmd_items; i++) {
34808b78:	e51bd024 	ldr	sp, [fp, #-36]	; 0x24
34808b7c:	ea00000f 	b	34808bc0 <_do_help+0x174>
	}
	/*
	 * command help (long version)
	 */
	for (i = 1; i < argc; ++i) {
		if ((cmdtp = find_cmd_tbl (argv[i], cmd_start, cmd_items )) != NULL) {
34808b80:	e5b70004 	ldr	r0, [r7, #4]!
34808b84:	e1a0100a 	mov	r1, sl
34808b88:	e1a02004 	mov	r2, r4
34808b8c:	ebffff66 	bl	3480892c <find_cmd_tbl>
34808b90:	e3500000 	cmp	r0, #0
34808b94:	0a000002 	beq	34808ba4 <_do_help+0x158>
			rcode |= cmd_usage(cmdtp);
34808b98:	ebffff94 	bl	348089f0 <cmd_usage>
34808b9c:	e1855000 	orr	r5, r5, r0
34808ba0:	ea000003 	b	34808bb4 <_do_help+0x168>
		} else {
			printf ("Unknown command '%s' - try 'help'"
34808ba4:	e59f0024 	ldr	r0, [pc, #36]	; 34808bd0 <_do_help+0x184>
34808ba8:	e5971000 	ldr	r1, [r7]
34808bac:	eb0000e6 	bl	34808f4c <printf>
				" without arguments for list of all"
				" known commands\n\n", argv[i]
					);
			rcode = 1;
34808bb0:	e3a05001 	mov	r5, #1
		return 0;
	}
	/*
	 * command help (long version)
	 */
	for (i = 1; i < argc; ++i) {
34808bb4:	e2866001 	add	r6, r6, #1
34808bb8:	e1560009 	cmp	r6, r9
34808bbc:	baffffef 	blt	34808b80 <_do_help+0x134>
					);
			rcode = 1;
		}
	}
	return rcode;
}
34808bc0:	e1a00005 	mov	r0, r5
34808bc4:	e24bd01c 	sub	sp, fp, #28
34808bc8:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
34808bcc:	34825e89 	.word	0x34825e89
34808bd0:	34825e93 	.word	0x34825e93

34808bd4 <cmd_get_data_size>:

#endif

#ifdef CMD_DATA_SIZE
int cmd_get_data_size(char* arg, int default_size)
{
34808bd4:	e92d4038 	push	{r3, r4, r5, lr}
34808bd8:	e1a04000 	mov	r4, r0
34808bdc:	e1a05001 	mov	r5, r1
	/* Check for a size specification .b, .w or .l.
	 */
	int len = strlen(arg);
34808be0:	eb003fe6 	bl	34818b80 <strlen>
	if (len > 2 && arg[len-2] == '.') {
34808be4:	e3500002 	cmp	r0, #2
34808be8:	da00000a 	ble	34808c18 <cmd_get_data_size+0x44>
34808bec:	e0844000 	add	r4, r4, r0
34808bf0:	e5543002 	ldrb	r3, [r4, #-2]
34808bf4:	e353002e 	cmp	r3, #46	; 0x2e
34808bf8:	1a000006 	bne	34808c18 <cmd_get_data_size+0x44>
		switch(arg[len-1]) {
34808bfc:	e5543001 	ldrb	r3, [r4, #-1]
34808c00:	e2433062 	sub	r3, r3, #98	; 0x62
34808c04:	e6ef3073 	uxtb	r3, r3
34808c08:	e3530015 	cmp	r3, #21
34808c0c:	959f200c 	ldrls	r2, [pc, #12]	; 34808c20 <cmd_get_data_size+0x4c>
34808c10:	83e05000 	mvnhi	r5, #0
34808c14:	97925103 	ldrls	r5, [r2, r3, lsl #2]
		default:
			return -1;
		}
	}
	return default_size;
}
34808c18:	e1a00005 	mov	r0, r5
34808c1c:	e8bd8038 	pop	{r3, r4, r5, pc}
34808c20:	34820564 	.word	0x34820564

34808c24 <cmd_process>:
	return result;
}

enum command_ret_t cmd_process(int flag, int argc, char * const argv[],
			       int *repeatable)
{
34808c24:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
34808c28:	e1a05000 	mov	r5, r0
	enum command_ret_t rc = CMD_RET_SUCCESS;
	cmd_tbl_t *cmdtp;

	/* Look up command in command table */
	cmdtp = find_cmd(argv[0]);
34808c2c:	e5920000 	ldr	r0, [r2]
	return result;
}

enum command_ret_t cmd_process(int flag, int argc, char * const argv[],
			       int *repeatable)
{
34808c30:	e1a0a001 	mov	sl, r1
34808c34:	e1a06002 	mov	r6, r2
34808c38:	e1a07003 	mov	r7, r3
	enum command_ret_t rc = CMD_RET_SUCCESS;
	cmd_tbl_t *cmdtp;

	/* Look up command in command table */
	cmdtp = find_cmd(argv[0]);
34808c3c:	ebffff61 	bl	348089c8 <find_cmd>
	if (cmdtp == NULL) {
34808c40:	e2504000 	subs	r4, r0, #0
34808c44:	1a000003 	bne	34808c58 <cmd_process+0x34>
		printf("Unknown command '%s' - try 'help'\n", argv[0]);
34808c48:	e5961000 	ldr	r1, [r6]
34808c4c:	e59f0078 	ldr	r0, [pc, #120]	; 34808ccc <cmd_process+0xa8>
34808c50:	eb0000bd 	bl	34808f4c <printf>
34808c54:	ea00000b 	b	34808c88 <cmd_process+0x64>
		return 1;
	}

	/* found - check max args */
	if (argc > cmdtp->maxargs)
34808c58:	e5943004 	ldr	r3, [r4, #4]
34808c5c:	e15a0003 	cmp	sl, r3
34808c60:	ca00000a 	bgt	34808c90 <cmd_process+0x6c>
		rc = CMD_RET_USAGE;

#if defined(CONFIG_CMD_BOOTD)
	/* avoid "bootd" recursion */
	else if (cmdtp->cmd == do_bootd) {
34808c64:	e594c00c 	ldr	ip, [r4, #12]
34808c68:	e59f3060 	ldr	r3, [pc, #96]	; 34808cd0 <cmd_process+0xac>
34808c6c:	e15c0003 	cmp	ip, r3
34808c70:	1a000009 	bne	34808c9c <cmd_process+0x78>
		if (flag & CMD_FLAG_BOOTD) {
34808c74:	e3150002 	tst	r5, #2
			puts("'bootd' recursion detected\n");
			rc = CMD_RET_FAILURE;
		} else {
			flag |= CMD_FLAG_BOOTD;
34808c78:	03855002 	orreq	r5, r5, #2
		rc = CMD_RET_USAGE;

#if defined(CONFIG_CMD_BOOTD)
	/* avoid "bootd" recursion */
	else if (cmdtp->cmd == do_bootd) {
		if (flag & CMD_FLAG_BOOTD) {
34808c7c:	0a000006 	beq	34808c9c <cmd_process+0x78>
			puts("'bootd' recursion detected\n");
34808c80:	e59f004c 	ldr	r0, [pc, #76]	; 34808cd4 <cmd_process+0xb0>
34808c84:	eb0000a6 	bl	34808f24 <puts>
			rc = CMD_RET_FAILURE;
34808c88:	e3a00001 	mov	r0, #1
34808c8c:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
	if (!rc) {
		rc = cmd_call(cmdtp, flag, argc, argv);
		*repeatable &= cmdtp->repeatable;
	}
	if (rc == CMD_RET_USAGE)
		rc = cmd_usage(cmdtp);
34808c90:	e1a00004 	mov	r0, r4
	return rc;
}
34808c94:	e8bd44f0 	pop	{r4, r5, r6, r7, sl, lr}
	if (!rc) {
		rc = cmd_call(cmdtp, flag, argc, argv);
		*repeatable &= cmdtp->repeatable;
	}
	if (rc == CMD_RET_USAGE)
		rc = cmd_usage(cmdtp);
34808c98:	eaffff54 	b	348089f0 <cmd_usage>
 */
static int cmd_call(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	int result;

	result = (cmdtp->cmd)(cmdtp, flag, argc, argv);
34808c9c:	e1a0200a 	mov	r2, sl
34808ca0:	e1a03006 	mov	r3, r6
34808ca4:	e1a00004 	mov	r0, r4
34808ca8:	e1a01005 	mov	r1, r5
34808cac:	e12fff3c 	blx	ip
#endif

	/* If OK so far, then do the command */
	if (!rc) {
		rc = cmd_call(cmdtp, flag, argc, argv);
		*repeatable &= cmdtp->repeatable;
34808cb0:	e5972000 	ldr	r2, [r7]
34808cb4:	e5943008 	ldr	r3, [r4, #8]
	}
	if (rc == CMD_RET_USAGE)
34808cb8:	e3700001 	cmn	r0, #1
#endif

	/* If OK so far, then do the command */
	if (!rc) {
		rc = cmd_call(cmdtp, flag, argc, argv);
		*repeatable &= cmdtp->repeatable;
34808cbc:	e0023003 	and	r3, r2, r3
34808cc0:	e5873000 	str	r3, [r7]
	}
	if (rc == CMD_RET_USAGE)
34808cc4:	18bd84f0 	popne	{r4, r5, r6, r7, sl, pc}
34808cc8:	eafffff0 	b	34808c90 <cmd_process+0x6c>
34808ccc:	34825ee8 	.word	0x34825ee8
34808cd0:	34802464 	.word	0x34802464
34808cd4:	34825f0b 	.word	0x34825f0b

34808cd8 <console_setfile>:
#endif /* CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE */

#endif /* CONFIG_SYS_CONSOLE_IS_IN_ENV */

static int console_setfile(int file, struct stdio_dev * dev)
{
34808cd8:	e92d4038 	push	{r3, r4, r5, lr}
	int error = 0;

	if (dev == NULL)
34808cdc:	e2515000 	subs	r5, r1, #0
#endif /* CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE */

#endif /* CONFIG_SYS_CONSOLE_IS_IN_ENV */

static int console_setfile(int file, struct stdio_dev * dev)
{
34808ce0:	e1a04000 	mov	r4, r0
	int error = 0;

	if (dev == NULL)
		return -1;
34808ce4:	03e00000 	mvneq	r0, #0

static int console_setfile(int file, struct stdio_dev * dev)
{
	int error = 0;

	if (dev == NULL)
34808ce8:	08bd8038 	popeq	{r3, r4, r5, pc}
		return -1;

	switch (file) {
34808cec:	e3540002 	cmp	r4, #2
34808cf0:	8a00001d 	bhi	34808d6c <console_setfile+0x94>
	case stdin:
	case stdout:
	case stderr:
		/* Start new device */
		if (dev->start) {
34808cf4:	e5950018 	ldr	r0, [r5, #24]
34808cf8:	e3500000 	cmp	r0, #0
34808cfc:	0a000002 	beq	34808d0c <console_setfile+0x34>
			error = dev->start();
34808d00:	e12fff30 	blx	r0
			/* If it's not started dont use it */
			if (error < 0)
34808d04:	e3500000 	cmp	r0, #0
34808d08:	b8bd8038 	poplt	{r3, r4, r5, pc}
				break;
		}

		/* Assign the new device (leaving the existing one started) */
		stdio_devices[file] = dev;
34808d0c:	e59f3060 	ldr	r3, [pc, #96]	; 34808d74 <console_setfile+0x9c>

		/*
		 * Update monitor functions
		 * (to use the console stuff by other applications)
		 */
		switch (file) {
34808d10:	e3540000 	cmp	r4, #0
			if (error < 0)
				break;
		}

		/* Assign the new device (leaving the existing one started) */
		stdio_devices[file] = dev;
34808d14:	e7835104 	str	r5, [r3, r4, lsl #2]

		/*
		 * Update monitor functions
		 * (to use the console stuff by other applications)
		 */
		switch (file) {
34808d18:	0a000002 	beq	34808d28 <console_setfile+0x50>
34808d1c:	e3540001 	cmp	r4, #1
34808d20:	18bd8038 	popne	{r3, r4, r5, pc}
34808d24:	ea000006 	b	34808d44 <console_setfile+0x6c>
		case stdin:
			gd->jt[XF_getc] = dev->getc;
34808d28:	e5982054 	ldr	r2, [r8, #84]	; 0x54
34808d2c:	e595102c 	ldr	r1, [r5, #44]	; 0x2c
			gd->jt[XF_tstc] = dev->tstc;
34808d30:	e5983054 	ldr	r3, [r8, #84]	; 0x54
		 * Update monitor functions
		 * (to use the console stuff by other applications)
		 */
		switch (file) {
		case stdin:
			gd->jt[XF_getc] = dev->getc;
34808d34:	e5821004 	str	r1, [r2, #4]
			gd->jt[XF_tstc] = dev->tstc;
34808d38:	e5952028 	ldr	r2, [r5, #40]	; 0x28
34808d3c:	e5832008 	str	r2, [r3, #8]
			break;
34808d40:	e8bd8038 	pop	{r3, r4, r5, pc}
		case stdout:
			gd->jt[XF_putc] = dev->putc;
34808d44:	e5982054 	ldr	r2, [r8, #84]	; 0x54
34808d48:	e5951020 	ldr	r1, [r5, #32]
34808d4c:	e582100c 	str	r1, [r2, #12]
			gd->jt[XF_puts] = dev->puts;
34808d50:	e5982054 	ldr	r2, [r8, #84]	; 0x54
34808d54:	e5951024 	ldr	r1, [r5, #36]	; 0x24
			gd->jt[XF_printf] = printf;
34808d58:	e5983054 	ldr	r3, [r8, #84]	; 0x54
			gd->jt[XF_getc] = dev->getc;
			gd->jt[XF_tstc] = dev->tstc;
			break;
		case stdout:
			gd->jt[XF_putc] = dev->putc;
			gd->jt[XF_puts] = dev->puts;
34808d5c:	e5821010 	str	r1, [r2, #16]
			gd->jt[XF_printf] = printf;
34808d60:	e59f2010 	ldr	r2, [pc, #16]	; 34808d78 <console_setfile+0xa0>
34808d64:	e5832014 	str	r2, [r3, #20]
			break;
34808d68:	e8bd8038 	pop	{r3, r4, r5, pc}
		}
		break;

	default:		/* Invalid file ID */
		error = -1;
34808d6c:	e3e00000 	mvn	r0, #0
	}
	return error;
}
34808d70:	e8bd8038 	pop	{r3, r4, r5, pc}
34808d74:	3482ad24 	.word	0x3482ad24
34808d78:	34808f4c 	.word	0x34808f4c

34808d7c <serial_printf>:
#endif /* defined(CONFIG_CONSOLE_MUX) */

/** U-Boot INITIAL CONSOLE-NOT COMPATIBLE FUNCTIONS *************************/

int serial_printf(const char *fmt, ...)
{
34808d7c:	e92d000f 	push	{r0, r1, r2, r3}
34808d80:	e92d4030 	push	{r4, r5, lr}
34808d84:	e24ddf63 	sub	sp, sp, #396	; 0x18c
	va_start(args, fmt);

	/* For this to work, printbuffer must be larger than
	 * anything we ever want to print.
	 */
	i = vscnprintf(printbuffer, sizeof(printbuffer), fmt, args);
34808d88:	e28d4004 	add	r4, sp, #4
{
	va_list args;
	uint i;
	char printbuffer[CONFIG_SYS_PBSIZE];

	va_start(args, fmt);
34808d8c:	e28d2f67 	add	r2, sp, #412	; 0x19c

	/* For this to work, printbuffer must be larger than
	 * anything we ever want to print.
	 */
	i = vscnprintf(printbuffer, sizeof(printbuffer), fmt, args);
34808d90:	e59d1198 	ldr	r1, [sp, #408]	; 0x198
34808d94:	e1a00004 	mov	r0, r4
{
	va_list args;
	uint i;
	char printbuffer[CONFIG_SYS_PBSIZE];

	va_start(args, fmt);
34808d98:	e58d2184 	str	r2, [sp, #388]	; 0x184

	/* For this to work, printbuffer must be larger than
	 * anything we ever want to print.
	 */
	i = vscnprintf(printbuffer, sizeof(printbuffer), fmt, args);
34808d9c:	eb00443a 	bl	34819e8c <vsprintf>
34808da0:	e1a05000 	mov	r5, r0
	va_end(args);

	serial_puts(printbuffer);
34808da4:	e1a00004 	mov	r0, r4
34808da8:	eb00153e 	bl	3480e2a8 <serial_puts>
	return i;
}
34808dac:	e1a00005 	mov	r0, r5
34808db0:	e28ddf63 	add	sp, sp, #396	; 0x18c
34808db4:	e8bd4030 	pop	{r4, r5, lr}
34808db8:	e28dd010 	add	sp, sp, #16
34808dbc:	e12fff1e 	bx	lr

34808dc0 <fgetc>:

int fgetc(int file)
{
	if (file < MAX_FILES) {
34808dc0:	e3500002 	cmp	r0, #2
	serial_puts(printbuffer);
	return i;
}

int fgetc(int file)
{
34808dc4:	e92d4008 	push	{r3, lr}
	if (file < MAX_FILES) {
34808dc8:	ca000004 	bgt	34808de0 <fgetc+0x20>
	iomux_doenv(file, dev->name);
}
#else
static inline int console_getc(int file)
{
	return stdio_devices[file]->getc();
34808dcc:	e59f3014 	ldr	r3, [pc, #20]	; 34808de8 <fgetc+0x28>
34808dd0:	e7933100 	ldr	r3, [r3, r0, lsl #2]
34808dd4:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
34808dd8:	e12fff33 	blx	r3
			 */
			 udelay(1);
#endif
		}
#else
		return console_getc(file);
34808ddc:	e8bd8008 	pop	{r3, pc}
#endif
	}

	return -1;
34808de0:	e3e00000 	mvn	r0, #0
}
34808de4:	e8bd8008 	pop	{r3, pc}
34808de8:	3482ad24 	.word	0x3482ad24

34808dec <ftstc>:

int ftstc(int file)
{
	if (file < MAX_FILES)
34808dec:	e3500002 	cmp	r0, #2

	return -1;
}

int ftstc(int file)
{
34808df0:	e92d4008 	push	{r3, lr}
	if (file < MAX_FILES)
34808df4:	ca000004 	bgt	34808e0c <ftstc+0x20>
	return stdio_devices[file]->getc();
}

static inline int console_tstc(int file)
{
	return stdio_devices[file]->tstc();
34808df8:	e59f3014 	ldr	r3, [pc, #20]	; 34808e14 <ftstc+0x28>
34808dfc:	e7933100 	ldr	r3, [r3, r0, lsl #2]
34808e00:	e5933028 	ldr	r3, [r3, #40]	; 0x28
34808e04:	e12fff33 	blx	r3
}

int ftstc(int file)
{
	if (file < MAX_FILES)
		return console_tstc(file);
34808e08:	e8bd8008 	pop	{r3, pc}

	return -1;
34808e0c:	e3e00000 	mvn	r0, #0
}
34808e10:	e8bd8008 	pop	{r3, pc}
34808e14:	3482ad24 	.word	0x3482ad24

34808e18 <fputc>:

void fputc(int file, const char c)
{
	if (file < MAX_FILES)
34808e18:	e3500002 	cmp	r0, #2

	return -1;
}

void fputc(int file, const char c)
{
34808e1c:	e92d4008 	push	{r3, lr}
	if (file < MAX_FILES)
34808e20:	c8bd8008 	popgt	{r3, pc}
	return stdio_devices[file]->tstc();
}

static inline void console_putc(int file, const char c)
{
	stdio_devices[file]->putc(c);
34808e24:	e59f2010 	ldr	r2, [pc, #16]	; 34808e3c <fputc+0x24>
34808e28:	e7923100 	ldr	r3, [r2, r0, lsl #2]
34808e2c:	e1a00001 	mov	r0, r1
34808e30:	e5933020 	ldr	r3, [r3, #32]
34808e34:	e12fff33 	blx	r3
34808e38:	e8bd8008 	pop	{r3, pc}
34808e3c:	3482ad24 	.word	0x3482ad24

34808e40 <fputs>:
		console_putc(file, c);
}

void fputs(int file, const char *s)
{
	if (file < MAX_FILES)
34808e40:	e3500002 	cmp	r0, #2
	if (file < MAX_FILES)
		console_putc(file, c);
}

void fputs(int file, const char *s)
{
34808e44:	e92d4008 	push	{r3, lr}
	if (file < MAX_FILES)
34808e48:	c8bd8008 	popgt	{r3, pc}
	stdio_devices[file]->putc(c);
}

static inline void console_puts(int file, const char *s)
{
	stdio_devices[file]->puts(s);
34808e4c:	e59f2010 	ldr	r2, [pc, #16]	; 34808e64 <fputs+0x24>
34808e50:	e7923100 	ldr	r3, [r2, r0, lsl #2]
34808e54:	e1a00001 	mov	r0, r1
34808e58:	e5933024 	ldr	r3, [r3, #36]	; 0x24
34808e5c:	e12fff33 	blx	r3
34808e60:	e8bd8008 	pop	{r3, pc}
34808e64:	3482ad24 	.word	0x3482ad24

34808e68 <fprintf>:
	if (file < MAX_FILES)
		console_puts(file, s);
}

int fprintf(int file, const char *fmt, ...)
{
34808e68:	e92d000e 	push	{r1, r2, r3}
34808e6c:	e92d4070 	push	{r4, r5, r6, lr}
34808e70:	e24ddf63 	sub	sp, sp, #396	; 0x18c
	va_start(args, fmt);

	/* For this to work, printbuffer must be larger than
	 * anything we ever want to print.
	 */
	i = vscnprintf(printbuffer, sizeof(printbuffer), fmt, args);
34808e74:	e28d4004 	add	r4, sp, #4
{
	va_list args;
	uint i;
	char printbuffer[CONFIG_SYS_PBSIZE];

	va_start(args, fmt);
34808e78:	e28d2e1a 	add	r2, sp, #416	; 0x1a0
	if (file < MAX_FILES)
		console_puts(file, s);
}

int fprintf(int file, const char *fmt, ...)
{
34808e7c:	e1a05000 	mov	r5, r0
	va_start(args, fmt);

	/* For this to work, printbuffer must be larger than
	 * anything we ever want to print.
	 */
	i = vscnprintf(printbuffer, sizeof(printbuffer), fmt, args);
34808e80:	e59d119c 	ldr	r1, [sp, #412]	; 0x19c
34808e84:	e1a00004 	mov	r0, r4
{
	va_list args;
	uint i;
	char printbuffer[CONFIG_SYS_PBSIZE];

	va_start(args, fmt);
34808e88:	e58d2184 	str	r2, [sp, #388]	; 0x184

	/* For this to work, printbuffer must be larger than
	 * anything we ever want to print.
	 */
	i = vscnprintf(printbuffer, sizeof(printbuffer), fmt, args);
34808e8c:	eb0043fe 	bl	34819e8c <vsprintf>
	va_end(args);

	/* Send to desired file */
	fputs(file, printbuffer);
34808e90:	e1a01004 	mov	r1, r4
	va_start(args, fmt);

	/* For this to work, printbuffer must be larger than
	 * anything we ever want to print.
	 */
	i = vscnprintf(printbuffer, sizeof(printbuffer), fmt, args);
34808e94:	e1a06000 	mov	r6, r0
	va_end(args);

	/* Send to desired file */
	fputs(file, printbuffer);
34808e98:	e1a00005 	mov	r0, r5
34808e9c:	ebffffe7 	bl	34808e40 <fputs>
	return i;
}
34808ea0:	e1a00006 	mov	r0, r6
34808ea4:	e28ddf63 	add	sp, sp, #396	; 0x18c
34808ea8:	e8bd4070 	pop	{r4, r5, r6, lr}
34808eac:	e28dd00c 	add	sp, sp, #12
34808eb0:	e12fff1e 	bx	lr

34808eb4 <getc>:
#ifdef CONFIG_DISABLE_CONSOLE
	if (gd->flags & GD_FLG_DISABLE_CONSOLE)
		return 0;
#endif

	if (!gd->have_console)
34808eb4:	e598000c 	ldr	r0, [r8, #12]
34808eb8:	e3500000 	cmp	r0, #0
34808ebc:	012fff1e 	bxeq	lr
		return 0;

	if (gd->flags & GD_FLG_DEVINIT) {
34808ec0:	e5983004 	ldr	r3, [r8, #4]
34808ec4:	e3130002 	tst	r3, #2
34808ec8:	0a000001 	beq	34808ed4 <getc+0x20>
		/* Get from the standard input */
		return fgetc(stdin);
34808ecc:	e3a00000 	mov	r0, #0
34808ed0:	eaffffba 	b	34808dc0 <fgetc>
	}

	/* Send directly to the handler */
	return serial_getc();
34808ed4:	ea0014e2 	b	3480e264 <serial_getc>

34808ed8 <tstc>:
#ifdef CONFIG_DISABLE_CONSOLE
	if (gd->flags & GD_FLG_DISABLE_CONSOLE)
		return 0;
#endif

	if (!gd->have_console)
34808ed8:	e598000c 	ldr	r0, [r8, #12]
34808edc:	e3500000 	cmp	r0, #0
34808ee0:	012fff1e 	bxeq	lr
		return 0;

	if (gd->flags & GD_FLG_DEVINIT) {
34808ee4:	e5983004 	ldr	r3, [r8, #4]
34808ee8:	e3130002 	tst	r3, #2
34808eec:	0a000001 	beq	34808ef8 <tstc+0x20>
		/* Test the standard input */
		return ftstc(stdin);
34808ef0:	e3a00000 	mov	r0, #0
34808ef4:	eaffffbc 	b	34808dec <ftstc>
	}

	/* Send directly to the handler */
	return serial_tstc();
34808ef8:	ea0014de 	b	3480e278 <serial_tstc>

34808efc <putc>:
#ifdef CONFIG_DISABLE_CONSOLE
	if (gd->flags & GD_FLG_DISABLE_CONSOLE)
		return;
#endif

	if (!gd->have_console)
34808efc:	e598200c 	ldr	r2, [r8, #12]
static inline void pre_console_puts(const char *s) {}
static inline void print_pre_console_buffer(void) {}
#endif

void putc(const char c)
{
34808f00:	e1a01000 	mov	r1, r0
#ifdef CONFIG_DISABLE_CONSOLE
	if (gd->flags & GD_FLG_DISABLE_CONSOLE)
		return;
#endif

	if (!gd->have_console)
34808f04:	e3520000 	cmp	r2, #0
34808f08:	012fff1e 	bxeq	lr
		return pre_console_putc(c);

	if (gd->flags & GD_FLG_DEVINIT) {
34808f0c:	e5983004 	ldr	r3, [r8, #4]
34808f10:	e3130002 	tst	r3, #2
34808f14:	0a000001 	beq	34808f20 <putc+0x24>
		/* Send to the standard output */
		fputc(stdout, c);
34808f18:	e3a00001 	mov	r0, #1
34808f1c:	eaffffbd 	b	34808e18 <fputc>
	} else {
		/* Send directly to the handler */
		serial_putc(c);
34808f20:	ea0014d9 	b	3480e28c <serial_putc>

34808f24 <puts>:
#ifdef CONFIG_DISABLE_CONSOLE
	if (gd->flags & GD_FLG_DISABLE_CONSOLE)
		return;
#endif

	if (!gd->have_console)
34808f24:	e598200c 	ldr	r2, [r8, #12]
		serial_putc(c);
	}
}

void puts(const char *s)
{
34808f28:	e1a01000 	mov	r1, r0
#ifdef CONFIG_DISABLE_CONSOLE
	if (gd->flags & GD_FLG_DISABLE_CONSOLE)
		return;
#endif

	if (!gd->have_console)
34808f2c:	e3520000 	cmp	r2, #0
34808f30:	012fff1e 	bxeq	lr
		return pre_console_puts(s);

	if (gd->flags & GD_FLG_DEVINIT) {
34808f34:	e5983004 	ldr	r3, [r8, #4]
34808f38:	e3130002 	tst	r3, #2
34808f3c:	0a000001 	beq	34808f48 <puts+0x24>
		/* Send to the standard output */
		fputs(stdout, s);
34808f40:	e3a00001 	mov	r0, #1
34808f44:	eaffffbd 	b	34808e40 <fputs>
	} else {
		/* Send directly to the handler */
		serial_puts(s);
34808f48:	ea0014d6 	b	3480e2a8 <serial_puts>

34808f4c <printf>:
	}
}

int printf(const char *fmt, ...)
{
34808f4c:	e92d000f 	push	{r0, r1, r2, r3}
34808f50:	e92d4030 	push	{r4, r5, lr}
	va_list args;
	uint i;
	char printbuffer[CONFIG_SYS_PBSIZE];

#ifndef CONFIG_PRE_CONSOLE_BUFFER
	if (!gd->have_console)
34808f54:	e598500c 	ldr	r5, [r8, #12]
		serial_puts(s);
	}
}

int printf(const char *fmt, ...)
{
34808f58:	e24ddf63 	sub	sp, sp, #396	; 0x18c
	va_list args;
	uint i;
	char printbuffer[CONFIG_SYS_PBSIZE];

#ifndef CONFIG_PRE_CONSOLE_BUFFER
	if (!gd->have_console)
34808f5c:	e3550000 	cmp	r5, #0
34808f60:	0a000008 	beq	34808f88 <printf+0x3c>
	va_start(args, fmt);

	/* For this to work, printbuffer must be larger than
	 * anything we ever want to print.
	 */
	i = vscnprintf(printbuffer, sizeof(printbuffer), fmt, args);
34808f64:	e28d4004 	add	r4, sp, #4
#ifndef CONFIG_PRE_CONSOLE_BUFFER
	if (!gd->have_console)
		return 0;
#endif

	va_start(args, fmt);
34808f68:	e28d2f67 	add	r2, sp, #412	; 0x19c

	/* For this to work, printbuffer must be larger than
	 * anything we ever want to print.
	 */
	i = vscnprintf(printbuffer, sizeof(printbuffer), fmt, args);
34808f6c:	e1a00004 	mov	r0, r4
34808f70:	e59d1198 	ldr	r1, [sp, #408]	; 0x198
#ifndef CONFIG_PRE_CONSOLE_BUFFER
	if (!gd->have_console)
		return 0;
#endif

	va_start(args, fmt);
34808f74:	e58d2184 	str	r2, [sp, #388]	; 0x184

	/* For this to work, printbuffer must be larger than
	 * anything we ever want to print.
	 */
	i = vscnprintf(printbuffer, sizeof(printbuffer), fmt, args);
34808f78:	eb0043c3 	bl	34819e8c <vsprintf>
34808f7c:	e1a05000 	mov	r5, r0
	va_end(args);

	/* Print the string */
	puts(printbuffer);
34808f80:	e1a00004 	mov	r0, r4
34808f84:	ebffffe6 	bl	34808f24 <puts>
	return i;
}
34808f88:	e1a00005 	mov	r0, r5
34808f8c:	e28ddf63 	add	sp, sp, #396	; 0x18c
34808f90:	e8bd4030 	pop	{r4, r5, lr}
34808f94:	e28dd010 	add	sp, sp, #16
34808f98:	e12fff1e 	bx	lr

34808f9c <vprintf>:

int vprintf(const char *fmt, va_list args)
{
34808f9c:	e92d4030 	push	{r4, r5, lr}
	uint i;
	char printbuffer[CONFIG_SYS_PBSIZE];

#ifndef CONFIG_PRE_CONSOLE_BUFFER
	if (!gd->have_console)
34808fa0:	e598500c 	ldr	r5, [r8, #12]
	puts(printbuffer);
	return i;
}

int vprintf(const char *fmt, va_list args)
{
34808fa4:	e24ddf61 	sub	sp, sp, #388	; 0x184
	uint i;
	char printbuffer[CONFIG_SYS_PBSIZE];

#ifndef CONFIG_PRE_CONSOLE_BUFFER
	if (!gd->have_console)
34808fa8:	e3550000 	cmp	r5, #0
	puts(printbuffer);
	return i;
}

int vprintf(const char *fmt, va_list args)
{
34808fac:	e1a03000 	mov	r3, r0
34808fb0:	e1a02001 	mov	r2, r1
	uint i;
	char printbuffer[CONFIG_SYS_PBSIZE];

#ifndef CONFIG_PRE_CONSOLE_BUFFER
	if (!gd->have_console)
34808fb4:	0a000006 	beq	34808fd4 <vprintf+0x38>
#endif

	/* For this to work, printbuffer must be larger than
	 * anything we ever want to print.
	 */
	i = vscnprintf(printbuffer, sizeof(printbuffer), fmt, args);
34808fb8:	e1a0000d 	mov	r0, sp
34808fbc:	e1a01003 	mov	r1, r3
34808fc0:	eb0043b1 	bl	34819e8c <vsprintf>
34808fc4:	e1a05000 	mov	r5, r0

	/* Print the string */
	puts(printbuffer);
34808fc8:	e1a0000d 	mov	r0, sp
#endif

	/* For this to work, printbuffer must be larger than
	 * anything we ever want to print.
	 */
	i = vscnprintf(printbuffer, sizeof(printbuffer), fmt, args);
34808fcc:	e1a0400d 	mov	r4, sp

	/* Print the string */
	puts(printbuffer);
34808fd0:	ebffffd3 	bl	34808f24 <puts>
	return i;
}
34808fd4:	e1a00005 	mov	r0, r5
34808fd8:	e28ddf61 	add	sp, sp, #388	; 0x184
34808fdc:	e8bd8030 	pop	{r4, r5, pc}

34808fe0 <ctrlc>:

/* test if ctrl-c was pressed */
static int ctrlc_disabled = 0;	/* see disable_ctrl() */
static int ctrlc_was_pressed = 0;
int ctrlc(void)
{
34808fe0:	e92d4038 	push	{r3, r4, r5, lr}
	if (!ctrlc_disabled && gd->have_console) {
34808fe4:	e59f503c 	ldr	r5, [pc, #60]	; 34809028 <ctrlc+0x48>
34808fe8:	e5954000 	ldr	r4, [r5]
34808fec:	e3540000 	cmp	r4, #0
			default:
				break;
			}
		}
	}
	return 0;
34808ff0:	13a00000 	movne	r0, #0
/* test if ctrl-c was pressed */
static int ctrlc_disabled = 0;	/* see disable_ctrl() */
static int ctrlc_was_pressed = 0;
int ctrlc(void)
{
	if (!ctrlc_disabled && gd->have_console) {
34808ff4:	18bd8038 	popne	{r3, r4, r5, pc}
34808ff8:	e598000c 	ldr	r0, [r8, #12]
34808ffc:	e3500000 	cmp	r0, #0
34809000:	08bd8038 	popeq	{r3, r4, r5, pc}
		if (tstc()) {
34809004:	ebffffb3 	bl	34808ed8 <tstc>
34809008:	e3500000 	cmp	r0, #0
3480900c:	08bd8038 	popeq	{r3, r4, r5, pc}
			switch (getc()) {
34809010:	ebffffa7 	bl	34808eb4 <getc>
34809014:	e3500003 	cmp	r0, #3
			case 0x03:		/* ^C - Control C */
				ctrlc_was_pressed = 1;
34809018:	03a00001 	moveq	r0, #1
3480901c:	05850004 	streq	r0, [r5, #4]
			default:
				break;
			}
		}
	}
	return 0;
34809020:	11a00004 	movne	r0, r4
}
34809024:	e8bd8038 	pop	{r3, r4, r5, pc}
34809028:	348294d8 	.word	0x348294d8

3480902c <disable_ctrlc>:
/* pass 1 to disable ctrlc() checking, 0 to enable.
 * returns previous state
 */
int disable_ctrlc(int disable)
{
	int prev = ctrlc_disabled;	/* save previous state */
3480902c:	e59f300c 	ldr	r3, [pc, #12]	; 34809040 <disable_ctrlc+0x14>
34809030:	e5932000 	ldr	r2, [r3]

	ctrlc_disabled = disable;
34809034:	e5830000 	str	r0, [r3]
	return prev;
}
34809038:	e1a00002 	mov	r0, r2
3480903c:	e12fff1e 	bx	lr
34809040:	348294d8 	.word	0x348294d8

34809044 <had_ctrlc>:

int had_ctrlc (void)
{
	return ctrlc_was_pressed;
}
34809044:	e59f3004 	ldr	r3, [pc, #4]	; 34809050 <had_ctrlc+0xc>
34809048:	e5930004 	ldr	r0, [r3, #4]
3480904c:	e12fff1e 	bx	lr
34809050:	348294d8 	.word	0x348294d8

34809054 <clear_ctrlc>:

void clear_ctrlc(void)
{
	ctrlc_was_pressed = 0;
34809054:	e59f3008 	ldr	r3, [pc, #8]	; 34809064 <clear_ctrlc+0x10>
34809058:	e3a02000 	mov	r2, #0
3480905c:	e5832004 	str	r2, [r3, #4]
}
34809060:	e12fff1e 	bx	lr
34809064:	348294d8 	.word	0x348294d8

34809068 <dbg>:
	cursor += strlen(printbuffer);

}
#else
inline void dbg(const char *fmt, ...)
{
34809068:	e92d000f 	push	{r0, r1, r2, r3}
}
3480906c:	e28dd010 	add	sp, sp, #16
34809070:	e12fff1e 	bx	lr

34809074 <search_device>:
#endif

/** U-Boot INIT FUNCTIONS *************************************************/

struct stdio_dev *search_device(int flags, const char *name)
{
34809074:	e92d4010 	push	{r4, lr}
34809078:	e1a04000 	mov	r4, r0
	struct stdio_dev *dev;

	dev = stdio_get_by_name(name);
3480907c:	e1a00001 	mov	r0, r1
34809080:	eb001492 	bl	3480e2d0 <stdio_get_by_name>

	if (dev && (dev->flags & flags))
34809084:	e3500000 	cmp	r0, #0
34809088:	08bd8010 	popeq	{r4, pc}
3480908c:	e5903000 	ldr	r3, [r0]
34809090:	e0144003 	ands	r4, r4, r3
		return dev;

	return NULL;
34809094:	01a00004 	moveq	r0, r4
}
34809098:	e8bd8010 	pop	{r4, pc}

3480909c <console_assign>:

int console_assign(int file, const char *devname)
{
3480909c:	e92d4010 	push	{r4, lr}
	int flag;
	struct stdio_dev *dev;

	/* Check for valid file */
	switch (file) {
348090a0:	e2504000 	subs	r4, r0, #0
	case stdin:
		flag = DEV_FLAGS_INPUT;
348090a4:	03a00001 	moveq	r0, #1
{
	int flag;
	struct stdio_dev *dev;

	/* Check for valid file */
	switch (file) {
348090a8:	0a000003 	beq	348090bc <console_assign+0x20>
348090ac:	ba000008 	blt	348090d4 <console_assign+0x38>
348090b0:	e3540002 	cmp	r4, #2
348090b4:	ca000006 	bgt	348090d4 <console_assign+0x38>
	case stdin:
		flag = DEV_FLAGS_INPUT;
		break;
	case stdout:
	case stderr:
		flag = DEV_FLAGS_OUTPUT;
348090b8:	e3a00002 	mov	r0, #2
		return -1;
	}

	/* Check for valid device name */

	dev = search_device(flag, devname);
348090bc:	ebffffec 	bl	34809074 <search_device>

	if (dev)
348090c0:	e2501000 	subs	r1, r0, #0
348090c4:	0a000002 	beq	348090d4 <console_assign+0x38>
		return console_setfile(file, dev);
348090c8:	e1a00004 	mov	r0, r4

	return -1;
}
348090cc:	e8bd4010 	pop	{r4, lr}
	/* Check for valid device name */

	dev = search_device(flag, devname);

	if (dev)
		return console_setfile(file, dev);
348090d0:	eaffff00 	b	34808cd8 <console_setfile>

	return -1;
}
348090d4:	e3e00000 	mvn	r0, #0
348090d8:	e8bd8010 	pop	{r4, pc}

348090dc <console_init_f>:

/* Called before relocation - use serial functions */
int console_init_f(void)
{
	gd->have_console = 1;
348090dc:	e3a02001 	mov	r2, #1
348090e0:	e588200c 	str	r2, [r8, #12]
#endif

	print_pre_console_buffer();

	return 0;
}
348090e4:	e3a00000 	mov	r0, #0
348090e8:	e12fff1e 	bx	lr

348090ec <stdio_print_current_devices>:

void stdio_print_current_devices(void)
{
348090ec:	e92d4010 	push	{r4, lr}
#ifndef CONFIG_SYS_CONSOLE_INFO_QUIET
	/* Print information */
	puts("In:    ");
348090f0:	e59f008c 	ldr	r0, [pc, #140]	; 34809184 <stdio_print_current_devices+0x98>
348090f4:	ebffff8a 	bl	34808f24 <puts>
	if (stdio_devices[stdin] == NULL) {
348090f8:	e59f3088 	ldr	r3, [pc, #136]	; 34809188 <stdio_print_current_devices+0x9c>
348090fc:	e5931000 	ldr	r1, [r3]
34809100:	e3510000 	cmp	r1, #0
34809104:	1a000002 	bne	34809114 <stdio_print_current_devices+0x28>
		puts("No input devices available!\n");
34809108:	e59f007c 	ldr	r0, [pc, #124]	; 3480918c <stdio_print_current_devices+0xa0>
3480910c:	ebffff84 	bl	34808f24 <puts>
34809110:	ea000002 	b	34809120 <stdio_print_current_devices+0x34>
	} else {
		printf ("%s\n", stdio_devices[stdin]->name);
34809114:	e59f0074 	ldr	r0, [pc, #116]	; 34809190 <stdio_print_current_devices+0xa4>
34809118:	e2811008 	add	r1, r1, #8
3480911c:	ebffff8a 	bl	34808f4c <printf>
	}

	puts("Out:   ");
34809120:	e59f006c 	ldr	r0, [pc, #108]	; 34809194 <stdio_print_current_devices+0xa8>
34809124:	ebffff7e 	bl	34808f24 <puts>
	if (stdio_devices[stdout] == NULL) {
34809128:	e59f3058 	ldr	r3, [pc, #88]	; 34809188 <stdio_print_current_devices+0x9c>
3480912c:	e5931004 	ldr	r1, [r3, #4]
34809130:	e3510000 	cmp	r1, #0
34809134:	1a000002 	bne	34809144 <stdio_print_current_devices+0x58>
		puts("No output devices available!\n");
34809138:	e59f0058 	ldr	r0, [pc, #88]	; 34809198 <stdio_print_current_devices+0xac>
3480913c:	ebffff78 	bl	34808f24 <puts>
34809140:	ea000002 	b	34809150 <stdio_print_current_devices+0x64>
	} else {
		printf ("%s\n", stdio_devices[stdout]->name);
34809144:	e59f0044 	ldr	r0, [pc, #68]	; 34809190 <stdio_print_current_devices+0xa4>
34809148:	e2811008 	add	r1, r1, #8
3480914c:	ebffff7e 	bl	34808f4c <printf>
	}

	puts("Err:   ");
34809150:	e59f0044 	ldr	r0, [pc, #68]	; 3480919c <stdio_print_current_devices+0xb0>
34809154:	ebffff72 	bl	34808f24 <puts>
	if (stdio_devices[stderr] == NULL) {
34809158:	e59f3028 	ldr	r3, [pc, #40]	; 34809188 <stdio_print_current_devices+0x9c>
3480915c:	e5931008 	ldr	r1, [r3, #8]
34809160:	e3510000 	cmp	r1, #0
34809164:	1a000002 	bne	34809174 <stdio_print_current_devices+0x88>
		puts("No error devices available!\n");
34809168:	e59f0030 	ldr	r0, [pc, #48]	; 348091a0 <stdio_print_current_devices+0xb4>
	} else {
		printf ("%s\n", stdio_devices[stderr]->name);
	}
#endif /* CONFIG_SYS_CONSOLE_INFO_QUIET */
}
3480916c:	e8bd4010 	pop	{r4, lr}
		printf ("%s\n", stdio_devices[stdout]->name);
	}

	puts("Err:   ");
	if (stdio_devices[stderr] == NULL) {
		puts("No error devices available!\n");
34809170:	eaffff6b 	b	34808f24 <puts>
	} else {
		printf ("%s\n", stdio_devices[stderr]->name);
34809174:	e59f0014 	ldr	r0, [pc, #20]	; 34809190 <stdio_print_current_devices+0xa4>
34809178:	e2811008 	add	r1, r1, #8
	}
#endif /* CONFIG_SYS_CONSOLE_INFO_QUIET */
}
3480917c:	e8bd4010 	pop	{r4, lr}

	puts("Err:   ");
	if (stdio_devices[stderr] == NULL) {
		puts("No error devices available!\n");
	} else {
		printf ("%s\n", stdio_devices[stderr]->name);
34809180:	eaffff71 	b	34808f4c <printf>
34809184:	34825f27 	.word	0x34825f27
34809188:	3482ad24 	.word	0x3482ad24
3480918c:	34825f2f 	.word	0x34825f2f
34809190:	34825dd8 	.word	0x34825dd8
34809194:	34825f4c 	.word	0x34825f4c
34809198:	34825f54 	.word	0x34825f54
3480919c:	34825f72 	.word	0x34825f72
348091a0:	34825f7a 	.word	0x34825f7a

348091a4 <console_init_r>:
#ifdef CONFIG_CONSOLE_MUX
	int iomux_err = 0;
#endif

	/* set default handlers at first */
	gd->jt[XF_getc] = serial_getc;
348091a4:	e5982054 	ldr	r2, [r8, #84]	; 0x54
348091a8:	e59f1124 	ldr	r1, [pc, #292]	; 348092d4 <console_init_r+0x130>
}

#ifdef CONFIG_SYS_CONSOLE_IS_IN_ENV
/* Called after the relocation - use desired console functions */
int console_init_r(void)
{
348091ac:	e92d4070 	push	{r4, r5, r6, lr}
#ifdef CONFIG_CONSOLE_MUX
	int iomux_err = 0;
#endif

	/* set default handlers at first */
	gd->jt[XF_getc] = serial_getc;
348091b0:	e5821004 	str	r1, [r2, #4]
	gd->jt[XF_tstc] = serial_tstc;
348091b4:	e5982054 	ldr	r2, [r8, #84]	; 0x54
348091b8:	e59f1118 	ldr	r1, [pc, #280]	; 348092d8 <console_init_r+0x134>
	gd->jt[XF_puts] = serial_puts;
	gd->jt[XF_printf] = serial_printf;

	/* stdin stdout and stderr are in environment */
	/* scan for it */
	stdinname  = getenv("stdin");
348091bc:	e59f0118 	ldr	r0, [pc, #280]	; 348092dc <console_init_r+0x138>
	int iomux_err = 0;
#endif

	/* set default handlers at first */
	gd->jt[XF_getc] = serial_getc;
	gd->jt[XF_tstc] = serial_tstc;
348091c0:	e5821008 	str	r1, [r2, #8]
	gd->jt[XF_putc] = serial_putc;
348091c4:	e5982054 	ldr	r2, [r8, #84]	; 0x54
348091c8:	e59f1110 	ldr	r1, [pc, #272]	; 348092e0 <console_init_r+0x13c>
348091cc:	e582100c 	str	r1, [r2, #12]
	gd->jt[XF_puts] = serial_puts;
348091d0:	e5982054 	ldr	r2, [r8, #84]	; 0x54
348091d4:	e59f1108 	ldr	r1, [pc, #264]	; 348092e4 <console_init_r+0x140>
	gd->jt[XF_printf] = serial_printf;
348091d8:	e5983054 	ldr	r3, [r8, #84]	; 0x54

	/* set default handlers at first */
	gd->jt[XF_getc] = serial_getc;
	gd->jt[XF_tstc] = serial_tstc;
	gd->jt[XF_putc] = serial_putc;
	gd->jt[XF_puts] = serial_puts;
348091dc:	e5821010 	str	r1, [r2, #16]
	gd->jt[XF_printf] = serial_printf;
348091e0:	e59f2100 	ldr	r2, [pc, #256]	; 348092e8 <console_init_r+0x144>
348091e4:	e5832014 	str	r2, [r3, #20]

	/* stdin stdout and stderr are in environment */
	/* scan for it */
	stdinname  = getenv("stdin");
348091e8:	ebfffc13 	bl	3480823c <getenv>
348091ec:	e1a04000 	mov	r4, r0
	stdoutname = getenv("stdout");
348091f0:	e59f00f4 	ldr	r0, [pc, #244]	; 348092ec <console_init_r+0x148>
348091f4:	ebfffc10 	bl	3480823c <getenv>
348091f8:	e1a06000 	mov	r6, r0
	stderrname = getenv("stderr");
348091fc:	e59f00ec 	ldr	r0, [pc, #236]	; 348092f0 <console_init_r+0x14c>
34809200:	ebfffc0d 	bl	3480823c <getenv>

	if (OVERWRITE_CONSOLE == 0) {	/* if not overwritten by config switch */
		inputdev  = search_device(DEV_FLAGS_INPUT,  stdinname);
34809204:	e1a01004 	mov	r1, r4

	/* stdin stdout and stderr are in environment */
	/* scan for it */
	stdinname  = getenv("stdin");
	stdoutname = getenv("stdout");
	stderrname = getenv("stderr");
34809208:	e1a05000 	mov	r5, r0

	if (OVERWRITE_CONSOLE == 0) {	/* if not overwritten by config switch */
		inputdev  = search_device(DEV_FLAGS_INPUT,  stdinname);
3480920c:	e3a00001 	mov	r0, #1
34809210:	ebffff97 	bl	34809074 <search_device>
		outputdev = search_device(DEV_FLAGS_OUTPUT, stdoutname);
34809214:	e1a01006 	mov	r1, r6
	stdinname  = getenv("stdin");
	stdoutname = getenv("stdout");
	stderrname = getenv("stderr");

	if (OVERWRITE_CONSOLE == 0) {	/* if not overwritten by config switch */
		inputdev  = search_device(DEV_FLAGS_INPUT,  stdinname);
34809218:	e1a04000 	mov	r4, r0
		outputdev = search_device(DEV_FLAGS_OUTPUT, stdoutname);
3480921c:	e3a00002 	mov	r0, #2
34809220:	ebffff93 	bl	34809074 <search_device>
		errdev    = search_device(DEV_FLAGS_OUTPUT, stderrname);
34809224:	e1a01005 	mov	r1, r5
	stdoutname = getenv("stdout");
	stderrname = getenv("stderr");

	if (OVERWRITE_CONSOLE == 0) {	/* if not overwritten by config switch */
		inputdev  = search_device(DEV_FLAGS_INPUT,  stdinname);
		outputdev = search_device(DEV_FLAGS_OUTPUT, stdoutname);
34809228:	e1a06000 	mov	r6, r0
		errdev    = search_device(DEV_FLAGS_OUTPUT, stderrname);
3480922c:	e3a00002 	mov	r0, #2
34809230:	ebffff8f 	bl	34809074 <search_device>
			/* Successful, so skip all the code below. */
			goto done;
#endif
	}
	/* if the devices are overwritten or not found, use default device */
	if (inputdev == NULL) {
34809234:	e3540000 	cmp	r4, #0
	stderrname = getenv("stderr");

	if (OVERWRITE_CONSOLE == 0) {	/* if not overwritten by config switch */
		inputdev  = search_device(DEV_FLAGS_INPUT,  stdinname);
		outputdev = search_device(DEV_FLAGS_OUTPUT, stdoutname);
		errdev    = search_device(DEV_FLAGS_OUTPUT, stderrname);
34809238:	e1a05000 	mov	r5, r0
			/* Successful, so skip all the code below. */
			goto done;
#endif
	}
	/* if the devices are overwritten or not found, use default device */
	if (inputdev == NULL) {
3480923c:	1a000003 	bne	34809250 <console_init_r+0xac>
		inputdev  = search_device(DEV_FLAGS_INPUT,  "serial");
34809240:	e3a00001 	mov	r0, #1
34809244:	e59f10a8 	ldr	r1, [pc, #168]	; 348092f4 <console_init_r+0x150>
34809248:	ebffff89 	bl	34809074 <search_device>
3480924c:	e1a04000 	mov	r4, r0
	}
	if (outputdev == NULL) {
34809250:	e3560000 	cmp	r6, #0
34809254:	1a000003 	bne	34809268 <console_init_r+0xc4>
		outputdev = search_device(DEV_FLAGS_OUTPUT, "serial");
34809258:	e3a00002 	mov	r0, #2
3480925c:	e59f1090 	ldr	r1, [pc, #144]	; 348092f4 <console_init_r+0x150>
34809260:	ebffff83 	bl	34809074 <search_device>
34809264:	e1a06000 	mov	r6, r0
	}
	if (errdev == NULL) {
34809268:	e3550000 	cmp	r5, #0
3480926c:	1a000003 	bne	34809280 <console_init_r+0xdc>
		errdev    = search_device(DEV_FLAGS_OUTPUT, "serial");
34809270:	e3a00002 	mov	r0, #2
34809274:	e59f1078 	ldr	r1, [pc, #120]	; 348092f4 <console_init_r+0x150>
34809278:	ebffff7d 	bl	34809074 <search_device>
3480927c:	e1a05000 	mov	r5, r0
	}
	/* Initializes output console first */
	if (outputdev != NULL) {
34809280:	e3560000 	cmp	r6, #0
34809284:	0a000002 	beq	34809294 <console_init_r+0xf0>
	printf("%s\n", stdio_devices[file]->name);
}

static inline void console_doenv(int file, struct stdio_dev *dev)
{
	console_setfile(file, dev);
34809288:	e3a00001 	mov	r0, #1
3480928c:	e1a01006 	mov	r1, r6
34809290:	ebfffe90 	bl	34808cd8 <console_setfile>
	/* Initializes output console first */
	if (outputdev != NULL) {
		/* need to set a console if not done above. */
		console_doenv(stdout, outputdev);
	}
	if (errdev != NULL) {
34809294:	e3550000 	cmp	r5, #0
34809298:	0a000002 	beq	348092a8 <console_init_r+0x104>
	printf("%s\n", stdio_devices[file]->name);
}

static inline void console_doenv(int file, struct stdio_dev *dev)
{
	console_setfile(file, dev);
3480929c:	e3a00002 	mov	r0, #2
348092a0:	e1a01005 	mov	r1, r5
348092a4:	ebfffe8b 	bl	34808cd8 <console_setfile>
	}
	if (errdev != NULL) {
		/* need to set a console if not done above. */
		console_doenv(stderr, errdev);
	}
	if (inputdev != NULL) {
348092a8:	e3540000 	cmp	r4, #0
348092ac:	0a000002 	beq	348092bc <console_init_r+0x118>
	printf("%s\n", stdio_devices[file]->name);
}

static inline void console_doenv(int file, struct stdio_dev *dev)
{
	console_setfile(file, dev);
348092b0:	e3a00000 	mov	r0, #0
348092b4:	e1a01004 	mov	r1, r4
348092b8:	ebfffe86 	bl	34808cd8 <console_setfile>

#ifdef CONFIG_CONSOLE_MUX
done:
#endif

	gd->flags |= GD_FLG_DEVINIT;	/* device initialization completed */
348092bc:	e5982004 	ldr	r2, [r8, #4]
348092c0:	e3822002 	orr	r2, r2, #2
348092c4:	e5882004 	str	r2, [r8, #4]

	stdio_print_current_devices();
348092c8:	ebffff87 	bl	348090ec <stdio_print_current_devices>
	/* If nothing usable installed, use only the initial console */
	if ((stdio_devices[stdin] == NULL) && (stdio_devices[stdout] == NULL))
		return 0;
#endif
	return 0;
}
348092cc:	e3a00000 	mov	r0, #0
348092d0:	e8bd8070 	pop	{r4, r5, r6, pc}
348092d4:	3480e264 	.word	0x3480e264
348092d8:	3480e278 	.word	0x3480e278
348092dc:	348256e0 	.word	0x348256e0
348092e0:	3480e28c 	.word	0x3480e28c
348092e4:	3480e2a8 	.word	0x3480e2a8
348092e8:	34808d7c 	.word	0x34808d7c
348092ec:	348256e6 	.word	0x348256e6
348092f0:	348256ed 	.word	0x348256ed
348092f4:	34825f97 	.word	0x34825f97

348092f8 <sbrk>:
ulong mem_malloc_start = 0;
ulong mem_malloc_end = 0;
ulong mem_malloc_brk = 0;

void *sbrk(ptrdiff_t increment)
{
348092f8:	e92d4038 	push	{r3, r4, r5, lr}
	ulong old = mem_malloc_brk;
348092fc:	e59f304c 	ldr	r3, [pc, #76]	; 34809350 <sbrk+0x58>

	/*
	 * if we are giving memory back make sure we clear it out since
	 * we set MORECORE_CLEARS to 1
	 */
	if (increment < 0)
34809300:	e3500000 	cmp	r0, #0
ulong mem_malloc_end = 0;
ulong mem_malloc_brk = 0;

void *sbrk(ptrdiff_t increment)
{
	ulong old = mem_malloc_brk;
34809304:	e5935000 	ldr	r5, [r3]
ulong mem_malloc_start = 0;
ulong mem_malloc_end = 0;
ulong mem_malloc_brk = 0;

void *sbrk(ptrdiff_t increment)
{
34809308:	e1a02000 	mov	r2, r0
	ulong old = mem_malloc_brk;
	ulong new = old + increment;
3480930c:	e0804005 	add	r4, r0, r5

	/*
	 * if we are giving memory back make sure we clear it out since
	 * we set MORECORE_CLEARS to 1
	 */
	if (increment < 0)
34809310:	aa000003 	bge	34809324 <sbrk+0x2c>
		memset((void *)new, 0, -increment);
34809314:	e1a00004 	mov	r0, r4
34809318:	e3a01000 	mov	r1, #0
3480931c:	e2622000 	rsb	r2, r2, #0
34809320:	eb003eb6 	bl	34818e00 <memset>

	if ((new < mem_malloc_start) || (new > mem_malloc_end))
34809324:	e59f3024 	ldr	r3, [pc, #36]	; 34809350 <sbrk+0x58>
34809328:	e5932004 	ldr	r2, [r3, #4]
3480932c:	e1540002 	cmp	r4, r2
		return (void *)MORECORE_FAILURE;
34809330:	33e00000 	mvncc	r0, #0
	 * we set MORECORE_CLEARS to 1
	 */
	if (increment < 0)
		memset((void *)new, 0, -increment);

	if ((new < mem_malloc_start) || (new > mem_malloc_end))
34809334:	38bd8038 	popcc	{r3, r4, r5, pc}
34809338:	e5932008 	ldr	r2, [r3, #8]
3480933c:	e1540002 	cmp	r4, r2
		return (void *)MORECORE_FAILURE;

	mem_malloc_brk = new;
34809340:	95834000 	strls	r4, [r3]

	return (void *)old;
34809344:	91a00005 	movls	r0, r5
	 */
	if (increment < 0)
		memset((void *)new, 0, -increment);

	if ((new < mem_malloc_start) || (new > mem_malloc_end))
		return (void *)MORECORE_FAILURE;
34809348:	83e00000 	mvnhi	r0, #0

	mem_malloc_brk = new;

	return (void *)old;
}
3480934c:	e8bd8038 	pop	{r3, r4, r5, pc}
34809350:	348294e0 	.word	0x348294e0

34809354 <mem_malloc_init>:

void mem_malloc_init(ulong start, ulong size)
{
34809354:	e1a02001 	mov	r2, r1
	mem_malloc_start = start;
34809358:	e59f1010 	ldr	r1, [pc, #16]	; 34809370 <mem_malloc_init+0x1c>
	mem_malloc_end = start + size;
3480935c:	e082c000 	add	ip, r2, r0
	return (void *)old;
}

void mem_malloc_init(ulong start, ulong size)
{
	mem_malloc_start = start;
34809360:	e9811001 	stmib	r1, {r0, ip}
	mem_malloc_end = start + size;
	mem_malloc_brk = start;
34809364:	e5810000 	str	r0, [r1]

	memset((void *)mem_malloc_start, 0, size);
34809368:	e3a01000 	mov	r1, #0
3480936c:	ea003ea3 	b	34818e00 <memset>
34809370:	348294e0 	.word	0x348294e0

34809374 <malloc_trim>:
#if __STD_C
int malloc_trim(size_t pad)
#else
int malloc_trim(pad) size_t pad;
#endif
{
34809374:	e92d4070 	push	{r4, r5, r6, lr}
  char* current_brk;     /* address returned by pre-check sbrk call */
  char* new_brk;         /* address returned by negative sbrk call */

  unsigned long pagesz = malloc_getpagesize;

  top_size = chunksize(top);
34809378:	e59f40bc 	ldr	r4, [pc, #188]	; 3480943c <malloc_trim+0xc8>
3480937c:	e5943008 	ldr	r3, [r4, #8]
34809380:	e5936004 	ldr	r6, [r3, #4]
34809384:	e3c66003 	bic	r6, r6, #3
  extra = ((top_size - pad - MINSIZE + (pagesz-1)) / pagesz - 1) * pagesz;
34809388:	e0605006 	rsb	r5, r0, r6
3480938c:	e2855efe 	add	r5, r5, #4064	; 0xfe0
34809390:	e285500f 	add	r5, r5, #15
34809394:	e3c55eff 	bic	r5, r5, #4080	; 0xff0
34809398:	e3c5500f 	bic	r5, r5, #15
3480939c:	e2455a01 	sub	r5, r5, #4096	; 0x1000

  if (extra < (long)pagesz)  /* Not enough memory to release */
348093a0:	e3550a01 	cmp	r5, #4096	; 0x1000
348093a4:	ba000020 	blt	3480942c <malloc_trim+0xb8>
    return 0;

  else
  {
    /* Test to make sure no one else called sbrk */
    current_brk = (char*)(MORECORE (0));
348093a8:	e3a00000 	mov	r0, #0
348093ac:	ebffffd1 	bl	348092f8 <sbrk>
    if (current_brk != (char*)(top) + top_size)
348093b0:	e5943008 	ldr	r3, [r4, #8]
348093b4:	e0833006 	add	r3, r3, r6
348093b8:	e1500003 	cmp	r0, r3
348093bc:	1a00001a 	bne	3480942c <malloc_trim+0xb8>
      return 0;     /* Apparently we don't own memory; must fail */

    else
    {
      new_brk = (char*)(MORECORE (-extra));
348093c0:	e2650000 	rsb	r0, r5, #0
348093c4:	ebffffcb 	bl	348092f8 <sbrk>

      if (new_brk == (char*)(MORECORE_FAILURE)) /* sbrk failed? */
348093c8:	e3700001 	cmn	r0, #1
348093cc:	1a00000c 	bne	34809404 <malloc_trim+0x90>
      {
	/* Try to figure out what we have */
	current_brk = (char*)(MORECORE (0));
348093d0:	e2800001 	add	r0, r0, #1
348093d4:	ebffffc7 	bl	348092f8 <sbrk>
	top_size = current_brk - (char*)top;
348093d8:	e5943008 	ldr	r3, [r4, #8]
348093dc:	e0632000 	rsb	r2, r3, r0
	if (top_size >= (long)MINSIZE) /* if not, we are very very dead! */
348093e0:	e352000f 	cmp	r2, #15
348093e4:	da000012 	ble	34809434 <malloc_trim+0xc0>
	{
	  sbrked_mem = current_brk - sbrk_base;
348093e8:	e5941408 	ldr	r1, [r4, #1032]	; 0x408
	  set_head(top, top_size | PREV_INUSE);
348093ec:	e3822001 	orr	r2, r2, #1
	/* Try to figure out what we have */
	current_brk = (char*)(MORECORE (0));
	top_size = current_brk - (char*)top;
	if (top_size >= (long)MINSIZE) /* if not, we are very very dead! */
	{
	  sbrked_mem = current_brk - sbrk_base;
348093f0:	e0610000 	rsb	r0, r1, r0
348093f4:	e59f1044 	ldr	r1, [pc, #68]	; 34809440 <malloc_trim+0xcc>
	  set_head(top, top_size | PREV_INUSE);
348093f8:	e5832004 	str	r2, [r3, #4]
	/* Try to figure out what we have */
	current_brk = (char*)(MORECORE (0));
	top_size = current_brk - (char*)top;
	if (top_size >= (long)MINSIZE) /* if not, we are very very dead! */
	{
	  sbrked_mem = current_brk - sbrk_base;
348093fc:	e581000c 	str	r0, [r1, #12]
34809400:	ea000009 	b	3480942c <malloc_trim+0xb8>
      }

      else
      {
	/* Success. Adjust top accordingly. */
	set_head(top, (top_size - extra) | PREV_INUSE);
34809404:	e5943008 	ldr	r3, [r4, #8]
34809408:	e0656006 	rsb	r6, r5, r6
3480940c:	e3866001 	orr	r6, r6, #1
34809410:	e5836004 	str	r6, [r3, #4]
	sbrked_mem -= extra;
34809414:	e59f3024 	ldr	r3, [pc, #36]	; 34809440 <malloc_trim+0xcc>
	check_chunk(top);
	return 1;
34809418:	e3a00001 	mov	r0, #1

      else
      {
	/* Success. Adjust top accordingly. */
	set_head(top, (top_size - extra) | PREV_INUSE);
	sbrked_mem -= extra;
3480941c:	e593200c 	ldr	r2, [r3, #12]
34809420:	e0655002 	rsb	r5, r5, r2
34809424:	e583500c 	str	r5, [r3, #12]
	check_chunk(top);
	return 1;
34809428:	e8bd8070 	pop	{r4, r5, r6, pc}
  else
  {
    /* Test to make sure no one else called sbrk */
    current_brk = (char*)(MORECORE (0));
    if (current_brk != (char*)(top) + top_size)
      return 0;     /* Apparently we don't own memory; must fail */
3480942c:	e3a00000 	mov	r0, #0
34809430:	e8bd8070 	pop	{r4, r5, r6, pc}
	{
	  sbrked_mem = current_brk - sbrk_base;
	  set_head(top, top_size | PREV_INUSE);
	}
	check_chunk(top);
	return 0;
34809434:	e3a00000 	mov	r0, #0
	check_chunk(top);
	return 1;
      }
    }
  }
}
34809438:	e8bd8070 	pop	{r4, r5, r6, pc}
3480943c:	348283c8 	.word	0x348283c8
34809440:	348294e0 	.word	0x348294e0

34809444 <free>:
#if __STD_C
void fREe(Void_t* mem)
#else
void fREe(mem) Void_t* mem;
#endif
{
34809444:	e92d4070 	push	{r4, r5, r6, lr}
  INTERNAL_SIZE_T prevsz; /* size of previous contiguous chunk */
  mchunkptr bck;       /* misc temp for linking */
  mchunkptr fwd;       /* misc temp for linking */
  int       islr;      /* track whether merging with last_remainder */

  if (mem == 0)                              /* free(0) has no effect */
34809448:	e2504000 	subs	r4, r0, #0
3480944c:	08bd8070 	popeq	{r4, r5, r6, pc}
    return;

  p = mem2chunk(mem);
  hd = p->size;
34809450:	e5140004 	ldr	r0, [r4, #-4]

  sz = hd & ~PREV_INUSE;
  next = chunk_at_offset(p, sz);
  nextsz = chunksize(next);

  if (next == top)                            /* merge with top */
34809454:	e59f51fc 	ldr	r5, [pc, #508]	; 34809658 <free+0x214>
  }
#endif

  check_inuse_chunk(p);

  sz = hd & ~PREV_INUSE;
34809458:	e3c02001 	bic	r2, r0, #1
  int       islr;      /* track whether merging with last_remainder */

  if (mem == 0)                              /* free(0) has no effect */
    return;

  p = mem2chunk(mem);
3480945c:	e2443008 	sub	r3, r4, #8
#endif

  check_inuse_chunk(p);

  sz = hd & ~PREV_INUSE;
  next = chunk_at_offset(p, sz);
34809460:	e0831002 	add	r1, r3, r2
  nextsz = chunksize(next);

  if (next == top)                            /* merge with top */
34809464:	e5956008 	ldr	r6, [r5, #8]

  check_inuse_chunk(p);

  sz = hd & ~PREV_INUSE;
  next = chunk_at_offset(p, sz);
  nextsz = chunksize(next);
34809468:	e591c004 	ldr	ip, [r1, #4]

  if (next == top)                            /* merge with top */
3480946c:	e1510006 	cmp	r1, r6

  check_inuse_chunk(p);

  sz = hd & ~PREV_INUSE;
  next = chunk_at_offset(p, sz);
  nextsz = chunksize(next);
34809470:	e3ccc003 	bic	ip, ip, #3
34809474:	e2000001 	and	r0, r0, #1

  if (next == top)                            /* merge with top */
34809478:	1a000014 	bne	348094d0 <free+0x8c>
  {
    sz += nextsz;

    if (!(hd & PREV_INUSE))                    /* consolidate backward */
3480947c:	e3500000 	cmp	r0, #0
  next = chunk_at_offset(p, sz);
  nextsz = chunksize(next);

  if (next == top)                            /* merge with top */
  {
    sz += nextsz;
34809480:	e08c2002 	add	r2, ip, r2

    if (!(hd & PREV_INUSE))                    /* consolidate backward */
34809484:	1a000006 	bne	348094a4 <free+0x60>
    {
      prevsz = p->prev_size;
34809488:	e5141008 	ldr	r1, [r4, #-8]
      p = chunk_at_offset(p, -((long) prevsz));
3480948c:	e0613003 	rsb	r3, r1, r3
      sz += prevsz;
      unlink(p, bck, fwd);
34809490:	e5930008 	ldr	r0, [r3, #8]

    if (!(hd & PREV_INUSE))                    /* consolidate backward */
    {
      prevsz = p->prev_size;
      p = chunk_at_offset(p, -((long) prevsz));
      sz += prevsz;
34809494:	e0822001 	add	r2, r2, r1
      unlink(p, bck, fwd);
34809498:	e593100c 	ldr	r1, [r3, #12]
3480949c:	e580100c 	str	r1, [r0, #12]
348094a0:	e5810008 	str	r0, [r1, #8]
    }

    set_head(p, sz | PREV_INUSE);
348094a4:	e3821001 	orr	r1, r2, #1
348094a8:	e5831004 	str	r1, [r3, #4]
    top = p;
348094ac:	e59f11a4 	ldr	r1, [pc, #420]	; 34809658 <free+0x214>
348094b0:	e5813008 	str	r3, [r1, #8]
    if ((unsigned long)(sz) >= (unsigned long)trim_threshold)
348094b4:	e591340c 	ldr	r3, [r1, #1036]	; 0x40c
348094b8:	e1520003 	cmp	r2, r3
348094bc:	38bd8070 	popcc	{r4, r5, r6, pc}
      malloc_trim(top_pad);
348094c0:	e59f3194 	ldr	r3, [pc, #404]	; 3480965c <free+0x218>
348094c4:	e5930034 	ldr	r0, [r3, #52]	; 0x34

  set_head(p, sz | PREV_INUSE);
  set_foot(p, sz);
  if (!islr)
    frontlink(p, sz, idx, bck, fwd);
}
348094c8:	e8bd4070 	pop	{r4, r5, r6, lr}
    }

    set_head(p, sz | PREV_INUSE);
    top = p;
    if ((unsigned long)(sz) >= (unsigned long)trim_threshold)
      malloc_trim(top_pad);
348094cc:	eaffffa8 	b	34809374 <malloc_trim>

  set_head(next, nextsz);                    /* clear inuse bit */

  islr = 0;

  if (!(hd & PREV_INUSE))                    /* consolidate backward */
348094d0:	e3500000 	cmp	r0, #0
    if ((unsigned long)(sz) >= (unsigned long)trim_threshold)
      malloc_trim(top_pad);
    return;
  }

  set_head(next, nextsz);                    /* clear inuse bit */
348094d4:	e581c004 	str	ip, [r1, #4]

  islr = 0;
348094d8:	13a00000 	movne	r0, #0

  if (!(hd & PREV_INUSE))                    /* consolidate backward */
348094dc:	1a000009 	bne	34809508 <free+0xc4>
  {
    prevsz = p->prev_size;
348094e0:	e5144008 	ldr	r4, [r4, #-8]
    p = chunk_at_offset(p, -((long) prevsz));
    sz += prevsz;

    if (p->fd == last_remainder)             /* keep as last_remainder */
348094e4:	e2855008 	add	r5, r5, #8
  islr = 0;

  if (!(hd & PREV_INUSE))                    /* consolidate backward */
  {
    prevsz = p->prev_size;
    p = chunk_at_offset(p, -((long) prevsz));
348094e8:	e0643003 	rsb	r3, r4, r3
    sz += prevsz;
348094ec:	e0822004 	add	r2, r2, r4

    if (p->fd == last_remainder)             /* keep as last_remainder */
348094f0:	e5934008 	ldr	r4, [r3, #8]
348094f4:	e1540005 	cmp	r4, r5
      islr = 1;
    else
      unlink(p, bck, fwd);
348094f8:	1593500c 	ldrne	r5, [r3, #12]
    prevsz = p->prev_size;
    p = chunk_at_offset(p, -((long) prevsz));
    sz += prevsz;

    if (p->fd == last_remainder)             /* keep as last_remainder */
      islr = 1;
348094fc:	03a00001 	moveq	r0, #1
    else
      unlink(p, bck, fwd);
34809500:	1584500c 	strne	r5, [r4, #12]
34809504:	15854008 	strne	r4, [r5, #8]
  }

  if (!(inuse_bit_at_offset(next, nextsz)))   /* consolidate forward */
34809508:	e081400c 	add	r4, r1, ip
3480950c:	e5944004 	ldr	r4, [r4, #4]
34809510:	e3140001 	tst	r4, #1
34809514:	1a000010 	bne	3480955c <free+0x118>
  {
    sz += nextsz;

    if (!islr && next->fd == last_remainder)  /* re-insert last_remainder */
34809518:	e3500000 	cmp	r0, #0
      unlink(p, bck, fwd);
  }

  if (!(inuse_bit_at_offset(next, nextsz)))   /* consolidate forward */
  {
    sz += nextsz;
3480951c:	e082200c 	add	r2, r2, ip

    if (!islr && next->fd == last_remainder)  /* re-insert last_remainder */
34809520:	1a000009 	bne	3480954c <free+0x108>
34809524:	e591c008 	ldr	ip, [r1, #8]
34809528:	e59f4130 	ldr	r4, [pc, #304]	; 34809660 <free+0x21c>
3480952c:	e15c0004 	cmp	ip, r4
34809530:	1a000005 	bne	3480954c <free+0x108>
    {
      islr = 1;
      link_last_remainder(p);
34809534:	e58c300c 	str	r3, [ip, #12]
34809538:	e58c3008 	str	r3, [ip, #8]
3480953c:	e583c00c 	str	ip, [r3, #12]
34809540:	e583c008 	str	ip, [r3, #8]
  {
    sz += nextsz;

    if (!islr && next->fd == last_remainder)  /* re-insert last_remainder */
    {
      islr = 1;
34809544:	e2800001 	add	r0, r0, #1
      link_last_remainder(p);
34809548:	ea000003 	b	3480955c <free+0x118>
    }
    else
      unlink(next, bck, fwd);
3480954c:	e591c00c 	ldr	ip, [r1, #12]
34809550:	e5911008 	ldr	r1, [r1, #8]
34809554:	e581c00c 	str	ip, [r1, #12]
34809558:	e58c1008 	str	r1, [ip, #8]
  }


  set_head(p, sz | PREV_INUSE);
3480955c:	e3821001 	orr	r1, r2, #1
  set_foot(p, sz);
  if (!islr)
34809560:	e3500000 	cmp	r0, #0
    else
      unlink(next, bck, fwd);
  }


  set_head(p, sz | PREV_INUSE);
34809564:	e5831004 	str	r1, [r3, #4]
  set_foot(p, sz);
34809568:	e7832002 	str	r2, [r3, r2]
  if (!islr)
3480956c:	18bd8070 	popne	{r4, r5, r6, pc}
    frontlink(p, sz, idx, bck, fwd);
34809570:	e3520c02 	cmp	r2, #512	; 0x200
34809574:	2a000009 	bcs	348095a0 <free+0x15c>
34809578:	e59f10d8 	ldr	r1, [pc, #216]	; 34809658 <free+0x214>
3480957c:	e1a021a2 	lsr	r2, r2, #3
34809580:	e591c004 	ldr	ip, [r1, #4]
34809584:	e1a00142 	asr	r0, r2, #2
34809588:	e3a04001 	mov	r4, #1
3480958c:	e18c0014 	orr	r0, ip, r4, lsl r0
34809590:	e0812182 	add	r2, r1, r2, lsl #3
34809594:	e5810004 	str	r0, [r1, #4]
34809598:	e5921008 	ldr	r1, [r2, #8]
3480959c:	ea000028 	b	34809644 <free+0x200>
348095a0:	e1a004a2 	lsr	r0, r2, #9
348095a4:	e3500004 	cmp	r0, #4
348095a8:	91a00322 	lsrls	r0, r2, #6
348095ac:	92800038 	addls	r0, r0, #56	; 0x38
348095b0:	9a00000f 	bls	348095f4 <free+0x1b0>
348095b4:	e3500014 	cmp	r0, #20
348095b8:	9280005b 	addls	r0, r0, #91	; 0x5b
348095bc:	9a00000c 	bls	348095f4 <free+0x1b0>
348095c0:	e3500054 	cmp	r0, #84	; 0x54
348095c4:	91a00622 	lsrls	r0, r2, #12
348095c8:	9280006e 	addls	r0, r0, #110	; 0x6e
348095cc:	9a000008 	bls	348095f4 <free+0x1b0>
348095d0:	e3500f55 	cmp	r0, #340	; 0x154
348095d4:	91a007a2 	lsrls	r0, r2, #15
348095d8:	92800077 	addls	r0, r0, #119	; 0x77
348095dc:	9a000004 	bls	348095f4 <free+0x1b0>
348095e0:	e3001554 	movw	r1, #1364	; 0x554
348095e4:	e1500001 	cmp	r0, r1
348095e8:	91a00922 	lsrls	r0, r2, #18
348095ec:	9280007c 	addls	r0, r0, #124	; 0x7c
348095f0:	83a0007e 	movhi	r0, #126	; 0x7e
348095f4:	e59fc05c 	ldr	ip, [pc, #92]	; 34809658 <free+0x214>
348095f8:	e08c4180 	add	r4, ip, r0, lsl #3
348095fc:	e5941008 	ldr	r1, [r4, #8]
34809600:	e1510004 	cmp	r1, r4
34809604:	1a000009 	bne	34809630 <free+0x1ec>
34809608:	e59c2004 	ldr	r2, [ip, #4]
3480960c:	e1a00140 	asr	r0, r0, #2
34809610:	e3a04001 	mov	r4, #1
34809614:	e1820014 	orr	r0, r2, r4, lsl r0
34809618:	e1a02001 	mov	r2, r1
3480961c:	e58c0004 	str	r0, [ip, #4]
34809620:	ea000007 	b	34809644 <free+0x200>
34809624:	e5911008 	ldr	r1, [r1, #8]
34809628:	e1510004 	cmp	r1, r4
3480962c:	0a000003 	beq	34809640 <free+0x1fc>
34809630:	e5910004 	ldr	r0, [r1, #4]
34809634:	e3c00003 	bic	r0, r0, #3
34809638:	e1520000 	cmp	r2, r0
3480963c:	3afffff8 	bcc	34809624 <free+0x1e0>
34809640:	e591200c 	ldr	r2, [r1, #12]
34809644:	e583200c 	str	r2, [r3, #12]
34809648:	e5831008 	str	r1, [r3, #8]
3480964c:	e5823008 	str	r3, [r2, #8]
34809650:	e581300c 	str	r3, [r1, #12]
34809654:	e8bd8070 	pop	{r4, r5, r6, pc}
34809658:	348283c8 	.word	0x348283c8
3480965c:	348294e0 	.word	0x348294e0
34809660:	348283d0 	.word	0x348283d0

34809664 <cfree>:
void cfree(Void_t *mem)
#else
void cfree(mem) Void_t *mem;
#endif
{
  fREe(mem);
34809664:	eaffff76 	b	34809444 <free>

34809668 <malloc>:
  mbinptr q;                         /* misc temp */

  INTERNAL_SIZE_T nb;

  /* check if mem_malloc_init() was run */
  if ((mem_malloc_start == 0) && (mem_malloc_end == 0)) {
34809668:	e59f35a0 	ldr	r3, [pc, #1440]	; 34809c10 <malloc+0x5a8>
#if __STD_C
Void_t* mALLOc(size_t bytes)
#else
Void_t* mALLOc(bytes) size_t bytes;
#endif
{
3480966c:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
  mbinptr q;                         /* misc temp */

  INTERNAL_SIZE_T nb;

  /* check if mem_malloc_init() was run */
  if ((mem_malloc_start == 0) && (mem_malloc_end == 0)) {
34809670:	e5932004 	ldr	r2, [r3, #4]
34809674:	e3520000 	cmp	r2, #0
34809678:	1a000003 	bne	3480968c <malloc+0x24>
3480967c:	e5933008 	ldr	r3, [r3, #8]
34809680:	e3530000 	cmp	r3, #0
    /* not initialized yet */
    return 0;
34809684:	01a00003 	moveq	r0, r3
  mbinptr q;                         /* misc temp */

  INTERNAL_SIZE_T nb;

  /* check if mem_malloc_init() was run */
  if ((mem_malloc_start == 0) && (mem_malloc_end == 0)) {
34809688:	08bd8ef0 	popeq	{r4, r5, r6, r7, r9, sl, fp, pc}
    /* not initialized yet */
    return 0;
  }

  if ((long)bytes < 0) return 0;
3480968c:	e3500000 	cmp	r0, #0
34809690:	b3a00000 	movlt	r0, #0
34809694:	b8bd8ef0 	poplt	{r4, r5, r6, r7, r9, sl, fp, pc}

  nb = request2size(bytes);  /* padded request size; */
34809698:	e280400b 	add	r4, r0, #11
3480969c:	e3540016 	cmp	r4, #22
348096a0:	d3a04010 	movle	r4, #16
348096a4:	da000002 	ble	348096b4 <malloc+0x4c>
348096a8:	e3c44007 	bic	r4, r4, #7

  /* Check for exact match in a bin */

  if (is_small_request(nb))  /* Faster version for small requests */
348096ac:	e3540f7e 	cmp	r4, #504	; 0x1f8
348096b0:	2a00000d 	bcs	348096ec <malloc+0x84>
  {
    idx = smallbin_index(nb);

    /* No traversal or size check necessary for small bins.  */

    q = bin_at(idx);
348096b4:	e59f3558 	ldr	r3, [pc, #1368]	; 34809c14 <malloc+0x5ac>

  /* Check for exact match in a bin */

  if (is_small_request(nb))  /* Faster version for small requests */
  {
    idx = smallbin_index(nb);
348096b8:	e1a011a4 	lsr	r1, r4, #3

    /* No traversal or size check necessary for small bins.  */

    q = bin_at(idx);
348096bc:	e0833181 	add	r3, r3, r1, lsl #3
    victim = last(q);
348096c0:	e593000c 	ldr	r0, [r3, #12]

    /* Also scan the next one, since it would have a remainder < MINSIZE */
    if (victim == q)
348096c4:	e1500003 	cmp	r0, r3
348096c8:	1a000004 	bne	348096e0 <malloc+0x78>
    {
      q = next_bin(q);
348096cc:	e2803008 	add	r3, r0, #8
      victim = last(q);
348096d0:	e593000c 	ldr	r0, [r3, #12]
    }
    if (victim != q)
348096d4:	e1500003 	cmp	r0, r3
      set_inuse_bit_at_offset(victim, victim_size);
      check_malloced_chunk(victim, nb);
      return chunk2mem(victim);
    }

    idx += 2; /* Set for bin scan below. We've already scanned 2 bins. */
348096d8:	02811002 	addeq	r1, r1, #2
    if (victim == q)
    {
      q = next_bin(q);
      victim = last(q);
    }
    if (victim != q)
348096dc:	0a00002e 	beq	3480979c <malloc+0x134>
    {
      victim_size = chunksize(victim);
348096e0:	e5903004 	ldr	r3, [r0, #4]
348096e4:	e3c33003 	bic	r3, r3, #3
348096e8:	ea000022 	b	34809778 <malloc+0x110>
    idx += 2; /* Set for bin scan below. We've already scanned 2 bins. */

  }
  else
  {
    idx = bin_index(nb);
348096ec:	e1b014a4 	lsrs	r1, r4, #9
348096f0:	01a011a4 	lsreq	r1, r4, #3
348096f4:	0a000013 	beq	34809748 <malloc+0xe0>
348096f8:	e3510004 	cmp	r1, #4
348096fc:	91a01324 	lsrls	r1, r4, #6
34809700:	92811038 	addls	r1, r1, #56	; 0x38
34809704:	9a00000f 	bls	34809748 <malloc+0xe0>
34809708:	e3510014 	cmp	r1, #20
3480970c:	9281105b 	addls	r1, r1, #91	; 0x5b
34809710:	9a00000c 	bls	34809748 <malloc+0xe0>
34809714:	e3510054 	cmp	r1, #84	; 0x54
34809718:	91a01624 	lsrls	r1, r4, #12
3480971c:	9281106e 	addls	r1, r1, #110	; 0x6e
34809720:	9a000008 	bls	34809748 <malloc+0xe0>
34809724:	e3510f55 	cmp	r1, #340	; 0x154
34809728:	91a017a4 	lsrls	r1, r4, #15
3480972c:	92811077 	addls	r1, r1, #119	; 0x77
34809730:	9a000004 	bls	34809748 <malloc+0xe0>
34809734:	e3003554 	movw	r3, #1364	; 0x554
34809738:	e1510003 	cmp	r1, r3
3480973c:	91a01924 	lsrls	r1, r4, #18
34809740:	9281107c 	addls	r1, r1, #124	; 0x7c
34809744:	83a0107e 	movhi	r1, #126	; 0x7e
    bin = bin_at(idx);
34809748:	e59f24c4 	ldr	r2, [pc, #1220]	; 34809c14 <malloc+0x5ac>
3480974c:	e0822181 	add	r2, r2, r1, lsl #3

    for (victim = last(bin); victim != bin; victim = victim->bk)
34809750:	e592000c 	ldr	r0, [r2, #12]
34809754:	ea00000d 	b	34809790 <malloc+0x128>
    {
      victim_size = chunksize(victim);
34809758:	e5903004 	ldr	r3, [r0, #4]
3480975c:	e3c33003 	bic	r3, r3, #3
      remainder_size = victim_size - nb;
34809760:	e064c003 	rsb	ip, r4, r3

      if (remainder_size >= (long)MINSIZE) /* too big */
34809764:	e35c000f 	cmp	ip, #15
      {
	--idx; /* adjust to rescan below after checking last remainder */
34809768:	c2411001 	subgt	r1, r1, #1
	break;
3480976c:	ca000009 	bgt	34809798 <malloc+0x130>
      }

      else if (remainder_size >= 0) /* exact fit */
34809770:	e35c0000 	cmp	ip, #0
34809774:	ba000004 	blt	3480978c <malloc+0x124>
      {
	unlink(victim, bck, fwd);
34809778:	e590200c 	ldr	r2, [r0, #12]
3480977c:	e5901008 	ldr	r1, [r0, #8]
34809780:	e581200c 	str	r2, [r1, #12]
34809784:	e5821008 	str	r1, [r2, #8]
34809788:	ea00001c 	b	34809800 <malloc+0x198>
  else
  {
    idx = bin_index(nb);
    bin = bin_at(idx);

    for (victim = last(bin); victim != bin; victim = victim->bk)
3480978c:	e590000c 	ldr	r0, [r0, #12]
34809790:	e1500002 	cmp	r0, r2
34809794:	1affffef 	bne	34809758 <malloc+0xf0>
	check_malloced_chunk(victim, nb);
	return chunk2mem(victim);
      }
    }

    ++idx;
34809798:	e2811001 	add	r1, r1, #1

  }

  /* Try to use the last split-off remainder */

  if ( (victim = last_remainder->fd) != last_remainder)
3480979c:	e59f5470 	ldr	r5, [pc, #1136]	; 34809c14 <malloc+0x5ac>
348097a0:	e2852008 	add	r2, r5, #8
348097a4:	e5920008 	ldr	r0, [r2, #8]
348097a8:	e1500002 	cmp	r0, r2
348097ac:	0a000050 	beq	348098f4 <malloc+0x28c>
  {
    victim_size = chunksize(victim);
348097b0:	e5903004 	ldr	r3, [r0, #4]
348097b4:	e3c33003 	bic	r3, r3, #3
    remainder_size = victim_size - nb;
348097b8:	e064c003 	rsb	ip, r4, r3

    if (remainder_size >= (long)MINSIZE) /* re-split */
348097bc:	e35c000f 	cmp	ip, #15
348097c0:	da00000a 	ble	348097f0 <malloc+0x188>
    {
      remainder = chunk_at_offset(victim, nb);
348097c4:	e0803004 	add	r3, r0, r4
      set_head(victim, nb | PREV_INUSE);
      link_last_remainder(remainder);
348097c8:	e582300c 	str	r3, [r2, #12]
348097cc:	e5823008 	str	r3, [r2, #8]
    remainder_size = victim_size - nb;

    if (remainder_size >= (long)MINSIZE) /* re-split */
    {
      remainder = chunk_at_offset(victim, nb);
      set_head(victim, nb | PREV_INUSE);
348097d0:	e3844001 	orr	r4, r4, #1
      link_last_remainder(remainder);
348097d4:	e583200c 	str	r2, [r3, #12]
348097d8:	e5832008 	str	r2, [r3, #8]
      set_head(remainder, remainder_size | PREV_INUSE);
348097dc:	e38c2001 	orr	r2, ip, #1
    remainder_size = victim_size - nb;

    if (remainder_size >= (long)MINSIZE) /* re-split */
    {
      remainder = chunk_at_offset(victim, nb);
      set_head(victim, nb | PREV_INUSE);
348097e0:	e5804004 	str	r4, [r0, #4]
      link_last_remainder(remainder);
      set_head(remainder, remainder_size | PREV_INUSE);
      set_foot(remainder, remainder_size);
348097e4:	e783c00c 	str	ip, [r3, ip]
    if (remainder_size >= (long)MINSIZE) /* re-split */
    {
      remainder = chunk_at_offset(victim, nb);
      set_head(victim, nb | PREV_INUSE);
      link_last_remainder(remainder);
      set_head(remainder, remainder_size | PREV_INUSE);
348097e8:	e5832004 	str	r2, [r3, #4]
348097ec:	ea000103 	b	34809c00 <malloc+0x598>
      return chunk2mem(victim);
    }

    clear_last_remainder;

    if (remainder_size >= 0)  /* exhaust */
348097f0:	e35c0000 	cmp	ip, #0
      set_foot(remainder, remainder_size);
      check_malloced_chunk(victim, nb);
      return chunk2mem(victim);
    }

    clear_last_remainder;
348097f4:	e582200c 	str	r2, [r2, #12]
348097f8:	e5822008 	str	r2, [r2, #8]

    if (remainder_size >= 0)  /* exhaust */
348097fc:	ba000004 	blt	34809814 <malloc+0x1ac>
    {
      set_inuse_bit_at_offset(victim, victim_size);
34809800:	e0803003 	add	r3, r0, r3
34809804:	e5932004 	ldr	r2, [r3, #4]
34809808:	e3822001 	orr	r2, r2, #1
3480980c:	e5832004 	str	r2, [r3, #4]
34809810:	ea0000fa 	b	34809c00 <malloc+0x598>
      return chunk2mem(victim);
    }

    /* Else place in bin */

    frontlink(victim, victim_size, remainder_index, bck, fwd);
34809814:	e3530c02 	cmp	r3, #512	; 0x200
34809818:	2a000008 	bcs	34809840 <malloc+0x1d8>
3480981c:	e1a031a3 	lsr	r3, r3, #3
34809820:	e5956004 	ldr	r6, [r5, #4]
34809824:	e1a0c143 	asr	ip, r3, #2
34809828:	e3a07001 	mov	r7, #1
3480982c:	e186cc17 	orr	ip, r6, r7, lsl ip
34809830:	e0853183 	add	r3, r5, r3, lsl #3
34809834:	e585c004 	str	ip, [r5, #4]
34809838:	e593c008 	ldr	ip, [r3, #8]
3480983c:	ea000028 	b	348098e4 <malloc+0x27c>
34809840:	e1a064a3 	lsr	r6, r3, #9
34809844:	e3560004 	cmp	r6, #4
34809848:	91a06323 	lsrls	r6, r3, #6
3480984c:	92866038 	addls	r6, r6, #56	; 0x38
34809850:	9a00000f 	bls	34809894 <malloc+0x22c>
34809854:	e3560014 	cmp	r6, #20
34809858:	9286605b 	addls	r6, r6, #91	; 0x5b
3480985c:	9a00000c 	bls	34809894 <malloc+0x22c>
34809860:	e3560054 	cmp	r6, #84	; 0x54
34809864:	91a06623 	lsrls	r6, r3, #12
34809868:	9286606e 	addls	r6, r6, #110	; 0x6e
3480986c:	9a000008 	bls	34809894 <malloc+0x22c>
34809870:	e3560f55 	cmp	r6, #340	; 0x154
34809874:	91a067a3 	lsrls	r6, r3, #15
34809878:	92866077 	addls	r6, r6, #119	; 0x77
3480987c:	9a000004 	bls	34809894 <malloc+0x22c>
34809880:	e300c554 	movw	ip, #1364	; 0x554
34809884:	e156000c 	cmp	r6, ip
34809888:	91a06923 	lsrls	r6, r3, #18
3480988c:	9286607c 	addls	r6, r6, #124	; 0x7c
34809890:	83a0607e 	movhi	r6, #126	; 0x7e
34809894:	e0857186 	add	r7, r5, r6, lsl #3
34809898:	e597c008 	ldr	ip, [r7, #8]
3480989c:	e15c0007 	cmp	ip, r7
348098a0:	1a00000a 	bne	348098d0 <malloc+0x268>
348098a4:	e59f3368 	ldr	r3, [pc, #872]	; 34809c14 <malloc+0x5ac>
348098a8:	e1a06146 	asr	r6, r6, #2
348098ac:	e5937004 	ldr	r7, [r3, #4]
348098b0:	e3a0a001 	mov	sl, #1
348098b4:	e187661a 	orr	r6, r7, sl, lsl r6
348098b8:	e5836004 	str	r6, [r3, #4]
348098bc:	e1a0300c 	mov	r3, ip
348098c0:	ea000007 	b	348098e4 <malloc+0x27c>
348098c4:	e59cc008 	ldr	ip, [ip, #8]
348098c8:	e15c0007 	cmp	ip, r7
348098cc:	0a000003 	beq	348098e0 <malloc+0x278>
348098d0:	e59c6004 	ldr	r6, [ip, #4]
348098d4:	e3c66003 	bic	r6, r6, #3
348098d8:	e1530006 	cmp	r3, r6
348098dc:	3afffff8 	bcc	348098c4 <malloc+0x25c>
348098e0:	e59c300c 	ldr	r3, [ip, #12]
348098e4:	e580300c 	str	r3, [r0, #12]
348098e8:	e580c008 	str	ip, [r0, #8]
348098ec:	e5830008 	str	r0, [r3, #8]
348098f0:	e58c000c 	str	r0, [ip, #12]
  /*
     If there are any possibly nonempty big-enough blocks,
     search for best fitting chunk by scanning bins in blockwidth units.
  */

  if ( (block = idx2binblock(idx)) <= binblocks_r)
348098f4:	e3a00001 	mov	r0, #1
348098f8:	e1a03141 	asr	r3, r1, #2
348098fc:	e1a03310 	lsl	r3, r0, r3
34809900:	e59f030c 	ldr	r0, [pc, #780]	; 34809c14 <malloc+0x5ac>
34809904:	e5900004 	ldr	r0, [r0, #4]
34809908:	e1530000 	cmp	r3, r0
3480990c:	8a00004a 	bhi	34809a3c <malloc+0x3d4>
  {

    /* Get to the first marked block */

    if ( (block & binblocks_r) == 0)
34809910:	e1130000 	tst	r3, r0
34809914:	1a000004 	bne	3480992c <malloc+0x2c4>
    {
      /* force to an even block boundary */
      idx = (idx & ~(BINBLOCKWIDTH - 1)) + BINBLOCKWIDTH;
34809918:	e3c11003 	bic	r1, r1, #3
      block <<= 1;
      while ((block & binblocks_r) == 0)
      {
	idx += BINBLOCKWIDTH;
	block <<= 1;
3480991c:	e1a03083 	lsl	r3, r3, #1
    if ( (block & binblocks_r) == 0)
    {
      /* force to an even block boundary */
      idx = (idx & ~(BINBLOCKWIDTH - 1)) + BINBLOCKWIDTH;
      block <<= 1;
      while ((block & binblocks_r) == 0)
34809920:	e1130000 	tst	r3, r0
      {
	idx += BINBLOCKWIDTH;
34809924:	e2811004 	add	r1, r1, #4
    if ( (block & binblocks_r) == 0)
    {
      /* force to an even block boundary */
      idx = (idx & ~(BINBLOCKWIDTH - 1)) + BINBLOCKWIDTH;
      block <<= 1;
      while ((block & binblocks_r) == 0)
34809928:	0afffffb 	beq	3480991c <malloc+0x2b4>

      do   /* Possibly backtrack to try to clear a partial block */
      {
	if ((startidx & (BINBLOCKWIDTH - 1)) == 0)
	{
	  av_[1] = (mbinptr)(binblocks_r & ~block);
3480992c:	e59fa2e0 	ldr	sl, [pc, #736]	; 34809c14 <malloc+0x5ac>

    /* For each possibly nonempty block ... */
    for (;;)
    {
      startidx = idx;          /* (track incomplete blocks) */
      q = bin = bin_at(idx);
34809930:	e0859181 	add	r9, r5, r1, lsl #3
34809934:	e1a07009 	mov	r7, r9
34809938:	e1a06001 	mov	r6, r1
      /* For each bin in this block ... */
      do
      {
	/* Find and use first big enough chunk ... */

	for (victim = last(bin); victim != bin; victim = victim->bk)
3480993c:	e597000c 	ldr	r0, [r7, #12]
34809940:	ea000020 	b	348099c8 <malloc+0x360>
	{
	  victim_size = chunksize(victim);
34809944:	e590b004 	ldr	fp, [r0, #4]
34809948:	e3cbb003 	bic	fp, fp, #3
	  remainder_size = victim_size - nb;
3480994c:	e064c00b 	rsb	ip, r4, fp

	  if (remainder_size >= (long)MINSIZE) /* split */
34809950:	e35c000f 	cmp	ip, #15
34809954:	da00000f 	ble	34809998 <malloc+0x330>
	  {
	    remainder = chunk_at_offset(victim, nb);
34809958:	e0803004 	add	r3, r0, r4
	    set_head(victim, nb | PREV_INUSE);
3480995c:	e3844001 	orr	r4, r4, #1
	    unlink(victim, bck, fwd);
34809960:	e590100c 	ldr	r1, [r0, #12]
	  remainder_size = victim_size - nb;

	  if (remainder_size >= (long)MINSIZE) /* split */
	  {
	    remainder = chunk_at_offset(victim, nb);
	    set_head(victim, nb | PREV_INUSE);
34809964:	e5804004 	str	r4, [r0, #4]
	    unlink(victim, bck, fwd);
34809968:	e5b04008 	ldr	r4, [r0, #8]!
	    link_last_remainder(remainder);
	    set_head(remainder, remainder_size | PREV_INUSE);
	    set_foot(remainder, remainder_size);
3480996c:	e783c00c 	str	ip, [r3, ip]

	  if (remainder_size >= (long)MINSIZE) /* split */
	  {
	    remainder = chunk_at_offset(victim, nb);
	    set_head(victim, nb | PREV_INUSE);
	    unlink(victim, bck, fwd);
34809970:	e584100c 	str	r1, [r4, #12]
34809974:	e5814008 	str	r4, [r1, #8]
	    link_last_remainder(remainder);
34809978:	e582300c 	str	r3, [r2, #12]
3480997c:	e5823008 	str	r3, [r2, #8]
34809980:	e59f2290 	ldr	r2, [pc, #656]	; 34809c18 <malloc+0x5b0>
34809984:	e583200c 	str	r2, [r3, #12]
34809988:	e5832008 	str	r2, [r3, #8]
	    set_head(remainder, remainder_size | PREV_INUSE);
3480998c:	e38c2001 	orr	r2, ip, #1
34809990:	e5832004 	str	r2, [r3, #4]
	    set_foot(remainder, remainder_size);
	    check_malloced_chunk(victim, nb);
	    return chunk2mem(victim);
34809994:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
	  }

	  else if (remainder_size >= 0)  /* take */
34809998:	e35c0000 	cmp	ip, #0
3480999c:	ba000008 	blt	348099c4 <malloc+0x35c>
	  {
	    set_inuse_bit_at_offset(victim, victim_size);
348099a0:	e080b00b 	add	fp, r0, fp
348099a4:	e59b3004 	ldr	r3, [fp, #4]
348099a8:	e3833001 	orr	r3, r3, #1
348099ac:	e58b3004 	str	r3, [fp, #4]
	    unlink(victim, bck, fwd);
348099b0:	e590300c 	ldr	r3, [r0, #12]
348099b4:	e5b02008 	ldr	r2, [r0, #8]!
348099b8:	e582300c 	str	r3, [r2, #12]
348099bc:	e5832008 	str	r2, [r3, #8]
	    check_malloced_chunk(victim, nb);
	    return chunk2mem(victim);
348099c0:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
      /* For each bin in this block ... */
      do
      {
	/* Find and use first big enough chunk ... */

	for (victim = last(bin); victim != bin; victim = victim->bk)
348099c4:	e590000c 	ldr	r0, [r0, #12]
348099c8:	e1500007 	cmp	r0, r7
348099cc:	1affffdc 	bne	34809944 <malloc+0x2dc>

	}

       bin = next_bin(bin);

      } while ((++idx & (BINBLOCKWIDTH - 1)) != 0);
348099d0:	e2866001 	add	r6, r6, #1
348099d4:	e3160003 	tst	r6, #3
	    return chunk2mem(victim);
	  }

	}

       bin = next_bin(bin);
348099d8:	12877008 	addne	r7, r7, #8
348099dc:	1affffd6 	bne	3480993c <malloc+0x2d4>

      /* Clear out the block bit. */

      do   /* Possibly backtrack to try to clear a partial block */
      {
	if ((startidx & (BINBLOCKWIDTH - 1)) == 0)
348099e0:	e3110003 	tst	r1, #3
	{
	  av_[1] = (mbinptr)(binblocks_r & ~block);
348099e4:	059a1004 	ldreq	r1, [sl, #4]
348099e8:	01c11003 	biceq	r1, r1, r3
348099ec:	058a1004 	streq	r1, [sl, #4]
	  break;
348099f0:	0a000004 	beq	34809a08 <malloc+0x3a0>
	}
	--startidx;
       q = prev_bin(q);
348099f4:	e1a00009 	mov	r0, r9
      } while (first(q) == q);
348099f8:	e4109008 	ldr	r9, [r0], #-8
348099fc:	e1590000 	cmp	r9, r0
	if ((startidx & (BINBLOCKWIDTH - 1)) == 0)
	{
	  av_[1] = (mbinptr)(binblocks_r & ~block);
	  break;
	}
	--startidx;
34809a00:	02411001 	subeq	r1, r1, #1
34809a04:	0afffff5 	beq	348099e0 <malloc+0x378>
       q = prev_bin(q);
      } while (first(q) == q);

      /* Get to the next possibly nonempty block */

      if ( (block <<= 1) <= binblocks_r && (block != 0) )
34809a08:	e59a0004 	ldr	r0, [sl, #4]
34809a0c:	e1a03083 	lsl	r3, r3, #1
34809a10:	e1530000 	cmp	r3, r0
34809a14:	8a000008 	bhi	34809a3c <malloc+0x3d4>
34809a18:	e3530000 	cmp	r3, #0
34809a1c:	0a000006 	beq	34809a3c <malloc+0x3d4>
34809a20:	e1a01006 	mov	r1, r6
34809a24:	ea000001 	b	34809a30 <malloc+0x3c8>
      {
	while ((block & binblocks_r) == 0)
	{
	  idx += BINBLOCKWIDTH;
34809a28:	e2811004 	add	r1, r1, #4
	  block <<= 1;
34809a2c:	e1a03083 	lsl	r3, r3, #1

      /* Get to the next possibly nonempty block */

      if ( (block <<= 1) <= binblocks_r && (block != 0) )
      {
	while ((block & binblocks_r) == 0)
34809a30:	e1130000 	tst	r3, r0
34809a34:	1affffbd 	bne	34809930 <malloc+0x2c8>
34809a38:	eafffffa 	b	34809a28 <malloc+0x3c0>


  /* Try to use top chunk */

  /* Require that there be a remainder, ensuring top always exists  */
  if ( (remainder_size = chunksize(top) - nb) < (long)MINSIZE)
34809a3c:	e59f21d0 	ldr	r2, [pc, #464]	; 34809c14 <malloc+0x5ac>
34809a40:	e5927008 	ldr	r7, [r2, #8]
34809a44:	e5979004 	ldr	r9, [r7, #4]
34809a48:	e3c99003 	bic	r9, r9, #3
34809a4c:	e0643009 	rsb	r3, r4, r9
34809a50:	e353000f 	cmp	r3, #15
34809a54:	ca000061 	bgt	34809be0 <malloc+0x578>
  INTERNAL_SIZE_T old_top_size = chunksize(old_top);
  char*     old_end      = (char*)(chunk_at_offset(old_top, old_top_size));

  /* Pad request with top_pad plus minimal overhead */

  INTERNAL_SIZE_T    sbrk_size     = nb + top_pad + MINSIZE;
34809a58:	e59f31b0 	ldr	r3, [pc, #432]	; 34809c10 <malloc+0x5a8>
34809a5c:	e593a034 	ldr	sl, [r3, #52]	; 0x34

  /* If not the first time through, round to preserve page boundary */
  /* Otherwise, we need to correct to a page size below anyway. */
  /* (We also correct below if an intervening foreign sbrk call.) */

  if (sbrk_base != (char*)(-1))
34809a60:	e5923408 	ldr	r3, [r2, #1032]	; 0x408
  INTERNAL_SIZE_T old_top_size = chunksize(old_top);
  char*     old_end      = (char*)(chunk_at_offset(old_top, old_top_size));

  /* Pad request with top_pad plus minimal overhead */

  INTERNAL_SIZE_T    sbrk_size     = nb + top_pad + MINSIZE;
34809a64:	e28aa010 	add	sl, sl, #16

  /* If not the first time through, round to preserve page boundary */
  /* Otherwise, we need to correct to a page size below anyway. */
  /* (We also correct below if an intervening foreign sbrk call.) */

  if (sbrk_base != (char*)(-1))
34809a68:	e3730001 	cmn	r3, #1
  INTERNAL_SIZE_T old_top_size = chunksize(old_top);
  char*     old_end      = (char*)(chunk_at_offset(old_top, old_top_size));

  /* Pad request with top_pad plus minimal overhead */

  INTERNAL_SIZE_T    sbrk_size     = nb + top_pad + MINSIZE;
34809a6c:	e08aa004 	add	sl, sl, r4
  /* If not the first time through, round to preserve page boundary */
  /* Otherwise, we need to correct to a page size below anyway. */
  /* (We also correct below if an intervening foreign sbrk call.) */

  if (sbrk_base != (char*)(-1))
    sbrk_size = (sbrk_size + (pagesz - 1)) & ~(pagesz - 1);
34809a70:	128aaeff 	addne	sl, sl, #4080	; 0xff0
34809a74:	128aa00f 	addne	sl, sl, #15
34809a78:	13caaeff 	bicne	sl, sl, #4080	; 0xff0
34809a7c:	13caa00f 	bicne	sl, sl, #15

  brk = (char*)(MORECORE (sbrk_size));
34809a80:	e1a0000a 	mov	r0, sl
34809a84:	ebfffe1b 	bl	348092f8 <sbrk>

  /* Fail if sbrk failed or if a foreign sbrk call killed our space */
  if (brk == (char*)(MORECORE_FAILURE) ||
34809a88:	e3700001 	cmn	r0, #1
  /* (We also correct below if an intervening foreign sbrk call.) */

  if (sbrk_base != (char*)(-1))
    sbrk_size = (sbrk_size + (pagesz - 1)) & ~(pagesz - 1);

  brk = (char*)(MORECORE (sbrk_size));
34809a8c:	e1a06000 	mov	r6, r0

  /* Fail if sbrk failed or if a foreign sbrk call killed our space */
  if (brk == (char*)(MORECORE_FAILURE) ||
34809a90:	0a00004b 	beq	34809bc4 <malloc+0x55c>
  char*     new_brk;              /* return of 2nd sbrk call */
  INTERNAL_SIZE_T top_size;       /* new size of top chunk */

  mchunkptr old_top     = top;  /* Record state of old top */
  INTERNAL_SIZE_T old_top_size = chunksize(old_top);
  char*     old_end      = (char*)(chunk_at_offset(old_top, old_top_size));
34809a94:	e0872009 	add	r2, r7, r9
    sbrk_size = (sbrk_size + (pagesz - 1)) & ~(pagesz - 1);

  brk = (char*)(MORECORE (sbrk_size));

  /* Fail if sbrk failed or if a foreign sbrk call killed our space */
  if (brk == (char*)(MORECORE_FAILURE) ||
34809a98:	e1500002 	cmp	r0, r2
34809a9c:	2a000001 	bcs	34809aa8 <malloc+0x440>
      (brk < old_end && old_top != initial_top))
34809aa0:	e1570005 	cmp	r7, r5
34809aa4:	1a000046 	bne	34809bc4 <malloc+0x55c>
    return;

  sbrked_mem += sbrk_size;
34809aa8:	e59f3160 	ldr	r3, [pc, #352]	; 34809c10 <malloc+0x5a8>

  if (brk == old_end) /* can just add bytes to current top */
34809aac:	e1560002 	cmp	r6, r2
  /* Fail if sbrk failed or if a foreign sbrk call killed our space */
  if (brk == (char*)(MORECORE_FAILURE) ||
      (brk < old_end && old_top != initial_top))
    return;

  sbrked_mem += sbrk_size;
34809ab0:	e593000c 	ldr	r0, [r3, #12]
34809ab4:	e59f1158 	ldr	r1, [pc, #344]	; 34809c14 <malloc+0x5ac>
34809ab8:	e08a0000 	add	r0, sl, r0
34809abc:	e583000c 	str	r0, [r3, #12]

  if (brk == old_end) /* can just add bytes to current top */
  {
    top_size = sbrk_size + old_top_size;
    set_head(top, top_size | PREV_INUSE);
34809ac0:	05913008 	ldreq	r3, [r1, #8]

  sbrked_mem += sbrk_size;

  if (brk == old_end) /* can just add bytes to current top */
  {
    top_size = sbrk_size + old_top_size;
34809ac4:	008aa009 	addeq	sl, sl, r9
    set_head(top, top_size | PREV_INUSE);
34809ac8:	038aa001 	orreq	sl, sl, #1
34809acc:	0583a004 	streq	sl, [r3, #4]
34809ad0:	0a000032 	beq	34809ba0 <malloc+0x538>
  }
  else
  {
    if (sbrk_base == (char*)(-1))  /* First time through. Record base */
34809ad4:	e591c408 	ldr	ip, [r1, #1032]	; 0x408
34809ad8:	e37c0001 	cmn	ip, #1
      sbrk_base = brk;
    else  /* Someone else called sbrk().  Count those bytes as sbrked_mem. */
      sbrked_mem += brk - (char*)old_end;
34809adc:	10860000 	addne	r0, r6, r0
34809ae0:	10622000 	rsbne	r2, r2, r0
    set_head(top, top_size | PREV_INUSE);
  }
  else
  {
    if (sbrk_base == (char*)(-1))  /* First time through. Record base */
      sbrk_base = brk;
34809ae4:	05816408 	streq	r6, [r1, #1032]	; 0x408
    else  /* Someone else called sbrk().  Count those bytes as sbrked_mem. */
      sbrked_mem += brk - (char*)old_end;
34809ae8:	1583200c 	strne	r2, [r3, #12]

    /* Guarantee alignment of first new chunk made from this space */
    front_misalign = (unsigned long)chunk2mem(brk) & MALLOC_ALIGN_MASK;
    if (front_misalign > 0)
34809aec:	e2163007 	ands	r3, r6, #7
    {
      correction = (MALLOC_ALIGNMENT) - front_misalign;
34809af0:	12633008 	rsbne	r3, r3, #8
      brk += correction;
34809af4:	10866003 	addne	r6, r6, r3
    else
      correction = 0;

    /* Guarantee the next brk will be at a page boundary */

    correction += ((((unsigned long)(brk + sbrk_size))+(pagesz-1)) &
34809af8:	e086a00a 	add	sl, r6, sl
		   ~(pagesz - 1)) - ((unsigned long)(brk + sbrk_size));
34809afc:	e06a3003 	rsb	r3, sl, r3
    else
      correction = 0;

    /* Guarantee the next brk will be at a page boundary */

    correction += ((((unsigned long)(brk + sbrk_size))+(pagesz-1)) &
34809b00:	e28aaeff 	add	sl, sl, #4080	; 0xff0
34809b04:	e28aa00f 	add	sl, sl, #15
34809b08:	e3caaeff 	bic	sl, sl, #4080	; 0xff0
34809b0c:	e3caa00f 	bic	sl, sl, #15
34809b10:	e083a00a 	add	sl, r3, sl
		   ~(pagesz - 1)) - ((unsigned long)(brk + sbrk_size));

    /* Allocate correction */
    new_brk = (char*)(MORECORE (correction));
34809b14:	e1a0000a 	mov	r0, sl
34809b18:	ebfffdf6 	bl	348092f8 <sbrk>
    if (new_brk == (char*)(MORECORE_FAILURE)) return;
34809b1c:	e3700001 	cmn	r0, #1
34809b20:	0a000027 	beq	34809bc4 <malloc+0x55c>

    sbrked_mem += correction;
34809b24:	e59f30e4 	ldr	r3, [pc, #228]	; 34809c10 <malloc+0x5a8>

    top = (mchunkptr)brk;
    top_size = new_brk - brk + correction;
34809b28:	e0660000 	rsb	r0, r6, r0

    /* Allocate correction */
    new_brk = (char*)(MORECORE (correction));
    if (new_brk == (char*)(MORECORE_FAILURE)) return;

    sbrked_mem += correction;
34809b2c:	e593200c 	ldr	r2, [r3, #12]

    top = (mchunkptr)brk;
    top_size = new_brk - brk + correction;
    set_head(top, top_size | PREV_INUSE);

    if (old_top != initial_top)
34809b30:	e1570005 	cmp	r7, r5

    /* Allocate correction */
    new_brk = (char*)(MORECORE (correction));
    if (new_brk == (char*)(MORECORE_FAILURE)) return;

    sbrked_mem += correction;
34809b34:	e08a2002 	add	r2, sl, r2
34809b38:	e583200c 	str	r2, [r3, #12]

    top = (mchunkptr)brk;
    top_size = new_brk - brk + correction;
34809b3c:	e08aa000 	add	sl, sl, r0
    new_brk = (char*)(MORECORE (correction));
    if (new_brk == (char*)(MORECORE_FAILURE)) return;

    sbrked_mem += correction;

    top = (mchunkptr)brk;
34809b40:	e59f30cc 	ldr	r3, [pc, #204]	; 34809c14 <malloc+0x5ac>
    top_size = new_brk - brk + correction;
    set_head(top, top_size | PREV_INUSE);
34809b44:	e38aa001 	orr	sl, sl, #1
    new_brk = (char*)(MORECORE (correction));
    if (new_brk == (char*)(MORECORE_FAILURE)) return;

    sbrked_mem += correction;

    top = (mchunkptr)brk;
34809b48:	e5836008 	str	r6, [r3, #8]
    top_size = new_brk - brk + correction;
    set_head(top, top_size | PREV_INUSE);
34809b4c:	e586a004 	str	sl, [r6, #4]

    if (old_top != initial_top)
34809b50:	0a000012 	beq	34809ba0 <malloc+0x538>

      /* There must have been an intervening foreign sbrk call. */
      /* A double fencepost is necessary to prevent consolidation */

      /* If not enough space to do this, then user did something very wrong */
      if (old_top_size < MINSIZE)
34809b54:	e359000f 	cmp	r9, #15
      {
	set_head(top, PREV_INUSE); /* will force null return from malloc */
34809b58:	95933008 	ldrls	r3, [r3, #8]
34809b5c:	93a02001 	movls	r2, #1
34809b60:	95832004 	strls	r2, [r3, #4]

      /* There must have been an intervening foreign sbrk call. */
      /* A double fencepost is necessary to prevent consolidation */

      /* If not enough space to do this, then user did something very wrong */
      if (old_top_size < MINSIZE)
34809b64:	9a000016 	bls	34809bc4 <malloc+0x55c>
	return;
      }

      /* Also keep size a multiple of MALLOC_ALIGNMENT */
      old_top_size = (old_top_size - 3*SIZE_SZ) & ~MALLOC_ALIGN_MASK;
      set_head_size(old_top, old_top_size);
34809b68:	e5973004 	ldr	r3, [r7, #4]
	set_head(top, PREV_INUSE); /* will force null return from malloc */
	return;
      }

      /* Also keep size a multiple of MALLOC_ALIGNMENT */
      old_top_size = (old_top_size - 3*SIZE_SZ) & ~MALLOC_ALIGN_MASK;
34809b6c:	e249900c 	sub	r9, r9, #12
34809b70:	e3c99007 	bic	r9, r9, #7
      set_head_size(old_top, old_top_size);
34809b74:	e2033001 	and	r3, r3, #1
34809b78:	e1893003 	orr	r3, r9, r3
34809b7c:	e5873004 	str	r3, [r7, #4]
      chunk_at_offset(old_top, old_top_size          )->size =
34809b80:	e3a02005 	mov	r2, #5
34809b84:	e0873009 	add	r3, r7, r9
	SIZE_SZ|PREV_INUSE;
      chunk_at_offset(old_top, old_top_size + SIZE_SZ)->size =
	SIZE_SZ|PREV_INUSE;
      /* If possible, release the rest. */
      if (old_top_size >= MINSIZE)
34809b88:	e359000f 	cmp	r9, #15
      }

      /* Also keep size a multiple of MALLOC_ALIGNMENT */
      old_top_size = (old_top_size - 3*SIZE_SZ) & ~MALLOC_ALIGN_MASK;
      set_head_size(old_top, old_top_size);
      chunk_at_offset(old_top, old_top_size          )->size =
34809b8c:	e5832004 	str	r2, [r3, #4]
	SIZE_SZ|PREV_INUSE;
      chunk_at_offset(old_top, old_top_size + SIZE_SZ)->size =
34809b90:	e5832008 	str	r2, [r3, #8]
	SIZE_SZ|PREV_INUSE;
      /* If possible, release the rest. */
      if (old_top_size >= MINSIZE)
34809b94:	9a000001 	bls	34809ba0 <malloc+0x538>
	fREe(chunk2mem(old_top));
34809b98:	e2870008 	add	r0, r7, #8
34809b9c:	ebfffe28 	bl	34809444 <free>
    }
  }

  if ((unsigned long)sbrked_mem > (unsigned long)max_sbrked_mem)
34809ba0:	e59f2068 	ldr	r2, [pc, #104]	; 34809c10 <malloc+0x5a8>
34809ba4:	e592300c 	ldr	r3, [r2, #12]
34809ba8:	e5921038 	ldr	r1, [r2, #56]	; 0x38
34809bac:	e1530001 	cmp	r3, r1
    max_sbrked_mem = sbrked_mem;
34809bb0:	85823038 	strhi	r3, [r2, #56]	; 0x38
  if ((unsigned long)(mmapped_mem + sbrked_mem) > (unsigned long)max_total_mem)
34809bb4:	e59f2054 	ldr	r2, [pc, #84]	; 34809c10 <malloc+0x5a8>
34809bb8:	e592103c 	ldr	r1, [r2, #60]	; 0x3c
34809bbc:	e1530001 	cmp	r3, r1
    max_total_mem = mmapped_mem + sbrked_mem;
34809bc0:	8582303c 	strhi	r3, [r2, #60]	; 0x3c
      return chunk2mem(victim);
#endif

    /* Try to extend */
    malloc_extend_top(nb);
    if ( (remainder_size = chunksize(top) - nb) < (long)MINSIZE)
34809bc4:	e59f3048 	ldr	r3, [pc, #72]	; 34809c14 <malloc+0x5ac>
34809bc8:	e5933008 	ldr	r3, [r3, #8]
34809bcc:	e5933004 	ldr	r3, [r3, #4]
34809bd0:	e3c33003 	bic	r3, r3, #3
34809bd4:	e0643003 	rsb	r3, r4, r3
34809bd8:	e353000f 	cmp	r3, #15
34809bdc:	da000009 	ble	34809c08 <malloc+0x5a0>
      return 0; /* propagate failure */
  }

  victim = top;
34809be0:	e59f202c 	ldr	r2, [pc, #44]	; 34809c14 <malloc+0x5ac>
  set_head(victim, nb | PREV_INUSE);
34809be4:	e3841001 	orr	r1, r4, #1
    malloc_extend_top(nb);
    if ( (remainder_size = chunksize(top) - nb) < (long)MINSIZE)
      return 0; /* propagate failure */
  }

  victim = top;
34809be8:	e5920008 	ldr	r0, [r2, #8]
  set_head(victim, nb | PREV_INUSE);
  top = chunk_at_offset(victim, nb);
  set_head(top, remainder_size | PREV_INUSE);
34809bec:	e3833001 	orr	r3, r3, #1
      return 0; /* propagate failure */
  }

  victim = top;
  set_head(victim, nb | PREV_INUSE);
  top = chunk_at_offset(victim, nb);
34809bf0:	e0804004 	add	r4, r0, r4
    if ( (remainder_size = chunksize(top) - nb) < (long)MINSIZE)
      return 0; /* propagate failure */
  }

  victim = top;
  set_head(victim, nb | PREV_INUSE);
34809bf4:	e5801004 	str	r1, [r0, #4]
  top = chunk_at_offset(victim, nb);
34809bf8:	e5824008 	str	r4, [r2, #8]
  set_head(top, remainder_size | PREV_INUSE);
34809bfc:	e5843004 	str	r3, [r4, #4]
  check_malloced_chunk(victim, nb);
  return chunk2mem(victim);
34809c00:	e2800008 	add	r0, r0, #8
34809c04:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
#endif

    /* Try to extend */
    malloc_extend_top(nb);
    if ( (remainder_size = chunksize(top) - nb) < (long)MINSIZE)
      return 0; /* propagate failure */
34809c08:	e3a00000 	mov	r0, #0
  top = chunk_at_offset(victim, nb);
  set_head(top, remainder_size | PREV_INUSE);
  check_malloced_chunk(victim, nb);
  return chunk2mem(victim);

}
34809c0c:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
34809c10:	348294e0 	.word	0x348294e0
34809c14:	348283c8 	.word	0x348283c8
34809c18:	348283d0 	.word	0x348283d0

34809c1c <calloc>:
#if __STD_C
Void_t* cALLOc(size_t n, size_t elem_size)
#else
Void_t* cALLOc(n, elem_size) size_t n; size_t elem_size;
#endif
{
34809c1c:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
  INTERNAL_SIZE_T sz = n * elem_size;


  /* check if expand_top called, in which case don't need to clear */
#if MORECORE_CLEARS
  mchunkptr oldtop = top;
34809c20:	e59f30d0 	ldr	r3, [pc, #208]	; 34809cf8 <calloc+0xdc>
#if __STD_C
Void_t* cALLOc(size_t n, size_t elem_size)
#else
Void_t* cALLOc(n, elem_size) size_t n; size_t elem_size;
#endif
{
34809c24:	e1a06000 	mov	r6, r0
  INTERNAL_SIZE_T sz = n * elem_size;


  /* check if expand_top called, in which case don't need to clear */
#if MORECORE_CLEARS
  mchunkptr oldtop = top;
34809c28:	e5935008 	ldr	r5, [r3, #8]
  INTERNAL_SIZE_T oldtopsize = chunksize(top);
#endif
  Void_t* mem = mALLOc (sz);
34809c2c:	e0000190 	mul	r0, r0, r1


  /* check if expand_top called, in which case don't need to clear */
#if MORECORE_CLEARS
  mchunkptr oldtop = top;
  INTERNAL_SIZE_T oldtopsize = chunksize(top);
34809c30:	e5957004 	ldr	r7, [r5, #4]
#endif
  Void_t* mem = mALLOc (sz);
34809c34:	ebfffe8b 	bl	34809668 <malloc>

  if ((long)n < 0) return 0;
34809c38:	e3560000 	cmp	r6, #0
  /* check if expand_top called, in which case don't need to clear */
#if MORECORE_CLEARS
  mchunkptr oldtop = top;
  INTERNAL_SIZE_T oldtopsize = chunksize(top);
#endif
  Void_t* mem = mALLOc (sz);
34809c3c:	e1a04000 	mov	r4, r0

  if ((long)n < 0) return 0;
34809c40:	b3a04000 	movlt	r4, #0
34809c44:	ba000029 	blt	34809cf0 <calloc+0xd4>

  if (mem == 0)
34809c48:	e3540000 	cmp	r4, #0
34809c4c:	0a000027 	beq	34809cf0 <calloc+0xd4>

#if HAVE_MMAP
    if (chunk_is_mmapped(p)) return mem;
#endif

    csz = chunksize(p);
34809c50:	e5142004 	ldr	r2, [r4, #-4]


  /* check if expand_top called, in which case don't need to clear */
#if MORECORE_CLEARS
  mchunkptr oldtop = top;
  INTERNAL_SIZE_T oldtopsize = chunksize(top);
34809c54:	e3c77003 	bic	r7, r7, #3

#if HAVE_MMAP
    if (chunk_is_mmapped(p)) return mem;
#endif

    csz = chunksize(p);
34809c58:	e3c22003 	bic	r2, r2, #3

  if (mem == 0)
    return 0;
  else
  {
    p = mem2chunk(mem);
34809c5c:	e2443008 	sub	r3, r4, #8
#endif

    csz = chunksize(p);

#if MORECORE_CLEARS
    if (p == oldtop && csz > oldtopsize)
34809c60:	e1530005 	cmp	r3, r5
34809c64:	13a05000 	movne	r5, #0
34809c68:	03a05001 	moveq	r5, #1
34809c6c:	e1520007 	cmp	r2, r7
34809c70:	93a05000 	movls	r5, #0
34809c74:	e3550000 	cmp	r5, #0
34809c78:	11a02007 	movne	r2, r7
      /* clear only the bytes from non-freshly-sbrked memory */
      csz = oldtopsize;
    }
#endif

    MALLOC_ZERO(mem, csz - SIZE_SZ);
34809c7c:	e2422004 	sub	r2, r2, #4
34809c80:	e3520024 	cmp	r2, #36	; 0x24
34809c84:	8a000017 	bhi	34809ce8 <calloc+0xcc>
34809c88:	e3520013 	cmp	r2, #19
34809c8c:	e1a03004 	mov	r3, r4
34809c90:	9a00000e 	bls	34809cd0 <calloc+0xb4>
34809c94:	e3a01000 	mov	r1, #0
34809c98:	e1a00004 	mov	r0, r4
34809c9c:	e4801004 	str	r1, [r0], #4
34809ca0:	e352001b 	cmp	r2, #27
34809ca4:	e5841004 	str	r1, [r4, #4]
34809ca8:	e2803004 	add	r3, r0, #4
34809cac:	9a000007 	bls	34809cd0 <calloc+0xb4>
34809cb0:	e5801004 	str	r1, [r0, #4]
34809cb4:	e2830004 	add	r0, r3, #4
34809cb8:	e5831004 	str	r1, [r3, #4]
34809cbc:	e3520024 	cmp	r2, #36	; 0x24
34809cc0:	e2803004 	add	r3, r0, #4
34809cc4:	05801004 	streq	r1, [r0, #4]
34809cc8:	05831004 	streq	r1, [r3, #4]
34809ccc:	02833008 	addeq	r3, r3, #8
34809cd0:	e3a01000 	mov	r1, #0
34809cd4:	e1a02003 	mov	r2, r3
34809cd8:	e4821004 	str	r1, [r2], #4
34809cdc:	e5831004 	str	r1, [r3, #4]
34809ce0:	e5821004 	str	r1, [r2, #4]
34809ce4:	ea000001 	b	34809cf0 <calloc+0xd4>
34809ce8:	e3a01000 	mov	r1, #0
34809cec:	eb003c43 	bl	34818e00 <memset>
    return mem;
  }
}
34809cf0:	e1a00004 	mov	r0, r4
34809cf4:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
34809cf8:	348283c8 	.word	0x348283c8

34809cfc <memalign>:
#if __STD_C
Void_t* mEMALIGn(size_t alignment, size_t bytes)
#else
Void_t* mEMALIGn(alignment, bytes) size_t alignment; size_t bytes;
#endif
{
34809cfc:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
34809d00:	e1a04000 	mov	r4, r0
  INTERNAL_SIZE_T  newsize;   /* its size */
  INTERNAL_SIZE_T  leadsize;  /* leading space befor alignment point */
  mchunkptr remainder;        /* spare room at end to split off */
  long      remainder_size;   /* its size */

  if ((long)bytes < 0) return 0;
34809d04:	e2510000 	subs	r0, r1, #0
34809d08:	b3a00000 	movlt	r0, #0
34809d0c:	b8bd84f0 	poplt	{r4, r5, r6, r7, sl, pc}

  /* If need less alignment than we give anyway, just relay to malloc */

  if (alignment <= MALLOC_ALIGNMENT) return mALLOc(bytes);
34809d10:	e3540008 	cmp	r4, #8
34809d14:	8a000001 	bhi	34809d20 <memalign+0x24>
  }

  check_inuse_chunk(p);
  return chunk2mem(p);

}
34809d18:	e8bd44f0 	pop	{r4, r5, r6, r7, sl, lr}

  if ((long)bytes < 0) return 0;

  /* If need less alignment than we give anyway, just relay to malloc */

  if (alignment <= MALLOC_ALIGNMENT) return mALLOc(bytes);
34809d1c:	eafffe51 	b	34809668 <malloc>

  if (alignment <  MINSIZE) alignment = MINSIZE;

  /* Call malloc with worst case padding to hit alignment. */

  nb = request2size(bytes);
34809d20:	e280700b 	add	r7, r0, #11

  if (alignment <= MALLOC_ALIGNMENT) return mALLOc(bytes);

  /* Otherwise, ensure that it is at least a minimum chunk size */

  if (alignment <  MINSIZE) alignment = MINSIZE;
34809d24:	e354000f 	cmp	r4, #15
34809d28:	93a04010 	movls	r4, #16

  /* Call malloc with worst case padding to hit alignment. */

  nb = request2size(bytes);
34809d2c:	e3570016 	cmp	r7, #22
34809d30:	c3c77007 	bicgt	r7, r7, #7
34809d34:	d3a07010 	movle	r7, #16
  m  = (char*)(mALLOc(nb + alignment + MINSIZE));
34809d38:	e2840010 	add	r0, r4, #16
34809d3c:	e0800007 	add	r0, r0, r7
34809d40:	ebfffe48 	bl	34809668 <malloc>

  if (m == 0) return 0; /* propagate failure */
34809d44:	e2506000 	subs	r6, r0, #0
34809d48:	0a00002d 	beq	34809e04 <memalign+0x108>

  p = mem2chunk(m);

  if ((((unsigned long)(m)) % alignment) == 0) /* aligned */
34809d4c:	e1a01004 	mov	r1, r4
34809d50:	eb0058ce 	bl	34820090 <__aeabi_uidivmod>
34809d54:	e3510000 	cmp	r1, #0
  nb = request2size(bytes);
  m  = (char*)(mALLOc(nb + alignment + MINSIZE));

  if (m == 0) return 0; /* propagate failure */

  p = mem2chunk(m);
34809d58:	e2465008 	sub	r5, r6, #8

  if ((((unsigned long)(m)) % alignment) == 0) /* aligned */
34809d5c:	0a000018 	beq	34809dc4 <memalign+0xc8>
      a spot with less than MINSIZE leader, we can move to the
      next aligned spot -- we've allocated enough total room so that
      this is always possible.
    */

    brk = (char*)mem2chunk(((unsigned long)(m + alignment - 1)) & -((signed) alignment));
34809d60:	e244a001 	sub	sl, r4, #1
34809d64:	e2643000 	rsb	r3, r4, #0
34809d68:	e086a00a 	add	sl, r6, sl
34809d6c:	e00aa003 	and	sl, sl, r3
34809d70:	e24aa008 	sub	sl, sl, #8
    if ((long)(brk - (char*)(p)) < MINSIZE) brk = brk + alignment;
34809d74:	e065300a 	rsb	r3, r5, sl
34809d78:	e353000f 	cmp	r3, #15

    newp = (mchunkptr)brk;
    leadsize = brk - (char*)(p);
    newsize = chunksize(p) - leadsize;
34809d7c:	e5163004 	ldr	r3, [r6, #-4]
      next aligned spot -- we've allocated enough total room so that
      this is always possible.
    */

    brk = (char*)mem2chunk(((unsigned long)(m + alignment - 1)) & -((signed) alignment));
    if ((long)(brk - (char*)(p)) < MINSIZE) brk = brk + alignment;
34809d80:	908aa004 	addls	sl, sl, r4

    newp = (mchunkptr)brk;
    leadsize = brk - (char*)(p);
34809d84:	e065500a 	rsb	r5, r5, sl
    newsize = chunksize(p) - leadsize;
34809d88:	e3c33003 	bic	r3, r3, #3
34809d8c:	e0653003 	rsb	r3, r5, r3
    }
#endif

    /* give back leader, use the rest */

    set_head(newp, newsize | PREV_INUSE);
34809d90:	e3832001 	orr	r2, r3, #1
34809d94:	e58a2004 	str	r2, [sl, #4]
    set_inuse_bit_at_offset(newp, newsize);
34809d98:	e08a3003 	add	r3, sl, r3
34809d9c:	e5932004 	ldr	r2, [r3, #4]
    set_head_size(p, leadsize);
    fREe(chunk2mem(p));
34809da0:	e1a00006 	mov	r0, r6
#endif

    /* give back leader, use the rest */

    set_head(newp, newsize | PREV_INUSE);
    set_inuse_bit_at_offset(newp, newsize);
34809da4:	e3822001 	orr	r2, r2, #1
34809da8:	e5832004 	str	r2, [r3, #4]
    set_head_size(p, leadsize);
34809dac:	e5163004 	ldr	r3, [r6, #-4]
34809db0:	e2033001 	and	r3, r3, #1
34809db4:	e1855003 	orr	r5, r5, r3
34809db8:	e5065004 	str	r5, [r6, #-4]
    fREe(chunk2mem(p));
34809dbc:	ebfffda0 	bl	34809444 <free>
34809dc0:	e1a0500a 	mov	r5, sl
    assert (newsize >= nb && (((unsigned long)(chunk2mem(p))) % alignment) == 0);
  }

  /* Also give back spare room at the end */

  remainder_size = chunksize(p) - nb;
34809dc4:	e5953004 	ldr	r3, [r5, #4]
34809dc8:	e3c33003 	bic	r3, r3, #3
34809dcc:	e0673003 	rsb	r3, r7, r3

  if (remainder_size >= (long)MINSIZE)
34809dd0:	e353000f 	cmp	r3, #15
34809dd4:	da000008 	ble	34809dfc <memalign+0x100>
  {
    remainder = chunk_at_offset(p, nb);
34809dd8:	e0850007 	add	r0, r5, r7
    set_head(remainder, remainder_size | PREV_INUSE);
34809ddc:	e3833001 	orr	r3, r3, #1
34809de0:	e5803004 	str	r3, [r0, #4]
    set_head_size(p, nb);
34809de4:	e5953004 	ldr	r3, [r5, #4]
    fREe(chunk2mem(remainder));
34809de8:	e2800008 	add	r0, r0, #8

  if (remainder_size >= (long)MINSIZE)
  {
    remainder = chunk_at_offset(p, nb);
    set_head(remainder, remainder_size | PREV_INUSE);
    set_head_size(p, nb);
34809dec:	e2033001 	and	r3, r3, #1
34809df0:	e1877003 	orr	r7, r7, r3
34809df4:	e5857004 	str	r7, [r5, #4]
    fREe(chunk2mem(remainder));
34809df8:	ebfffd91 	bl	34809444 <free>
  }

  check_inuse_chunk(p);
  return chunk2mem(p);
34809dfc:	e2850008 	add	r0, r5, #8
34809e00:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
  /* Call malloc with worst case padding to hit alignment. */

  nb = request2size(bytes);
  m  = (char*)(mALLOc(nb + alignment + MINSIZE));

  if (m == 0) return 0; /* propagate failure */
34809e04:	e1a00006 	mov	r0, r6
  }

  check_inuse_chunk(p);
  return chunk2mem(p);

}
34809e08:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}

34809e0c <pvalloc>:
#else
Void_t* pvALLOc(bytes) size_t bytes;
#endif
{
  size_t pagesize = malloc_getpagesize;
  return mEMALIGn (pagesize, (bytes + pagesize - 1) & ~(pagesize - 1));
34809e0c:	e2801eff 	add	r1, r0, #4080	; 0xff0
34809e10:	e281100f 	add	r1, r1, #15
34809e14:	e3c11eff 	bic	r1, r1, #4080	; 0xff0
34809e18:	e3a00a01 	mov	r0, #4096	; 0x1000
34809e1c:	e3c1100f 	bic	r1, r1, #15
34809e20:	eaffffb5 	b	34809cfc <memalign>

34809e24 <valloc>:
#if __STD_C
Void_t* vALLOc(size_t bytes)
#else
Void_t* vALLOc(bytes) size_t bytes;
#endif
{
34809e24:	e1a01000 	mov	r1, r0
  return mEMALIGn (malloc_getpagesize, bytes);
34809e28:	e3a00a01 	mov	r0, #4096	; 0x1000
34809e2c:	eaffffb2 	b	34809cfc <memalign>

34809e30 <realloc>:
#if __STD_C
Void_t* rEALLOc(Void_t* oldmem, size_t bytes)
#else
Void_t* rEALLOc(oldmem, bytes) Void_t* oldmem; size_t bytes;
#endif
{
34809e30:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
34809e34:	e1a05000 	mov	r5, r0

#ifdef REALLOC_ZERO_BYTES_FREES
  if (bytes == 0) { fREe(oldmem); return 0; }
#endif

  if ((long)bytes < 0) return 0;
34809e38:	e2510000 	subs	r0, r1, #0
34809e3c:	ba00010b 	blt	3480a270 <realloc+0x440>

  /* realloc of null is supposed to be same as malloc */
  if (oldmem == 0) return mALLOc(bytes);
34809e40:	e3550000 	cmp	r5, #0
34809e44:	1a000001 	bne	34809e50 <realloc+0x20>
    set_inuse_bit_at_offset(newp, newsize);
  }

  check_inuse_chunk(newp);
  return chunk2mem(newp);
}
34809e48:	e8bd4ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, lr}
#endif

  if ((long)bytes < 0) return 0;

  /* realloc of null is supposed to be same as malloc */
  if (oldmem == 0) return mALLOc(bytes);
34809e4c:	eafffe05 	b	34809668 <malloc>

  newp    = oldp    = mem2chunk(oldmem);
  newsize = oldsize = chunksize(oldp);


  nb = request2size(bytes);
34809e50:	e280600b 	add	r6, r0, #11

  /* realloc of null is supposed to be same as malloc */
  if (oldmem == 0) return mALLOc(bytes);

  newp    = oldp    = mem2chunk(oldmem);
  newsize = oldsize = chunksize(oldp);
34809e54:	e5151004 	ldr	r1, [r5, #-4]


  nb = request2size(bytes);
34809e58:	e3560016 	cmp	r6, #22

  /* realloc of null is supposed to be same as malloc */
  if (oldmem == 0) return mALLOc(bytes);

  newp    = oldp    = mem2chunk(oldmem);
  newsize = oldsize = chunksize(oldp);
34809e5c:	e3c19003 	bic	r9, r1, #3


  nb = request2size(bytes);
34809e60:	c3c66007 	bicgt	r6, r6, #7
34809e64:	d3a06010 	movle	r6, #16
  }
#endif

  check_inuse_chunk(oldp);

  if ((long)(oldsize) < (long)(nb))
34809e68:	e1590006 	cmp	r9, r6
  if ((long)bytes < 0) return 0;

  /* realloc of null is supposed to be same as malloc */
  if (oldmem == 0) return mALLOc(bytes);

  newp    = oldp    = mem2chunk(oldmem);
34809e6c:	e245b008 	sub	fp, r5, #8
  newsize = oldsize = chunksize(oldp);
34809e70:	a1a0a009 	movge	sl, r9
  }
#endif

  check_inuse_chunk(oldp);

  if ((long)(oldsize) < (long)(nb))
34809e74:	aa0000e2 	bge	3480a204 <realloc+0x3d4>
  {

    /* Try expanding forward */

    next = chunk_at_offset(oldp, oldsize);
    if (next == top || !inuse(next))
34809e78:	e59f23fc 	ldr	r2, [pc, #1020]	; 3480a27c <realloc+0x44c>
  if ((long)(oldsize) < (long)(nb))
  {

    /* Try expanding forward */

    next = chunk_at_offset(oldp, oldsize);
34809e7c:	e08b3009 	add	r3, fp, r9
    if (next == top || !inuse(next))
34809e80:	e592c008 	ldr	ip, [r2, #8]
34809e84:	e153000c 	cmp	r3, ip
34809e88:	0a000007 	beq	34809eac <realloc+0x7c>
34809e8c:	e5932004 	ldr	r2, [r3, #4]
34809e90:	e3c22001 	bic	r2, r2, #1
34809e94:	e0832002 	add	r2, r3, r2
34809e98:	e5922004 	ldr	r2, [r2, #4]
34809e9c:	e3120001 	tst	r2, #1
      }
    }
    else
    {
      next = 0;
      nextsize = 0;
34809ea0:	13a02000 	movne	r2, #0
	goto split;
      }
    }
    else
    {
      next = 0;
34809ea4:	11a03002 	movne	r3, r2
  {

    /* Try expanding forward */

    next = chunk_at_offset(oldp, oldsize);
    if (next == top || !inuse(next))
34809ea8:	1a000019 	bne	34809f14 <realloc+0xe4>
    {
      nextsize = chunksize(next);
34809eac:	e5932004 	ldr	r2, [r3, #4]

      /* Forward into top only if a remainder */
      if (next == top)
34809eb0:	e153000c 	cmp	r3, ip
    /* Try expanding forward */

    next = chunk_at_offset(oldp, oldsize);
    if (next == top || !inuse(next))
    {
      nextsize = chunksize(next);
34809eb4:	e3c22003 	bic	r2, r2, #3
34809eb8:	e082a009 	add	sl, r2, r9

      /* Forward into top only if a remainder */
      if (next == top)
34809ebc:	1a00000e 	bne	34809efc <realloc+0xcc>
      {
	if ((long)(nextsize + newsize) >= (long)(nb + MINSIZE))
34809ec0:	e2864010 	add	r4, r6, #16
34809ec4:	e15a0004 	cmp	sl, r4
34809ec8:	ba000011 	blt	34809f14 <realloc+0xe4>
	{
	  newsize += nextsize;
	  top = chunk_at_offset(oldp, nb);
34809ecc:	e59f33a8 	ldr	r3, [pc, #936]	; 3480a27c <realloc+0x44c>
	  set_head(top, (newsize - nb) | PREV_INUSE);
34809ed0:	e066a00a 	rsb	sl, r6, sl
      if (next == top)
      {
	if ((long)(nextsize + newsize) >= (long)(nb + MINSIZE))
	{
	  newsize += nextsize;
	  top = chunk_at_offset(oldp, nb);
34809ed4:	e08bb006 	add	fp, fp, r6
	  set_head(top, (newsize - nb) | PREV_INUSE);
34809ed8:	e38aa001 	orr	sl, sl, #1
      if (next == top)
      {
	if ((long)(nextsize + newsize) >= (long)(nb + MINSIZE))
	{
	  newsize += nextsize;
	  top = chunk_at_offset(oldp, nb);
34809edc:	e583b008 	str	fp, [r3, #8]
	  set_head(top, (newsize - nb) | PREV_INUSE);
34809ee0:	e58ba004 	str	sl, [fp, #4]
	  set_head_size(oldp, nb);
34809ee4:	e5153004 	ldr	r3, [r5, #-4]
	  return chunk2mem(oldp);
34809ee8:	e1a07005 	mov	r7, r5
	if ((long)(nextsize + newsize) >= (long)(nb + MINSIZE))
	{
	  newsize += nextsize;
	  top = chunk_at_offset(oldp, nb);
	  set_head(top, (newsize - nb) | PREV_INUSE);
	  set_head_size(oldp, nb);
34809eec:	e2033001 	and	r3, r3, #1
34809ef0:	e1866003 	orr	r6, r6, r3
34809ef4:	e5056004 	str	r6, [r5, #-4]
	  return chunk2mem(oldp);
34809ef8:	ea0000dd 	b	3480a274 <realloc+0x444>
	}
      }

      /* Forward into next chunk */
      else if (((long)(nextsize + newsize) >= (long)(nb)))
34809efc:	e15a0006 	cmp	sl, r6
      {
	unlink(next, bck, fwd);
34809f00:	a593200c 	ldrge	r2, [r3, #12]
34809f04:	a5933008 	ldrge	r3, [r3, #8]
34809f08:	a583200c 	strge	r2, [r3, #12]
34809f0c:	a5823008 	strge	r3, [r2, #8]
34809f10:	aa0000bb 	bge	3480a204 <realloc+0x3d4>
      nextsize = 0;
    }

    /* Try shifting backwards. */

    if (!prev_inuse(oldp))
34809f14:	e3110001 	tst	r1, #1
34809f18:	1a00007e 	bne	3480a118 <realloc+0x2e8>
    {
      prev = prev_chunk(oldp);
34809f1c:	e5154008 	ldr	r4, [r5, #-8]
      prevsize = chunksize(prev);

      /* try forward + backward first to save a later consolidation */

      if (next != 0)
34809f20:	e3530000 	cmp	r3, #0

    /* Try shifting backwards. */

    if (!prev_inuse(oldp))
    {
      prev = prev_chunk(oldp);
34809f24:	e064400b 	rsb	r4, r4, fp
      prevsize = chunksize(prev);
34809f28:	e5941004 	ldr	r1, [r4, #4]
34809f2c:	e3c11003 	bic	r1, r1, #3

      /* try forward + backward first to save a later consolidation */

      if (next != 0)
34809f30:	0a000047 	beq	3480a054 <realloc+0x224>
      {
	/* into top */
	if (next == top)
34809f34:	e153000c 	cmp	r3, ip
34809f38:	e081a009 	add	sl, r1, r9
34809f3c:	1a00003d 	bne	3480a038 <realloc+0x208>
	{
	  if ((long)(nextsize + prevsize + newsize) >= (long)(nb + MINSIZE))
34809f40:	e08aa002 	add	sl, sl, r2
34809f44:	e2863010 	add	r3, r6, #16
34809f48:	e15a0003 	cmp	sl, r3
34809f4c:	ba000040 	blt	3480a054 <realloc+0x224>
	  {
	    unlink(prev, bck, fwd);
34809f50:	e1a07004 	mov	r7, r4
34809f54:	e5b72008 	ldr	r2, [r7, #8]!
34809f58:	e594300c 	ldr	r3, [r4, #12]
34809f5c:	e582300c 	str	r3, [r2, #12]
34809f60:	e5832008 	str	r2, [r3, #8]
	    newp = prev;
	    newsize += prevsize + nextsize;
	    newmem = chunk2mem(newp);
	    MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
34809f64:	e2492004 	sub	r2, r9, #4
34809f68:	e3520024 	cmp	r2, #36	; 0x24
34809f6c:	8a000023 	bhi	3480a000 <realloc+0x1d0>
34809f70:	e3520013 	cmp	r2, #19
34809f74:	e1a03007 	mov	r3, r7
34809f78:	9a000017 	bls	34809fdc <realloc+0x1ac>
34809f7c:	e1a01005 	mov	r1, r5
34809f80:	e4913004 	ldr	r3, [r1], #4
34809f84:	e352001b 	cmp	r2, #27
34809f88:	e5843008 	str	r3, [r4, #8]
34809f8c:	e5953004 	ldr	r3, [r5, #4]
34809f90:	e2815004 	add	r5, r1, #4
34809f94:	e584300c 	str	r3, [r4, #12]
34809f98:	e2843010 	add	r3, r4, #16
34809f9c:	9a00000e 	bls	34809fdc <realloc+0x1ac>
34809fa0:	e5913004 	ldr	r3, [r1, #4]
34809fa4:	e3520024 	cmp	r2, #36	; 0x24
34809fa8:	e5843010 	str	r3, [r4, #16]
34809fac:	e5953004 	ldr	r3, [r5, #4]
34809fb0:	e2851004 	add	r1, r5, #4
34809fb4:	e5843014 	str	r3, [r4, #20]
34809fb8:	e2815004 	add	r5, r1, #4
34809fbc:	e2843018 	add	r3, r4, #24
34809fc0:	1a000005 	bne	34809fdc <realloc+0x1ac>
34809fc4:	e5913004 	ldr	r3, [r1, #4]
34809fc8:	e5843018 	str	r3, [r4, #24]
34809fcc:	e5953004 	ldr	r3, [r5, #4]
34809fd0:	e2855008 	add	r5, r5, #8
34809fd4:	e584301c 	str	r3, [r4, #28]
34809fd8:	e2843020 	add	r3, r4, #32
34809fdc:	e1a01005 	mov	r1, r5
34809fe0:	e4910004 	ldr	r0, [r1], #4
34809fe4:	e1a02003 	mov	r2, r3
34809fe8:	e4820004 	str	r0, [r2], #4
34809fec:	e5950004 	ldr	r0, [r5, #4]
34809ff0:	e5830004 	str	r0, [r3, #4]
34809ff4:	e5913004 	ldr	r3, [r1, #4]
34809ff8:	e5823004 	str	r3, [r2, #4]
34809ffc:	ea000002 	b	3480a00c <realloc+0x1dc>
3480a000:	e1a00007 	mov	r0, r7
3480a004:	e1a01005 	mov	r1, r5
3480a008:	eb003ba0 	bl	34818e90 <memcpy>
	    top = chunk_at_offset(newp, nb);
	    set_head(top, (newsize - nb) | PREV_INUSE);
3480a00c:	e066a00a 	rsb	sl, r6, sl
	    unlink(prev, bck, fwd);
	    newp = prev;
	    newsize += prevsize + nextsize;
	    newmem = chunk2mem(newp);
	    MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
	    top = chunk_at_offset(newp, nb);
3480a010:	e59f2264 	ldr	r2, [pc, #612]	; 3480a27c <realloc+0x44c>
3480a014:	e0843006 	add	r3, r4, r6
	    set_head(top, (newsize - nb) | PREV_INUSE);
3480a018:	e38aa001 	orr	sl, sl, #1
	    unlink(prev, bck, fwd);
	    newp = prev;
	    newsize += prevsize + nextsize;
	    newmem = chunk2mem(newp);
	    MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
	    top = chunk_at_offset(newp, nb);
3480a01c:	e5823008 	str	r3, [r2, #8]
	    set_head(top, (newsize - nb) | PREV_INUSE);
3480a020:	e583a004 	str	sl, [r3, #4]
	    set_head_size(newp, nb);
3480a024:	e5943004 	ldr	r3, [r4, #4]
3480a028:	e2033001 	and	r3, r3, #1
3480a02c:	e1866003 	orr	r6, r6, r3
3480a030:	e5846004 	str	r6, [r4, #4]
	    return newmem;
3480a034:	ea00008e 	b	3480a274 <realloc+0x444>
	  }
	}

	/* into next chunk */
	else if (((long)(nextsize + prevsize + newsize) >= (long)(nb)))
3480a038:	e08aa002 	add	sl, sl, r2
3480a03c:	e15a0006 	cmp	sl, r6
	{
	  unlink(next, bck, fwd);
3480a040:	a593200c 	ldrge	r2, [r3, #12]
3480a044:	a5933008 	ldrge	r3, [r3, #8]
3480a048:	a583200c 	strge	r2, [r3, #12]
3480a04c:	a5823008 	strge	r3, [r2, #8]
3480a050:	aa000002 	bge	3480a060 <realloc+0x230>
	  goto split;
	}
      }

      /* backward only */
      if (prev != 0 && (long)(prevsize + newsize) >= (long)nb)
3480a054:	e081a009 	add	sl, r1, r9
3480a058:	e15a0006 	cmp	sl, r6
3480a05c:	ba00002d 	blt	3480a118 <realloc+0x2e8>
      {
	unlink(prev, bck, fwd);
3480a060:	e1a00004 	mov	r0, r4
3480a064:	e5b02008 	ldr	r2, [r0, #8]!
3480a068:	e594300c 	ldr	r3, [r4, #12]
3480a06c:	e582300c 	str	r3, [r2, #12]
3480a070:	e5832008 	str	r2, [r3, #8]
	newp = prev;
	newsize += prevsize;
	newmem = chunk2mem(newp);
	MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
3480a074:	e2492004 	sub	r2, r9, #4
3480a078:	e3520024 	cmp	r2, #36	; 0x24
3480a07c:	8a000022 	bhi	3480a10c <realloc+0x2dc>
3480a080:	e3520013 	cmp	r2, #19
3480a084:	9a000017 	bls	3480a0e8 <realloc+0x2b8>
3480a088:	e1a03005 	mov	r3, r5
3480a08c:	e4931004 	ldr	r1, [r3], #4
3480a090:	e352001b 	cmp	r2, #27
3480a094:	e5841008 	str	r1, [r4, #8]
3480a098:	e5951004 	ldr	r1, [r5, #4]
3480a09c:	e2840010 	add	r0, r4, #16
3480a0a0:	e584100c 	str	r1, [r4, #12]
3480a0a4:	e2835004 	add	r5, r3, #4
3480a0a8:	9a00000e 	bls	3480a0e8 <realloc+0x2b8>
3480a0ac:	e5933004 	ldr	r3, [r3, #4]
3480a0b0:	e3520024 	cmp	r2, #36	; 0x24
3480a0b4:	e5843010 	str	r3, [r4, #16]
3480a0b8:	e5951004 	ldr	r1, [r5, #4]
3480a0bc:	e2853004 	add	r3, r5, #4
3480a0c0:	e5841014 	str	r1, [r4, #20]
3480a0c4:	e2840018 	add	r0, r4, #24
3480a0c8:	e2835004 	add	r5, r3, #4
3480a0cc:	1a000005 	bne	3480a0e8 <realloc+0x2b8>
3480a0d0:	e5933004 	ldr	r3, [r3, #4]
3480a0d4:	e2840020 	add	r0, r4, #32
3480a0d8:	e5843018 	str	r3, [r4, #24]
3480a0dc:	e5953004 	ldr	r3, [r5, #4]
3480a0e0:	e2855008 	add	r5, r5, #8
3480a0e4:	e584301c 	str	r3, [r4, #28]
3480a0e8:	e1a02005 	mov	r2, r5
3480a0ec:	e4921004 	ldr	r1, [r2], #4
3480a0f0:	e1a03000 	mov	r3, r0
3480a0f4:	e4831004 	str	r1, [r3], #4
3480a0f8:	e5951004 	ldr	r1, [r5, #4]
3480a0fc:	e5801004 	str	r1, [r0, #4]
3480a100:	e5922004 	ldr	r2, [r2, #4]
3480a104:	e5832004 	str	r2, [r3, #4]
3480a108:	ea00003e 	b	3480a208 <realloc+0x3d8>
3480a10c:	e1a01005 	mov	r1, r5
3480a110:	eb003b5e 	bl	34818e90 <memcpy>
3480a114:	ea00003b 	b	3480a208 <realloc+0x3d8>
      }
    }

    /* Must allocate */

    newmem = mALLOc (bytes);
3480a118:	ebfffd52 	bl	34809668 <malloc>

    if (newmem == 0)  /* propagate failure */
3480a11c:	e2507000 	subs	r7, r0, #0
3480a120:	0a000053 	beq	3480a274 <realloc+0x444>
      return 0;

    /* Avoid copy if newp is next chunk after oldp. */
    /* (This can only happen when new chunk is sbrk'ed.) */

    if ( (newp = mem2chunk(newmem)) == next_chunk(oldp))
3480a124:	e5153004 	ldr	r3, [r5, #-4]
3480a128:	e2472008 	sub	r2, r7, #8
3480a12c:	e3c33001 	bic	r3, r3, #1
3480a130:	e08b3003 	add	r3, fp, r3
3480a134:	e1520003 	cmp	r2, r3
    {
      newsize += chunksize(newp);
3480a138:	0517a004 	ldreq	sl, [r7, #-4]
3480a13c:	03caa003 	biceq	sl, sl, #3
3480a140:	008aa009 	addeq	sl, sl, r9
      return 0;

    /* Avoid copy if newp is next chunk after oldp. */
    /* (This can only happen when new chunk is sbrk'ed.) */

    if ( (newp = mem2chunk(newmem)) == next_chunk(oldp))
3480a144:	0a00002e 	beq	3480a204 <realloc+0x3d4>
      newp = oldp;
      goto split;
    }

    /* Otherwise copy, free, and exit */
    MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
3480a148:	e2492004 	sub	r2, r9, #4
3480a14c:	e3520024 	cmp	r2, #36	; 0x24
3480a150:	8a000026 	bhi	3480a1f0 <realloc+0x3c0>
3480a154:	e3520013 	cmp	r2, #19
3480a158:	e1a01005 	mov	r1, r5
3480a15c:	e1a03007 	mov	r3, r7
3480a160:	9a000019 	bls	3480a1cc <realloc+0x39c>
3480a164:	e1a0c005 	mov	ip, r5
3480a168:	e49c3004 	ldr	r3, [ip], #4
3480a16c:	e1a00007 	mov	r0, r7
3480a170:	e4803004 	str	r3, [r0], #4
3480a174:	e5953004 	ldr	r3, [r5, #4]
3480a178:	e352001b 	cmp	r2, #27
3480a17c:	e5873004 	str	r3, [r7, #4]
3480a180:	e28c1004 	add	r1, ip, #4
3480a184:	e2803004 	add	r3, r0, #4
3480a188:	9a00000f 	bls	3480a1cc <realloc+0x39c>
3480a18c:	e59cc004 	ldr	ip, [ip, #4]
3480a190:	e3520024 	cmp	r2, #36	; 0x24
3480a194:	e580c004 	str	ip, [r0, #4]
3480a198:	e281c004 	add	ip, r1, #4
3480a19c:	e5911004 	ldr	r1, [r1, #4]
3480a1a0:	e2830004 	add	r0, r3, #4
3480a1a4:	e5831004 	str	r1, [r3, #4]
3480a1a8:	e2803004 	add	r3, r0, #4
3480a1ac:	e28c1004 	add	r1, ip, #4
3480a1b0:	1a000005 	bne	3480a1cc <realloc+0x39c>
3480a1b4:	e59c2004 	ldr	r2, [ip, #4]
3480a1b8:	e5802004 	str	r2, [r0, #4]
3480a1bc:	e5912004 	ldr	r2, [r1, #4]
3480a1c0:	e2811008 	add	r1, r1, #8
3480a1c4:	e5832004 	str	r2, [r3, #4]
3480a1c8:	e2833008 	add	r3, r3, #8
3480a1cc:	e1a00001 	mov	r0, r1
3480a1d0:	e490c004 	ldr	ip, [r0], #4
3480a1d4:	e1a02003 	mov	r2, r3
3480a1d8:	e482c004 	str	ip, [r2], #4
3480a1dc:	e5911004 	ldr	r1, [r1, #4]
3480a1e0:	e5831004 	str	r1, [r3, #4]
3480a1e4:	e5903004 	ldr	r3, [r0, #4]
3480a1e8:	e5823004 	str	r3, [r2, #4]
3480a1ec:	ea000001 	b	3480a1f8 <realloc+0x3c8>
3480a1f0:	e1a01005 	mov	r1, r5
3480a1f4:	eb003b25 	bl	34818e90 <memcpy>
    fREe(oldmem);
3480a1f8:	e1a00005 	mov	r0, r5
3480a1fc:	ebfffc90 	bl	34809444 <free>
    return newmem;
3480a200:	ea00001b 	b	3480a274 <realloc+0x444>
  }
#endif

  check_inuse_chunk(oldp);

  if ((long)(oldsize) < (long)(nb))
3480a204:	e1a0400b 	mov	r4, fp
  }


 split:  /* split off extra room in old or expanded chunk */

  if (newsize - nb >= MINSIZE) /* split off remainder */
3480a208:	e066300a 	rsb	r3, r6, sl
3480a20c:	e353000f 	cmp	r3, #15
3480a210:	e5942004 	ldr	r2, [r4, #4]
3480a214:	9a00000c 	bls	3480a24c <realloc+0x41c>
  {
    remainder = chunk_at_offset(newp, nb);
    remainder_size = newsize - nb;
    set_head_size(newp, nb);
3480a218:	e2022001 	and	r2, r2, #1

 split:  /* split off extra room in old or expanded chunk */

  if (newsize - nb >= MINSIZE) /* split off remainder */
  {
    remainder = chunk_at_offset(newp, nb);
3480a21c:	e0840006 	add	r0, r4, r6
    remainder_size = newsize - nb;
    set_head_size(newp, nb);
3480a220:	e1866002 	orr	r6, r6, r2
    set_head(remainder, remainder_size | PREV_INUSE);
3480a224:	e3832001 	orr	r2, r3, #1

  if (newsize - nb >= MINSIZE) /* split off remainder */
  {
    remainder = chunk_at_offset(newp, nb);
    remainder_size = newsize - nb;
    set_head_size(newp, nb);
3480a228:	e5846004 	str	r6, [r4, #4]
    set_head(remainder, remainder_size | PREV_INUSE);
    set_inuse_bit_at_offset(remainder, remainder_size);
3480a22c:	e0803003 	add	r3, r0, r3
  if (newsize - nb >= MINSIZE) /* split off remainder */
  {
    remainder = chunk_at_offset(newp, nb);
    remainder_size = newsize - nb;
    set_head_size(newp, nb);
    set_head(remainder, remainder_size | PREV_INUSE);
3480a230:	e5802004 	str	r2, [r0, #4]
    set_inuse_bit_at_offset(remainder, remainder_size);
3480a234:	e5932004 	ldr	r2, [r3, #4]
    fREe(chunk2mem(remainder)); /* let free() deal with it */
3480a238:	e2800008 	add	r0, r0, #8
  {
    remainder = chunk_at_offset(newp, nb);
    remainder_size = newsize - nb;
    set_head_size(newp, nb);
    set_head(remainder, remainder_size | PREV_INUSE);
    set_inuse_bit_at_offset(remainder, remainder_size);
3480a23c:	e3822001 	orr	r2, r2, #1
3480a240:	e5832004 	str	r2, [r3, #4]
    fREe(chunk2mem(remainder)); /* let free() deal with it */
3480a244:	ebfffc7e 	bl	34809444 <free>
3480a248:	ea000006 	b	3480a268 <realloc+0x438>
  }
  else
  {
    set_head_size(newp, newsize);
3480a24c:	e2022001 	and	r2, r2, #1
3480a250:	e18a2002 	orr	r2, sl, r2
3480a254:	e5842004 	str	r2, [r4, #4]
    set_inuse_bit_at_offset(newp, newsize);
3480a258:	e084a00a 	add	sl, r4, sl
3480a25c:	e59a3004 	ldr	r3, [sl, #4]
3480a260:	e3833001 	orr	r3, r3, #1
3480a264:	e58a3004 	str	r3, [sl, #4]
  }

  check_inuse_chunk(newp);
  return chunk2mem(newp);
3480a268:	e2847008 	add	r7, r4, #8
3480a26c:	ea000000 	b	3480a274 <realloc+0x444>

#ifdef REALLOC_ZERO_BYTES_FREES
  if (bytes == 0) { fREe(oldmem); return 0; }
#endif

  if ((long)bytes < 0) return 0;
3480a270:	e3a07000 	mov	r7, #0
    set_inuse_bit_at_offset(newp, newsize);
  }

  check_inuse_chunk(newp);
  return chunk2mem(newp);
}
3480a274:	e1a00007 	mov	r0, r7
3480a278:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
3480a27c:	348283c8 	.word	0x348283c8

3480a280 <malloc_usable_size>:
#else
size_t malloc_usable_size(mem) Void_t* mem;
#endif
{
  mchunkptr p;
  if (mem == 0)
3480a280:	e3500000 	cmp	r0, #0
3480a284:	012fff1e 	bxeq	lr
    return 0;
  else
  {
    p = mem2chunk(mem);
    if(!chunk_is_mmapped(p))
3480a288:	e5103004 	ldr	r3, [r0, #-4]
  mchunkptr p;
  if (mem == 0)
    return 0;
  else
  {
    p = mem2chunk(mem);
3480a28c:	e2401008 	sub	r1, r0, #8
    if(!chunk_is_mmapped(p))
3480a290:	e3130002 	tst	r3, #2
3480a294:	1a000006 	bne	3480a2b4 <malloc_usable_size+0x34>
    {
      if (!inuse(p)) return 0;
3480a298:	e3c32001 	bic	r2, r3, #1
3480a29c:	e0812002 	add	r2, r1, r2
3480a2a0:	e5920004 	ldr	r0, [r2, #4]
3480a2a4:	e2100001 	ands	r0, r0, #1
      check_inuse_chunk(p);
      return chunksize(p) - SIZE_SZ;
3480a2a8:	13c30003 	bicne	r0, r3, #3
3480a2ac:	12400004 	subne	r0, r0, #4
3480a2b0:	e12fff1e 	bx	lr
    }
    return chunksize(p) - 2*SIZE_SZ;
3480a2b4:	e3c30003 	bic	r0, r3, #3
3480a2b8:	e2400008 	sub	r0, r0, #8
  }
}
3480a2bc:	e12fff1e 	bx	lr

3480a2c0 <mallopt>:
int mALLOPt(int param_number, int value)
#else
int mALLOPt(param_number, value) int param_number; int value;
#endif
{
  switch(param_number)
3480a2c0:	e2800004 	add	r0, r0, #4
3480a2c4:	e3500003 	cmp	r0, #3
3480a2c8:	979ff100 	ldrls	pc, [pc, r0, lsl #2]
3480a2cc:	ea000012 	b	3480a31c <mallopt+0x5c>
3480a2d0:	3480a304 	.word	0x3480a304
3480a2d4:	3480a2f8 	.word	0x3480a2f8
3480a2d8:	3480a2ec 	.word	0x3480a2ec
3480a2dc:	3480a2e0 	.word	0x3480a2e0
  {
    case M_TRIM_THRESHOLD:
      trim_threshold = value; return 1;
3480a2e0:	e59f3044 	ldr	r3, [pc, #68]	; 3480a32c <mallopt+0x6c>
3480a2e4:	e583140c 	str	r1, [r3, #1036]	; 0x40c
3480a2e8:	ea000009 	b	3480a314 <mallopt+0x54>
    case M_TOP_PAD:
      top_pad = value; return 1;
3480a2ec:	e59f303c 	ldr	r3, [pc, #60]	; 3480a330 <mallopt+0x70>
3480a2f0:	e5831034 	str	r1, [r3, #52]	; 0x34
3480a2f4:	ea000006 	b	3480a314 <mallopt+0x54>
    case M_MMAP_THRESHOLD:
      mmap_threshold = value; return 1;
3480a2f8:	e59f302c 	ldr	r3, [pc, #44]	; 3480a32c <mallopt+0x6c>
3480a2fc:	e5831410 	str	r1, [r3, #1040]	; 0x410
3480a300:	ea000003 	b	3480a314 <mallopt+0x54>
    case M_MMAP_MAX:
#if HAVE_MMAP
      n_mmaps_max = value; return 1;
#else
      if (value != 0) return 0; else  n_mmaps_max = value; return 1;
3480a304:	e3510000 	cmp	r1, #0
3480a308:	1a000005 	bne	3480a324 <mallopt+0x64>
3480a30c:	e59f301c 	ldr	r3, [pc, #28]	; 3480a330 <mallopt+0x70>
3480a310:	e5831040 	str	r1, [r3, #64]	; 0x40
3480a314:	e3a00001 	mov	r0, #1
3480a318:	e12fff1e 	bx	lr
#endif

    default:
      return 0;
3480a31c:	e3a00000 	mov	r0, #0
3480a320:	e12fff1e 	bx	lr
      mmap_threshold = value; return 1;
    case M_MMAP_MAX:
#if HAVE_MMAP
      n_mmaps_max = value; return 1;
#else
      if (value != 0) return 0; else  n_mmaps_max = value; return 1;
3480a324:	e3a00000 	mov	r0, #0
#endif

    default:
      return 0;
  }
}
3480a328:	e12fff1e 	bx	lr
3480a32c:	348283c8 	.word	0x348283c8
3480a330:	348294e0 	.word	0x348294e0

3480a334 <env_get_char_spec>:
	.apply = env_check_apply,
};

static uchar __env_get_char_spec(int index)
{
	return *((uchar *)(gd->env_addr + index));
3480a334:	e5983010 	ldr	r3, [r8, #16]
}
3480a338:	e7d00003 	ldrb	r0, [r0, r3]
3480a33c:	e12fff1e 	bx	lr

3480a340 <env_get_addr>:
		return env_get_char_init(index);
}

const uchar *env_get_addr(int index)
{
	if (gd->env_valid)
3480a340:	e5982014 	ldr	r2, [r8, #20]
3480a344:	e1a03008 	mov	r3, r8
3480a348:	e3520000 	cmp	r2, #0
		return (uchar *)(gd->env_addr + index);
3480a34c:	15983010 	ldrne	r3, [r8, #16]
	else
		return &default_environment[index];
3480a350:	059f3008 	ldreq	r3, [pc, #8]	; 3480a360 <env_get_addr+0x20>
}

const uchar *env_get_addr(int index)
{
	if (gd->env_valid)
		return (uchar *)(gd->env_addr + index);
3480a354:	10800003 	addne	r0, r0, r3
	else
		return &default_environment[index];
3480a358:	00830000 	addeq	r0, r3, r0
}
3480a35c:	e12fff1e 	bx	lr
3480a360:	348205bc 	.word	0x348205bc

3480a364 <env_get_char_memory>:
	else
		return default_environment[index];
}

uchar env_get_char_memory(int index)
{
3480a364:	e92d4008 	push	{r3, lr}
	return *env_get_addr(index);
3480a368:	ebfffff4 	bl	3480a340 <env_get_addr>
}
3480a36c:	e5d00000 	ldrb	r0, [r0]
3480a370:	e8bd8008 	pop	{r3, pc}

3480a374 <env_get_char>:

uchar env_get_char(int index)
{
	/* if relocated to RAM */
	if (gd->flags & GD_FLG_RELOC)
3480a374:	e5981004 	ldr	r1, [r8, #4]
3480a378:	e3110001 	tst	r1, #1
3480a37c:	0a000000 	beq	3480a384 <env_get_char+0x10>
		return env_get_char_memory(index);
3480a380:	eafffff7 	b	3480a364 <env_get_char_memory>
	__attribute__((weak, alias("__env_get_char_spec")));

static uchar env_get_char_init(int index)
{
	/* if crc was bad, use the default environment */
	if (gd->env_valid)
3480a384:	e5983014 	ldr	r3, [r8, #20]
3480a388:	e3530000 	cmp	r3, #0
3480a38c:	0a000000 	beq	3480a394 <env_get_char+0x20>
		return env_get_char_spec(index);
3480a390:	eaffffe7 	b	3480a334 <env_get_char_spec>
	else
		return default_environment[index];
3480a394:	e59f3008 	ldr	r3, [pc, #8]	; 3480a3a4 <env_get_char+0x30>
3480a398:	e0832000 	add	r2, r3, r0
	/* if relocated to RAM */
	if (gd->flags & GD_FLG_RELOC)
		return env_get_char_memory(index);
	else
		return env_get_char_init(index);
}
3480a39c:	e5d2073b 	ldrb	r0, [r2, #1851]	; 0x73b
3480a3a0:	e12fff1e 	bx	lr
3480a3a4:	348205bc 	.word	0x348205bc

3480a3a8 <set_default_env>:
	else
		return &default_environment[index];
}

void set_default_env(const char *s)
{
3480a3a8:	e92d401f 	push	{r0, r1, r2, r3, r4, lr}
	if (sizeof(default_environment) > ENV_SIZE) {
		puts("*** Error - default environment is too large\n\n");
		return;
	}

	if (s) {
3480a3ac:	e2504000 	subs	r4, r0, #0
3480a3b0:	0a00000a 	beq	3480a3e0 <set_default_env+0x38>
		if (*s == '!') {
3480a3b4:	e5d43000 	ldrb	r3, [r4]
3480a3b8:	e3530021 	cmp	r3, #33	; 0x21
3480a3bc:	1a000004 	bne	3480a3d4 <set_default_env+0x2c>
			printf("*** Warning - %s, "
3480a3c0:	e2841001 	add	r1, r4, #1
3480a3c4:	e59f0078 	ldr	r0, [pc, #120]	; 3480a444 <set_default_env+0x9c>
3480a3c8:	ebfffadf 	bl	34808f4c <printf>
{
	/*
	 * By default, do not apply changes as they will eventually
	 * be applied by someone else
	 */
	int do_apply = 0;
3480a3cc:	e3a04000 	mov	r4, #0
3480a3d0:	ea000004 	b	3480a3e8 <set_default_env+0x40>
			 * mechanism.  Therefore we check every single
			 * variable and apply changes to the system
			 * right away (e.g. baudrate, console).
			 */
			do_apply = 1;
			puts(s);
3480a3d4:	ebfffad2 	bl	34808f24 <puts>
			 * by the user, as opposed to being a recovery
			 * mechanism.  Therefore we check every single
			 * variable and apply changes to the system
			 * right away (e.g. baudrate, console).
			 */
			do_apply = 1;
3480a3d8:	e3a04001 	mov	r4, #1
3480a3dc:	ea000001 	b	3480a3e8 <set_default_env+0x40>
			puts(s);
		}
	} else {
		puts("Using default environment\n\n");
3480a3e0:	e59f0060 	ldr	r0, [pc, #96]	; 3480a448 <set_default_env+0xa0>
3480a3e4:	ebffface 	bl	34808f24 <puts>
	}

	if (himport_r(&env_htab, (char *)default_environment,
3480a3e8:	e3a03000 	mov	r3, #0
3480a3ec:	e59f0058 	ldr	r0, [pc, #88]	; 3480a44c <set_default_env+0xa4>
3480a3f0:	e59f1058 	ldr	r1, [pc, #88]	; 3480a450 <set_default_env+0xa8>
3480a3f4:	e300273b 	movw	r2, #1851	; 0x73b
3480a3f8:	e58d3000 	str	r3, [sp]
3480a3fc:	e58d3004 	str	r3, [sp, #4]
3480a400:	e58d3008 	str	r3, [sp, #8]
3480a404:	e58d400c 	str	r4, [sp, #12]
3480a408:	eb0036e1 	bl	34817f94 <himport_r>
3480a40c:	e3500000 	cmp	r0, #0
3480a410:	1a000007 	bne	3480a434 <set_default_env+0x8c>
			sizeof(default_environment), '\0', 0,
			0, NULL, do_apply) == 0)
		error("Environment import failed: errno = %d\n", errno);
3480a414:	e59f3038 	ldr	r3, [pc, #56]	; 3480a454 <set_default_env+0xac>
3480a418:	e59f0038 	ldr	r0, [pc, #56]	; 3480a458 <set_default_env+0xb0>
3480a41c:	e58d3000 	str	r3, [sp]
3480a420:	e59f3034 	ldr	r3, [pc, #52]	; 3480a45c <set_default_env+0xb4>
3480a424:	e59f2034 	ldr	r2, [pc, #52]	; 3480a460 <set_default_env+0xb8>
3480a428:	e5931000 	ldr	r1, [r3]
3480a42c:	e3a030d8 	mov	r3, #216	; 0xd8
3480a430:	ebfffac5 	bl	34808f4c <printf>

	gd->flags |= GD_FLG_ENV_READY;
3480a434:	e5982004 	ldr	r2, [r8, #4]
3480a438:	e3822080 	orr	r2, r2, #128	; 0x80
3480a43c:	e5882004 	str	r2, [r8, #4]
}
3480a440:	e8bd801f 	pop	{r0, r1, r2, r3, r4, pc}
3480a444:	34825f9e 	.word	0x34825f9e
3480a448:	34825fcc 	.word	0x34825fcc
3480a44c:	348287dc 	.word	0x348287dc
3480a450:	348205bc 	.word	0x348205bc
3480a454:	34821434 	.word	0x34821434
3480a458:	348255fe 	.word	0x348255fe
3480a45c:	3482b338 	.word	0x3482b338
3480a460:	34825fe8 	.word	0x34825fe8

3480a464 <set_default_vars>:


/* [re]set individual variables to their value in the default environment */
int set_default_vars(int nvars, char * const vars[])
{
3480a464:	e92d401f 	push	{r0, r1, r2, r3, r4, lr}
	/*
	 * Special use-case: import from default environment
	 * (and use \0 as a separator)
	 */
	return himport_r(&env_htab, (const char *)default_environment,
3480a468:	e3a03001 	mov	r3, #1
3480a46c:	e58d3000 	str	r3, [sp]
3480a470:	e98d000b 	stmib	sp, {r0, r1, r3}
3480a474:	e59f1014 	ldr	r1, [pc, #20]	; 3480a490 <set_default_vars+0x2c>
3480a478:	e300273b 	movw	r2, #1851	; 0x73b
3480a47c:	e3a03000 	mov	r3, #0
3480a480:	e59f000c 	ldr	r0, [pc, #12]	; 3480a494 <set_default_vars+0x30>
3480a484:	eb0036c2 	bl	34817f94 <himport_r>
				sizeof(default_environment), '\0', H_NOCLEAR,
				nvars, vars, 1 /* do_apply */);
}
3480a488:	e28dd014 	add	sp, sp, #20
3480a48c:	e8bd8000 	pop	{pc}
3480a490:	348205bc 	.word	0x348205bc
3480a494:	348287dc 	.word	0x348287dc

3480a498 <env_import>:
/*
 * Check if CRC is valid and (if yes) import the environment.
 * Note that "buf" may or may not be aligned.
 */
int env_import(const char *buf, int check)
{
3480a498:	e92d4010 	push	{r4, lr}
	env_t *ep = (env_t *)buf;

	if (check) {
3480a49c:	e3510000 	cmp	r1, #0
/*
 * Check if CRC is valid and (if yes) import the environment.
 * Note that "buf" may or may not be aligned.
 */
int env_import(const char *buf, int check)
{
3480a4a0:	e24dd018 	sub	sp, sp, #24
3480a4a4:	e1a04000 	mov	r4, r0
	env_t *ep = (env_t *)buf;

	if (check) {
3480a4a8:	0a00000e 	beq	3480a4e8 <env_import+0x50>
		uint32_t crc;

		memcpy(&crc, &ep->crc, sizeof(crc));
3480a4ac:	e1a01004 	mov	r1, r4
3480a4b0:	e3a02004 	mov	r2, #4
3480a4b4:	e28d0014 	add	r0, sp, #20
3480a4b8:	eb003a74 	bl	34818e90 <memcpy>

		if (crc32(0, ep->data, ENV_SIZE) != crc) {
3480a4bc:	e3a00000 	mov	r0, #0
3480a4c0:	e2841004 	add	r1, r4, #4
3480a4c4:	e59f208c 	ldr	r2, [pc, #140]	; 3480a558 <env_import+0xc0>
3480a4c8:	eb0032ee 	bl	34817088 <crc32>
3480a4cc:	e59d3014 	ldr	r3, [sp, #20]
3480a4d0:	e1500003 	cmp	r0, r3
3480a4d4:	0a000003 	beq	3480a4e8 <env_import+0x50>
			set_default_env("!bad CRC");
3480a4d8:	e59f007c 	ldr	r0, [pc, #124]	; 3480a55c <env_import+0xc4>
3480a4dc:	ebffffb1 	bl	3480a3a8 <set_default_env>
			return 0;
3480a4e0:	e3a00000 	mov	r0, #0
3480a4e4:	ea000019 	b	3480a550 <env_import+0xb8>
		}
	}

	if (himport_r(&env_htab, (char *)ep->data, ENV_SIZE, '\0', 0,
3480a4e8:	e3a03000 	mov	r3, #0
3480a4ec:	e2841004 	add	r1, r4, #4
3480a4f0:	e59f0068 	ldr	r0, [pc, #104]	; 3480a560 <env_import+0xc8>
3480a4f4:	e59f205c 	ldr	r2, [pc, #92]	; 3480a558 <env_import+0xc0>
3480a4f8:	e58d3000 	str	r3, [sp]
3480a4fc:	e58d3004 	str	r3, [sp, #4]
3480a500:	e58d3008 	str	r3, [sp, #8]
3480a504:	e58d300c 	str	r3, [sp, #12]
3480a508:	eb0036a1 	bl	34817f94 <himport_r>
3480a50c:	e2504000 	subs	r4, r0, #0
			0, NULL, 0 /* do_apply */)) {
		gd->flags |= GD_FLG_ENV_READY;
3480a510:	15982004 	ldrne	r2, [r8, #4]
		return 1;
3480a514:	13a00001 	movne	r0, #1
		}
	}

	if (himport_r(&env_htab, (char *)ep->data, ENV_SIZE, '\0', 0,
			0, NULL, 0 /* do_apply */)) {
		gd->flags |= GD_FLG_ENV_READY;
3480a518:	13822080 	orrne	r2, r2, #128	; 0x80
3480a51c:	15882004 	strne	r2, [r8, #4]
		return 1;
3480a520:	1a00000a 	bne	3480a550 <env_import+0xb8>
	}

	error("Cannot import environment: errno = %d\n", errno);
3480a524:	e59f3038 	ldr	r3, [pc, #56]	; 3480a564 <env_import+0xcc>
3480a528:	e59f2038 	ldr	r2, [pc, #56]	; 3480a568 <env_import+0xd0>
3480a52c:	e58d3000 	str	r3, [sp]
3480a530:	e59f3034 	ldr	r3, [pc, #52]	; 3480a56c <env_import+0xd4>
3480a534:	e59f0034 	ldr	r0, [pc, #52]	; 3480a570 <env_import+0xd8>
3480a538:	e5931000 	ldr	r1, [r3]
3480a53c:	e3a03f41 	mov	r3, #260	; 0x104
3480a540:	ebfffa81 	bl	34808f4c <printf>

	set_default_env("!import failed");
3480a544:	e59f0028 	ldr	r0, [pc, #40]	; 3480a574 <env_import+0xdc>
3480a548:	ebffff96 	bl	3480a3a8 <set_default_env>

	return 0;
3480a54c:	e1a00004 	mov	r0, r4
}
3480a550:	e28dd018 	add	sp, sp, #24
3480a554:	e8bd8010 	pop	{r4, pc}
3480a558:	0003fffc 	.word	0x0003fffc
3480a55c:	34825ff5 	.word	0x34825ff5
3480a560:	348287dc 	.word	0x348287dc
3480a564:	34821444 	.word	0x34821444
3480a568:	34825fe8 	.word	0x34825fe8
3480a56c:	3482b338 	.word	0x3482b338
3480a570:	34825ffe 	.word	0x34825ffe
3480a574:	3482603b 	.word	0x3482603b

3480a578 <env_relocate>:
void env_relocate(void)
{
#if defined(CONFIG_NEEDS_MANUAL_RELOC)
	env_reloc();
#endif
	if (gd->env_valid == 0) {
3480a578:	e5980014 	ldr	r0, [r8, #20]
3480a57c:	e3500000 	cmp	r0, #0
3480a580:	1a000000 	bne	3480a588 <env_relocate+0x10>
#if defined(CONFIG_ENV_IS_NOWHERE) || defined(CONFIG_SPL_BUILD)
		/* Environment not changable */
		set_default_env(NULL);
3480a584:	eaffff87 	b	3480a3a8 <set_default_env>
#else
		bootstage_error(BOOTSTAGE_ID_NET_CHECKSUM);
		set_default_env("!bad CRC");
#endif
	} else {
		env_relocate_spec();
3480a588:	eaffffff 	b	3480a58c <env_relocate_spec>

3480a58c <env_relocate_spec>:

env_t *env_ptr;

void env_relocate_spec(void)
{
}
3480a58c:	e12fff1e 	bx	lr

3480a590 <env_init>:
 *
 * We are still running from ROM, so data use is limited
 */
int env_init(void)
{
	gd->env_addr	= (ulong)&default_environment[0];
3480a590:	e59f200c 	ldr	r2, [pc, #12]	; 3480a5a4 <env_init+0x14>
	gd->env_valid	= 0;
3480a594:	e3a00000 	mov	r0, #0
 *
 * We are still running from ROM, so data use is limited
 */
int env_init(void)
{
	gd->env_addr	= (ulong)&default_environment[0];
3480a598:	e5882010 	str	r2, [r8, #16]
	gd->env_valid	= 0;
3480a59c:	e5880014 	str	r0, [r8, #20]

	return 0;
}
3480a5a0:	e12fff1e 	bx	lr
3480a5a4:	348205bc 	.word	0x348205bc

3480a5a8 <dummy>:

DECLARE_GLOBAL_DATA_PTR;

__attribute__((unused)) static void dummy(void)
{
}
3480a5a8:	e12fff1e 	bx	lr

3480a5ac <get_version>:

unsigned long get_version(void)
{
	return XF_VERSION;
}
3480a5ac:	e3a00006 	mov	r0, #6
3480a5b0:	e12fff1e 	bx	lr

3480a5b4 <jumptable_init>:
# define spi_release_bus   dummy
# define spi_xfer          dummy
#endif

void jumptable_init(void)
{
3480a5b4:	e92d4010 	push	{r4, lr}
	gd->jt = malloc(XF_MAX * sizeof(void *));
3480a5b8:	e3a00070 	mov	r0, #112	; 0x70
3480a5bc:	e1a04008 	mov	r4, r8
3480a5c0:	ebfffc28 	bl	34809668 <malloc>
3480a5c4:	e5840054 	str	r0, [r4, #84]	; 0x54
/*
 * You do not need to use #ifdef around functions that may not exist
 * in the final configuration (such as i2c).
 */
EXPORT_FUNC(get_version)
3480a5c8:	e5982054 	ldr	r2, [r8, #84]	; 0x54
3480a5cc:	e59f1124 	ldr	r1, [pc, #292]	; 3480a6f8 <jumptable_init+0x144>
EXPORT_FUNC(putc)
EXPORT_FUNC(puts)
EXPORT_FUNC(printf)
EXPORT_FUNC(install_hdlr)
EXPORT_FUNC(free_hdlr)
EXPORT_FUNC(malloc)
3480a5d0:	e59f0124 	ldr	r0, [pc, #292]	; 3480a6fc <jumptable_init+0x148>
/*
 * You do not need to use #ifdef around functions that may not exist
 * in the final configuration (such as i2c).
 */
EXPORT_FUNC(get_version)
3480a5d4:	e5821000 	str	r1, [r2]
EXPORT_FUNC(getc)
3480a5d8:	e5982054 	ldr	r2, [r8, #84]	; 0x54
3480a5dc:	e59f111c 	ldr	r1, [pc, #284]	; 3480a700 <jumptable_init+0x14c>
3480a5e0:	e5821004 	str	r1, [r2, #4]
EXPORT_FUNC(tstc)
3480a5e4:	e5982054 	ldr	r2, [r8, #84]	; 0x54
3480a5e8:	e59f1114 	ldr	r1, [pc, #276]	; 3480a704 <jumptable_init+0x150>
3480a5ec:	e5821008 	str	r1, [r2, #8]
EXPORT_FUNC(putc)
3480a5f0:	e5982054 	ldr	r2, [r8, #84]	; 0x54
3480a5f4:	e59f110c 	ldr	r1, [pc, #268]	; 3480a708 <jumptable_init+0x154>
3480a5f8:	e582100c 	str	r1, [r2, #12]
EXPORT_FUNC(puts)
3480a5fc:	e5982054 	ldr	r2, [r8, #84]	; 0x54
3480a600:	e59f1104 	ldr	r1, [pc, #260]	; 3480a70c <jumptable_init+0x158>
3480a604:	e5821010 	str	r1, [r2, #16]
EXPORT_FUNC(printf)
3480a608:	e5982054 	ldr	r2, [r8, #84]	; 0x54
3480a60c:	e59f10fc 	ldr	r1, [pc, #252]	; 3480a710 <jumptable_init+0x15c>
3480a610:	e5821014 	str	r1, [r2, #20]
EXPORT_FUNC(install_hdlr)
3480a614:	e5981054 	ldr	r1, [r8, #84]	; 0x54
3480a618:	e59f20f4 	ldr	r2, [pc, #244]	; 3480a714 <jumptable_init+0x160>
3480a61c:	e5812018 	str	r2, [r1, #24]
EXPORT_FUNC(free_hdlr)
3480a620:	e5981054 	ldr	r1, [r8, #84]	; 0x54
3480a624:	e581201c 	str	r2, [r1, #28]
EXPORT_FUNC(malloc)
3480a628:	e5981054 	ldr	r1, [r8, #84]	; 0x54
3480a62c:	e5810020 	str	r0, [r1, #32]
EXPORT_FUNC(free)
3480a630:	e5981054 	ldr	r1, [r8, #84]	; 0x54
3480a634:	e59f00dc 	ldr	r0, [pc, #220]	; 3480a718 <jumptable_init+0x164>
3480a638:	e5810024 	str	r0, [r1, #36]	; 0x24
EXPORT_FUNC(udelay)
3480a63c:	e5981054 	ldr	r1, [r8, #84]	; 0x54
3480a640:	e59f00d4 	ldr	r0, [pc, #212]	; 3480a71c <jumptable_init+0x168>
3480a644:	e5810028 	str	r0, [r1, #40]	; 0x28
EXPORT_FUNC(get_timer)
3480a648:	e5981054 	ldr	r1, [r8, #84]	; 0x54
3480a64c:	e59f00cc 	ldr	r0, [pc, #204]	; 3480a720 <jumptable_init+0x16c>
3480a650:	e581002c 	str	r0, [r1, #44]	; 0x2c
EXPORT_FUNC(vprintf)
3480a654:	e5981054 	ldr	r1, [r8, #84]	; 0x54
3480a658:	e59f00c4 	ldr	r0, [pc, #196]	; 3480a724 <jumptable_init+0x170>
3480a65c:	e5810030 	str	r0, [r1, #48]	; 0x30
EXPORT_FUNC(do_reset)
3480a660:	e5981054 	ldr	r1, [r8, #84]	; 0x54
3480a664:	e59f00bc 	ldr	r0, [pc, #188]	; 3480a728 <jumptable_init+0x174>
3480a668:	e5810034 	str	r0, [r1, #52]	; 0x34
EXPORT_FUNC(getenv)
3480a66c:	e5981054 	ldr	r1, [r8, #84]	; 0x54
3480a670:	e59f00b4 	ldr	r0, [pc, #180]	; 3480a72c <jumptable_init+0x178>
3480a674:	e5810038 	str	r0, [r1, #56]	; 0x38
EXPORT_FUNC(setenv)
3480a678:	e5981054 	ldr	r1, [r8, #84]	; 0x54
3480a67c:	e59f00ac 	ldr	r0, [pc, #172]	; 3480a730 <jumptable_init+0x17c>
3480a680:	e581003c 	str	r0, [r1, #60]	; 0x3c
EXPORT_FUNC(simple_strtoul)
3480a684:	e5981054 	ldr	r1, [r8, #84]	; 0x54
3480a688:	e59f00a4 	ldr	r0, [pc, #164]	; 3480a734 <jumptable_init+0x180>
3480a68c:	e5810040 	str	r0, [r1, #64]	; 0x40
EXPORT_FUNC(strict_strtoul)
3480a690:	e5981054 	ldr	r1, [r8, #84]	; 0x54
3480a694:	e59f009c 	ldr	r0, [pc, #156]	; 3480a738 <jumptable_init+0x184>
3480a698:	e5810044 	str	r0, [r1, #68]	; 0x44
EXPORT_FUNC(simple_strtol)
3480a69c:	e5981054 	ldr	r1, [r8, #84]	; 0x54
3480a6a0:	e59f0094 	ldr	r0, [pc, #148]	; 3480a73c <jumptable_init+0x188>
3480a6a4:	e5810048 	str	r0, [r1, #72]	; 0x48
EXPORT_FUNC(strcmp)
3480a6a8:	e5981054 	ldr	r1, [r8, #84]	; 0x54
3480a6ac:	e59f008c 	ldr	r0, [pc, #140]	; 3480a740 <jumptable_init+0x18c>
3480a6b0:	e581004c 	str	r0, [r1, #76]	; 0x4c
EXPORT_FUNC(i2c_write)
3480a6b4:	e5981054 	ldr	r1, [r8, #84]	; 0x54
3480a6b8:	e5812050 	str	r2, [r1, #80]	; 0x50
EXPORT_FUNC(i2c_read)
3480a6bc:	e5981054 	ldr	r1, [r8, #84]	; 0x54
3480a6c0:	e5812054 	str	r2, [r1, #84]	; 0x54
EXPORT_FUNC(spi_init)
3480a6c4:	e5981054 	ldr	r1, [r8, #84]	; 0x54
3480a6c8:	e5812058 	str	r2, [r1, #88]	; 0x58
EXPORT_FUNC(spi_setup_slave)
3480a6cc:	e5981054 	ldr	r1, [r8, #84]	; 0x54
3480a6d0:	e581205c 	str	r2, [r1, #92]	; 0x5c
EXPORT_FUNC(spi_free_slave)
3480a6d4:	e5981054 	ldr	r1, [r8, #84]	; 0x54
3480a6d8:	e5812060 	str	r2, [r1, #96]	; 0x60
EXPORT_FUNC(spi_claim_bus)
3480a6dc:	e5981054 	ldr	r1, [r8, #84]	; 0x54
3480a6e0:	e5812064 	str	r2, [r1, #100]	; 0x64
EXPORT_FUNC(spi_release_bus)
3480a6e4:	e5981054 	ldr	r1, [r8, #84]	; 0x54
EXPORT_FUNC(spi_xfer)
3480a6e8:	e5983054 	ldr	r3, [r8, #84]	; 0x54
EXPORT_FUNC(i2c_read)
EXPORT_FUNC(spi_init)
EXPORT_FUNC(spi_setup_slave)
EXPORT_FUNC(spi_free_slave)
EXPORT_FUNC(spi_claim_bus)
EXPORT_FUNC(spi_release_bus)
3480a6ec:	e5812068 	str	r2, [r1, #104]	; 0x68
EXPORT_FUNC(spi_xfer)
3480a6f0:	e583206c 	str	r2, [r3, #108]	; 0x6c
#include <_exports.h>
}
3480a6f4:	e8bd8010 	pop	{r4, pc}
3480a6f8:	3480a5ac 	.word	0x3480a5ac
3480a6fc:	34809668 	.word	0x34809668
3480a700:	34808eb4 	.word	0x34808eb4
3480a704:	34808ed8 	.word	0x34808ed8
3480a708:	34808efc 	.word	0x34808efc
3480a70c:	34808f24 	.word	0x34808f24
3480a710:	34808f4c 	.word	0x34808f4c
3480a714:	3480a5a8 	.word	0x3480a5a8
3480a718:	34809444 	.word	0x34809444
3480a71c:	348190bc 	.word	0x348190bc
3480a720:	34801254 	.word	0x34801254
3480a724:	34808f9c 	.word	0x34808f9c
3480a728:	348020d8 	.word	0x348020d8
3480a72c:	3480823c 	.word	0x3480823c
3480a730:	34807e1c 	.word	0x34807e1c
3480a734:	34819bf8 	.word	0x34819bf8
3480a738:	34819ca4 	.word	0x34819ca4
3480a73c:	34819d1c 	.word	0x34819d1c
3480a740:	34818ab0 	.word	0x34818ab0

3480a744 <static_get>:
}
#endif

static int static_get(struct in_str *i)
{
	int ch = *i->p++;
3480a744:	e5903000 	ldr	r3, [r0]
3480a748:	e4d32001 	ldrb	r2, [r3], #1
	if (ch=='\0') return EOF;
3480a74c:	e3520000 	cmp	r2, #0
}
#endif

static int static_get(struct in_str *i)
{
	int ch = *i->p++;
3480a750:	e5803000 	str	r3, [r0]
	if (ch=='\0') return EOF;
	return ch;
}
3480a754:	11a00002 	movne	r0, r2
3480a758:	03e00000 	mvneq	r0, #0
3480a75c:	e12fff1e 	bx	lr

3480a760 <static_peek>:

static int static_peek(struct in_str *i)
{
	return *i->p;
3480a760:	e5903000 	ldr	r3, [r0]
}
3480a764:	e5d30000 	ldrb	r0, [r3]
3480a768:	e12fff1e 	bx	lr

3480a76c <file_peek>:
static int file_peek(struct in_str *i)
{
#ifndef __U_BOOT__
	if (i->p && *i->p) {
#endif
		return *i->p;
3480a76c:	e5903000 	ldr	r3, [r0]
		i->p = i->peek_buf;
		debug_printf("b_peek: got a %d\n", *i->p);
		return *i->p;
	}
#endif
}
3480a770:	e5d30000 	ldrb	r0, [r3]
3480a774:	e12fff1e 	bx	lr

3480a778 <is_assignment>:
	}
}

static int is_assignment(const char *s)
{
	if (s == NULL)
3480a778:	e3500000 	cmp	r0, #0
3480a77c:	012fff1e 	bxeq	lr
		return 0;

	if (!isalpha(*s)) return 0;
3480a780:	e59f3040 	ldr	r3, [pc, #64]	; 3480a7c8 <is_assignment+0x50>
3480a784:	e5d02000 	ldrb	r2, [r0]
3480a788:	e7d32002 	ldrb	r2, [r3, r2]
3480a78c:	e2122003 	ands	r2, r2, #3
3480a790:	0a00000a 	beq	3480a7c0 <is_assignment+0x48>
	++s;
	while(isalnum(*s) || *s=='_') ++s;
3480a794:	e1a02003 	mov	r2, r3
3480a798:	e5f03001 	ldrb	r3, [r0, #1]!
3480a79c:	e7d21003 	ldrb	r1, [r2, r3]
3480a7a0:	e3110007 	tst	r1, #7
3480a7a4:	1afffffb 	bne	3480a798 <is_assignment+0x20>
3480a7a8:	e353005f 	cmp	r3, #95	; 0x5f
3480a7ac:	0afffff9 	beq	3480a798 <is_assignment+0x20>
	return *s=='=';
3480a7b0:	e353003d 	cmp	r3, #61	; 0x3d
3480a7b4:	13a00000 	movne	r0, #0
3480a7b8:	03a00001 	moveq	r0, #1
3480a7bc:	e12fff1e 	bx	lr
static int is_assignment(const char *s)
{
	if (s == NULL)
		return 0;

	if (!isalpha(*s)) return 0;
3480a7c0:	e1a00002 	mov	r0, r2
	++s;
	while(isalnum(*s) || *s=='_') ++s;
	return *s=='=';
}
3480a7c4:	e12fff1e 	bx	lr
3480a7c8:	34821fd4 	.word	0x34821fd4

3480a7cc <syntax_err>:
#endif
#define final_printf debug_printf

#ifdef __U_BOOT__
static void syntax_err(void) {
	 printf("syntax error\n");
3480a7cc:	e59f0000 	ldr	r0, [pc, #0]	; 3480a7d4 <syntax_err+0x8>
3480a7d0:	eafff9dd 	b	34808f4c <printf>
3480a7d4:	3482604a 	.word	0x3482604a

3480a7d8 <do_showvar>:
	return str;
}

#ifdef __U_BOOT__
int do_showvar (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
3480a7d8:	e92d4ef3 	push	{r0, r1, r4, r5, r6, r7, r9, sl, fp, lr}
	int i, k;
	int rcode = 0;
	struct variables *cur;

	if (argc == 1) {		/* Print all env variables	*/
3480a7dc:	e3520001 	cmp	r2, #1
		for (cur = top_vars; cur; cur = cur->next) {
3480a7e0:	059f30d0 	ldreq	r3, [pc, #208]	; 3480a8b8 <do_showvar+0xe0>
	return str;
}

#ifdef __U_BOOT__
int do_showvar (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
3480a7e4:	e58d2004 	str	r2, [sp, #4]
	int i, k;
	int rcode = 0;
	struct variables *cur;

	if (argc == 1) {		/* Print all env variables	*/
3480a7e8:	11a09003 	movne	r9, r3
3480a7ec:	13a04000 	movne	r4, #0
3480a7f0:	13a06001 	movne	r6, #1
		for (cur = top_vars; cur; cur = cur->next) {
3480a7f4:	05934000 	ldreq	r4, [r3]
{
	int i, k;
	int rcode = 0;
	struct variables *cur;

	if (argc == 1) {		/* Print all env variables	*/
3480a7f8:	1a000029 	bne	3480a8a4 <do_showvar+0xcc>
3480a7fc:	ea000006 	b	3480a81c <do_showvar+0x44>
		for (cur = top_vars; cur; cur = cur->next) {
			printf ("%s=%s\n", cur->name, cur->value);
3480a800:	e8940006 	ldm	r4, {r1, r2}
3480a804:	e59f00b0 	ldr	r0, [pc, #176]	; 3480a8bc <do_showvar+0xe4>
3480a808:	ebfff9cf 	bl	34808f4c <printf>
			if (ctrlc ()) {
3480a80c:	ebfff9f3 	bl	34808fe0 <ctrlc>
3480a810:	e3500000 	cmp	r0, #0
3480a814:	1a000014 	bne	3480a86c <do_showvar+0x94>
	int i, k;
	int rcode = 0;
	struct variables *cur;

	if (argc == 1) {		/* Print all env variables	*/
		for (cur = top_vars; cur; cur = cur->next) {
3480a818:	e5944010 	ldr	r4, [r4, #16]
3480a81c:	e3540000 	cmp	r4, #0
3480a820:	1afffff6 	bne	3480a800 <do_showvar+0x28>
3480a824:	ea000021 	b	3480a8b0 <do_showvar+0xd8>
	}
	for (i = 1; i < argc; ++i) {	/* print single env variables	*/
		char *name = argv[i];

		k = -1;
		for (cur = top_vars; cur; cur = cur->next) {
3480a828:	e59f2088 	ldr	r2, [pc, #136]	; 3480a8b8 <do_showvar+0xe0>
			}
		}
		return 0;
	}
	for (i = 1; i < argc; ++i) {	/* print single env variables	*/
		char *name = argv[i];
3480a82c:	e5b97004 	ldr	r7, [r9, #4]!

		k = -1;
		for (cur = top_vars; cur; cur = cur->next) {
3480a830:	e5925000 	ldr	r5, [r2]
		return 0;
	}
	for (i = 1; i < argc; ++i) {	/* print single env variables	*/
		char *name = argv[i];

		k = -1;
3480a834:	e3e0b000 	mvn	fp, #0
		for (cur = top_vars; cur; cur = cur->next) {
3480a838:	ea000010 	b	3480a880 <do_showvar+0xa8>
			if(strcmp (cur->name, name) == 0) {
3480a83c:	e5950000 	ldr	r0, [r5]
3480a840:	e1a01007 	mov	r1, r7
3480a844:	eb003899 	bl	34818ab0 <strcmp>
3480a848:	e250a000 	subs	sl, r0, #0
3480a84c:	1a000003 	bne	3480a860 <do_showvar+0x88>
				k = 0;
				printf ("%s=%s\n", cur->name, cur->value);
3480a850:	e59f0064 	ldr	r0, [pc, #100]	; 3480a8bc <do_showvar+0xe4>
3480a854:	e8950006 	ldm	r5, {r1, r2}
3480a858:	ebfff9bb 	bl	34808f4c <printf>
		char *name = argv[i];

		k = -1;
		for (cur = top_vars; cur; cur = cur->next) {
			if(strcmp (cur->name, name) == 0) {
				k = 0;
3480a85c:	e1a0b00a 	mov	fp, sl
				printf ("%s=%s\n", cur->name, cur->value);
			}
			if (ctrlc ()) {
3480a860:	ebfff9de 	bl	34808fe0 <ctrlc>
3480a864:	e3500000 	cmp	r0, #0
3480a868:	0a000003 	beq	3480a87c <do_showvar+0xa4>
				puts ("\n ** Abort\n");
3480a86c:	e59f004c 	ldr	r0, [pc, #76]	; 3480a8c0 <do_showvar+0xe8>
3480a870:	ebfff9ab 	bl	34808f24 <puts>
				return 1;
3480a874:	e3a04001 	mov	r4, #1
3480a878:	ea00000c 	b	3480a8b0 <do_showvar+0xd8>
	}
	for (i = 1; i < argc; ++i) {	/* print single env variables	*/
		char *name = argv[i];

		k = -1;
		for (cur = top_vars; cur; cur = cur->next) {
3480a87c:	e5955010 	ldr	r5, [r5, #16]
3480a880:	e3550000 	cmp	r5, #0
3480a884:	1affffec 	bne	3480a83c <do_showvar+0x64>
			if (ctrlc ()) {
				puts ("\n ** Abort\n");
				return 1;
			}
		}
		if (k < 0) {
3480a888:	e37b0001 	cmn	fp, #1
3480a88c:	1a000003 	bne	3480a8a0 <do_showvar+0xc8>
			printf ("## Error: \"%s\" not defined\n", name);
3480a890:	e59f002c 	ldr	r0, [pc, #44]	; 3480a8c4 <do_showvar+0xec>
3480a894:	e1a01007 	mov	r1, r7
3480a898:	ebfff9ab 	bl	34808f4c <printf>
			rcode ++;
3480a89c:	e2844001 	add	r4, r4, #1
				return 1;
			}
		}
		return 0;
	}
	for (i = 1; i < argc; ++i) {	/* print single env variables	*/
3480a8a0:	e2866001 	add	r6, r6, #1
3480a8a4:	e59d3004 	ldr	r3, [sp, #4]
3480a8a8:	e1560003 	cmp	r6, r3
3480a8ac:	baffffdd 	blt	3480a828 <do_showvar+0x50>
			printf ("## Error: \"%s\" not defined\n", name);
			rcode ++;
		}
	}
	return rcode;
}
3480a8b0:	e1a00004 	mov	r0, r4
3480a8b4:	e8bd8efc 	pop	{r2, r3, r4, r5, r6, r7, r9, sl, fp, pc}
3480a8b8:	34829528 	.word	0x34829528
3480a8bc:	3482569c 	.word	0x3482569c
3480a8c0:	34826058 	.word	0x34826058
3480a8c4:	348256c4 	.word	0x348256c4

3480a8c8 <xmalloc>:
	}
	return 0;
}

static void *xmalloc(size_t size)
{
3480a8c8:	e92d4008 	push	{r3, lr}
	void *p = NULL;

	if (!(p = malloc(size))) {
3480a8cc:	ebfffb65 	bl	34809668 <malloc>
3480a8d0:	e3500000 	cmp	r0, #0
3480a8d4:	18bd8008 	popne	{r3, pc}
	    printf("ERROR : memory not allocated\n");
3480a8d8:	e59f0004 	ldr	r0, [pc, #4]	; 3480a8e4 <xmalloc+0x1c>
3480a8dc:	ebfff99a 	bl	34808f4c <printf>
3480a8e0:	eafffffe 	b	3480a8e0 <xmalloc+0x18>
3480a8e4:	34826064 	.word	0x34826064

3480a8e8 <file_get>:
{
	int ch;

	ch = 0;
	/* If there is data waiting, eat it up */
	if (i->p && *i->p) {
3480a8e8:	e5903000 	ldr	r3, [r0]
}

/* This is the magic location that prints prompts
 * and gets data back from the user */
static int file_get(struct in_str *i)
{
3480a8ec:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	int ch;

	ch = 0;
	/* If there is data waiting, eat it up */
	if (i->p && *i->p) {
3480a8f0:	e3530000 	cmp	r3, #0
}

/* This is the magic location that prints prompts
 * and gets data back from the user */
static int file_get(struct in_str *i)
{
3480a8f4:	e1a04000 	mov	r4, r0
	int ch;

	ch = 0;
	/* If there is data waiting, eat it up */
	if (i->p && *i->p) {
3480a8f8:	0a000047 	beq	3480aa1c <file_get+0x134>
3480a8fc:	e5d30000 	ldrb	r0, [r3]
3480a900:	e3500000 	cmp	r0, #0
3480a904:	0a000044 	beq	3480aa1c <file_get+0x134>
3480a908:	ea000056 	b	3480aa68 <file_get+0x180>
#	error "This currently only works with CONFIG_RESET_TO_RETRY enabled"
#  endif
	reset_cmd_timeout();
#endif
	i->__promptme = 1;
	if (i->promptmode == 1) {
3480a90c:	e5943008 	ldr	r3, [r4, #8]
#  ifndef CONFIG_RESET_TO_RETRY
#	error "This currently only works with CONFIG_RESET_TO_RETRY enabled"
#  endif
	reset_cmd_timeout();
#endif
	i->__promptme = 1;
3480a910:	e3a02001 	mov	r2, #1
	if (i->promptmode == 1) {
3480a914:	e1530002 	cmp	r3, r2
#  ifndef CONFIG_RESET_TO_RETRY
#	error "This currently only works with CONFIG_RESET_TO_RETRY enabled"
#  endif
	reset_cmd_timeout();
#endif
	i->__promptme = 1;
3480a918:	e5842004 	str	r2, [r4, #4]
	if (i->promptmode == 1) {
		n = readline(CONFIG_SYS_PROMPT);
3480a91c:	059f0158 	ldreq	r0, [pc, #344]	; 3480aa7c <file_get+0x194>
	} else {
		n = readline(CONFIG_SYS_PROMPT_HUSH_PS2);
3480a920:	159f0158 	ldrne	r0, [pc, #344]	; 3480aa80 <file_get+0x198>
3480a924:	eb000c3d 	bl	3480da20 <readline>
#  else
#	error "This currently only works with CONFIG_RESET_TO_RETRY enabled"
#  endif
	}
#endif
	if (n == -1 ) {
3480a928:	e3700001 	cmn	r0, #1
		flag_repeat = 0;
		i->__promptme = 0;
3480a92c:	05846004 	streq	r6, [r4, #4]
	}
	n = strlen(console_buffer);
3480a930:	e59f014c 	ldr	r0, [pc, #332]	; 3480aa84 <file_get+0x19c>
#	error "This currently only works with CONFIG_RESET_TO_RETRY enabled"
#  endif
	}
#endif
	if (n == -1 ) {
		flag_repeat = 0;
3480a934:	05856004 	streq	r6, [r5, #4]
		i->__promptme = 0;
	}
	n = strlen(console_buffer);
3480a938:	eb003890 	bl	34818b80 <strlen>
	console_buffer[n] = '\n';
3480a93c:	e1a03007 	mov	r3, r7
3480a940:	e7e3a000 	strb	sl, [r3, r0]!
	console_buffer[n+1]= '\0';
3480a944:	e5c36001 	strb	r6, [r3, #1]
	if (had_ctrlc()) flag_repeat = 0;
3480a948:	ebfff9bd 	bl	34809044 <had_ctrlc>
3480a94c:	e3500000 	cmp	r0, #0
3480a950:	15856004 	strne	r6, [r5, #4]
	clear_ctrlc();
3480a954:	ebfff9be 	bl	34809054 <clear_ctrlc>
	do_repeat = 0;
	if (i->promptmode == 1) {
3480a958:	e5949008 	ldr	r9, [r4, #8]
	n = strlen(console_buffer);
	console_buffer[n] = '\n';
	console_buffer[n+1]= '\0';
	if (had_ctrlc()) flag_repeat = 0;
	clear_ctrlc();
	do_repeat = 0;
3480a95c:	e5856008 	str	r6, [r5, #8]
	if (i->promptmode == 1) {
3480a960:	e3590001 	cmp	r9, #1
3480a964:	1a000010 	bne	3480a9ac <file_get+0xc4>
		if (console_buffer[0] == '\n'&& flag_repeat == 0) {
3480a968:	e5d73000 	ldrb	r3, [r7]
3480a96c:	e353000a 	cmp	r3, #10
3480a970:	1a000007 	bne	3480a994 <file_get+0xac>
3480a974:	e5953004 	ldr	r3, [r5, #4]
3480a978:	e3530000 	cmp	r3, #0
			if (console_buffer[0] != '\n') {
				strcpy(the_command,console_buffer);
				flag_repeat = 1;
			}
			else {
				do_repeat = 1;
3480a97c:	15859008 	strne	r9, [r5, #8]
	console_buffer[n+1]= '\0';
	if (had_ctrlc()) flag_repeat = 0;
	clear_ctrlc();
	do_repeat = 0;
	if (i->promptmode == 1) {
		if (console_buffer[0] == '\n'&& flag_repeat == 0) {
3480a980:	1a000007 	bne	3480a9a4 <file_get+0xbc>
			strcpy(the_command,console_buffer);
3480a984:	e59f10f8 	ldr	r1, [pc, #248]	; 3480aa84 <file_get+0x19c>
3480a988:	e59f00f8 	ldr	r0, [pc, #248]	; 3480aa88 <file_get+0x1a0>
3480a98c:	eb003816 	bl	348189ec <strcpy>
3480a990:	ea000003 	b	3480a9a4 <file_get+0xbc>
		}
		else {
			if (console_buffer[0] != '\n') {
				strcpy(the_command,console_buffer);
3480a994:	e59f00ec 	ldr	r0, [pc, #236]	; 3480aa88 <file_get+0x1a0>
3480a998:	e59f10e4 	ldr	r1, [pc, #228]	; 3480aa84 <file_get+0x19c>
3480a99c:	eb003812 	bl	348189ec <strcpy>
				flag_repeat = 1;
3480a9a0:	e5859004 	str	r9, [r5, #4]
			}
			else {
				do_repeat = 1;
			}
		}
		i->p = the_command;
3480a9a4:	e584b000 	str	fp, [r4]
3480a9a8:	ea000020 	b	3480aa30 <file_get+0x148>
	}
	else {
		if (console_buffer[0] != '\n') {
3480a9ac:	e5d73000 	ldrb	r3, [r7]
3480a9b0:	e353000a 	cmp	r3, #10
3480a9b4:	0a000012 	beq	3480aa04 <file_get+0x11c>
			if (strlen(the_command) + strlen(console_buffer)
3480a9b8:	e59f00c8 	ldr	r0, [pc, #200]	; 3480aa88 <file_get+0x1a0>
3480a9bc:	eb00386f 	bl	34818b80 <strlen>
3480a9c0:	e1a09000 	mov	r9, r0
3480a9c4:	e59f00b8 	ldr	r0, [pc, #184]	; 3480aa84 <file_get+0x19c>
3480a9c8:	eb00386c 	bl	34818b80 <strlen>
3480a9cc:	e0800009 	add	r0, r0, r9
3480a9d0:	e35000ff 	cmp	r0, #255	; 0xff
				n = strlen(the_command);
				the_command[n-1] = ' ';
				strcpy(&the_command[n],console_buffer);
			}
			else {
				the_command[0] = '\n';
3480a9d4:	85c5a00c 	strbhi	sl, [r5, #12]
				the_command[1] = '\0';
3480a9d8:	85c5600d 	strbhi	r6, [r5, #13]
				flag_repeat = 0;
3480a9dc:	85856004 	strhi	r6, [r5, #4]
		}
		i->p = the_command;
	}
	else {
		if (console_buffer[0] != '\n') {
			if (strlen(the_command) + strlen(console_buffer)
3480a9e0:	8a000007 	bhi	3480aa04 <file_get+0x11c>
			    < CONFIG_SYS_CBSIZE) {
				n = strlen(the_command);
3480a9e4:	e59f009c 	ldr	r0, [pc, #156]	; 3480aa88 <file_get+0x1a0>
3480a9e8:	eb003864 	bl	34818b80 <strlen>
				the_command[n-1] = ' ';
3480a9ec:	e3a02020 	mov	r2, #32
3480a9f0:	e0853000 	add	r3, r5, r0
3480a9f4:	e5c3200b 	strb	r2, [r3, #11]
				strcpy(&the_command[n],console_buffer);
3480a9f8:	e08b0000 	add	r0, fp, r0
3480a9fc:	e59f1080 	ldr	r1, [pc, #128]	; 3480aa84 <file_get+0x19c>
3480aa00:	eb0037f9 	bl	348189ec <strcpy>
				the_command[0] = '\n';
				the_command[1] = '\0';
				flag_repeat = 0;
			}
		}
		if (i->__promptme == 0) {
3480aa04:	e5943004 	ldr	r3, [r4, #4]
3480aa08:	e3530000 	cmp	r3, #0
			the_command[0] = '\n';
3480aa0c:	05c5a00c 	strbeq	sl, [r5, #12]
			the_command[1] = '\0';
3480aa10:	05c5300d 	strbeq	r3, [r5, #13]
		}
		i->p = console_buffer;
3480aa14:	e5847000 	str	r7, [r4]
3480aa18:	ea000004 	b	3480aa30 <file_get+0x148>
#	error "This currently only works with CONFIG_RESET_TO_RETRY enabled"
#  endif
	}
#endif
	if (n == -1 ) {
		flag_repeat = 0;
3480aa1c:	e59f5068 	ldr	r5, [pc, #104]	; 3480aa8c <file_get+0x1a4>
		i->__promptme = 0;
	}
	n = strlen(console_buffer);
3480aa20:	e59f705c 	ldr	r7, [pc, #92]	; 3480aa84 <file_get+0x19c>
#	error "This currently only works with CONFIG_RESET_TO_RETRY enabled"
#  endif
	}
#endif
	if (n == -1 ) {
		flag_repeat = 0;
3480aa24:	e3a06000 	mov	r6, #0
		i->__promptme = 0;
	}
	n = strlen(console_buffer);
	console_buffer[n] = '\n';
3480aa28:	e3a0a00a 	mov	sl, #10
		}
		i->p = the_command;
	}
	else {
		if (console_buffer[0] != '\n') {
			if (strlen(the_command) + strlen(console_buffer)
3480aa2c:	e285b00c 	add	fp, r5, #12
		 * more complicated by now, like sourcing or substituting. */
#ifndef __U_BOOT__
		if (i->__promptme && interactive && i->file == stdin) {
			while(! i->p || (interactive && strlen(i->p)==0) ) {
#else
			while(! i->p  || strlen(i->p)==0 ) {
3480aa30:	e5940000 	ldr	r0, [r4]
3480aa34:	e3500000 	cmp	r0, #0
3480aa38:	0affffb3 	beq	3480a90c <file_get+0x24>
3480aa3c:	eb00384f 	bl	34818b80 <strlen>
3480aa40:	e3500000 	cmp	r0, #0
3480aa44:	0affffb0 	beq	3480a90c <file_get+0x24>
#endif
				get_user_input(i);
			}
			i->promptmode=2;
3480aa48:	e3a03002 	mov	r3, #2
3480aa4c:	e5843008 	str	r3, [r4, #8]
#ifndef __U_BOOT__
			i->__promptme = 0;
#endif
			if (i->p && *i->p) {
3480aa50:	e5943000 	ldr	r3, [r4]
3480aa54:	e3530000 	cmp	r3, #0
3480aa58:	0a000005 	beq	3480aa74 <file_get+0x18c>
3480aa5c:	e5d30000 	ldrb	r0, [r3]
3480aa60:	e3500000 	cmp	r0, #0
3480aa64:	08bd8ef0 	popeq	{r4, r5, r6, r7, r9, sl, fp, pc}
				ch = *i->p++;
3480aa68:	e2833001 	add	r3, r3, #1
3480aa6c:	e5843000 	str	r3, [r4]
3480aa70:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
 * and gets data back from the user */
static int file_get(struct in_str *i)
{
	int ch;

	ch = 0;
3480aa74:	e1a00003 	mov	r0, r3
	}
#ifndef __U_BOOT__
	if (ch == '\n') i->__promptme=1;
#endif
	return ch;
}
3480aa78:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
3480aa7c:	34826082 	.word	0x34826082
3480aa80:	3482608a 	.word	0x3482608a
3480aa84:	3482abdc 	.word	0x3482abdc
3480aa88:	34829534 	.word	0x34829534
3480aa8c:	34829528 	.word	0x34829528

3480aa90 <free_pipe_list>:
	pi->progs=NULL;
	return ret_code;
}

static int free_pipe_list(struct pipe *head, int indent)
{
3480aa90:	e92d4ef3 	push	{r0, r1, r4, r5, r6, r7, r9, sl, fp, lr}
	int rcode=0;   /* if list has no members */
3480aa94:	e3a05000 	mov	r5, #0
	struct pipe *pi, *next;
	char *ind = indenter(indent);
	for (pi=head; pi; pi=next) {
3480aa98:	e1a04000 	mov	r4, r0
3480aa9c:	e1a06005 	mov	r6, r5
			child->argv=NULL;
		} else if (child->group) {
#ifndef __U_BOOT__
			final_printf("%s   begin group (subshell:%d)\n",ind, child->subshell);
#endif
			ret_code = free_pipe_list(child->group,indent+3);
3480aaa0:	e2819003 	add	r9, r1, #3
static int free_pipe_list(struct pipe *head, int indent)
{
	int rcode=0;   /* if list has no members */
	struct pipe *pi, *next;
	char *ind = indenter(indent);
	for (pi=head; pi; pi=next) {
3480aaa4:	ea000029 	b	3480ab50 <free_pipe_list+0xc0>
	if (pi->stopped_progs > 0)
		return ret_code;
	final_printf("%s run pipe: (pid %d)\n",ind,getpid());
#endif
	for (i=0; i<pi->num_progs; i++) {
		child = &pi->progs[i];
3480aaa8:	e5943004 	ldr	r3, [r4, #4]
		final_printf("%s  command %d:\n",ind,i);
		if (child->argv) {
3480aaac:	e7932007 	ldr	r2, [r3, r7]
	if (pi->stopped_progs > 0)
		return ret_code;
	final_printf("%s run pipe: (pid %d)\n",ind,getpid());
#endif
	for (i=0; i<pi->num_progs; i++) {
		child = &pi->progs[i];
3480aab0:	e083b007 	add	fp, r3, r7
		final_printf("%s  command %d:\n",ind,i);
		if (child->argv) {
3480aab4:	e3520000 	cmp	r2, #0
3480aab8:	0a000011 	beq	3480ab04 <free_pipe_list+0x74>
			for (a=0,p=child->argv; *p; a++,p++) {
3480aabc:	e4923004 	ldr	r3, [r2], #4
3480aac0:	e3530000 	cmp	r3, #0
3480aac4:	1afffffc 	bne	3480aabc <free_pipe_list+0x2c>
3480aac8:	ea000005 	b	3480aae4 <free_pipe_list+0x54>
			}
#ifndef __U_BOOT__
			globfree(&child->glob_result);
#else
			for (a = 0; a < child->argc; a++) {
				free(child->argv[a]);
3480aacc:	e59b2000 	ldr	r2, [fp]
3480aad0:	e7920103 	ldr	r0, [r2, r3, lsl #2]
3480aad4:	e58d3004 	str	r3, [sp, #4]
3480aad8:	ebfffa59 	bl	34809444 <free>
				final_printf("%s   argv[%d] = %s\n",ind,a,*p);
			}
#ifndef __U_BOOT__
			globfree(&child->glob_result);
#else
			for (a = 0; a < child->argc; a++) {
3480aadc:	e59d3004 	ldr	r3, [sp, #4]
3480aae0:	e2833001 	add	r3, r3, #1
3480aae4:	e59b2004 	ldr	r2, [fp, #4]
3480aae8:	e1530002 	cmp	r3, r2
3480aaec:	bafffff6 	blt	3480aacc <free_pipe_list+0x3c>
				free(child->argv[a]);
			}
					free(child->argv);
3480aaf0:	e59b0000 	ldr	r0, [fp]
3480aaf4:	ebfffa52 	bl	34809444 <free>
			child->argc = 0;
3480aaf8:	e58b6004 	str	r6, [fp, #4]
#endif
			child->argv=NULL;
3480aafc:	e58b6000 	str	r6, [fp]
3480ab00:	ea000005 	b	3480ab1c <free_pipe_list+0x8c>
		} else if (child->group) {
3480ab04:	e59b0008 	ldr	r0, [fp, #8]
3480ab08:	e3500000 	cmp	r0, #0
3480ab0c:	0a000002 	beq	3480ab1c <free_pipe_list+0x8c>
#ifndef __U_BOOT__
			final_printf("%s   begin group (subshell:%d)\n",ind, child->subshell);
#endif
			ret_code = free_pipe_list(child->group,indent+3);
3480ab10:	e1a01009 	mov	r1, r9
3480ab14:	ebffffdd 	bl	3480aa90 <free_pipe_list>
3480ab18:	e1a05000 	mov	r5, r0
#ifndef __U_BOOT__
	if (pi->stopped_progs > 0)
		return ret_code;
	final_printf("%s run pipe: (pid %d)\n",ind,getpid());
#endif
	for (i=0; i<pi->num_progs; i++) {
3480ab1c:	e28aa001 	add	sl, sl, #1
3480ab20:	e2877014 	add	r7, r7, #20
3480ab24:	e5943000 	ldr	r3, [r4]
3480ab28:	e15a0003 	cmp	sl, r3
3480ab2c:	baffffdd 	blt	3480aaa8 <free_pipe_list+0x18>
			free(r);
		}
		child->redirects=NULL;
#endif
	}
	free(pi->progs);   /* children are an array, they get freed all at once */
3480ab30:	e5940004 	ldr	r0, [r4, #4]
3480ab34:	ebfffa42 	bl	34809444 <free>
	char *ind = indenter(indent);
	for (pi=head; pi; pi=next) {
		final_printf("%s pipe reserved mode %d\n", ind, pi->r_mode);
		rcode = free_pipe(pi, indent);
		final_printf("%s pipe followup code %d\n", ind, pi->followup);
		next=pi->next;
3480ab38:	e5947008 	ldr	r7, [r4, #8]
		}
		child->redirects=NULL;
#endif
	}
	free(pi->progs);   /* children are an array, they get freed all at once */
	pi->progs=NULL;
3480ab3c:	e5846004 	str	r6, [r4, #4]
	for (pi=head; pi; pi=next) {
		final_printf("%s pipe reserved mode %d\n", ind, pi->r_mode);
		rcode = free_pipe(pi, indent);
		final_printf("%s pipe followup code %d\n", ind, pi->followup);
		next=pi->next;
		pi->next=NULL;
3480ab40:	e5846008 	str	r6, [r4, #8]
		free(pi);
3480ab44:	e1a00004 	mov	r0, r4
3480ab48:	ebfffa3d 	bl	34809444 <free>
static int free_pipe_list(struct pipe *head, int indent)
{
	int rcode=0;   /* if list has no members */
	struct pipe *pi, *next;
	char *ind = indenter(indent);
	for (pi=head; pi; pi=next) {
3480ab4c:	e1a04007 	mov	r4, r7
3480ab50:	e3540000 	cmp	r4, #0
3480ab54:	13a05000 	movne	r5, #0
3480ab58:	11a07005 	movne	r7, r5
3480ab5c:	11a0a005 	movne	sl, r5
3480ab60:	1affffef 	bne	3480ab24 <free_pipe_list+0x94>
		next=pi->next;
		pi->next=NULL;
		free(pi);
	}
	return rcode;
}
3480ab64:	e1a00005 	mov	r0, r5
3480ab68:	e8bd8efc 	pop	{r2, r3, r4, r5, r6, r7, r9, sl, fp, pc}

3480ab6c <xrealloc>:
	}
	return p;
}

static void *xrealloc(void *ptr, size_t size)
{
3480ab6c:	e92d4008 	push	{r3, lr}
	void *p = NULL;

	if (!(p = realloc(ptr, size))) {
3480ab70:	ebfffcae 	bl	34809e30 <realloc>
3480ab74:	e3500000 	cmp	r0, #0
3480ab78:	18bd8008 	popne	{r3, pc}
	    printf("ERROR : memory not allocated\n");
3480ab7c:	e59f0004 	ldr	r0, [pc, #4]	; 3480ab88 <xrealloc+0x1c>
3480ab80:	ebfff8f1 	bl	34808f4c <printf>
3480ab84:	eafffffe 	b	3480ab84 <xrealloc+0x18>
3480ab88:	34826064 	.word	0x34826064

3480ab8c <done_command>:
	 * advance the pipe counter and make a new, null child.
	 * Only real trickiness here is that the uncommitted
	 * child structure, to which ctx->child points, is not
	 * counted in pi->num_progs. */
	struct pipe *pi=ctx->pipe;
	struct child_prog *prog=ctx->child;
3480ab8c:	e5903000 	ldr	r3, [r0]
}

/* The only possible error here is out of memory, in which case
 * xmalloc exits. */
static int done_command(struct p_context *ctx)
{
3480ab90:	e92d4070 	push	{r4, r5, r6, lr}
	 * child structure, to which ctx->child points, is not
	 * counted in pi->num_progs. */
	struct pipe *pi=ctx->pipe;
	struct child_prog *prog=ctx->child;

	if (prog && prog->group == NULL
3480ab94:	e3530000 	cmp	r3, #0
}

/* The only possible error here is out of memory, in which case
 * xmalloc exits. */
static int done_command(struct p_context *ctx)
{
3480ab98:	e1a05000 	mov	r5, r0
	/* The child is really already in the pipe structure, so
	 * advance the pipe counter and make a new, null child.
	 * Only real trickiness here is that the uncommitted
	 * child structure, to which ctx->child points, is not
	 * counted in pi->num_progs. */
	struct pipe *pi=ctx->pipe;
3480ab9c:	e5904008 	ldr	r4, [r0, #8]
	struct child_prog *prog=ctx->child;

	if (prog && prog->group == NULL
3480aba0:	0a000008 	beq	3480abc8 <done_command+0x3c>
3480aba4:	e5932008 	ldr	r2, [r3, #8]
3480aba8:	e3520000 	cmp	r2, #0
3480abac:	1a000002 	bne	3480abbc <done_command+0x30>
		 && prog->argv == NULL
3480abb0:	e5933000 	ldr	r3, [r3]
3480abb4:	e3530000 	cmp	r3, #0
3480abb8:	0a000013 	beq	3480ac0c <done_command+0x80>
										) {
#endif
		debug_printf("done_command: skipping null command\n");
		return 0;
	} else if (prog) {
		pi->num_progs++;
3480abbc:	e5943000 	ldr	r3, [r4]
3480abc0:	e2833001 	add	r3, r3, #1
3480abc4:	e5843000 	str	r3, [r4]
		debug_printf("done_command: num_progs incremented to %d\n",pi->num_progs);
	} else {
		debug_printf("done_command: initializing\n");
	}
	pi->progs = xrealloc(pi->progs, sizeof(*pi->progs) * (pi->num_progs+1));
3480abc8:	e5941000 	ldr	r1, [r4]
3480abcc:	e3a06014 	mov	r6, #20
3480abd0:	e2811001 	add	r1, r1, #1
3480abd4:	e0010196 	mul	r1, r6, r1
3480abd8:	e5940004 	ldr	r0, [r4, #4]
3480abdc:	ebffffe2 	bl	3480ab6c <xrealloc>

	prog = pi->progs + pi->num_progs;
3480abe0:	e5943000 	ldr	r3, [r4]
#ifndef __U_BOOT__
	prog->redirects = NULL;
#endif
	prog->argv = NULL;
3480abe4:	e3a02000 	mov	r2, #0
	} else {
		debug_printf("done_command: initializing\n");
	}
	pi->progs = xrealloc(pi->progs, sizeof(*pi->progs) * (pi->num_progs+1));

	prog = pi->progs + pi->num_progs;
3480abe8:	e0060396 	mul	r6, r6, r3
3480abec:	e0803006 	add	r3, r0, r6
		pi->num_progs++;
		debug_printf("done_command: num_progs incremented to %d\n",pi->num_progs);
	} else {
		debug_printf("done_command: initializing\n");
	}
	pi->progs = xrealloc(pi->progs, sizeof(*pi->progs) * (pi->num_progs+1));
3480abf0:	e5840004 	str	r0, [r4, #4]

	prog = pi->progs + pi->num_progs;
#ifndef __U_BOOT__
	prog->redirects = NULL;
#endif
	prog->argv = NULL;
3480abf4:	e7802006 	str	r2, [r0, r6]
#ifndef __U_BOOT__
	prog->is_stopped = 0;
#endif
	prog->group = NULL;
3480abf8:	e5832008 	str	r2, [r3, #8]
#ifndef __U_BOOT__
	prog->glob_result.gl_pathv = NULL;
	prog->family = pi;
#endif
	prog->sp = 0;
3480abfc:	e583200c 	str	r2, [r3, #12]
	ctx->child = prog;
	prog->type = ctx->type;
3480ac00:	e5952018 	ldr	r2, [r5, #24]
#ifndef __U_BOOT__
	prog->glob_result.gl_pathv = NULL;
	prog->family = pi;
#endif
	prog->sp = 0;
	ctx->child = prog;
3480ac04:	e5853000 	str	r3, [r5]
	prog->type = ctx->type;
3480ac08:	e5832010 	str	r2, [r3, #16]

	/* but ctx->pipe and ctx->list_head remain unchanged */
	return 0;
}
3480ac0c:	e3a00000 	mov	r0, #0
3480ac10:	e8bd8070 	pop	{r4, r5, r6, pc}

3480ac14 <b_addchr>:
	}
	return o->data == NULL;
}

static int b_addchr(o_string *o, int ch)
{
3480ac14:	e92d4070 	push	{r4, r5, r6, lr}

static int b_check_space(o_string *o, int len)
{
	/* It would be easy to drop a more restrictive policy
	 * in here, such as setting a maximum string length */
	if (o->length + len > o->maxlen) {
3480ac18:	e5903004 	ldr	r3, [r0, #4]
	}
	return o->data == NULL;
}

static int b_addchr(o_string *o, int ch)
{
3480ac1c:	e1a06001 	mov	r6, r1

static int b_check_space(o_string *o, int len)
{
	/* It would be easy to drop a more restrictive policy
	 * in here, such as setting a maximum string length */
	if (o->length + len > o->maxlen) {
3480ac20:	e5901008 	ldr	r1, [r0, #8]
	}
	return o->data == NULL;
}

static int b_addchr(o_string *o, int ch)
{
3480ac24:	e1a04000 	mov	r4, r0

static int b_check_space(o_string *o, int len)
{
	/* It would be easy to drop a more restrictive policy
	 * in here, such as setting a maximum string length */
	if (o->length + len > o->maxlen) {
3480ac28:	e1530001 	cmp	r3, r1
3480ac2c:	ba00000a 	blt	3480ac5c <b_addchr+0x48>
		char *old_data = o->data;
3480ac30:	e5905000 	ldr	r5, [r0]
		/* assert (data == NULL || o->maxlen != 0); */
		o->maxlen += max(2*len, B_CHUNK);
3480ac34:	e2813064 	add	r3, r1, #100	; 0x64
3480ac38:	e5803008 	str	r3, [r0, #8]
		o->data = realloc(o->data, 1 + o->maxlen);
3480ac3c:	e2811065 	add	r1, r1, #101	; 0x65
3480ac40:	e1a00005 	mov	r0, r5
3480ac44:	ebfffc79 	bl	34809e30 <realloc>
		if (o->data == NULL) {
3480ac48:	e3500000 	cmp	r0, #0
	 * in here, such as setting a maximum string length */
	if (o->length + len > o->maxlen) {
		char *old_data = o->data;
		/* assert (data == NULL || o->maxlen != 0); */
		o->maxlen += max(2*len, B_CHUNK);
		o->data = realloc(o->data, 1 + o->maxlen);
3480ac4c:	e5840000 	str	r0, [r4]
		if (o->data == NULL) {
3480ac50:	1a000001 	bne	3480ac5c <b_addchr+0x48>
			free(old_data);
3480ac54:	e1a00005 	mov	r0, r5
3480ac58:	ebfff9f9 	bl	34809444 <free>
		}
	}
	return o->data == NULL;
3480ac5c:	e5943000 	ldr	r3, [r4]
}

static int b_addchr(o_string *o, int ch)
{
	debug_printf("b_addchr: %c %d %p\n", ch, o->length, o);
	if (b_check_space(o, 1)) return B_NOSPAC;
3480ac60:	e3530000 	cmp	r3, #0
	o->data[o->length] = ch;
3480ac64:	15942004 	ldrne	r2, [r4, #4]
	o->length++;
	o->data[o->length] = '\0';
3480ac68:	13a00000 	movne	r0, #0

static int b_addchr(o_string *o, int ch)
{
	debug_printf("b_addchr: %c %d %p\n", ch, o->length, o);
	if (b_check_space(o, 1)) return B_NOSPAC;
	o->data[o->length] = ch;
3480ac6c:	17c36002 	strbne	r6, [r3, r2]
	o->length++;
3480ac70:	15943004 	ldrne	r3, [r4, #4]
	o->data[o->length] = '\0';
3480ac74:	15942000 	ldrne	r2, [r4]
static int b_addchr(o_string *o, int ch)
{
	debug_printf("b_addchr: %c %d %p\n", ch, o->length, o);
	if (b_check_space(o, 1)) return B_NOSPAC;
	o->data[o->length] = ch;
	o->length++;
3480ac78:	12833001 	addne	r3, r3, #1
3480ac7c:	15843004 	strne	r3, [r4, #4]
}

static int b_addchr(o_string *o, int ch)
{
	debug_printf("b_addchr: %c %d %p\n", ch, o->length, o);
	if (b_check_space(o, 1)) return B_NOSPAC;
3480ac80:	03a00001 	moveq	r0, #1
	o->data[o->length] = ch;
	o->length++;
	o->data[o->length] = '\0';
3480ac84:	17c20003 	strbne	r0, [r2, r3]
	return 0;
}
3480ac88:	e8bd8070 	pop	{r4, r5, r6, pc}

3480ac8c <b_addqchr>:
/* My analysis of quoting semantics tells me that state information
 * is associated with a destination, not a source.
 */
static int b_addqchr(o_string *o, int ch, int quote)
{
	if (quote && strchr("*?[\\",ch)) {
3480ac8c:	e3520000 	cmp	r2, #0

/* My analysis of quoting semantics tells me that state information
 * is associated with a destination, not a source.
 */
static int b_addqchr(o_string *o, int ch, int quote)
{
3480ac90:	e92d4070 	push	{r4, r5, r6, lr}
3480ac94:	e1a04000 	mov	r4, r0
3480ac98:	e1a05001 	mov	r5, r1
	if (quote && strchr("*?[\\",ch)) {
3480ac9c:	0a000008 	beq	3480acc4 <b_addqchr+0x38>
3480aca0:	e59f002c 	ldr	r0, [pc, #44]	; 3480acd4 <b_addqchr+0x48>
3480aca4:	eb00379f 	bl	34818b28 <strchr>
3480aca8:	e3500000 	cmp	r0, #0
3480acac:	0a000004 	beq	3480acc4 <b_addqchr+0x38>
		int rc;
		rc = b_addchr(o, '\\');
3480acb0:	e1a00004 	mov	r0, r4
3480acb4:	e3a0105c 	mov	r1, #92	; 0x5c
3480acb8:	ebffffd5 	bl	3480ac14 <b_addchr>
		if (rc) return rc;
3480acbc:	e3500000 	cmp	r0, #0
3480acc0:	18bd8070 	popne	{r4, r5, r6, pc}
	}
	return b_addchr(o, ch);
3480acc4:	e1a00004 	mov	r0, r4
3480acc8:	e1a01005 	mov	r1, r5
}
3480accc:	e8bd4070 	pop	{r4, r5, r6, lr}
	if (quote && strchr("*?[\\",ch)) {
		int rc;
		rc = b_addchr(o, '\\');
		if (rc) return rc;
	}
	return b_addchr(o, ch);
3480acd0:	eaffffcf 	b	3480ac14 <b_addchr>
3480acd4:	3482608d 	.word	0x3482608d

3480acd8 <get_local_var>:
static char *get_dollar_var(char ch);
#endif

/* This is used to get/check local shell variables */
char *get_local_var(const char *s)
{
3480acd8:	e92d4038 	push	{r3, r4, r5, lr}
	struct variables *cur;

	if (!s)
3480acdc:	e2505000 	subs	r5, r0, #0
3480ace0:	0a00001c 	beq	3480ad58 <get_local_var+0x80>
		return NULL;

#ifdef __U_BOOT__
	if (*s == '$')
3480ace4:	e5d53000 	ldrb	r3, [r5]
3480ace8:	e59f4070 	ldr	r4, [pc, #112]	; 3480ad60 <get_local_var+0x88>
3480acec:	e3530024 	cmp	r3, #36	; 0x24
3480acf0:	1a00000a 	bne	3480ad20 <get_local_var+0x48>
		return get_dollar_var(s[1]);
3480acf4:	e5d53001 	ldrb	r3, [r5, #1]
#ifdef __U_BOOT__
static char *get_dollar_var(char ch)
{
	static char buf[40];

	buf[0] = '\0';
3480acf8:	e3a00000 	mov	r0, #0
	switch (ch) {
3480acfc:	e353003f 	cmp	r3, #63	; 0x3f
#ifdef __U_BOOT__
static char *get_dollar_var(char ch)
{
	static char buf[40];

	buf[0] = '\0';
3480ad00:	e5c4010c 	strb	r0, [r4, #268]	; 0x10c
	switch (ch) {
3480ad04:	18bd8038 	popne	{r3, r4, r5, pc}
		case '?':
			sprintf(buf, "%u", (unsigned int)last_return_code);
3480ad08:	e2840f43 	add	r0, r4, #268	; 0x10c
3480ad0c:	e59f1050 	ldr	r1, [pc, #80]	; 3480ad64 <get_local_var+0x8c>
3480ad10:	e5942134 	ldr	r2, [r4, #308]	; 0x134
3480ad14:	eb003c5d 	bl	34819e90 <sprintf>
			break;
		default:
			return NULL;
	}
	return buf;
3480ad18:	e2840f43 	add	r0, r4, #268	; 0x10c
3480ad1c:	e8bd8038 	pop	{r3, r4, r5, pc}
#ifdef __U_BOOT__
	if (*s == '$')
		return get_dollar_var(s[1]);
#endif

	for (cur = top_vars; cur; cur=cur->next)
3480ad20:	e5944000 	ldr	r4, [r4]
3480ad24:	ea000007 	b	3480ad48 <get_local_var+0x70>
		if(strcmp(cur->name, s)==0)
3480ad28:	e5940000 	ldr	r0, [r4]
3480ad2c:	e1a01005 	mov	r1, r5
3480ad30:	eb00375e 	bl	34818ab0 <strcmp>
3480ad34:	e3500000 	cmp	r0, #0
3480ad38:	1a000001 	bne	3480ad44 <get_local_var+0x6c>
			return cur->value;
3480ad3c:	e5940004 	ldr	r0, [r4, #4]
3480ad40:	e8bd8038 	pop	{r3, r4, r5, pc}
#ifdef __U_BOOT__
	if (*s == '$')
		return get_dollar_var(s[1]);
#endif

	for (cur = top_vars; cur; cur=cur->next)
3480ad44:	e5944010 	ldr	r4, [r4, #16]
3480ad48:	e3540000 	cmp	r4, #0
3480ad4c:	1afffff5 	bne	3480ad28 <get_local_var+0x50>
		if(strcmp(cur->name, s)==0)
			return cur->value;
	return NULL;
3480ad50:	e1a00004 	mov	r0, r4
3480ad54:	e8bd8038 	pop	{r3, r4, r5, pc}
char *get_local_var(const char *s)
{
	struct variables *cur;

	if (!s)
		return NULL;
3480ad58:	e1a00005 	mov	r0, r5

	for (cur = top_vars; cur; cur=cur->next)
		if(strcmp(cur->name, s)==0)
			return cur->value;
	return NULL;
}
3480ad5c:	e8bd8038 	pop	{r3, r4, r5, pc}
3480ad60:	34829528 	.word	0x34829528
3480ad64:	34824760 	.word	0x34824760

3480ad68 <set_local_var>:
/* This is used to set local shell variables
   flg_export==0 if only local (not exporting) variable
   flg_export==1 if "new" exporting environ
   flg_export>1  if current startup environ (not call putenv()) */
int set_local_var(const char *s, int flg_export)
{
3480ad68:	e92d46f8 	push	{r3, r4, r5, r6, r7, r9, sl, lr}
	int result=0;
	struct variables *cur;

#ifdef __U_BOOT__
	/* might be possible! */
	if (!isalpha(*s))
3480ad6c:	e59f219c 	ldr	r2, [pc, #412]	; 3480af10 <set_local_var+0x1a8>
3480ad70:	e5d03000 	ldrb	r3, [r0]
/* This is used to set local shell variables
   flg_export==0 if only local (not exporting) variable
   flg_export==1 if "new" exporting environ
   flg_export>1  if current startup environ (not call putenv()) */
int set_local_var(const char *s, int flg_export)
{
3480ad74:	e1a07001 	mov	r7, r1
	int result=0;
	struct variables *cur;

#ifdef __U_BOOT__
	/* might be possible! */
	if (!isalpha(*s))
3480ad78:	e7d23003 	ldrb	r3, [r2, r3]
3480ad7c:	e3130003 	tst	r3, #3
3480ad80:	0a00005a 	beq	3480aef0 <set_local_var+0x188>
		return -1;
#endif

	name=strdup(s);
3480ad84:	eb0037b2 	bl	34818c54 <strdup>
3480ad88:	e1a05000 	mov	r5, r0

#ifdef __U_BOOT__
	if (getenv(name) != NULL) {
3480ad8c:	ebfff52a 	bl	3480823c <getenv>
3480ad90:	e2504000 	subs	r4, r0, #0
3480ad94:	0a000004 	beq	3480adac <set_local_var+0x44>
		printf ("ERROR: "
3480ad98:	e59f0174 	ldr	r0, [pc, #372]	; 3480af14 <set_local_var+0x1ac>
3480ad9c:	ebfff86a 	bl	34808f4c <printf>
				"There is a global environment variable with the same name.\n");
		free(name);
3480ada0:	e1a00005 	mov	r0, r5
3480ada4:	ebfff9a6 	bl	34809444 <free>
3480ada8:	ea000050 	b	3480aef0 <set_local_var+0x188>
	}
#endif
	/* Assume when we enter this function that we are already in
	 * NAME=VALUE format.  So the first order of business is to
	 * split 's' on the '=' into 'name' and 'value' */
	value = strchr(name, '=');
3480adac:	e1a00005 	mov	r0, r5
3480adb0:	e3a0103d 	mov	r1, #61	; 0x3d
3480adb4:	eb00375b 	bl	34818b28 <strchr>
	if (value==0 && ++value==0) {
		free(name);
		return -1;
	}
	*value++ = 0;
3480adb8:	e3500000 	cmp	r0, #0
3480adbc:	11a06000 	movne	r6, r0
3480adc0:	03a06001 	moveq	r6, #1

	for(cur = top_vars; cur; cur = cur->next) {
3480adc4:	e59f314c 	ldr	r3, [pc, #332]	; 3480af18 <set_local_var+0x1b0>
	value = strchr(name, '=');
	if (value==0 && ++value==0) {
		free(name);
		return -1;
	}
	*value++ = 0;
3480adc8:	e4c64001 	strb	r4, [r6], #1

	for(cur = top_vars; cur; cur = cur->next) {
3480adcc:	e5934000 	ldr	r4, [r3]
3480add0:	ea000005 	b	3480adec <set_local_var+0x84>
		if(strcmp(cur->name, name)==0)
3480add4:	e5940000 	ldr	r0, [r4]
3480add8:	e1a01005 	mov	r1, r5
3480addc:	eb003733 	bl	34818ab0 <strcmp>
3480ade0:	e3500000 	cmp	r0, #0
3480ade4:	0a000003 	beq	3480adf8 <set_local_var+0x90>
		free(name);
		return -1;
	}
	*value++ = 0;

	for(cur = top_vars; cur; cur = cur->next) {
3480ade8:	e5944010 	ldr	r4, [r4, #16]
3480adec:	e3540000 	cmp	r4, #0
3480adf0:	1afffff7 	bne	3480add4 <set_local_var+0x6c>
3480adf4:	ea000040 	b	3480aefc <set_local_var+0x194>
		if(strcmp(cur->name, name)==0)
			break;
	}

	if(cur) {
		if(strcmp(cur->value, value)==0) {
3480adf8:	e5940004 	ldr	r0, [r4, #4]
3480adfc:	e1a01006 	mov	r1, r6
3480ae00:	eb00372a 	bl	34818ab0 <strcmp>
3480ae04:	e3500000 	cmp	r0, #0
3480ae08:	1a000007 	bne	3480ae2c <set_local_var+0xc4>
			if(flg_export>0 && cur->flg_export==0)
3480ae0c:	e3570000 	cmp	r7, #0
3480ae10:	da000030 	ble	3480aed8 <set_local_var+0x170>
3480ae14:	e5943008 	ldr	r3, [r4, #8]
3480ae18:	e3530000 	cmp	r3, #0
				cur->flg_export=flg_export;
3480ae1c:	05847008 	streq	r7, [r4, #8]
   flg_export==1 if "new" exporting environ
   flg_export>1  if current startup environ (not call putenv()) */
int set_local_var(const char *s, int flg_export)
{
	char *name, *value;
	int result=0;
3480ae20:	01a04003 	moveq	r4, r3
			break;
	}

	if(cur) {
		if(strcmp(cur->value, value)==0) {
			if(flg_export>0 && cur->flg_export==0)
3480ae24:	0a00002e 	beq	3480aee4 <set_local_var+0x17c>
3480ae28:	ea00002a 	b	3480aed8 <set_local_var+0x170>
				cur->flg_export=flg_export;
			else
				result++;
		} else {
			if(cur->flg_read_only) {
3480ae2c:	e594300c 	ldr	r3, [r4, #12]
3480ae30:	e3530000 	cmp	r3, #0
3480ae34:	0a000003 	beq	3480ae48 <set_local_var+0xe0>
				error_msg("%s: readonly variable", name);
3480ae38:	e1a01005 	mov	r1, r5
3480ae3c:	e59f00d8 	ldr	r0, [pc, #216]	; 3480af1c <set_local_var+0x1b4>
3480ae40:	ebfff841 	bl	34808f4c <printf>
3480ae44:	ea000025 	b	3480aee0 <set_local_var+0x178>
				result = -1;
			} else {
				if(flg_export>0 || cur->flg_export>1)
3480ae48:	e3570000 	cmp	r7, #0
3480ae4c:	ca000002 	bgt	3480ae5c <set_local_var+0xf4>
3480ae50:	e5943008 	ldr	r3, [r4, #8]
3480ae54:	e3530001 	cmp	r3, #1
3480ae58:	da000001 	ble	3480ae64 <set_local_var+0xfc>
					cur->flg_export=1;
3480ae5c:	e3a03001 	mov	r3, #1
3480ae60:	e5843008 	str	r3, [r4, #8]
				free(cur->value);
3480ae64:	e5940004 	ldr	r0, [r4, #4]
3480ae68:	ebfff975 	bl	34809444 <free>

				cur->value = strdup(value);
3480ae6c:	e1a00006 	mov	r0, r6
3480ae70:	eb003777 	bl	34818c54 <strdup>
3480ae74:	e5840004 	str	r0, [r4, #4]
   flg_export==1 if "new" exporting environ
   flg_export>1  if current startup environ (not call putenv()) */
int set_local_var(const char *s, int flg_export)
{
	char *name, *value;
	int result=0;
3480ae78:	e3a04000 	mov	r4, #0
3480ae7c:	ea000018 	b	3480aee4 <set_local_var+0x17c>
	} else {
		cur = malloc(sizeof(struct variables));
		if(!cur) {
			result = -1;
		} else {
			cur->name = strdup(name);
3480ae80:	e1a00005 	mov	r0, r5
3480ae84:	eb003772 	bl	34818c54 <strdup>
			if(cur->name == 0) {
3480ae88:	e3500000 	cmp	r0, #0
	} else {
		cur = malloc(sizeof(struct variables));
		if(!cur) {
			result = -1;
		} else {
			cur->name = strdup(name);
3480ae8c:	e58a0000 	str	r0, [sl]
			if(cur->name == 0) {
3480ae90:	1a000002 	bne	3480aea0 <set_local_var+0x138>
				free(cur);
3480ae94:	e1a0000a 	mov	r0, sl
3480ae98:	ebfff969 	bl	34809444 <free>
3480ae9c:	ea00000f 	b	3480aee0 <set_local_var+0x178>
				result = -1;
			} else {
				struct variables *bottom = top_vars;
3480aea0:	e59f3070 	ldr	r3, [pc, #112]	; 3480af18 <set_local_var+0x1b0>
				cur->value = strdup(value);
3480aea4:	e1a00006 	mov	r0, r6
			cur->name = strdup(name);
			if(cur->name == 0) {
				free(cur);
				result = -1;
			} else {
				struct variables *bottom = top_vars;
3480aea8:	e5939000 	ldr	r9, [r3]
				cur->value = strdup(value);
3480aeac:	eb003768 	bl	34818c54 <strdup>
				cur->next = 0;
3480aeb0:	e58a4010 	str	r4, [sl, #16]
			if(cur->name == 0) {
				free(cur);
				result = -1;
			} else {
				struct variables *bottom = top_vars;
				cur->value = strdup(value);
3480aeb4:	e98a0081 	stmib	sl, {r0, r7}
				cur->next = 0;
				cur->flg_export = flg_export;
				cur->flg_read_only = 0;
3480aeb8:	e58a400c 	str	r4, [sl, #12]
				while(bottom->next) bottom=bottom->next;
3480aebc:	ea000000 	b	3480aec4 <set_local_var+0x15c>
3480aec0:	e1a09004 	mov	r9, r4
3480aec4:	e5994010 	ldr	r4, [r9, #16]
3480aec8:	e3540000 	cmp	r4, #0
3480aecc:	1afffffb 	bne	3480aec0 <set_local_var+0x158>
				bottom->next = cur;
3480aed0:	e589a010 	str	sl, [r9, #16]
3480aed4:	ea000002 	b	3480aee4 <set_local_var+0x17c>
	if(cur) {
		if(strcmp(cur->value, value)==0) {
			if(flg_export>0 && cur->flg_export==0)
				cur->flg_export=flg_export;
			else
				result++;
3480aed8:	e3a04001 	mov	r4, #1
3480aedc:	ea000000 	b	3480aee4 <set_local_var+0x17c>
			}
		}
	} else {
		cur = malloc(sizeof(struct variables));
		if(!cur) {
			result = -1;
3480aee0:	e3e04000 	mvn	r4, #0
	if(result==0 && cur->flg_export==1) {
		*(value-1) = '=';
		result = putenv(name);
	} else {
#endif
		free(name);
3480aee4:	e1a00005 	mov	r0, r5
3480aee8:	ebfff955 	bl	34809444 <free>
#ifndef __U_BOOT__
		if(result>0)            /* equivalent to previous set */
			result = 0;
	}
#endif
	return result;
3480aeec:	ea000000 	b	3480aef4 <set_local_var+0x18c>
	struct variables *cur;

#ifdef __U_BOOT__
	/* might be possible! */
	if (!isalpha(*s))
		return -1;
3480aef0:	e3e04000 	mvn	r4, #0
		if(result>0)            /* equivalent to previous set */
			result = 0;
	}
#endif
	return result;
}
3480aef4:	e1a00004 	mov	r0, r4
3480aef8:	e8bd86f8 	pop	{r3, r4, r5, r6, r7, r9, sl, pc}

				cur->value = strdup(value);
			}
		}
	} else {
		cur = malloc(sizeof(struct variables));
3480aefc:	e3a00014 	mov	r0, #20
3480af00:	ebfff9d8 	bl	34809668 <malloc>
		if(!cur) {
3480af04:	e250a000 	subs	sl, r0, #0
3480af08:	1affffdc 	bne	3480ae80 <set_local_var+0x118>
3480af0c:	eafffff3 	b	3480aee0 <set_local_var+0x178>
3480af10:	34821fd4 	.word	0x34821fd4
3480af14:	34826092 	.word	0x34826092
3480af18:	34829528 	.word	0x34829528
3480af1c:	348260d5 	.word	0x348260d5

3480af20 <insert_var_value_sub>:
{
	return insert_var_value_sub(inp, 0);
}

static char *insert_var_value_sub(char *inp, int tag_subst)
{
3480af20:	e92d4eff 	push	{r0, r1, r2, r3, r4, r5, r6, r7, r9, sl, fp, lr}
	int res_str_len = 0;
	int len;
	int done = 0;
	char *p, *p1, *res_str = NULL;
3480af24:	e3a04000 	mov	r4, #0
{
	return insert_var_value_sub(inp, 0);
}

static char *insert_var_value_sub(char *inp, int tag_subst)
{
3480af28:	e1a09000 	mov	r9, r0
3480af2c:	e58d100c 	str	r1, [sp, #12]
	int res_str_len = 0;
	int len;
	int done = 0;
3480af30:	e1a05004 	mov	r5, r4
	return insert_var_value_sub(inp, 0);
}

static char *insert_var_value_sub(char *inp, int tag_subst)
{
	int res_str_len = 0;
3480af34:	e1a07004 	mov	r7, r4
3480af38:	e1a06004 	mov	r6, r4
	int len;
	int done = 0;
	char *p, *p1, *res_str = NULL;

	while ((p = strchr(inp, SPECIAL_VAR_SYMBOL))) {
3480af3c:	ea00008a 	b	3480b16c <insert_var_value_sub+0x24c>
		/* check the beginning of the string for normal charachters */
		if (p != inp) {
3480af40:	e15b0009 	cmp	fp, r9
3480af44:	0a00000a 	beq	3480af74 <insert_var_value_sub+0x54>
			/* copy any charachters to the result string */
			len = p - inp;
3480af48:	e069500b 	rsb	r5, r9, fp
			res_str = xrealloc(res_str, (res_str_len + len));
3480af4c:	e0854007 	add	r4, r5, r7
3480af50:	e1a00006 	mov	r0, r6
3480af54:	e1a01004 	mov	r1, r4
3480af58:	ebffff03 	bl	3480ab6c <xrealloc>
			strncpy((res_str + res_str_len), inp, len);
3480af5c:	e1a01009 	mov	r1, r9
	while ((p = strchr(inp, SPECIAL_VAR_SYMBOL))) {
		/* check the beginning of the string for normal charachters */
		if (p != inp) {
			/* copy any charachters to the result string */
			len = p - inp;
			res_str = xrealloc(res_str, (res_str_len + len));
3480af60:	e1a06000 	mov	r6, r0
			strncpy((res_str + res_str_len), inp, len);
3480af64:	e1a02005 	mov	r2, r5
3480af68:	e0800007 	add	r0, r0, r7
3480af6c:	eb0036a5 	bl	34818a08 <strncpy>
			res_str_len += len;
3480af70:	e1a07004 	mov	r7, r4
		}
		inp = ++p;
3480af74:	e28bb001 	add	fp, fp, #1
		/* find the ending marker */
		p = strchr(inp, SPECIAL_VAR_SYMBOL);
3480af78:	e1a0000b 	mov	r0, fp
3480af7c:	e3a01003 	mov	r1, #3
3480af80:	eb0036e8 	bl	34818b28 <strchr>
		*p = '\0';
3480af84:	e3a03000 	mov	r3, #0
	char *sep;
	char *default_val = NULL;
	int assign = 0;
	int expand_empty = 0;

	if (!src)
3480af88:	e35b0000 	cmp	fp, #0
			strncpy((res_str + res_str_len), inp, len);
			res_str_len += len;
		}
		inp = ++p;
		/* find the ending marker */
		p = strchr(inp, SPECIAL_VAR_SYMBOL);
3480af8c:	e1a09000 	mov	r9, r0
		*p = '\0';
3480af90:	e5c03000 	strb	r3, [r0]
	char *sep;
	char *default_val = NULL;
	int assign = 0;
	int expand_empty = 0;

	if (!src)
3480af94:	0a000071 	beq	3480b160 <insert_var_value_sub+0x240>
		return NULL;

	sep = strchr(src, ':');
3480af98:	e1a0000b 	mov	r0, fp
3480af9c:	e3a0103a 	mov	r1, #58	; 0x3a
3480afa0:	eb0036e0 	bl	34818b28 <strchr>

	if (sep) {
3480afa4:	e250a000 	subs	sl, r0, #0
{
	char *p;
	char *sep;
	char *default_val = NULL;
	int assign = 0;
	int expand_empty = 0;
3480afa8:	01a0500a 	moveq	r5, sl
static char *lookup_param(char *src)
{
	char *p;
	char *sep;
	char *default_val = NULL;
	int assign = 0;
3480afac:	01a0200a 	moveq	r2, sl
 * see the bash man page under "Parameter Expansion" */
static char *lookup_param(char *src)
{
	char *p;
	char *sep;
	char *default_val = NULL;
3480afb0:	01a0400a 	moveq	r4, sl
	if (!src)
		return NULL;

	sep = strchr(src, ':');

	if (sep) {
3480afb4:	0a000013 	beq	3480b008 <insert_var_value_sub+0xe8>
		*sep = '\0';
3480afb8:	e3a03000 	mov	r3, #0
3480afbc:	e5ca3000 	strb	r3, [sl]
		if (*(sep + 1) == '-')
3480afc0:	e5da3001 	ldrb	r3, [sl, #1]
3480afc4:	e353002d 	cmp	r3, #45	; 0x2d
{
	char *p;
	char *sep;
	char *default_val = NULL;
	int assign = 0;
	int expand_empty = 0;
3480afc8:	03a05000 	moveq	r5, #0
	sep = strchr(src, ':');

	if (sep) {
		*sep = '\0';
		if (*(sep + 1) == '-')
			default_val = sep+2;
3480afcc:	028a4002 	addeq	r4, sl, #2
3480afd0:	01a02005 	moveq	r2, r5

	sep = strchr(src, ':');

	if (sep) {
		*sep = '\0';
		if (*(sep + 1) == '-')
3480afd4:	0a00000b 	beq	3480b008 <insert_var_value_sub+0xe8>
			default_val = sep+2;
		if (*(sep + 1) == '=') {
3480afd8:	e353003d 	cmp	r3, #61	; 0x3d
			default_val = sep+2;
3480afdc:	028a4002 	addeq	r4, sl, #2
{
	char *p;
	char *sep;
	char *default_val = NULL;
	int assign = 0;
	int expand_empty = 0;
3480afe0:	03a05000 	moveq	r5, #0
		*sep = '\0';
		if (*(sep + 1) == '-')
			default_val = sep+2;
		if (*(sep + 1) == '=') {
			default_val = sep+2;
			assign = 1;
3480afe4:	03a02001 	moveq	r2, #1

	if (sep) {
		*sep = '\0';
		if (*(sep + 1) == '-')
			default_val = sep+2;
		if (*(sep + 1) == '=') {
3480afe8:	0a000006 	beq	3480b008 <insert_var_value_sub+0xe8>
			default_val = sep+2;
			assign = 1;
		}
		if (*(sep + 1) == '+') {
3480afec:	e353002b 	cmp	r3, #43	; 0x2b
{
	char *p;
	char *sep;
	char *default_val = NULL;
	int assign = 0;
	int expand_empty = 0;
3480aff0:	13a05000 	movne	r5, #0
		if (*(sep + 1) == '=') {
			default_val = sep+2;
			assign = 1;
		}
		if (*(sep + 1) == '+') {
			default_val = sep+2;
3480aff4:	028a4002 	addeq	r4, sl, #2
			expand_empty = 1;
3480aff8:	03a05001 	moveq	r5, #1
		if (*(sep + 1) == '=') {
			default_val = sep+2;
			assign = 1;
		}
		if (*(sep + 1) == '+') {
			default_val = sep+2;
3480affc:	03a02000 	moveq	r2, #0
			default_val = sep+2;
		if (*(sep + 1) == '=') {
			default_val = sep+2;
			assign = 1;
		}
		if (*(sep + 1) == '+') {
3480b000:	11a02005 	movne	r2, r5
 * see the bash man page under "Parameter Expansion" */
static char *lookup_param(char *src)
{
	char *p;
	char *sep;
	char *default_val = NULL;
3480b004:	11a04005 	movne	r4, r5
			default_val = sep+2;
			expand_empty = 1;
		}
	}

	p = getenv(src);
3480b008:	e1a0000b 	mov	r0, fp
3480b00c:	e58d2004 	str	r2, [sp, #4]
3480b010:	ebfff489 	bl	3480823c <getenv>
	if (!p)
3480b014:	e2503000 	subs	r3, r0, #0
3480b018:	e59d2004 	ldr	r2, [sp, #4]
3480b01c:	1a000004 	bne	3480b034 <insert_var_value_sub+0x114>
		p = get_local_var(src);
3480b020:	e1a0000b 	mov	r0, fp
3480b024:	ebffff2b 	bl	3480acd8 <get_local_var>

	if (!p || strlen(p) == 0) {
3480b028:	e2503000 	subs	r3, r0, #0
3480b02c:	e59d2004 	ldr	r2, [sp, #4]
3480b030:	0a000005 	beq	3480b04c <insert_var_value_sub+0x12c>
3480b034:	e1a00003 	mov	r0, r3
3480b038:	e98d000c 	stmib	sp, {r2, r3}
3480b03c:	eb0036cf 	bl	34818b80 <strlen>
3480b040:	e3500000 	cmp	r0, #0
3480b044:	e99d000c 	ldmib	sp, {r2, r3}
3480b048:	1a000015 	bne	3480b0a4 <insert_var_value_sub+0x184>
		p = default_val;
		if (assign) {
3480b04c:	e3520000 	cmp	r2, #0
3480b050:	0a00001b 	beq	3480b0c4 <insert_var_value_sub+0x1a4>
			char *var = malloc(strlen(src)+strlen(default_val)+2);
3480b054:	e1a0000b 	mov	r0, fp
3480b058:	eb0036c8 	bl	34818b80 <strlen>
3480b05c:	e1a05000 	mov	r5, r0
3480b060:	e1a00004 	mov	r0, r4
3480b064:	eb0036c5 	bl	34818b80 <strlen>
3480b068:	e0850000 	add	r0, r5, r0
3480b06c:	e2800002 	add	r0, r0, #2
3480b070:	ebfff97c 	bl	34809668 <malloc>
			if (var) {
3480b074:	e2505000 	subs	r5, r0, #0
3480b078:	0a000006 	beq	3480b098 <insert_var_value_sub+0x178>
				sprintf(var, "%s=%s", src, default_val);
3480b07c:	e59f1164 	ldr	r1, [pc, #356]	; 3480b1e8 <insert_var_value_sub+0x2c8>
3480b080:	e1a0200b 	mov	r2, fp
3480b084:	e1a03004 	mov	r3, r4
3480b088:	eb003b80 	bl	34819e90 <sprintf>
				set_local_var(var, 0);
3480b08c:	e1a00005 	mov	r0, r5
3480b090:	e3a01000 	mov	r1, #0
3480b094:	ebffff33 	bl	3480ad68 <set_local_var>
			}
			free(var);
3480b098:	e1a00005 	mov	r0, r5
3480b09c:	ebfff8e8 	bl	34809444 <free>
3480b0a0:	ea000007 	b	3480b0c4 <insert_var_value_sub+0x1a4>
		}
	} else if (expand_empty) {
3480b0a4:	e3550000 	cmp	r5, #0
3480b0a8:	01a04003 	moveq	r4, r3
3480b0ac:	0a000004 	beq	3480b0c4 <insert_var_value_sub+0x1a4>
		p += strlen(p);
3480b0b0:	e1a00003 	mov	r0, r3
3480b0b4:	e58d3008 	str	r3, [sp, #8]
3480b0b8:	eb0036b0 	bl	34818b80 <strlen>
3480b0bc:	e59d3008 	ldr	r3, [sp, #8]
3480b0c0:	e0834000 	add	r4, r3, r0
	}

	if (sep)
3480b0c4:	e35a0000 	cmp	sl, #0
		*sep = ':';
3480b0c8:	13a0303a 	movne	r3, #58	; 0x3a
3480b0cc:	15ca3000 	strbne	r3, [sl]
		inp = ++p;
		/* find the ending marker */
		p = strchr(inp, SPECIAL_VAR_SYMBOL);
		*p = '\0';
		/* look up the value to substitute */
		if ((p1 = lookup_param(inp))) {
3480b0d0:	e3540000 	cmp	r4, #0
3480b0d4:	0a000021 	beq	3480b160 <insert_var_value_sub+0x240>
			if (tag_subst)
3480b0d8:	e59d300c 	ldr	r3, [sp, #12]
3480b0dc:	e3530000 	cmp	r3, #0
3480b0e0:	0a000004 	beq	3480b0f8 <insert_var_value_sub+0x1d8>
				len = res_str_len + strlen(p1) + 2;
3480b0e4:	e1a00004 	mov	r0, r4
3480b0e8:	eb0036a4 	bl	34818b80 <strlen>
3480b0ec:	e2875002 	add	r5, r7, #2
3480b0f0:	e0855000 	add	r5, r5, r0
3480b0f4:	ea000002 	b	3480b104 <insert_var_value_sub+0x1e4>
			else
				len = res_str_len + strlen(p1);
3480b0f8:	e1a00004 	mov	r0, r4
3480b0fc:	eb00369f 	bl	34818b80 <strlen>
3480b100:	e0805007 	add	r5, r0, r7
			res_str = xrealloc(res_str, (1 + len));
3480b104:	e1a00006 	mov	r0, r6
3480b108:	e2851001 	add	r1, r5, #1
3480b10c:	ebfffe96 	bl	3480ab6c <xrealloc>
			if (tag_subst) {
3480b110:	e59d300c 	ldr	r3, [sp, #12]
		if ((p1 = lookup_param(inp))) {
			if (tag_subst)
				len = res_str_len + strlen(p1) + 2;
			else
				len = res_str_len + strlen(p1);
			res_str = xrealloc(res_str, (1 + len));
3480b114:	e1a06000 	mov	r6, r0
			if (tag_subst) {
3480b118:	e3530000 	cmp	r3, #0
3480b11c:	0a00000b 	beq	3480b150 <insert_var_value_sub+0x230>
				/*
				 * copy the variable value to the result
				 * string
				 */
				strcpy((res_str + res_str_len + 1), p1);
3480b120:	e287a001 	add	sl, r7, #1
3480b124:	e080a00a 	add	sl, r0, sl
3480b128:	e1a01004 	mov	r1, r4
3480b12c:	e1a0000a 	mov	r0, sl
3480b130:	eb00362d 	bl	348189ec <strcpy>

				/*
				 * mark the replaced text to be accepted as
				 * is
				 */
				res_str[res_str_len] = SUBSTED_VAR_SYMBOL;
3480b134:	e3a03004 	mov	r3, #4
3480b138:	e7c63007 	strb	r3, [r6, r7]
				res_str[res_str_len + 1 + strlen(p1)] =
3480b13c:	e1a00004 	mov	r0, r4
3480b140:	eb00368e 	bl	34818b80 <strlen>
3480b144:	e3a03004 	mov	r3, #4
3480b148:	e7ca3000 	strb	r3, [sl, r0]
3480b14c:	ea000002 	b	3480b15c <insert_var_value_sub+0x23c>
			} else
				/*
				 * copy the variable value to the result
				 * string
				 */
				strcpy((res_str + res_str_len), p1);
3480b150:	e0800007 	add	r0, r0, r7
3480b154:	e1a01004 	mov	r1, r4
3480b158:	eb003623 	bl	348189ec <strcpy>

			res_str_len = len;
3480b15c:	e1a07005 	mov	r7, r5
		}
		*p = SPECIAL_VAR_SYMBOL;
3480b160:	e3a03003 	mov	r3, #3
3480b164:	e4c93001 	strb	r3, [r9], #1
		inp = ++p;
		done = 1;
3480b168:	e3a05001 	mov	r5, #1
	int res_str_len = 0;
	int len;
	int done = 0;
	char *p, *p1, *res_str = NULL;

	while ((p = strchr(inp, SPECIAL_VAR_SYMBOL))) {
3480b16c:	e1a00009 	mov	r0, r9
3480b170:	e3a01003 	mov	r1, #3
3480b174:	eb00366b 	bl	34818b28 <strchr>
3480b178:	e250b000 	subs	fp, r0, #0
3480b17c:	1affff6f 	bne	3480af40 <insert_var_value_sub+0x20>
		}
		*p = SPECIAL_VAR_SYMBOL;
		inp = ++p;
		done = 1;
	}
	if (done) {
3480b180:	e3550000 	cmp	r5, #0
3480b184:	e1a04006 	mov	r4, r6
3480b188:	0a000011 	beq	3480b1d4 <insert_var_value_sub+0x2b4>
		res_str = xrealloc(res_str, (1 + res_str_len + strlen(inp)));
3480b18c:	e1a00009 	mov	r0, r9
3480b190:	eb00367a 	bl	34818b80 <strlen>
3480b194:	e2871001 	add	r1, r7, #1
3480b198:	e0811000 	add	r1, r1, r0
3480b19c:	e1a00006 	mov	r0, r6
3480b1a0:	ebfffe71 	bl	3480ab6c <xrealloc>
		strcpy((res_str + res_str_len), inp);
3480b1a4:	e1a01009 	mov	r1, r9
		*p = SPECIAL_VAR_SYMBOL;
		inp = ++p;
		done = 1;
	}
	if (done) {
		res_str = xrealloc(res_str, (1 + res_str_len + strlen(inp)));
3480b1a8:	e1a04000 	mov	r4, r0
		strcpy((res_str + res_str_len), inp);
3480b1ac:	e0800007 	add	r0, r0, r7
3480b1b0:	eb00360d 	bl	348189ec <strcpy>
		while ((p = strchr(res_str, '\n'))) {
			*p = ' ';
3480b1b4:	e3a05020 	mov	r5, #32
		done = 1;
	}
	if (done) {
		res_str = xrealloc(res_str, (1 + res_str_len + strlen(inp)));
		strcpy((res_str + res_str_len), inp);
		while ((p = strchr(res_str, '\n'))) {
3480b1b8:	ea000000 	b	3480b1c0 <insert_var_value_sub+0x2a0>
			*p = ' ';
3480b1bc:	e5c05000 	strb	r5, [r0]
		done = 1;
	}
	if (done) {
		res_str = xrealloc(res_str, (1 + res_str_len + strlen(inp)));
		strcpy((res_str + res_str_len), inp);
		while ((p = strchr(res_str, '\n'))) {
3480b1c0:	e1a00004 	mov	r0, r4
3480b1c4:	e3a0100a 	mov	r1, #10
3480b1c8:	eb003656 	bl	34818b28 <strchr>
3480b1cc:	e3500000 	cmp	r0, #0
3480b1d0:	1afffff9 	bne	3480b1bc <insert_var_value_sub+0x29c>
			*p = ' ';
		}
	}
	return (res_str == NULL) ? inp : res_str;
}
3480b1d4:	e3540000 	cmp	r4, #0
3480b1d8:	11a00004 	movne	r0, r4
3480b1dc:	01a00009 	moveq	r0, r9
3480b1e0:	e28dd010 	add	sp, sp, #16
3480b1e4:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
3480b1e8:	348260eb 	.word	0x348260eb

3480b1ec <unset_local_var>:
#endif
	return result;
}

void unset_local_var(const char *name)
{
3480b1ec:	e92d4070 	push	{r4, r5, r6, lr}
	struct variables *cur;

	if (name) {
3480b1f0:	e2505000 	subs	r5, r0, #0
		for (cur = top_vars; cur; cur=cur->next) {
3480b1f4:	159f3088 	ldrne	r3, [pc, #136]	; 3480b284 <unset_local_var+0x98>
3480b1f8:	15934000 	ldrne	r4, [r3]

void unset_local_var(const char *name)
{
	struct variables *cur;

	if (name) {
3480b1fc:	1a000006 	bne	3480b21c <unset_local_var+0x30>
3480b200:	e8bd8070 	pop	{r4, r5, r6, pc}
		for (cur = top_vars; cur; cur=cur->next) {
			if(strcmp(cur->name, name)==0)
3480b204:	e5940000 	ldr	r0, [r4]
3480b208:	e1a01005 	mov	r1, r5
3480b20c:	eb003627 	bl	34818ab0 <strcmp>
3480b210:	e3500000 	cmp	r0, #0
3480b214:	0a000003 	beq	3480b228 <unset_local_var+0x3c>
void unset_local_var(const char *name)
{
	struct variables *cur;

	if (name) {
		for (cur = top_vars; cur; cur=cur->next) {
3480b218:	e5944010 	ldr	r4, [r4, #16]
3480b21c:	e3540000 	cmp	r4, #0
3480b220:	1afffff7 	bne	3480b204 <unset_local_var+0x18>
3480b224:	e8bd8070 	pop	{r4, r5, r6, pc}
			if(strcmp(cur->name, name)==0)
				break;
		}
		if(cur!=0) {
			struct variables *next = top_vars;
3480b228:	e59f3054 	ldr	r3, [pc, #84]	; 3480b284 <unset_local_var+0x98>
3480b22c:	e5936000 	ldr	r6, [r3]
			if(cur->flg_read_only) {
3480b230:	e594300c 	ldr	r3, [r4, #12]
3480b234:	e3530000 	cmp	r3, #0
3480b238:	0a000003 	beq	3480b24c <unset_local_var+0x60>
				error_msg("%s: readonly variable", name);
3480b23c:	e59f0044 	ldr	r0, [pc, #68]	; 3480b288 <unset_local_var+0x9c>
3480b240:	e1a01005 	mov	r1, r5
				next->next = cur->next;
			}
			free(cur);
		}
	}
}
3480b244:	e8bd4070 	pop	{r4, r5, r6, lr}
				break;
		}
		if(cur!=0) {
			struct variables *next = top_vars;
			if(cur->flg_read_only) {
				error_msg("%s: readonly variable", name);
3480b248:	eafff73f 	b	34808f4c <printf>
			} else {
#ifndef __U_BOOT__
				if(cur->flg_export)
					unsetenv(cur->name);
#endif
				free(cur->name);
3480b24c:	e5940000 	ldr	r0, [r4]
3480b250:	ebfff87b 	bl	34809444 <free>
				free(cur->value);
3480b254:	e5940004 	ldr	r0, [r4, #4]
3480b258:	ebfff879 	bl	34809444 <free>
				while (next->next != cur)
3480b25c:	ea000000 	b	3480b264 <unset_local_var+0x78>
3480b260:	e1a06003 	mov	r6, r3
3480b264:	e5963010 	ldr	r3, [r6, #16]
3480b268:	e1530004 	cmp	r3, r4
3480b26c:	1afffffb 	bne	3480b260 <unset_local_var+0x74>
					next = next->next;
				next->next = cur->next;
3480b270:	e5943010 	ldr	r3, [r4, #16]
			}
			free(cur);
3480b274:	e1a00004 	mov	r0, r4
#endif
				free(cur->name);
				free(cur->value);
				while (next->next != cur)
					next = next->next;
				next->next = cur->next;
3480b278:	e5863010 	str	r3, [r6, #16]
			}
			free(cur);
		}
	}
}
3480b27c:	e8bd4070 	pop	{r4, r5, r6, lr}
				free(cur->value);
				while (next->next != cur)
					next = next->next;
				next->next = cur->next;
			}
			free(cur);
3480b280:	eafff86f 	b	34809444 <free>
3480b284:	34829528 	.word	0x34829528
3480b288:	348260d5 	.word	0x348260d5

3480b28c <new_pipe>:
	}
	return 0;
}
#endif

struct pipe *new_pipe(void) {
3480b28c:	e92d4008 	push	{r3, lr}
	struct pipe *pi;
	pi = xmalloc(sizeof(struct pipe));
3480b290:	e3a00014 	mov	r0, #20
3480b294:	ebfffd8b 	bl	3480a8c8 <xmalloc>
	pi->num_progs = 0;
3480b298:	e3a02000 	mov	r2, #0
3480b29c:	e5802000 	str	r2, [r0]
	pi->progs = NULL;
3480b2a0:	e5802004 	str	r2, [r0, #4]
	pi->next = NULL;
3480b2a4:	e5802008 	str	r2, [r0, #8]
	pi->followup = 0;  /* invalid */
3480b2a8:	e580200c 	str	r2, [r0, #12]
	pi->r_mode = RES_NONE;
3480b2ac:	e5802010 	str	r2, [r0, #16]
	return pi;
}
3480b2b0:	e8bd8008 	pop	{r3, pc}

3480b2b4 <done_pipe>:
	/* but ctx->pipe and ctx->list_head remain unchanged */
	return 0;
}

static int done_pipe(struct p_context *ctx, pipe_style type)
{
3480b2b4:	e92d4038 	push	{r3, r4, r5, lr}
3480b2b8:	e1a04000 	mov	r4, r0
3480b2bc:	e1a05001 	mov	r5, r1
	struct pipe *new_p;
	done_command(ctx);  /* implicit closure of previous command */
3480b2c0:	ebfffe31 	bl	3480ab8c <done_command>
	debug_printf("done_pipe, type %d\n", type);
	ctx->pipe->followup = type;
3480b2c4:	e5943008 	ldr	r3, [r4, #8]
	ctx->pipe->r_mode = ctx->w;
3480b2c8:	e594200c 	ldr	r2, [r4, #12]
static int done_pipe(struct p_context *ctx, pipe_style type)
{
	struct pipe *new_p;
	done_command(ctx);  /* implicit closure of previous command */
	debug_printf("done_pipe, type %d\n", type);
	ctx->pipe->followup = type;
3480b2cc:	e583500c 	str	r5, [r3, #12]
	ctx->pipe->r_mode = ctx->w;
3480b2d0:	e5832010 	str	r2, [r3, #16]
	new_p=new_pipe();
3480b2d4:	ebffffec 	bl	3480b28c <new_pipe>
	ctx->pipe->next = new_p;
3480b2d8:	e5943008 	ldr	r3, [r4, #8]
	ctx->pipe = new_p;
	ctx->child = NULL;
3480b2dc:	e3a05000 	mov	r5, #0
	done_command(ctx);  /* implicit closure of previous command */
	debug_printf("done_pipe, type %d\n", type);
	ctx->pipe->followup = type;
	ctx->pipe->r_mode = ctx->w;
	new_p=new_pipe();
	ctx->pipe->next = new_p;
3480b2e0:	e5830008 	str	r0, [r3, #8]
	ctx->pipe = new_p;
3480b2e4:	e5840008 	str	r0, [r4, #8]
	ctx->child = NULL;
3480b2e8:	e5845000 	str	r5, [r4]
	done_command(ctx);  /* set up new pipe to accept commands */
3480b2ec:	e1a00004 	mov	r0, r4
3480b2f0:	ebfffe25 	bl	3480ab8c <done_command>
	return 0;
}
3480b2f4:	e1a00005 	mov	r0, r5
3480b2f8:	e8bd8038 	pop	{r3, r4, r5, pc}

3480b2fc <reserved_word>:
	{ "done",  RES_DONE,  FLAG_END  }
};
#define NRES (sizeof(reserved_list)/sizeof(struct reserved_combo))

int reserved_word(o_string *dest, struct p_context *ctx)
{
3480b2fc:	e92d46f8 	push	{r3, r4, r5, r6, r7, r9, sl, lr}
	{ "do",    RES_DO,    FLAG_DONE },
	{ "done",  RES_DONE,  FLAG_END  }
};
#define NRES (sizeof(reserved_list)/sizeof(struct reserved_combo))

int reserved_word(o_string *dest, struct p_context *ctx)
3480b300:	e59f719c 	ldr	r7, [pc, #412]	; 3480b4a4 <reserved_word+0x1a8>
{
	struct reserved_combo *r;
	for (r=reserved_list;
3480b304:	e59f619c 	ldr	r6, [pc, #412]	; 3480b4a8 <reserved_word+0x1ac>
	{ "done",  RES_DONE,  FLAG_END  }
};
#define NRES (sizeof(reserved_list)/sizeof(struct reserved_combo))

int reserved_word(o_string *dest, struct p_context *ctx)
{
3480b308:	e1a05000 	mov	r5, r0
3480b30c:	e1a04001 	mov	r4, r1
	struct reserved_combo *r;
	for (r=reserved_list;
		r<reserved_list+NRES; r++) {
		if (strcmp(dest->data, r->literal) == 0) {
3480b310:	e5950000 	ldr	r0, [r5]
3480b314:	e5961000 	ldr	r1, [r6]
3480b318:	eb0035e4 	bl	34818ab0 <strcmp>
3480b31c:	e2509000 	subs	r9, r0, #0
3480b320:	1a000056 	bne	3480b480 <reserved_word+0x184>
			debug_printf("found reserved word %s, code %d\n",r->literal,r->code);
			if (r->flag & FLAG_START) {
3480b324:	e5963008 	ldr	r3, [r6, #8]
3480b328:	e3130b02 	tst	r3, #2048	; 0x800
3480b32c:	0a000025 	beq	3480b3c8 <reserved_word+0xcc>
				struct p_context *new = xmalloc(sizeof(struct p_context));
3480b330:	e280001c 	add	r0, r0, #28
3480b334:	ebfffd63 	bl	3480a8c8 <xmalloc>
				debug_printf("push stack\n");
				if (ctx->w == RES_IN || ctx->w == RES_FOR) {
3480b338:	e594700c 	ldr	r7, [r4, #12]
	for (r=reserved_list;
		r<reserved_list+NRES; r++) {
		if (strcmp(dest->data, r->literal) == 0) {
			debug_printf("found reserved word %s, code %d\n",r->literal,r->code);
			if (r->flag & FLAG_START) {
				struct p_context *new = xmalloc(sizeof(struct p_context));
3480b33c:	e1a0a000 	mov	sl, r0
				debug_printf("push stack\n");
				if (ctx->w == RES_IN || ctx->w == RES_FOR) {
3480b340:	e357000c 	cmp	r7, #12
3480b344:	13570006 	cmpne	r7, #6
3480b348:	13a07000 	movne	r7, #0
3480b34c:	03a07001 	moveq	r7, #1
3480b350:	1a00000a 	bne	3480b380 <reserved_word+0x84>
					syntax();
3480b354:	ebfffd1c 	bl	3480a7cc <syntax_err>
					free(new);
3480b358:	e1a0000a 	mov	r0, sl
3480b35c:	ebfff838 	bl	34809444 <free>
					ctx->w = RES_SNTX;
3480b360:	e3a0300d 	mov	r3, #13
3480b364:	e584300c 	str	r3, [r4, #12]

static void b_reset(o_string *o)
{
	o->length = 0;
	o->nonnull = 0;
	if (o->data != NULL) *o->data = '\0';
3480b368:	e5953000 	ldr	r3, [r5]
	return 0;
}

static void b_reset(o_string *o)
{
	o->length = 0;
3480b36c:	e5859004 	str	r9, [r5, #4]
	o->nonnull = 0;
	if (o->data != NULL) *o->data = '\0';
3480b370:	e3530000 	cmp	r3, #0
}

static void b_reset(o_string *o)
{
	o->length = 0;
	o->nonnull = 0;
3480b374:	e5859010 	str	r9, [r5, #16]
	if (o->data != NULL) *o->data = '\0';
3480b378:	15c39000 	strbne	r9, [r3]
3480b37c:	ea000044 	b	3480b494 <reserved_word+0x198>
					free(new);
					ctx->w = RES_SNTX;
					b_reset(dest);
					return 1;
				}
				*new = *ctx;   /* physical copy */
3480b380:	e1a0c004 	mov	ip, r4
3480b384:	e1a0e00a 	mov	lr, sl
3480b388:	e8bc000f 	ldm	ip!, {r0, r1, r2, r3}
3480b38c:	e8ae000f 	stmia	lr!, {r0, r1, r2, r3}
3480b390:	e89c0007 	ldm	ip, {r0, r1, r2}
3480b394:	e88e0007 	stm	lr, {r0, r1, r2}
	return pi;
}

static void initialize_context(struct p_context *ctx)
{
	ctx->pipe=NULL;
3480b398:	e5847008 	str	r7, [r4, #8]
#ifndef __U_BOOT__
	ctx->pending_redirect=NULL;
#endif
	ctx->child=NULL;
3480b39c:	e5847000 	str	r7, [r4]
	ctx->list_head=new_pipe();
3480b3a0:	ebffffb9 	bl	3480b28c <new_pipe>
	ctx->pipe=ctx->list_head;
	ctx->w=RES_NONE;
3480b3a4:	e584700c 	str	r7, [r4, #12]
	ctx->pipe=NULL;
#ifndef __U_BOOT__
	ctx->pending_redirect=NULL;
#endif
	ctx->child=NULL;
	ctx->list_head=new_pipe();
3480b3a8:	e5840004 	str	r0, [r4, #4]
	ctx->pipe=ctx->list_head;
3480b3ac:	e5840008 	str	r0, [r4, #8]
	ctx->w=RES_NONE;
	ctx->stack=NULL;
3480b3b0:	e5847014 	str	r7, [r4, #20]
#ifdef __U_BOOT__
	ctx->old_flag=0;
3480b3b4:	e5847010 	str	r7, [r4, #16]
#endif
	done_command(ctx);   /* creates the memory for working child */
3480b3b8:	e1a00004 	mov	r0, r4
3480b3bc:	ebfffdf2 	bl	3480ab8c <done_command>
					b_reset(dest);
					return 1;
				}
				*new = *ctx;   /* physical copy */
				initialize_context(ctx);
				ctx->stack=new;
3480b3c0:	e584a014 	str	sl, [r4, #20]
3480b3c4:	ea000011 	b	3480b410 <reserved_word+0x114>
			} else if ( ctx->w == RES_NONE || ! (ctx->old_flag & (1<<r->code))) {
3480b3c8:	e594300c 	ldr	r3, [r4, #12]
3480b3cc:	e3530000 	cmp	r3, #0
3480b3d0:	0a000004 	beq	3480b3e8 <reserved_word+0xec>
3480b3d4:	e5942010 	ldr	r2, [r4, #16]
3480b3d8:	e5963004 	ldr	r3, [r6, #4]
3480b3dc:	e1a03352 	asr	r3, r2, r3
3480b3e0:	e3130001 	tst	r3, #1
3480b3e4:	1a000009 	bne	3480b410 <reserved_word+0x114>
				syntax();
3480b3e8:	ebfffcf7 	bl	3480a7cc <syntax_err>
				ctx->w = RES_SNTX;
3480b3ec:	e3a0300d 	mov	r3, #13

static void b_reset(o_string *o)
{
	o->length = 0;
	o->nonnull = 0;
	if (o->data != NULL) *o->data = '\0';
3480b3f0:	e5952000 	ldr	r2, [r5]
				*new = *ctx;   /* physical copy */
				initialize_context(ctx);
				ctx->stack=new;
			} else if ( ctx->w == RES_NONE || ! (ctx->old_flag & (1<<r->code))) {
				syntax();
				ctx->w = RES_SNTX;
3480b3f4:	e584300c 	str	r3, [r4, #12]
	return 0;
}

static void b_reset(o_string *o)
{
	o->length = 0;
3480b3f8:	e3a03000 	mov	r3, #0
	o->nonnull = 0;
	if (o->data != NULL) *o->data = '\0';
3480b3fc:	e1520003 	cmp	r2, r3
	return 0;
}

static void b_reset(o_string *o)
{
	o->length = 0;
3480b400:	e5853004 	str	r3, [r5, #4]
	o->nonnull = 0;
3480b404:	e5853010 	str	r3, [r5, #16]
	if (o->data != NULL) *o->data = '\0';
3480b408:	1a00001a 	bne	3480b478 <reserved_word+0x17c>
3480b40c:	ea000020 	b	3480b494 <reserved_word+0x198>
				syntax();
				ctx->w = RES_SNTX;
				b_reset(dest);
				return 1;
			}
			ctx->w=r->code;
3480b410:	e5963004 	ldr	r3, [r6, #4]
3480b414:	e584300c 	str	r3, [r4, #12]
			ctx->old_flag = r->flag;
3480b418:	e5963008 	ldr	r3, [r6, #8]
			if (ctx->old_flag & FLAG_END) {
3480b41c:	e3130001 	tst	r3, #1
				ctx->w = RES_SNTX;
				b_reset(dest);
				return 1;
			}
			ctx->w=r->code;
			ctx->old_flag = r->flag;
3480b420:	e5843010 	str	r3, [r4, #16]
			if (ctx->old_flag & FLAG_END) {
3480b424:	0a00000d 	beq	3480b460 <reserved_word+0x164>
				struct p_context *old;
				debug_printf("pop stack\n");
				done_pipe(ctx,PIPE_SEQ);
3480b428:	e1a00004 	mov	r0, r4
3480b42c:	e3a01001 	mov	r1, #1
3480b430:	ebffff9f 	bl	3480b2b4 <done_pipe>
				old = ctx->stack;
3480b434:	e594c014 	ldr	ip, [r4, #20]
				old->child->group = ctx->list_head;
3480b438:	e5942004 	ldr	r2, [r4, #4]
3480b43c:	e59c3000 	ldr	r3, [ip]
#ifndef __U_BOOT__
				old->child->subshell = 0;
#endif
				*ctx = *old;   /* physical copy */
3480b440:	e1a0e00c 	mov	lr, ip
			if (ctx->old_flag & FLAG_END) {
				struct p_context *old;
				debug_printf("pop stack\n");
				done_pipe(ctx,PIPE_SEQ);
				old = ctx->stack;
				old->child->group = ctx->list_head;
3480b444:	e5832008 	str	r2, [r3, #8]
#ifndef __U_BOOT__
				old->child->subshell = 0;
#endif
				*ctx = *old;   /* physical copy */
3480b448:	e8be000f 	ldm	lr!, {r0, r1, r2, r3}
3480b44c:	e8a4000f 	stmia	r4!, {r0, r1, r2, r3}
3480b450:	e89e0007 	ldm	lr, {r0, r1, r2}
3480b454:	e8840007 	stm	r4, {r0, r1, r2}
				free(old);
3480b458:	e1a0000c 	mov	r0, ip
3480b45c:	ebfff7f8 	bl	34809444 <free>

static void b_reset(o_string *o)
{
	o->length = 0;
	o->nonnull = 0;
	if (o->data != NULL) *o->data = '\0';
3480b460:	e5952000 	ldr	r2, [r5]
	return 0;
}

static void b_reset(o_string *o)
{
	o->length = 0;
3480b464:	e3a03000 	mov	r3, #0
	o->nonnull = 0;
	if (o->data != NULL) *o->data = '\0';
3480b468:	e1520003 	cmp	r2, r3
	return 0;
}

static void b_reset(o_string *o)
{
	o->length = 0;
3480b46c:	e5853004 	str	r3, [r5, #4]
	o->nonnull = 0;
3480b470:	e5853010 	str	r3, [r5, #16]
	if (o->data != NULL) *o->data = '\0';
3480b474:	0a000008 	beq	3480b49c <reserved_word+0x1a0>
3480b478:	e5c23000 	strb	r3, [r2]
3480b47c:	ea000004 	b	3480b494 <reserved_word+0x198>

int reserved_word(o_string *dest, struct p_context *ctx)
{
	struct reserved_combo *r;
	for (r=reserved_list;
		r<reserved_list+NRES; r++) {
3480b480:	e286600c 	add	r6, r6, #12
#define NRES (sizeof(reserved_list)/sizeof(struct reserved_combo))

int reserved_word(o_string *dest, struct p_context *ctx)
{
	struct reserved_combo *r;
	for (r=reserved_list;
3480b484:	e1560007 	cmp	r6, r7
3480b488:	1affffa0 	bne	3480b310 <reserved_word+0x14>
			}
			b_reset (dest);
			return 1;
		}
	}
	return 0;
3480b48c:	e3a00000 	mov	r0, #0
3480b490:	e8bd86f8 	pop	{r3, r4, r5, r6, r7, r9, sl, pc}
				ctx->stack=new;
			} else if ( ctx->w == RES_NONE || ! (ctx->old_flag & (1<<r->code))) {
				syntax();
				ctx->w = RES_SNTX;
				b_reset(dest);
				return 1;
3480b494:	e3a00001 	mov	r0, #1
3480b498:	e8bd86f8 	pop	{r3, r4, r5, r6, r7, r9, sl, pc}
#endif
				*ctx = *old;   /* physical copy */
				free(old);
			}
			b_reset (dest);
			return 1;
3480b49c:	e3a00001 	mov	r0, #1
		}
	}
	return 0;
}
3480b4a0:	e8bd86f8 	pop	{r3, r4, r5, r6, r7, r9, sl, pc}
3480b4a4:	34828870 	.word	0x34828870
3480b4a8:	348287ec 	.word	0x348287ec

3480b4ac <done_word>:

/* normal return is 0.
 * Syntax or xglob errors return 1. */
static int done_word(o_string *dest, struct p_context *ctx)
{
3480b4ac:	e92d46f8 	push	{r3, r4, r5, r6, r7, r9, sl, lr}
	char *str, *s;
	int argc, cnt;
#endif

	debug_printf("done_word: %s %p\n", dest->data, child);
	if (dest->length == 0 && !dest->nonnull) {
3480b4b0:	e5903004 	ldr	r3, [r0, #4]
}

/* normal return is 0.
 * Syntax or xglob errors return 1. */
static int done_word(o_string *dest, struct p_context *ctx)
{
3480b4b4:	e1a04000 	mov	r4, r0
	char *str, *s;
	int argc, cnt;
#endif

	debug_printf("done_word: %s %p\n", dest->data, child);
	if (dest->length == 0 && !dest->nonnull) {
3480b4b8:	e3530000 	cmp	r3, #0
}

/* normal return is 0.
 * Syntax or xglob errors return 1. */
static int done_word(o_string *dest, struct p_context *ctx)
{
3480b4bc:	e1a05001 	mov	r5, r1
	struct child_prog *child=ctx->child;
3480b4c0:	e5916000 	ldr	r6, [r1]
	char *str, *s;
	int argc, cnt;
#endif

	debug_printf("done_word: %s %p\n", dest->data, child);
	if (dest->length == 0 && !dest->nonnull) {
3480b4c4:	1a000002 	bne	3480b4d4 <done_word+0x28>
3480b4c8:	e5900010 	ldr	r0, [r0, #16]
3480b4cc:	e3500000 	cmp	r0, #0
3480b4d0:	08bd86f8 	popeq	{r3, r4, r5, r6, r7, r9, sl, pc}
#ifndef __U_BOOT__
	if (ctx->pending_redirect) {
		glob_target = &ctx->pending_redirect->word;
	} else {
#endif
		if (child->group) {
3480b4d4:	e5963008 	ldr	r3, [r6, #8]
3480b4d8:	e3530000 	cmp	r3, #0
3480b4dc:	0a000001 	beq	3480b4e8 <done_word+0x3c>
			syntax();
3480b4e0:	ebfffcb9 	bl	3480a7cc <syntax_err>
3480b4e4:	ea00004a 	b	3480b614 <done_word+0x168>
			return 1;  /* syntax error, groups and arglists don't mix */
		}
		if (!child->argv && (ctx->type & FLAG_PARSE_SEMICOLON)) {
3480b4e8:	e5963000 	ldr	r3, [r6]
3480b4ec:	e3530000 	cmp	r3, #0
3480b4f0:	1a00000c 	bne	3480b528 <done_word+0x7c>
3480b4f4:	e5953018 	ldr	r3, [r5, #24]
3480b4f8:	e3130002 	tst	r3, #2
3480b4fc:	0a000009 	beq	3480b528 <done_word+0x7c>
			debug_printf("checking %s for reserved-ness\n",dest->data);
			if (reserved_word(dest,ctx)) return ctx->w==RES_SNTX;
3480b500:	e1a00004 	mov	r0, r4
3480b504:	e1a01005 	mov	r1, r5
3480b508:	ebffff7b 	bl	3480b2fc <reserved_word>
3480b50c:	e3500000 	cmp	r0, #0
3480b510:	0a000004 	beq	3480b528 <done_word+0x7c>
3480b514:	e595000c 	ldr	r0, [r5, #12]
3480b518:	e350000d 	cmp	r0, #13
3480b51c:	13a00000 	movne	r0, #0
3480b520:	03a00001 	moveq	r0, #1
3480b524:	e8bd86f8 	pop	{r3, r4, r5, r6, r7, r9, sl, pc}
		}
#ifndef __U_BOOT__
		glob_target = &child->glob_result;
		if (child->argv) flags |= GLOB_APPEND;
#else
		for (cnt = 1, s = dest->data; s && *s; s++) {
3480b528:	e5943000 	ldr	r3, [r4]
3480b52c:	e3a00001 	mov	r0, #1
3480b530:	ea000003 	b	3480b544 <done_word+0x98>
			if (*s == '\\') s++;
3480b534:	e352005c 	cmp	r2, #92	; 0x5c
3480b538:	02833001 	addeq	r3, r3, #1
			cnt++;
3480b53c:	e2800001 	add	r0, r0, #1
		}
#ifndef __U_BOOT__
		glob_target = &child->glob_result;
		if (child->argv) flags |= GLOB_APPEND;
#else
		for (cnt = 1, s = dest->data; s && *s; s++) {
3480b540:	e2833001 	add	r3, r3, #1
3480b544:	e3530000 	cmp	r3, #0
3480b548:	0a000002 	beq	3480b558 <done_word+0xac>
3480b54c:	e5d32000 	ldrb	r2, [r3]
3480b550:	e3520000 	cmp	r2, #0
3480b554:	1afffff6 	bne	3480b534 <done_word+0x88>
			if (*s == '\\') s++;
			cnt++;
		}
		str = malloc(cnt);
3480b558:	ebfff842 	bl	34809668 <malloc>
		if (!str) return 1;
3480b55c:	e2507000 	subs	r7, r0, #0
3480b560:	0a00002b 	beq	3480b614 <done_word+0x168>
		if ( child->argv == NULL) {
3480b564:	e5960000 	ldr	r0, [r6]
3480b568:	e3500000 	cmp	r0, #0
			child->argc=0;
3480b56c:	05860004 	streq	r0, [r6, #4]
		}
		argc = ++child->argc;
3480b570:	e5969004 	ldr	r9, [r6, #4]
3480b574:	e289a001 	add	sl, r9, #1
		child->argv = realloc(child->argv, (argc+1)*sizeof(*child->argv));
3480b578:	e28a1001 	add	r1, sl, #1
		str = malloc(cnt);
		if (!str) return 1;
		if ( child->argv == NULL) {
			child->argc=0;
		}
		argc = ++child->argc;
3480b57c:	e586a004 	str	sl, [r6, #4]
		child->argv = realloc(child->argv, (argc+1)*sizeof(*child->argv));
3480b580:	e1a01101 	lsl	r1, r1, #2
3480b584:	ebfffa29 	bl	34809e30 <realloc>
		if (child->argv == NULL) return 1;
3480b588:	e3500000 	cmp	r0, #0
		if (!str) return 1;
		if ( child->argv == NULL) {
			child->argc=0;
		}
		argc = ++child->argc;
		child->argv = realloc(child->argv, (argc+1)*sizeof(*child->argv));
3480b58c:	e5860000 	str	r0, [r6]
		if (child->argv == NULL) return 1;
3480b590:	0a00001f 	beq	3480b614 <done_word+0x168>
		child->argv[argc-1]=str;
		child->argv[argc]=NULL;
3480b594:	e3a03000 	mov	r3, #0
			child->argc=0;
		}
		argc = ++child->argc;
		child->argv = realloc(child->argv, (argc+1)*sizeof(*child->argv));
		if (child->argv == NULL) return 1;
		child->argv[argc-1]=str;
3480b598:	e7807109 	str	r7, [r0, r9, lsl #2]
		child->argv[argc]=NULL;
3480b59c:	e780310a 	str	r3, [r0, sl, lsl #2]
		for (s = dest->data; s && *s; s++,str++) {
3480b5a0:	e5943000 	ldr	r3, [r4]
3480b5a4:	ea000003 	b	3480b5b8 <done_word+0x10c>
			if (*s == '\\') s++;
3480b5a8:	e352005c 	cmp	r2, #92	; 0x5c
3480b5ac:	02833001 	addeq	r3, r3, #1
			*str = *s;
3480b5b0:	e4d32001 	ldrb	r2, [r3], #1
3480b5b4:	e4c72001 	strb	r2, [r7], #1
		argc = ++child->argc;
		child->argv = realloc(child->argv, (argc+1)*sizeof(*child->argv));
		if (child->argv == NULL) return 1;
		child->argv[argc-1]=str;
		child->argv[argc]=NULL;
		for (s = dest->data; s && *s; s++,str++) {
3480b5b8:	e3530000 	cmp	r3, #0
3480b5bc:	0a000002 	beq	3480b5cc <done_word+0x120>
3480b5c0:	e5d32000 	ldrb	r2, [r3]
3480b5c4:	e3520000 	cmp	r2, #0
3480b5c8:	1afffff6 	bne	3480b5a8 <done_word+0xfc>
			if (*s == '\\') s++;
			*str = *s;
		}
		*str = '\0';
3480b5cc:	e3a03000 	mov	r3, #0
3480b5d0:	e5c73000 	strb	r3, [r7]

static void b_reset(o_string *o)
{
	o->length = 0;
	o->nonnull = 0;
	if (o->data != NULL) *o->data = '\0';
3480b5d4:	e5942000 	ldr	r2, [r4]
	return 0;
}

static void b_reset(o_string *o)
{
	o->length = 0;
3480b5d8:	e5843004 	str	r3, [r4, #4]
	o->nonnull = 0;
	if (o->data != NULL) *o->data = '\0';
3480b5dc:	e1520003 	cmp	r2, r3
}

static void b_reset(o_string *o)
{
	o->length = 0;
	o->nonnull = 0;
3480b5e0:	e5843010 	str	r3, [r4, #16]
	if (o->data != NULL) *o->data = '\0';
3480b5e4:	15c23000 	strbne	r3, [r2]
		}
	} else {
		child->argv = glob_target->gl_pathv;
	}
#endif
	if (ctx->w == RES_FOR) {
3480b5e8:	e595300c 	ldr	r3, [r5, #12]
3480b5ec:	e3530006 	cmp	r3, #6
3480b5f0:	1a000009 	bne	3480b61c <done_word+0x170>
		done_word(dest,ctx);
3480b5f4:	e1a01005 	mov	r1, r5
3480b5f8:	e1a00004 	mov	r0, r4
3480b5fc:	ebffffaa 	bl	3480b4ac <done_word>
		done_pipe(ctx,PIPE_SEQ);
3480b600:	e1a00005 	mov	r0, r5
3480b604:	e3a01001 	mov	r1, #1
3480b608:	ebffff29 	bl	3480b2b4 <done_pipe>
	}
	return 0;
3480b60c:	e3a00000 	mov	r0, #0
3480b610:	e8bd86f8 	pop	{r3, r4, r5, r6, r7, r9, sl, pc}
		if ( child->argv == NULL) {
			child->argc=0;
		}
		argc = ++child->argc;
		child->argv = realloc(child->argv, (argc+1)*sizeof(*child->argv));
		if (child->argv == NULL) return 1;
3480b614:	e3a00001 	mov	r0, #1
3480b618:	e8bd86f8 	pop	{r3, r4, r5, r6, r7, r9, sl, pc}
#endif
	if (ctx->w == RES_FOR) {
		done_word(dest,ctx);
		done_pipe(ctx,PIPE_SEQ);
	}
	return 0;
3480b61c:	e3a00000 	mov	r0, #0
}
3480b620:	e8bd86f8 	pop	{r3, r4, r5, r6, r7, r9, sl, pc}

3480b624 <mapset>:
}

void mapset(const unsigned char *set, int code)
{
	const unsigned char *s;
	for (s=set; *s; s++) map[*s] = code;
3480b624:	e59f2018 	ldr	r2, [pc, #24]	; 3480b644 <mapset+0x20>
3480b628:	ea000001 	b	3480b634 <mapset+0x10>
3480b62c:	e0823003 	add	r3, r2, r3
3480b630:	e5c31138 	strb	r1, [r3, #312]	; 0x138
3480b634:	e4d03001 	ldrb	r3, [r0], #1
3480b638:	e3530000 	cmp	r3, #0
3480b63c:	1afffffa 	bne	3480b62c <mapset+0x8>
}
3480b640:	e12fff1e 	bx	lr
3480b644:	34829528 	.word	0x34829528

3480b648 <update_ifs_map>:

void update_ifs_map(void)
{
3480b648:	e92d4013 	push	{r0, r1, r4, lr}
	/* char *ifs and char map[256] are both globals. */
	ifs = (uchar *)getenv("IFS");
3480b64c:	e59f006c 	ldr	r0, [pc, #108]	; 3480b6c0 <update_ifs_map+0x78>
3480b650:	ebfff2f9 	bl	3480823c <getenv>
	if (ifs == NULL) ifs=(uchar *)" \t\n";
3480b654:	e3500000 	cmp	r0, #0
3480b658:	059f2064 	ldreq	r2, [pc, #100]	; 3480b6c4 <update_ifs_map+0x7c>
}

void update_ifs_map(void)
{
	/* char *ifs and char map[256] are both globals. */
	ifs = (uchar *)getenv("IFS");
3480b65c:	e59f3064 	ldr	r3, [pc, #100]	; 3480b6c8 <update_ifs_map+0x80>
	 * quickly up front.  Computation is necessary because of IFS.
	 * Special case handling of IFS == " \t\n" is not implemented.
	 * The map[] array only really needs two bits each, and on most machines
	 * that would be faster because of the reduced L1 cache footprint.
	 */
	memset(map,0,sizeof(map)); /* most characters flow through always */
3480b660:	e59f4060 	ldr	r4, [pc, #96]	; 3480b6c8 <update_ifs_map+0x80>
}

void update_ifs_map(void)
{
	/* char *ifs and char map[256] are both globals. */
	ifs = (uchar *)getenv("IFS");
3480b664:	e5830238 	str	r0, [r3, #568]	; 0x238
	 * quickly up front.  Computation is necessary because of IFS.
	 * Special case handling of IFS == " \t\n" is not implemented.
	 * The map[] array only really needs two bits each, and on most machines
	 * that would be faster because of the reduced L1 cache footprint.
	 */
	memset(map,0,sizeof(map)); /* most characters flow through always */
3480b668:	e3a01000 	mov	r1, #0

void update_ifs_map(void)
{
	/* char *ifs and char map[256] are both globals. */
	ifs = (uchar *)getenv("IFS");
	if (ifs == NULL) ifs=(uchar *)" \t\n";
3480b66c:	05832238 	streq	r2, [r3, #568]	; 0x238
	 * quickly up front.  Computation is necessary because of IFS.
	 * Special case handling of IFS == " \t\n" is not implemented.
	 * The map[] array only really needs two bits each, and on most machines
	 * that would be faster because of the reduced L1 cache footprint.
	 */
	memset(map,0,sizeof(map)); /* most characters flow through always */
3480b670:	e2840f4e 	add	r0, r4, #312	; 0x138
3480b674:	e3a02c01 	mov	r2, #256	; 0x100
3480b678:	eb0035e0 	bl	34818e00 <memset>
#ifndef __U_BOOT__
	mapset((uchar *)"\\$'\"`", 3);      /* never flow through */
	mapset((uchar *)"<>;&|(){}#", 1);   /* flow through if quoted */
#else
	{
		uchar subst[2] = {SUBSTED_VAR_SYMBOL, 0};
3480b67c:	e3a03004 	mov	r3, #4
3480b680:	e5cd3004 	strb	r3, [sp, #4]
		mapset(subst, 3);       /* never flow through */
3480b684:	e28d0004 	add	r0, sp, #4
#ifndef __U_BOOT__
	mapset((uchar *)"\\$'\"`", 3);      /* never flow through */
	mapset((uchar *)"<>;&|(){}#", 1);   /* flow through if quoted */
#else
	{
		uchar subst[2] = {SUBSTED_VAR_SYMBOL, 0};
3480b688:	e3a03000 	mov	r3, #0
		mapset(subst, 3);       /* never flow through */
3480b68c:	e3a01003 	mov	r1, #3
#ifndef __U_BOOT__
	mapset((uchar *)"\\$'\"`", 3);      /* never flow through */
	mapset((uchar *)"<>;&|(){}#", 1);   /* flow through if quoted */
#else
	{
		uchar subst[2] = {SUBSTED_VAR_SYMBOL, 0};
3480b690:	e5cd3005 	strb	r3, [sp, #5]
		mapset(subst, 3);       /* never flow through */
3480b694:	ebffffe2 	bl	3480b624 <mapset>
	}
	mapset((uchar *)"\\$'\"", 3);       /* never flow through */
3480b698:	e59f002c 	ldr	r0, [pc, #44]	; 3480b6cc <update_ifs_map+0x84>
3480b69c:	e3a01003 	mov	r1, #3
3480b6a0:	ebffffdf 	bl	3480b624 <mapset>
	mapset((uchar *)";&|#", 1);         /* flow through if quoted */
3480b6a4:	e59f0024 	ldr	r0, [pc, #36]	; 3480b6d0 <update_ifs_map+0x88>
3480b6a8:	e3a01001 	mov	r1, #1
3480b6ac:	ebffffdc 	bl	3480b624 <mapset>
#endif
	mapset(ifs, 2);            /* also flow through if quoted */
3480b6b0:	e5940238 	ldr	r0, [r4, #568]	; 0x238
3480b6b4:	e3a01002 	mov	r1, #2
3480b6b8:	ebffffd9 	bl	3480b624 <mapset>
}
3480b6bc:	e8bd801c 	pop	{r2, r3, r4, pc}
3480b6c0:	348260f1 	.word	0x348260f1
3480b6c4:	348260f5 	.word	0x348260f5
3480b6c8:	34829528 	.word	0x34829528
3480b6cc:	348260f9 	.word	0x348260f9
3480b6d0:	348260fe 	.word	0x348260fe

3480b6d4 <parse_string_outer>:
#ifndef __U_BOOT__
static int parse_string_outer(const char *s, int flag)
#else
int parse_string_outer(const char *s, int flag)
#endif	/* __U_BOOT__ */
{
3480b6d4:	e92d4070 	push	{r4, r5, r6, lr}
	struct in_str input;
#ifdef __U_BOOT__
	char *p = NULL;
	int rcode;
	if ( !s || !*s)
3480b6d8:	e2504000 	subs	r4, r0, #0
#ifndef __U_BOOT__
static int parse_string_outer(const char *s, int flag)
#else
int parse_string_outer(const char *s, int flag)
#endif	/* __U_BOOT__ */
{
3480b6dc:	e24dd018 	sub	sp, sp, #24
3480b6e0:	e1a06001 	mov	r6, r1
	struct in_str input;
#ifdef __U_BOOT__
	char *p = NULL;
	int rcode;
	if ( !s || !*s)
3480b6e4:	0a00002f 	beq	3480b7a8 <parse_string_outer+0xd4>
3480b6e8:	e5d43000 	ldrb	r3, [r4]
3480b6ec:	e3530000 	cmp	r3, #0
3480b6f0:	0a00002c 	beq	3480b7a8 <parse_string_outer+0xd4>
		return 1;
	if (!(p = strchr(s, '\n')) || *++p) {
3480b6f4:	e3a0100a 	mov	r1, #10
3480b6f8:	eb00350a 	bl	34818b28 <strchr>
3480b6fc:	e3500000 	cmp	r0, #0
3480b700:	0a000002 	beq	3480b710 <parse_string_outer+0x3c>
3480b704:	e5d03001 	ldrb	r3, [r0, #1]
3480b708:	e3530000 	cmp	r3, #0
3480b70c:	0a000018 	beq	3480b774 <parse_string_outer+0xa0>
		p = xmalloc(strlen(s) + 2);
3480b710:	e1a00004 	mov	r0, r4
3480b714:	eb003519 	bl	34818b80 <strlen>
3480b718:	e2800002 	add	r0, r0, #2
3480b71c:	ebfffc69 	bl	3480a8c8 <xmalloc>
		strcpy(p, s);
3480b720:	e1a01004 	mov	r1, r4
	char *p = NULL;
	int rcode;
	if ( !s || !*s)
		return 1;
	if (!(p = strchr(s, '\n')) || *++p) {
		p = xmalloc(strlen(s) + 2);
3480b724:	e1a05000 	mov	r5, r0
		strcpy(p, s);
3480b728:	eb0034af 	bl	348189ec <strcpy>
		strcat(p, "\n");
3480b72c:	e1a00005 	mov	r0, r5
3480b730:	e59f1080 	ldr	r1, [pc, #128]	; 3480b7b8 <parse_string_outer+0xe4>
3480b734:	eb0034bd 	bl	34818a30 <strcat>
	i->p = NULL;
}

static void setup_string_in_str(struct in_str *i, const char *s)
{
	i->peek = static_peek;
3480b738:	e59f307c 	ldr	r3, [pc, #124]	; 3480b7bc <parse_string_outer+0xe8>
	i->get = static_get;
	i->__promptme=1;
	i->promptmode=1;
	i->p = s;
3480b73c:	e28d0018 	add	r0, sp, #24
	i->p = NULL;
}

static void setup_string_in_str(struct in_str *i, const char *s)
{
	i->peek = static_peek;
3480b740:	e58d3014 	str	r3, [sp, #20]
	i->get = static_get;
3480b744:	e59f3074 	ldr	r3, [pc, #116]	; 3480b7c0 <parse_string_outer+0xec>
	i->__promptme=1;
	i->promptmode=1;
	i->p = s;
3480b748:	e5205014 	str	r5, [r0, #-20]!
}

static void setup_string_in_str(struct in_str *i, const char *s)
{
	i->peek = static_peek;
	i->get = static_get;
3480b74c:	e58d3010 	str	r3, [sp, #16]
	if (!(p = strchr(s, '\n')) || *++p) {
		p = xmalloc(strlen(s) + 2);
		strcpy(p, s);
		strcat(p, "\n");
		setup_string_in_str(&input, p);
		rcode = parse_stream_outer(&input, flag);
3480b750:	e1a01006 	mov	r1, r6

static void setup_string_in_str(struct in_str *i, const char *s)
{
	i->peek = static_peek;
	i->get = static_get;
	i->__promptme=1;
3480b754:	e3a03001 	mov	r3, #1
3480b758:	e58d3008 	str	r3, [sp, #8]
	i->promptmode=1;
3480b75c:	e58d300c 	str	r3, [sp, #12]
	if (!(p = strchr(s, '\n')) || *++p) {
		p = xmalloc(strlen(s) + 2);
		strcpy(p, s);
		strcat(p, "\n");
		setup_string_in_str(&input, p);
		rcode = parse_stream_outer(&input, flag);
3480b760:	eb000210 	bl	3480bfa8 <parse_stream_outer>
3480b764:	e1a04000 	mov	r4, r0
		free(p);
3480b768:	e1a00005 	mov	r0, r5
3480b76c:	ebfff734 	bl	34809444 <free>
		return rcode;
3480b770:	ea00000d 	b	3480b7ac <parse_string_outer+0xd8>
	i->p = NULL;
}

static void setup_string_in_str(struct in_str *i, const char *s)
{
	i->peek = static_peek;
3480b774:	e59f3040 	ldr	r3, [pc, #64]	; 3480b7bc <parse_string_outer+0xe8>
	i->get = static_get;
	i->__promptme=1;
	i->promptmode=1;
	i->p = s;
3480b778:	e28d0018 	add	r0, sp, #24
	i->p = NULL;
}

static void setup_string_in_str(struct in_str *i, const char *s)
{
	i->peek = static_peek;
3480b77c:	e58d3014 	str	r3, [sp, #20]
	i->get = static_get;
3480b780:	e59f3038 	ldr	r3, [pc, #56]	; 3480b7c0 <parse_string_outer+0xec>
	i->__promptme=1;
	i->promptmode=1;
	i->p = s;
3480b784:	e5204014 	str	r4, [r0, #-20]!
}

static void setup_string_in_str(struct in_str *i, const char *s)
{
	i->peek = static_peek;
	i->get = static_get;
3480b788:	e58d3010 	str	r3, [sp, #16]
		free(p);
		return rcode;
	} else {
#endif
	setup_string_in_str(&input, s);
	return parse_stream_outer(&input, flag);
3480b78c:	e1a01006 	mov	r1, r6

static void setup_string_in_str(struct in_str *i, const char *s)
{
	i->peek = static_peek;
	i->get = static_get;
	i->__promptme=1;
3480b790:	e3a03001 	mov	r3, #1
3480b794:	e58d3008 	str	r3, [sp, #8]
	i->promptmode=1;
3480b798:	e58d300c 	str	r3, [sp, #12]
		free(p);
		return rcode;
	} else {
#endif
	setup_string_in_str(&input, s);
	return parse_stream_outer(&input, flag);
3480b79c:	eb000201 	bl	3480bfa8 <parse_stream_outer>
3480b7a0:	e1a04000 	mov	r4, r0
3480b7a4:	ea000000 	b	3480b7ac <parse_string_outer+0xd8>
	struct in_str input;
#ifdef __U_BOOT__
	char *p = NULL;
	int rcode;
	if ( !s || !*s)
		return 1;
3480b7a8:	e3a04001 	mov	r4, #1
	setup_string_in_str(&input, s);
	return parse_stream_outer(&input, flag);
#ifdef __U_BOOT__
	}
#endif
}
3480b7ac:	e1a00004 	mov	r0, r4
3480b7b0:	e28dd018 	add	sp, sp, #24
3480b7b4:	e8bd8070 	pop	{r4, r5, r6, pc}
3480b7b8:	348260f7 	.word	0x348260f7
3480b7bc:	3480a760 	.word	0x3480a760
3480b7c0:	3480a744 	.word	0x3480a744

3480b7c4 <run_list_real>:
#endif
	return -1;
}

static int run_list_real(struct pipe *pi)
{
3480b7c4:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
3480b7c8:	e1a04000 	mov	r4, r0
3480b7cc:	e24dd038 	sub	sp, sp, #56	; 0x38
	int rcode=0, flag_skip=1;
	int flag_restore = 0;
	int if_code=0, next_if_code=0;  /* need double-buffer to handle elif */
	reserved_style rmode, skip_more_in_this_rmode=RES_XXXX;
	/* check syntax for "for" */
	for (rpipe = pi; rpipe; rpipe = rpipe->next) {
3480b7d0:	e1a05000 	mov	r5, r0
3480b7d4:	ea000023 	b	3480b868 <run_list_real+0xa4>
		if ((rpipe->r_mode == RES_IN ||
3480b7d8:	e5953010 	ldr	r3, [r5, #16]
3480b7dc:	e353000c 	cmp	r3, #12
3480b7e0:	13a02000 	movne	r2, #0
3480b7e4:	03a02001 	moveq	r2, #1
3480b7e8:	e3530006 	cmp	r3, #6
3480b7ec:	13a03000 	movne	r3, #0
3480b7f0:	03a03001 	moveq	r3, #1
3480b7f4:	e1930002 	orrs	r0, r3, r2
3480b7f8:	0a000019 	beq	3480b864 <run_list_real+0xa0>
		    rpipe->r_mode == RES_FOR) &&
		    (rpipe->next == NULL)) {
3480b7fc:	e5956008 	ldr	r6, [r5, #8]
	int if_code=0, next_if_code=0;  /* need double-buffer to handle elif */
	reserved_style rmode, skip_more_in_this_rmode=RES_XXXX;
	/* check syntax for "for" */
	for (rpipe = pi; rpipe; rpipe = rpipe->next) {
		if ((rpipe->r_mode == RES_IN ||
		    rpipe->r_mode == RES_FOR) &&
3480b800:	e3560000 	cmp	r6, #0
3480b804:	1a000003 	bne	3480b818 <run_list_real+0x54>
		    (rpipe->next == NULL)) {
				syntax();
3480b808:	ebfffbef 	bl	3480a7cc <syntax_err>
#ifdef __U_BOOT__
				flag_repeat = 0;
3480b80c:	e59f377c 	ldr	r3, [pc, #1916]	; 3480bf90 <run_list_real+0x7cc>
3480b810:	e5836004 	str	r6, [r3, #4]
3480b814:	ea0001d7 	b	3480bf78 <run_list_real+0x7b4>
#endif
				return 1;
		}
		if ((rpipe->r_mode == RES_IN &&
3480b818:	e3520000 	cmp	r2, #0
3480b81c:	0a000006 	beq	3480b83c <run_list_real+0x78>
3480b820:	e5963010 	ldr	r3, [r6, #16]
3480b824:	e353000c 	cmp	r3, #12
3480b828:	1a00000d 	bne	3480b864 <run_list_real+0xa0>
			(rpipe->next->r_mode == RES_IN &&
			rpipe->next->progs->argv != NULL))||
3480b82c:	e5963004 	ldr	r3, [r6, #4]
				flag_repeat = 0;
#endif
				return 1;
		}
		if ((rpipe->r_mode == RES_IN &&
			(rpipe->next->r_mode == RES_IN &&
3480b830:	e5933000 	ldr	r3, [r3]
3480b834:	e3530000 	cmp	r3, #0
3480b838:	ea000003 	b	3480b84c <run_list_real+0x88>
			rpipe->next->progs->argv != NULL))||
3480b83c:	e3530000 	cmp	r3, #0
3480b840:	0a000007 	beq	3480b864 <run_list_real+0xa0>
			(rpipe->r_mode == RES_FOR &&
3480b844:	e5963010 	ldr	r3, [r6, #16]
3480b848:	e353000c 	cmp	r3, #12
3480b84c:	0a000004 	beq	3480b864 <run_list_real+0xa0>
			rpipe->next->r_mode != RES_IN)) {
				syntax();
3480b850:	ebfffbdd 	bl	3480a7cc <syntax_err>
#ifdef __U_BOOT__
				flag_repeat = 0;
3480b854:	e59f3734 	ldr	r3, [pc, #1844]	; 3480bf90 <run_list_real+0x7cc>
3480b858:	e3a02000 	mov	r2, #0
3480b85c:	e5832004 	str	r2, [r3, #4]
3480b860:	ea0001c4 	b	3480bf78 <run_list_real+0x7b4>
	int rcode=0, flag_skip=1;
	int flag_restore = 0;
	int if_code=0, next_if_code=0;  /* need double-buffer to handle elif */
	reserved_style rmode, skip_more_in_this_rmode=RES_XXXX;
	/* check syntax for "for" */
	for (rpipe = pi; rpipe; rpipe = rpipe->next) {
3480b864:	e5955008 	ldr	r5, [r5, #8]
3480b868:	e3550000 	cmp	r5, #0
3480b86c:	1affffd9 	bne	3480b7d8 <run_list_real+0x14>
3480b870:	e3a09001 	mov	r9, #1
3480b874:	e1a07009 	mov	r7, r9
3480b878:	e3a0300b 	mov	r3, #11
3480b87c:	e58d5028 	str	r5, [sp, #40]	; 0x28
3480b880:	e58d5018 	str	r5, [sp, #24]
3480b884:	e58d5014 	str	r5, [sp, #20]
3480b888:	e1a0a005 	mov	sl, r5
3480b88c:	e1a0b005 	mov	fp, r5
3480b890:	e58d5020 	str	r5, [sp, #32]
3480b894:	e1a06005 	mov	r6, r5
3480b898:	e58d501c 	str	r5, [sp, #28]
3480b89c:	e1a09005 	mov	r9, r5
3480b8a0:	ea0001b1 	b	3480bf6c <run_list_real+0x7a8>
#endif
				return 1;
		}
	}
	for (; pi; pi = (flag_restore != 0) ? rpipe : pi->next) {
		if (pi->r_mode == RES_WHILE || pi->r_mode == RES_UNTIL ||
3480b8a4:	e5942010 	ldr	r2, [r4, #16]
3480b8a8:	e2422006 	sub	r2, r2, #6
3480b8ac:	e3520002 	cmp	r2, #2
3480b8b0:	8a00000a 	bhi	3480b8e0 <run_list_real+0x11c>
			pi->r_mode == RES_FOR) {
#ifdef __U_BOOT__
				/* check Ctrl-C */
				ctrlc();
3480b8b4:	e58d3008 	str	r3, [sp, #8]
3480b8b8:	ebfff5c8 	bl	34808fe0 <ctrlc>
				if ((had_ctrlc())) {
3480b8bc:	ebfff5e0 	bl	34809044 <had_ctrlc>
3480b8c0:	e3500000 	cmp	r0, #0
3480b8c4:	e59d3008 	ldr	r3, [sp, #8]
3480b8c8:	1a0001aa 	bne	3480bf78 <run_list_real+0x7b4>
					return 1;
				}
#endif
				flag_restore = 0;
				if (!rpipe) {
3480b8cc:	e3590000 	cmp	r9, #0
				ctrlc();
				if ((had_ctrlc())) {
					return 1;
				}
#endif
				flag_restore = 0;
3480b8d0:	158d0014 	strne	r0, [sp, #20]
				if (!rpipe) {
3480b8d4:	01a09004 	moveq	r9, r4
				ctrlc();
				if ((had_ctrlc())) {
					return 1;
				}
#endif
				flag_restore = 0;
3480b8d8:	058d0014 	streq	r0, [sp, #20]
				if (!rpipe) {
					flag_rep = 0;
3480b8dc:	01a0b000 	moveq	fp, r0
					rpipe = pi;
				}
		}
		rmode = pi->r_mode;
3480b8e0:	e5945010 	ldr	r5, [r4, #16]
		debug_printf("rmode=%d  if_code=%d  next_if_code=%d skip_more=%d\n", rmode, if_code, next_if_code, skip_more_in_this_rmode);
		if (rmode == skip_more_in_this_rmode && flag_skip) {
3480b8e4:	e1550003 	cmp	r5, r3
3480b8e8:	13a07000 	movne	r7, #0
3480b8ec:	02077001 	andeq	r7, r7, #1
3480b8f0:	e3570000 	cmp	r7, #0
3480b8f4:	0a000003 	beq	3480b908 <run_list_real+0x144>
			if (pi->followup == PIPE_SEQ) flag_skip=0;
3480b8f8:	e594700c 	ldr	r7, [r4, #12]
3480b8fc:	e2577001 	subs	r7, r7, #1
3480b900:	13a07001 	movne	r7, #1
3480b904:	ea000194 	b	3480bf5c <run_list_real+0x798>
			continue;
		}
		flag_skip = 1;
		skip_more_in_this_rmode = RES_XXXX;
		if (rmode == RES_THEN || rmode == RES_ELSE) if_code = next_if_code;
3480b908:	e3550002 	cmp	r5, #2
3480b90c:	13a02000 	movne	r2, #0
3480b910:	03a02001 	moveq	r2, #1
3480b914:	e3550004 	cmp	r5, #4
3480b918:	13a03000 	movne	r3, #0
3480b91c:	03a03001 	moveq	r3, #1
3480b920:	e1931002 	orrs	r1, r3, r2
3480b924:	e59d0018 	ldr	r0, [sp, #24]
3480b928:	e59d1028 	ldr	r1, [sp, #40]	; 0x28
3480b92c:	11a00001 	movne	r0, r1
		if (rmode == RES_THEN &&  if_code) continue;
3480b930:	e3500000 	cmp	r0, #0
3480b934:	03a02000 	moveq	r2, #0
3480b938:	12022001 	andne	r2, r2, #1
3480b93c:	e3520000 	cmp	r2, #0
			if (pi->followup == PIPE_SEQ) flag_skip=0;
			continue;
		}
		flag_skip = 1;
		skip_more_in_this_rmode = RES_XXXX;
		if (rmode == RES_THEN || rmode == RES_ELSE) if_code = next_if_code;
3480b940:	e58d0018 	str	r0, [sp, #24]
		if (rmode == RES_THEN &&  if_code) continue;
3480b944:	1a000182 	bne	3480bf54 <run_list_real+0x790>
		if (rmode == RES_ELSE && !if_code) continue;
3480b948:	e2707001 	rsbs	r7, r0, #1
3480b94c:	33a07000 	movcc	r7, #0
3480b950:	e1170003 	tst	r7, r3
		if (rmode == skip_more_in_this_rmode && flag_skip) {
			if (pi->followup == PIPE_SEQ) flag_skip=0;
			continue;
		}
		flag_skip = 1;
		skip_more_in_this_rmode = RES_XXXX;
3480b954:	13a0300b 	movne	r3, #11
		if (rmode == RES_THEN || rmode == RES_ELSE) if_code = next_if_code;
		if (rmode == RES_THEN &&  if_code) continue;
		if (rmode == RES_ELSE && !if_code) continue;
3480b958:	158d2018 	strne	r2, [sp, #24]
3480b95c:	1a00017d 	bne	3480bf58 <run_list_real+0x794>
		if (rmode == RES_ELIF && !if_code) break;
3480b960:	e3550003 	cmp	r5, #3
3480b964:	13a02000 	movne	r2, #0
3480b968:	03a02001 	moveq	r2, #1
3480b96c:	e0177002 	ands	r7, r7, r2
3480b970:	e58d202c 	str	r2, [sp, #44]	; 0x2c
3480b974:	1a000180 	bne	3480bf7c <run_list_real+0x7b8>
		if (rmode == RES_FOR && pi->num_progs) {
3480b978:	e3550006 	cmp	r5, #6
3480b97c:	1a000082 	bne	3480bb8c <run_list_real+0x3c8>
3480b980:	e5943000 	ldr	r3, [r4]
3480b984:	e3530000 	cmp	r3, #0
3480b988:	0a00008d 	beq	3480bbc4 <run_list_real+0x400>
			if (!list) {
3480b98c:	e3560000 	cmp	r6, #0
3480b990:	1a00005f 	bne	3480bb14 <run_list_real+0x350>
				/* if no variable values after "in" we skip "for" */
				if (!pi->next->progs->argv) continue;
3480b994:	e5943008 	ldr	r3, [r4, #8]
3480b998:	e5933004 	ldr	r3, [r3, #4]
3480b99c:	e5933000 	ldr	r3, [r3]
3480b9a0:	e3530000 	cmp	r3, #0
3480b9a4:	0a00016a 	beq	3480bf54 <run_list_real+0x790>
				/* create list of variable values */
				list = make_list_in(pi->next->progs->argv,
					pi->progs->argv[0]);
3480b9a8:	e5942004 	ldr	r2, [r4, #4]
		if (rmode == RES_FOR && pi->num_progs) {
			if (!list) {
				/* if no variable values after "in" we skip "for" */
				if (!pi->next->progs->argv) continue;
				/* create list of variable values */
				list = make_list_in(pi->next->progs->argv,
3480b9ac:	e5922000 	ldr	r2, [r2]
3480b9b0:	e5922000 	ldr	r2, [r2]
}

static char **make_list_in(char **inp, char *name)
{
	int len, i;
	int name_len = strlen(name);
3480b9b4:	e58d3008 	str	r3, [sp, #8]
3480b9b8:	e1a00002 	mov	r0, r2
		if (rmode == RES_FOR && pi->num_progs) {
			if (!list) {
				/* if no variable values after "in" we skip "for" */
				if (!pi->next->progs->argv) continue;
				/* create list of variable values */
				list = make_list_in(pi->next->progs->argv,
3480b9bc:	e58d2010 	str	r2, [sp, #16]
}

static char **make_list_in(char **inp, char *name)
{
	int len, i;
	int name_len = strlen(name);
3480b9c0:	eb00346e 	bl	34818b80 <strlen>
3480b9c4:	e58d001c 	str	r0, [sp, #28]
	int n = 0;
	char **list;
	char *p1, *p2, *p3;

	/* create list of variable values */
	list = xmalloc(sizeof(*list));
3480b9c8:	e3a00004 	mov	r0, #4
3480b9cc:	ebfffbbd 	bl	3480a8c8 <xmalloc>
3480b9d0:	e59d3008 	ldr	r3, [sp, #8]
3480b9d4:	e58d9024 	str	r9, [sp, #36]	; 0x24
3480b9d8:	e58d300c 	str	r3, [sp, #12]
				p2 = p1 + len;
			}
			/* we use n + 2 in realloc for list,because we add
			 * new element and then we will add NULL element */
			list = xrealloc(list, sizeof(*list) * (n + 2));
			list[n] = xmalloc(2 + name_len + len);
3480b9dc:	e59d301c 	ldr	r3, [sp, #28]
	int n = 0;
	char **list;
	char *p1, *p2, *p3;

	/* create list of variable values */
	list = xmalloc(sizeof(*list));
3480b9e0:	e1a06000 	mov	r6, r0
				p2 = p1 + len;
			}
			/* we use n + 2 in realloc for list,because we add
			 * new element and then we will add NULL element */
			list = xrealloc(list, sizeof(*list) * (n + 2));
			list[n] = xmalloc(2 + name_len + len);
3480b9e4:	e2833002 	add	r3, r3, #2
3480b9e8:	e58d3020 	str	r3, [sp, #32]
3480b9ec:	e58da030 	str	sl, [sp, #48]	; 0x30
3480b9f0:	e58d5034 	str	r5, [sp, #52]	; 0x34
3480b9f4:	e1a09004 	mov	r9, r4
3480b9f8:	ea000034 	b	3480bad0 <run_list_real+0x30c>
}
#endif

static char *insert_var_value(char *inp)
{
	return insert_var_value_sub(inp, 0);
3480b9fc:	e3a01000 	mov	r1, #0
3480ba00:	ebfffd46 	bl	3480af20 <insert_var_value_sub>
3480ba04:	e1a0b000 	mov	fp, r0
3480ba08:	e1a0a000 	mov	sl, r0
3480ba0c:	ea000026 	b	3480baac <run_list_real+0x2e8>
	list = xmalloc(sizeof(*list));
	for (i = 0; inp[i]; i++) {
		p3 = insert_var_value(inp[i]);
		p1 = p3;
		while (*p1) {
			if ((*p1 == ' ')) {
3480ba10:	e3530020 	cmp	r3, #32
				p1++;
3480ba14:	028bb001 	addeq	fp, fp, #1
	list = xmalloc(sizeof(*list));
	for (i = 0; inp[i]; i++) {
		p3 = insert_var_value(inp[i]);
		p1 = p3;
		while (*p1) {
			if ((*p1 == ' ')) {
3480ba18:	0a000023 	beq	3480baac <run_list_real+0x2e8>
				p1++;
				continue;
			}
			if ((p2 = strchr(p1, ' '))) {
3480ba1c:	e1a0000b 	mov	r0, fp
3480ba20:	e3a01020 	mov	r1, #32
3480ba24:	eb00343f 	bl	34818b28 <strchr>
3480ba28:	e2505000 	subs	r5, r0, #0
				len = p2 - p1;
3480ba2c:	106b4005 	rsbne	r4, fp, r5
		while (*p1) {
			if ((*p1 == ' ')) {
				p1++;
				continue;
			}
			if ((p2 = strchr(p1, ' '))) {
3480ba30:	1a000003 	bne	3480ba44 <run_list_real+0x280>
				len = p2 - p1;
			} else {
				len = strlen(p1);
3480ba34:	e1a0000b 	mov	r0, fp
3480ba38:	eb003450 	bl	34818b80 <strlen>
3480ba3c:	e1a04000 	mov	r4, r0
				p2 = p1 + len;
3480ba40:	e08b5000 	add	r5, fp, r0
			}
			/* we use n + 2 in realloc for list,because we add
			 * new element and then we will add NULL element */
			list = xrealloc(list, sizeof(*list) * (n + 2));
3480ba44:	e2871002 	add	r1, r7, #2
3480ba48:	e1a00006 	mov	r0, r6
3480ba4c:	e1a01101 	lsl	r1, r1, #2
3480ba50:	ebfffc45 	bl	3480ab6c <xrealloc>
			list[n] = xmalloc(2 + name_len + len);
3480ba54:	e59d1020 	ldr	r1, [sp, #32]
				len = strlen(p1);
				p2 = p1 + len;
			}
			/* we use n + 2 in realloc for list,because we add
			 * new element and then we will add NULL element */
			list = xrealloc(list, sizeof(*list) * (n + 2));
3480ba58:	e1a06000 	mov	r6, r0
			list[n] = xmalloc(2 + name_len + len);
3480ba5c:	e0810004 	add	r0, r1, r4
3480ba60:	ebfffb98 	bl	3480a8c8 <xmalloc>
			strcpy(list[n], name);
3480ba64:	e59d1010 	ldr	r1, [sp, #16]
				p2 = p1 + len;
			}
			/* we use n + 2 in realloc for list,because we add
			 * new element and then we will add NULL element */
			list = xrealloc(list, sizeof(*list) * (n + 2));
			list[n] = xmalloc(2 + name_len + len);
3480ba68:	e7860107 	str	r0, [r6, r7, lsl #2]
			strcpy(list[n], name);
3480ba6c:	eb0033de 	bl	348189ec <strcpy>
			strcat(list[n], "=");
3480ba70:	e7960107 	ldr	r0, [r6, r7, lsl #2]
3480ba74:	e59f1518 	ldr	r1, [pc, #1304]	; 3480bf94 <run_list_real+0x7d0>
3480ba78:	eb0033ec 	bl	34818a30 <strcat>
			strncat(list[n], p1, len);
3480ba7c:	e1a02004 	mov	r2, r4
3480ba80:	e7960107 	ldr	r0, [r6, r7, lsl #2]
3480ba84:	e1a0100b 	mov	r1, fp
3480ba88:	eb0033f4 	bl	34818a60 <strncat>
			list[n++][name_len + len + 1] = '\0';
3480ba8c:	e7963107 	ldr	r3, [r6, r7, lsl #2]
3480ba90:	e59d201c 	ldr	r2, [sp, #28]
3480ba94:	e2877001 	add	r7, r7, #1
3480ba98:	e0833002 	add	r3, r3, r2
3480ba9c:	e0834004 	add	r4, r3, r4
3480baa0:	e3a03000 	mov	r3, #0
3480baa4:	e5c43001 	strb	r3, [r4, #1]
			p1 = p2;
3480baa8:	e1a0b005 	mov	fp, r5
	/* create list of variable values */
	list = xmalloc(sizeof(*list));
	for (i = 0; inp[i]; i++) {
		p3 = insert_var_value(inp[i]);
		p1 = p3;
		while (*p1) {
3480baac:	e5db3000 	ldrb	r3, [fp]
3480bab0:	e3530000 	cmp	r3, #0
3480bab4:	1affffd5 	bne	3480ba10 <run_list_real+0x24c>
			strcat(list[n], "=");
			strncat(list[n], p1, len);
			list[n++][name_len + len + 1] = '\0';
			p1 = p2;
		}
		if (p3 != inp[i]) free(p3);
3480bab8:	e59d000c 	ldr	r0, [sp, #12]
3480babc:	e5103004 	ldr	r3, [r0, #-4]
3480bac0:	e15a0003 	cmp	sl, r3
3480bac4:	0a000001 	beq	3480bad0 <run_list_real+0x30c>
3480bac8:	e1a0000a 	mov	r0, sl
3480bacc:	ebfff65c 	bl	34809444 <free>
	char **list;
	char *p1, *p2, *p3;

	/* create list of variable values */
	list = xmalloc(sizeof(*list));
	for (i = 0; inp[i]; i++) {
3480bad0:	e59d100c 	ldr	r1, [sp, #12]
3480bad4:	e4910004 	ldr	r0, [r1], #4
3480bad8:	e3500000 	cmp	r0, #0
3480badc:	e58d100c 	str	r1, [sp, #12]
3480bae0:	1affffc5 	bne	3480b9fc <run_list_real+0x238>
3480bae4:	e1a04009 	mov	r4, r9
				if (!pi->next->progs->argv) continue;
				/* create list of variable values */
				list = make_list_in(pi->next->progs->argv,
					pi->progs->argv[0]);
				save_list = list;
				save_name = pi->progs->argv[0];
3480bae8:	e5943004 	ldr	r3, [r4, #4]
3480baec:	e59da030 	ldr	sl, [sp, #48]	; 0x30
3480baf0:	e5933000 	ldr	r3, [r3]
3480baf4:	e59d5034 	ldr	r5, [sp, #52]	; 0x34
3480baf8:	e59d9024 	ldr	r9, [sp, #36]	; 0x24
			list[n++][name_len + len + 1] = '\0';
			p1 = p2;
		}
		if (p3 != inp[i]) free(p3);
	}
	list[n] = NULL;
3480bafc:	e7860107 	str	r0, [r6, r7, lsl #2]
				if (!pi->next->progs->argv) continue;
				/* create list of variable values */
				list = make_list_in(pi->next->progs->argv,
					pi->progs->argv[0]);
				save_list = list;
				save_name = pi->progs->argv[0];
3480bb00:	e5932000 	ldr	r2, [r3]
				pi->progs->argv[0] = NULL;
				flag_rep = 1;
3480bb04:	e3a0b001 	mov	fp, #1
				if (!pi->next->progs->argv) continue;
				/* create list of variable values */
				list = make_list_in(pi->next->progs->argv,
					pi->progs->argv[0]);
				save_list = list;
				save_name = pi->progs->argv[0];
3480bb08:	e58d201c 	str	r2, [sp, #28]
				pi->progs->argv[0] = NULL;
3480bb0c:	e5830000 	str	r0, [r3]
				/* if no variable values after "in" we skip "for" */
				if (!pi->next->progs->argv) continue;
				/* create list of variable values */
				list = make_list_in(pi->next->progs->argv,
					pi->progs->argv[0]);
				save_list = list;
3480bb10:	e58d6020 	str	r6, [sp, #32]
				save_name = pi->progs->argv[0];
				pi->progs->argv[0] = NULL;
				flag_rep = 1;
			}
			if (!(*list)) {
3480bb14:	e5962000 	ldr	r2, [r6]
3480bb18:	e5943004 	ldr	r3, [r4, #4]
3480bb1c:	e3520000 	cmp	r2, #0
3480bb20:	1a00000f 	bne	3480bb64 <run_list_real+0x3a0>
				free(pi->progs->argv[0]);
3480bb24:	e5933000 	ldr	r3, [r3]
		debug_printf("rmode=%d  if_code=%d  next_if_code=%d skip_more=%d\n", rmode, if_code, next_if_code, skip_more_in_this_rmode);
		if (rmode == skip_more_in_this_rmode && flag_skip) {
			if (pi->followup == PIPE_SEQ) flag_skip=0;
			continue;
		}
		flag_skip = 1;
3480bb28:	e3a07001 	mov	r7, #1
				save_name = pi->progs->argv[0];
				pi->progs->argv[0] = NULL;
				flag_rep = 1;
			}
			if (!(*list)) {
				free(pi->progs->argv[0]);
3480bb2c:	e5930000 	ldr	r0, [r3]
3480bb30:	e58d2008 	str	r2, [sp, #8]
3480bb34:	ebfff642 	bl	34809444 <free>
				free(save_list);
3480bb38:	e59d0020 	ldr	r0, [sp, #32]
3480bb3c:	ebfff640 	bl	34809444 <free>
				list = NULL;
				flag_rep = 0;
				pi->progs->argv[0] = save_name;
3480bb40:	e5943004 	ldr	r3, [r4, #4]
			}
			if (!(*list)) {
				free(pi->progs->argv[0]);
				free(save_list);
				list = NULL;
				flag_rep = 0;
3480bb44:	e59d2008 	ldr	r2, [sp, #8]
				pi->progs->argv[0] = save_name;
3480bb48:	e5933000 	ldr	r3, [r3]
3480bb4c:	e59d001c 	ldr	r0, [sp, #28]
			}
			if (!(*list)) {
				free(pi->progs->argv[0]);
				free(save_list);
				list = NULL;
				flag_rep = 0;
3480bb50:	e1a0b002 	mov	fp, r2
				pi->progs->argv[0] = save_name;
3480bb54:	e5830000 	str	r0, [r3]
				flag_rep = 1;
			}
			if (!(*list)) {
				free(pi->progs->argv[0]);
				free(save_list);
				list = NULL;
3480bb58:	e1a06002 	mov	r6, r2
		if (rmode == skip_more_in_this_rmode && flag_skip) {
			if (pi->followup == PIPE_SEQ) flag_skip=0;
			continue;
		}
		flag_skip = 1;
		skip_more_in_this_rmode = RES_XXXX;
3480bb5c:	e3a0300b 	mov	r3, #11
				pi->progs->argv[0] = save_name;
#ifndef __U_BOOT__
				pi->progs->glob_result.gl_pathv[0] =
					pi->progs->argv[0];
#endif
				continue;
3480bb60:	ea0000fd 	b	3480bf5c <run_list_real+0x798>
			} else {
				/* insert new value from list for variable */
				if (pi->progs->argv[0])
3480bb64:	e5933000 	ldr	r3, [r3]
3480bb68:	e5930000 	ldr	r0, [r3]
3480bb6c:	e3500000 	cmp	r0, #0
3480bb70:	0a000000 	beq	3480bb78 <run_list_real+0x3b4>
					free(pi->progs->argv[0]);
3480bb74:	ebfff632 	bl	34809444 <free>
				pi->progs->argv[0] = *list++;
3480bb78:	e5943004 	ldr	r3, [r4, #4]
3480bb7c:	e4962004 	ldr	r2, [r6], #4
3480bb80:	e5933000 	ldr	r3, [r3]
3480bb84:	e5832000 	str	r2, [r3]
3480bb88:	ea00000d 	b	3480bbc4 <run_list_real+0x400>
				pi->progs->glob_result.gl_pathv[0] =
					pi->progs->argv[0];
#endif
			}
		}
		if (rmode == RES_IN) continue;
3480bb8c:	e355000c 	cmp	r5, #12
3480bb90:	0a0000ef 	beq	3480bf54 <run_list_real+0x790>
		if (rmode == RES_DO) {
3480bb94:	e3550009 	cmp	r5, #9
3480bb98:	1a000002 	bne	3480bba8 <run_list_real+0x3e4>
			if (!flag_rep) continue;
3480bb9c:	e35b0000 	cmp	fp, #0
3480bba0:	0a0000eb 	beq	3480bf54 <run_list_real+0x790>
3480bba4:	ea000006 	b	3480bbc4 <run_list_real+0x400>
		}
		if ((rmode == RES_DONE)) {
3480bba8:	e355000a 	cmp	r5, #10
3480bbac:	1a000004 	bne	3480bbc4 <run_list_real+0x400>
			if (flag_rep) {
				flag_restore = 1;
3480bbb0:	e59d1014 	ldr	r1, [sp, #20]
3480bbb4:	e35b0000 	cmp	fp, #0
3480bbb8:	13a01001 	movne	r1, #1
3480bbbc:	e58d1014 	str	r1, [sp, #20]
3480bbc0:	03a09000 	moveq	r9, #0
			} else {
				rpipe = NULL;
			}
		}
		if (pi->num_progs == 0) continue;
3480bbc4:	e5943000 	ldr	r3, [r4]
3480bbc8:	e3530000 	cmp	r3, #0
3480bbcc:	0a0000e0 	beq	3480bf54 <run_list_real+0x790>
	(void) &nextout;
	(void) &child;
# endif
#else
	int nextin;
	int flag = do_repeat ? CMD_FLAG_REPEAT : 0;
3480bbd0:	e59f23b8 	ldr	r2, [pc, #952]	; 3480bf90 <run_list_real+0x7cc>

	/* Check if this is a simple builtin (not part of a pipe).
	 * Builtins within pipes have to fork anyway, and are handled in
	 * pseudo_exec.  "echo foo | read bar" doesn't work on bash, either.
	 */
	if (pi->num_progs == 1) child = & (pi->progs[0]);
3480bbd4:	e3530001 	cmp	r3, #1
	(void) &nextout;
	(void) &child;
# endif
#else
	int nextin;
	int flag = do_repeat ? CMD_FLAG_REPEAT : 0;
3480bbd8:	e5922008 	ldr	r2, [r2, #8]
3480bbdc:	e58d2010 	str	r2, [sp, #16]

	/* Check if this is a simple builtin (not part of a pipe).
	 * Builtins within pipes have to fork anyway, and are handled in
	 * pseudo_exec.  "echo foo | read bar" doesn't work on bash, either.
	 */
	if (pi->num_progs == 1) child = & (pi->progs[0]);
3480bbe0:	1a0000e8 	bne	3480bf88 <run_list_real+0x7c4>
3480bbe4:	e5947004 	ldr	r7, [r4, #4]
		/* XXX could we merge code with following builtin case,
		 * by creating a pseudo builtin that calls run_list_real? */
		rcode = run_list_real(child->group);
		restore_redirects(squirrel);
#else
		if (pi->num_progs == 1 && child->group) {
3480bbe8:	e5970008 	ldr	r0, [r7, #8]
3480bbec:	e3500000 	cmp	r0, #0
3480bbf0:	0a000001 	beq	3480bbfc <run_list_real+0x438>
		int rcode;
		debug_printf("non-subshell grouping\n");
		rcode = run_list_real(child->group);
3480bbf4:	ebfffef2 	bl	3480b7c4 <run_list_real>
3480bbf8:	ea0000b3 	b	3480becc <run_list_real+0x708>
#endif
		return rcode;
	} else if (pi->num_progs == 1 && pi->progs[0].argv != NULL) {
3480bbfc:	e5972000 	ldr	r2, [r7]
3480bc00:	e3520000 	cmp	r2, #0
3480bc04:	0a0000df 	beq	3480bf88 <run_list_real+0x7c4>
3480bc08:	e1a01007 	mov	r1, r7
3480bc0c:	e1a0c004 	mov	ip, r4
3480bc10:	e1a0a000 	mov	sl, r0
3480bc14:	e1a07005 	mov	r7, r5
3480bc18:	e1a04002 	mov	r4, r2
3480bc1c:	ea000000 	b	3480bc24 <run_list_real+0x460>
		for (i=0; is_assignment(child->argv[i]); i++) { /* nothing */ }
3480bc20:	e28aa001 	add	sl, sl, #1
3480bc24:	e4945004 	ldr	r5, [r4], #4
3480bc28:	e58d1008 	str	r1, [sp, #8]
3480bc2c:	e1a00005 	mov	r0, r5
3480bc30:	e58dc004 	str	ip, [sp, #4]
3480bc34:	ebfffacf 	bl	3480a778 <is_assignment>
3480bc38:	e3500000 	cmp	r0, #0
3480bc3c:	e59d1008 	ldr	r1, [sp, #8]
3480bc40:	e59dc004 	ldr	ip, [sp, #4]
3480bc44:	1afffff5 	bne	3480bc20 <run_list_real+0x45c>
		if (i!=0 && child->argv[i]==NULL) {
3480bc48:	e35a0000 	cmp	sl, #0
3480bc4c:	e1a03005 	mov	r3, r5
3480bc50:	e1a0400c 	mov	r4, ip
3480bc54:	e1a05007 	mov	r5, r7
3480bc58:	e1a07001 	mov	r7, r1
3480bc5c:	0a000035 	beq	3480bd38 <run_list_real+0x574>
3480bc60:	e3530000 	cmp	r3, #0
3480bc64:	01a0a003 	moveq	sl, r3
3480bc68:	1a000031 	bne	3480bd34 <run_list_real+0x570>
3480bc6c:	ea000018 	b	3480bcd4 <run_list_real+0x510>
				 * not exported, we need only set this as a local variable.
				 * This junk is all to decide whether or not to export this
				 * variable. */
				int export_me=0;
				char *name, *value;
				name = xstrdup(child->argv[i]);
3480bc70:	eb0033f7 	bl	34818c54 <strdup>
				debug_printf("Local environment set: %s\n", name);
				value = strchr(name, '=');
3480bc74:	e3a0103d 	mov	r1, #61	; 0x3d
3480bc78:	e58d0008 	str	r0, [sp, #8]
3480bc7c:	eb0033a9 	bl	34818b28 <strchr>
				if (value)
3480bc80:	e59d3008 	ldr	r3, [sp, #8]
3480bc84:	e3500000 	cmp	r0, #0
					*value=0;
3480bc88:	13a01000 	movne	r1, #0
3480bc8c:	15c01000 	strbne	r1, [r0]
#ifndef __U_BOOT__
				if ( get_local_var(name)) {
					export_me=1;
				}
#endif
				free(name);
3480bc90:	e1a00003 	mov	r0, r3
3480bc94:	ebfff5ea 	bl	34809444 <free>
				p = insert_var_value(child->argv[i]);
3480bc98:	e5973000 	ldr	r3, [r7]
}
#endif

static char *insert_var_value(char *inp)
{
	return insert_var_value_sub(inp, 0);
3480bc9c:	e3a01000 	mov	r1, #0
3480bca0:	e793000a 	ldr	r0, [r3, sl]
3480bca4:	ebfffc9d 	bl	3480af20 <insert_var_value_sub>
					export_me=1;
				}
#endif
				free(name);
				p = insert_var_value(child->argv[i]);
				set_local_var(p, export_me);
3480bca8:	e3a01000 	mov	r1, #0
3480bcac:	e58d0008 	str	r0, [sp, #8]
3480bcb0:	ebfffc2c 	bl	3480ad68 <set_local_var>
				if (p != child->argv[i]) free(p);
3480bcb4:	e5972000 	ldr	r2, [r7]
3480bcb8:	e59d3008 	ldr	r3, [sp, #8]
3480bcbc:	e792200a 	ldr	r2, [r2, sl]
3480bcc0:	e1530002 	cmp	r3, r2
3480bcc4:	0a000001 	beq	3480bcd0 <run_list_real+0x50c>
3480bcc8:	e1a00003 	mov	r0, r3
3480bccc:	ebfff5dc 	bl	34809444 <free>
3480bcd0:	e28aa004 	add	sl, sl, #4
		return rcode;
	} else if (pi->num_progs == 1 && pi->progs[0].argv != NULL) {
		for (i=0; is_assignment(child->argv[i]); i++) { /* nothing */ }
		if (i!=0 && child->argv[i]==NULL) {
			/* assignments, but no command: set the local environment */
			for (i=0; child->argv[i]!=NULL; i++) {
3480bcd4:	e5973000 	ldr	r3, [r7]
3480bcd8:	e793000a 	ldr	r0, [r3, sl]
3480bcdc:	e3500000 	cmp	r0, #0
3480bce0:	1affffe2 	bne	3480bc70 <run_list_real+0x4ac>
				free(name);
				p = insert_var_value(child->argv[i]);
				set_local_var(p, export_me);
				if (p != child->argv[i]) free(p);
			}
			return EXIT_SUCCESS;   /* don't worry about errors in set_local_var() yet */
3480bce4:	e1a0a000 	mov	sl, r0
3480bce8:	ea000080 	b	3480bef0 <run_list_real+0x72c>
}
#endif

static char *insert_var_value(char *inp)
{
	return insert_var_value_sub(inp, 0);
3480bcec:	e1a00003 	mov	r0, r3
3480bcf0:	e3a01000 	mov	r1, #0
3480bcf4:	ebfffc89 	bl	3480af20 <insert_var_value_sub>
		for (i = 0; is_assignment(child->argv[i]); i++) {
			p = insert_var_value(child->argv[i]);
#ifndef __U_BOOT__
			putenv(strdup(p));
#else
			set_local_var(p, 0);
3480bcf8:	e3a01000 	mov	r1, #0
3480bcfc:	e58d0008 	str	r0, [sp, #8]
3480bd00:	ebfffc18 	bl	3480ad68 <set_local_var>
#endif
			if (p != child->argv[i]) {
3480bd04:	e5972000 	ldr	r2, [r7]
3480bd08:	e59d3008 	ldr	r3, [sp, #8]
3480bd0c:	e792200a 	ldr	r2, [r2, sl]
3480bd10:	e1530002 	cmp	r3, r2
3480bd14:	0a000004 	beq	3480bd2c <run_list_real+0x568>
				child->sp--;
3480bd18:	e597200c 	ldr	r2, [r7, #12]
				free(p);
3480bd1c:	e1a00003 	mov	r0, r3
			putenv(strdup(p));
#else
			set_local_var(p, 0);
#endif
			if (p != child->argv[i]) {
				child->sp--;
3480bd20:	e2422001 	sub	r2, r2, #1
3480bd24:	e587200c 	str	r2, [r7, #12]
				free(p);
3480bd28:	ebfff5c5 	bl	34809444 <free>
3480bd2c:	e28aa004 	add	sl, sl, #4
3480bd30:	ea000000 	b	3480bd38 <run_list_real+0x574>
		rcode = run_list_real(child->group);
#endif
		return rcode;
	} else if (pi->num_progs == 1 && pi->progs[0].argv != NULL) {
		for (i=0; is_assignment(child->argv[i]); i++) { /* nothing */ }
		if (i!=0 && child->argv[i]==NULL) {
3480bd34:	e1a0a000 	mov	sl, r0
				set_local_var(p, export_me);
				if (p != child->argv[i]) free(p);
			}
			return EXIT_SUCCESS;   /* don't worry about errors in set_local_var() yet */
		}
		for (i = 0; is_assignment(child->argv[i]); i++) {
3480bd38:	e5973000 	ldr	r3, [r7]
3480bd3c:	e083200a 	add	r2, r3, sl
3480bd40:	e793300a 	ldr	r3, [r3, sl]
3480bd44:	e58d200c 	str	r2, [sp, #12]
3480bd48:	e1a00003 	mov	r0, r3
3480bd4c:	e58d3008 	str	r3, [sp, #8]
3480bd50:	ebfffa88 	bl	3480a778 <is_assignment>
3480bd54:	e2502000 	subs	r2, r0, #0
3480bd58:	e59d3008 	ldr	r3, [sp, #8]
3480bd5c:	1affffe2 	bne	3480bcec <run_list_real+0x528>
			if (p != child->argv[i]) {
				child->sp--;
				free(p);
			}
		}
		if (child->sp) {
3480bd60:	e597100c 	ldr	r1, [r7, #12]
3480bd64:	e3510000 	cmp	r1, #0
3480bd68:	0a000046 	beq	3480be88 <run_list_real+0x6c4>
	int n;
	int len = 2;
	char *noeval_str;
	int noeval = 0;

	noeval_str = get_local_var("HUSH_NO_EVAL");
3480bd6c:	e59f0224 	ldr	r0, [pc, #548]	; 3480bf98 <run_list_real+0x7d4>
3480bd70:	e58d2008 	str	r2, [sp, #8]
3480bd74:	ebfffbd7 	bl	3480acd8 <get_local_var>
	if (noeval_str != NULL && *noeval_str != '0' && *noeval_str != '\0')
3480bd78:	e3500000 	cmp	r0, #0
3480bd7c:	e59d2008 	ldr	r2, [sp, #8]
	char *p;
	char *str = NULL;
	int n;
	int len = 2;
	char *noeval_str;
	int noeval = 0;
3480bd80:	058d0010 	streq	r0, [sp, #16]

	noeval_str = get_local_var("HUSH_NO_EVAL");
	if (noeval_str != NULL && *noeval_str != '0' && *noeval_str != '\0')
3480bd84:	0a000006 	beq	3480bda4 <run_list_real+0x5e0>
3480bd88:	e5d03000 	ldrb	r3, [r0]
3480bd8c:	e3530030 	cmp	r3, #48	; 0x30
	char *p;
	char *str = NULL;
	int n;
	int len = 2;
	char *noeval_str;
	int noeval = 0;
3480bd90:	058d2010 	streq	r2, [sp, #16]

	noeval_str = get_local_var("HUSH_NO_EVAL");
	if (noeval_str != NULL && *noeval_str != '0' && *noeval_str != '\0')
3480bd94:	0a000002 	beq	3480bda4 <run_list_real+0x5e0>
	char *p;
	char *str = NULL;
	int n;
	int len = 2;
	char *noeval_str;
	int noeval = 0;
3480bd98:	e2533000 	subs	r3, r3, #0
3480bd9c:	13a03001 	movne	r3, #1
3480bda0:	e58d3010 	str	r3, [sp, #16]
static char * make_string(char ** inp)
{
	char *p;
	char *str = NULL;
	int n;
	int len = 2;
3480bda4:	e3a03002 	mov	r3, #2
	int noeval = 0;

	noeval_str = get_local_var("HUSH_NO_EVAL");
	if (noeval_str != NULL && *noeval_str != '0' && *noeval_str != '\0')
		noeval = 1;
	for (n = 0; inp[n]; n++) {
3480bda8:	e3a0a000 	mov	sl, #0
static char * make_string(char ** inp)
{
	char *p;
	char *str = NULL;
	int n;
	int len = 2;
3480bdac:	e58d3024 	str	r3, [sp, #36]	; 0x24

/* Make new string for parser */
static char * make_string(char ** inp)
{
	char *p;
	char *str = NULL;
3480bdb0:	e1a0700a 	mov	r7, sl
3480bdb4:	e58d6030 	str	r6, [sp, #48]	; 0x30
3480bdb8:	ea00001c 	b	3480be30 <run_list_real+0x66c>

	noeval_str = get_local_var("HUSH_NO_EVAL");
	if (noeval_str != NULL && *noeval_str != '0' && *noeval_str != '\0')
		noeval = 1;
	for (n = 0; inp[n]; n++) {
		p = insert_var_value_sub(inp[n], noeval);
3480bdbc:	e1a00003 	mov	r0, r3
3480bdc0:	e59d1010 	ldr	r1, [sp, #16]
3480bdc4:	ebfffc55 	bl	3480af20 <insert_var_value_sub>
3480bdc8:	e1a06000 	mov	r6, r0
		str = xrealloc(str, (len + strlen(p)));
3480bdcc:	eb00336b 	bl	34818b80 <strlen>
3480bdd0:	e59d2024 	ldr	r2, [sp, #36]	; 0x24
3480bdd4:	e0801002 	add	r1, r0, r2
3480bdd8:	e1a00007 	mov	r0, r7
3480bddc:	ebfffb62 	bl	3480ab6c <xrealloc>
		if (n) {
3480bde0:	e35a0000 	cmp	sl, #0
	noeval_str = get_local_var("HUSH_NO_EVAL");
	if (noeval_str != NULL && *noeval_str != '0' && *noeval_str != '\0')
		noeval = 1;
	for (n = 0; inp[n]; n++) {
		p = insert_var_value_sub(inp[n], noeval);
		str = xrealloc(str, (len + strlen(p)));
3480bde4:	e1a07000 	mov	r7, r0
		if (n) {
			strcat(str, " ");
		} else {
			*str = '\0';
3480bde8:	05c0a000 	strbeq	sl, [r0]
	if (noeval_str != NULL && *noeval_str != '0' && *noeval_str != '\0')
		noeval = 1;
	for (n = 0; inp[n]; n++) {
		p = insert_var_value_sub(inp[n], noeval);
		str = xrealloc(str, (len + strlen(p)));
		if (n) {
3480bdec:	0a000001 	beq	3480bdf8 <run_list_real+0x634>
			strcat(str, " ");
3480bdf0:	e59f11a4 	ldr	r1, [pc, #420]	; 3480bf9c <run_list_real+0x7d8>
3480bdf4:	eb00330d 	bl	34818a30 <strcat>
		} else {
			*str = '\0';
		}
		strcat(str, p);
3480bdf8:	e1a01006 	mov	r1, r6
3480bdfc:	e1a00007 	mov	r0, r7
3480be00:	eb00330a 	bl	34818a30 <strcat>
		len = strlen(str) + 3;
3480be04:	e1a00007 	mov	r0, r7
3480be08:	eb00335c 	bl	34818b80 <strlen>
3480be0c:	e2800003 	add	r0, r0, #3
3480be10:	e58d0024 	str	r0, [sp, #36]	; 0x24
		if (p != inp[n]) free(p);
3480be14:	e59d000c 	ldr	r0, [sp, #12]
3480be18:	e5103004 	ldr	r3, [r0, #-4]
3480be1c:	e1560003 	cmp	r6, r3
3480be20:	0a000001 	beq	3480be2c <run_list_real+0x668>
3480be24:	e1a00006 	mov	r0, r6
3480be28:	ebfff585 	bl	34809444 <free>
	int noeval = 0;

	noeval_str = get_local_var("HUSH_NO_EVAL");
	if (noeval_str != NULL && *noeval_str != '0' && *noeval_str != '\0')
		noeval = 1;
	for (n = 0; inp[n]; n++) {
3480be2c:	e28aa001 	add	sl, sl, #1
3480be30:	e59d100c 	ldr	r1, [sp, #12]
3480be34:	e4913004 	ldr	r3, [r1], #4
3480be38:	e3530000 	cmp	r3, #0
3480be3c:	e58d100c 	str	r1, [sp, #12]
3480be40:	1affffdd 	bne	3480bdbc <run_list_real+0x5f8>
		}
		strcat(str, p);
		len = strlen(str) + 3;
		if (p != inp[n]) free(p);
	}
	len = strlen(str);
3480be44:	e1a00007 	mov	r0, r7
3480be48:	e58d3008 	str	r3, [sp, #8]
3480be4c:	e59d6030 	ldr	r6, [sp, #48]	; 0x30
3480be50:	eb00334a 	bl	34818b80 <strlen>
	*(str + len) = '\n';
3480be54:	e1a02007 	mov	r2, r7
3480be58:	e3a0100a 	mov	r1, #10
3480be5c:	e7e21000 	strb	r1, [r2, r0]!
	*(str + len + 1) = '\0';
3480be60:	e59d3008 	ldr	r3, [sp, #8]
		}
		if (child->sp) {
			char * str = NULL;

			str = make_string((child->argv + i));
			parse_string_outer(str, FLAG_EXIT_FROM_LOOP | FLAG_REPARSING);
3480be64:	e3a01005 	mov	r1, #5
		len = strlen(str) + 3;
		if (p != inp[n]) free(p);
	}
	len = strlen(str);
	*(str + len) = '\n';
	*(str + len + 1) = '\0';
3480be68:	e5c23001 	strb	r3, [r2, #1]
		}
		if (child->sp) {
			char * str = NULL;

			str = make_string((child->argv + i));
			parse_string_outer(str, FLAG_EXIT_FROM_LOOP | FLAG_REPARSING);
3480be6c:	e1a00007 	mov	r0, r7
3480be70:	ebfffe17 	bl	3480b6d4 <parse_string_outer>
			free(str);
3480be74:	e1a00007 	mov	r0, r7
3480be78:	ebfff571 	bl	34809444 <free>
			return last_return_code;
3480be7c:	e59f210c 	ldr	r2, [pc, #268]	; 3480bf90 <run_list_real+0x7cc>
3480be80:	e592a134 	ldr	sl, [r2, #308]	; 0x134
3480be84:	ea000011 	b	3480bed0 <run_list_real+0x70c>
		}
#else
		/* check ";", because ,example , argv consist from
		 * "help;flinfo" must not execute
		 */
		if (strchr(child->argv[i], ';')) {
3480be88:	e1a00003 	mov	r0, r3
3480be8c:	e3a0103b 	mov	r1, #59	; 0x3b
3480be90:	eb003324 	bl	34818b28 <strchr>
3480be94:	e3500000 	cmp	r0, #0
3480be98:	0a000004 	beq	3480beb0 <run_list_real+0x6ec>
			printf("Unknown command '%s' - try 'help' or use "
3480be9c:	e5973000 	ldr	r3, [r7]
3480bea0:	e59f00f8 	ldr	r0, [pc, #248]	; 3480bfa0 <run_list_real+0x7dc>
3480bea4:	e793100a 	ldr	r1, [r3, sl]
3480bea8:	ebfff427 	bl	34808f4c <printf>
3480beac:	ea000035 	b	3480bf88 <run_list_real+0x7c4>
					"'run' command\n", child->argv[i]);
			return -1;
		}
		/* Process the command */
		return cmd_process(flag, child->argc, child->argv,
3480beb0:	e59d3010 	ldr	r3, [sp, #16]
3480beb4:	e5971004 	ldr	r1, [r7, #4]
3480beb8:	e2530000 	subs	r0, r3, #0
3480bebc:	13a00001 	movne	r0, #1
3480bec0:	e5972000 	ldr	r2, [r7]
3480bec4:	e59f30d8 	ldr	r3, [pc, #216]	; 3480bfa4 <run_list_real+0x7e0>
3480bec8:	ebfff355 	bl	34808c24 <cmd_process>
3480becc:	e1a0a000 	mov	sl, r0
			}
			debug_printf("checkjobs returned %d\n",rcode);
		}
		last_return_code=rcode;
#else
		if (rcode < -1) {
3480bed0:	e37a0001 	cmn	sl, #1
3480bed4:	aa000005 	bge	3480bef0 <run_list_real+0x72c>
			last_return_code = -rcode - 2;
3480bed8:	e3e03001 	mvn	r3, #1
3480bedc:	e59f20ac 	ldr	r2, [pc, #172]	; 3480bf90 <run_list_real+0x7cc>
3480bee0:	e06a3003 	rsb	r3, sl, r3
3480bee4:	e5823134 	str	r3, [r2, #308]	; 0x134
			return -2;	/* exit */
3480bee8:	e3e0a001 	mvn	sl, #1
3480beec:	ea000022 	b	3480bf7c <run_list_real+0x7b8>
		last_return_code=(rcode == 0) ? 0 : 1;
#endif
#ifndef __U_BOOT__
		pi->num_progs = save_num_progs; /* restore number of programs */
#endif
		if ( rmode == RES_IF || rmode == RES_ELIF )
3480bef0:	e59d202c 	ldr	r2, [sp, #44]	; 0x2c
#else
		if (rcode < -1) {
			last_return_code = -rcode - 2;
			return -2;	/* exit */
		}
		last_return_code=(rcode == 0) ? 0 : 1;
3480bef4:	e25a3000 	subs	r3, sl, #0
3480bef8:	13a03001 	movne	r3, #1
#endif
#ifndef __U_BOOT__
		pi->num_progs = save_num_progs; /* restore number of programs */
#endif
		if ( rmode == RES_IF || rmode == RES_ELIF )
3480befc:	e3550001 	cmp	r5, #1
3480bf00:	03822001 	orreq	r2, r2, #1
3480bf04:	e59d1028 	ldr	r1, [sp, #40]	; 0x28
3480bf08:	e3520000 	cmp	r2, #0
#else
		if (rcode < -1) {
			last_return_code = -rcode - 2;
			return -2;	/* exit */
		}
		last_return_code=(rcode == 0) ? 0 : 1;
3480bf0c:	e59f007c 	ldr	r0, [pc, #124]	; 3480bf90 <run_list_real+0x7cc>
#endif
#ifndef __U_BOOT__
		pi->num_progs = save_num_progs; /* restore number of programs */
#endif
		if ( rmode == RES_IF || rmode == RES_ELIF )
3480bf10:	11a0100a 	movne	r1, sl
			next_if_code=rcode;  /* can be overwritten a number of times */
		if (rmode == RES_WHILE)
3480bf14:	e3550007 	cmp	r5, #7
#else
		if (rcode < -1) {
			last_return_code = -rcode - 2;
			return -2;	/* exit */
		}
		last_return_code=(rcode == 0) ? 0 : 1;
3480bf18:	e5803134 	str	r3, [r0, #308]	; 0x134
#endif
#ifndef __U_BOOT__
		pi->num_progs = save_num_progs; /* restore number of programs */
#endif
		if ( rmode == RES_IF || rmode == RES_ELIF )
3480bf1c:	e58d1028 	str	r1, [sp, #40]	; 0x28
			next_if_code=rcode;  /* can be overwritten a number of times */
		if (rmode == RES_WHILE)
			flag_rep = !last_return_code;
3480bf20:	0223b001 	eoreq	fp, r3, #1
#ifndef __U_BOOT__
		pi->num_progs = save_num_progs; /* restore number of programs */
#endif
		if ( rmode == RES_IF || rmode == RES_ELIF )
			next_if_code=rcode;  /* can be overwritten a number of times */
		if (rmode == RES_WHILE)
3480bf24:	0a000001 	beq	3480bf30 <run_list_real+0x76c>
			flag_rep = !last_return_code;
		if (rmode == RES_UNTIL)
			flag_rep = last_return_code;
3480bf28:	e3550008 	cmp	r5, #8
3480bf2c:	01a0b003 	moveq	fp, r3
		if ( (rcode==EXIT_SUCCESS && pi->followup==PIPE_OR) ||
3480bf30:	e35a0000 	cmp	sl, #0
3480bf34:	e594300c 	ldr	r3, [r4, #12]
3480bf38:	1a000001 	bne	3480bf44 <run_list_real+0x780>
		if (rmode == skip_more_in_this_rmode && flag_skip) {
			if (pi->followup == PIPE_SEQ) flag_skip=0;
			continue;
		}
		flag_skip = 1;
		skip_more_in_this_rmode = RES_XXXX;
3480bf3c:	e3530003 	cmp	r3, #3
3480bf40:	ea000000 	b	3480bf48 <run_list_real+0x784>
3480bf44:	e3530002 	cmp	r3, #2
3480bf48:	01a03005 	moveq	r3, r5
3480bf4c:	13a0300b 	movne	r3, #11
3480bf50:	ea000000 	b	3480bf58 <run_list_real+0x794>
3480bf54:	e3a0300b 	mov	r3, #11
		debug_printf("rmode=%d  if_code=%d  next_if_code=%d skip_more=%d\n", rmode, if_code, next_if_code, skip_more_in_this_rmode);
		if (rmode == skip_more_in_this_rmode && flag_skip) {
			if (pi->followup == PIPE_SEQ) flag_skip=0;
			continue;
		}
		flag_skip = 1;
3480bf58:	e3a07001 	mov	r7, #1
				flag_repeat = 0;
#endif
				return 1;
		}
	}
	for (; pi; pi = (flag_restore != 0) ? rpipe : pi->next) {
3480bf5c:	e59d2014 	ldr	r2, [sp, #20]
3480bf60:	e3520000 	cmp	r2, #0
3480bf64:	05944008 	ldreq	r4, [r4, #8]
3480bf68:	11a04009 	movne	r4, r9
3480bf6c:	e3540000 	cmp	r4, #0
3480bf70:	1afffe4b 	bne	3480b8a4 <run_list_real+0xe0>
3480bf74:	ea000000 	b	3480bf7c <run_list_real+0x7b8>
			pi->r_mode == RES_FOR) {
#ifdef __U_BOOT__
				/* check Ctrl-C */
				ctrlc();
				if ((had_ctrlc())) {
					return 1;
3480bf78:	e3a0a001 	mov	sl, #1
#ifndef __U_BOOT__
		checkjobs(NULL);
#endif
	}
	return rcode;
}
3480bf7c:	e1a0000a 	mov	r0, sl
3480bf80:	e28dd038 	add	sp, sp, #56	; 0x38
3480bf84:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
		/* If there isn't another process, nextin is garbage
		   but it doesn't matter */
		nextin = pipefds[0];
	}
#endif
	return -1;
3480bf88:	e3e0a000 	mvn	sl, #0
3480bf8c:	eaffffd7 	b	3480bef0 <run_list_real+0x72c>
3480bf90:	34829528 	.word	0x34829528
3480bf94:	34823c7b 	.word	0x34823c7b
3480bf98:	34826103 	.word	0x34826103
3480bf9c:	34827f20 	.word	0x34827f20
3480bfa0:	34826110 	.word	0x34826110
3480bfa4:	3482952c 	.word	0x3482952c

3480bfa8 <parse_stream_outer>:
}

/* most recursion does not come through here, the exeception is
 * from builtin_source() */
int parse_stream_outer(struct in_str *inp, int flag)
{
3480bfa8:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
3480bfac:	e24dd038 	sub	sp, sp, #56	; 0x38

	struct p_context ctx;
	o_string temp=NULL_O_STRING;
3480bfb0:	e28d5024 	add	r5, sp, #36	; 0x24
}

/* most recursion does not come through here, the exeception is
 * from builtin_source() */
int parse_stream_outer(struct in_str *inp, int flag)
{
3480bfb4:	e58d1004 	str	r1, [sp, #4]
3480bfb8:	e1a04000 	mov	r4, r0

	struct p_context ctx;
	o_string temp=NULL_O_STRING;
3480bfbc:	e3a01000 	mov	r1, #0
3480bfc0:	e1a00005 	mov	r0, r5
3480bfc4:	e3a02014 	mov	r2, #20
3480bfc8:	eb00338c 	bl	34818e00 <memset>
	int rcode;
#ifdef __U_BOOT__
	int code = 0;
3480bfcc:	e3a07000 	mov	r7, #0
#endif
	do {
		ctx.type = flag;
		initialize_context(&ctx);
3480bfd0:	e28d6008 	add	r6, sp, #8
	int rcode;
#ifdef __U_BOOT__
	int code = 0;
#endif
	do {
		ctx.type = flag;
3480bfd4:	e59d2004 	ldr	r2, [sp, #4]
	return pi;
}

static void initialize_context(struct p_context *ctx)
{
	ctx->pipe=NULL;
3480bfd8:	e3a0a000 	mov	sl, #0
	int rcode;
#ifdef __U_BOOT__
	int code = 0;
#endif
	do {
		ctx.type = flag;
3480bfdc:	e58d2020 	str	r2, [sp, #32]
	return pi;
}

static void initialize_context(struct p_context *ctx)
{
	ctx->pipe=NULL;
3480bfe0:	e58da010 	str	sl, [sp, #16]
#ifndef __U_BOOT__
	ctx->pending_redirect=NULL;
#endif
	ctx->child=NULL;
3480bfe4:	e58da008 	str	sl, [sp, #8]
	ctx->list_head=new_pipe();
3480bfe8:	ebfffca7 	bl	3480b28c <new_pipe>
3480bfec:	e58d000c 	str	r0, [sp, #12]
	ctx->pipe=ctx->list_head;
3480bff0:	e58d0010 	str	r0, [sp, #16]
	ctx->w=RES_NONE;
	ctx->stack=NULL;
#ifdef __U_BOOT__
	ctx->old_flag=0;
#endif
	done_command(ctx);   /* creates the memory for working child */
3480bff4:	e1a00006 	mov	r0, r6
	ctx->pending_redirect=NULL;
#endif
	ctx->child=NULL;
	ctx->list_head=new_pipe();
	ctx->pipe=ctx->list_head;
	ctx->w=RES_NONE;
3480bff8:	e58da014 	str	sl, [sp, #20]
	ctx->stack=NULL;
3480bffc:	e58da01c 	str	sl, [sp, #28]
#ifdef __U_BOOT__
	ctx->old_flag=0;
3480c000:	e58da018 	str	sl, [sp, #24]
#endif
	done_command(ctx);   /* creates the memory for working child */
3480c004:	ebfffae0 	bl	3480ab8c <done_command>
	int code = 0;
#endif
	do {
		ctx.type = flag;
		initialize_context(&ctx);
		update_ifs_map();
3480c008:	ebfffd8e 	bl	3480b648 <update_ifs_map>
		if (!(flag & FLAG_PARSE_SEMICOLON) || (flag & FLAG_REPARSING)) mapset((uchar *)";$&|", 0);
3480c00c:	e59d2004 	ldr	r2, [sp, #4]
3480c010:	e2023006 	and	r3, r2, #6
3480c014:	e3530002 	cmp	r3, #2
3480c018:	0a000002 	beq	3480c028 <parse_stream_outer+0x80>
3480c01c:	e59f05e0 	ldr	r0, [pc, #1504]	; 3480c604 <parse_stream_outer+0x65c>
3480c020:	e1a0100a 	mov	r1, sl
3480c024:	ebfffd7e 	bl	3480b624 <mapset>
		inp->promptmode=1;
3480c028:	e3a03001 	mov	r3, #1
3480c02c:	e5843008 	str	r3, [r4, #8]
3480c030:	ea00010a 	b	3480c460 <parse_stream_outer+0x4b8>
	 * A single-quote triggers a bypass of the main loop until its mate is
	 * found.  When recursing, quote state is passed in via dest->quote. */

	debug_printf("parse_stream, end_trigger=%d\n",end_trigger);
	while ((ch=b_getch(input))!=EOF) {
		m = map[ch];
3480c034:	e59f25cc 	ldr	r2, [pc, #1484]	; 3480c608 <parse_stream_outer+0x660>
3480c038:	e082300a 	add	r3, r2, sl
3480c03c:	e5d3b138 	ldrb	fp, [r3, #312]	; 0x138
#ifdef __U_BOOT__
		if (input->__promptme == 0) return 1;
3480c040:	e5943004 	ldr	r3, [r4, #4]
3480c044:	e3530000 	cmp	r3, #0
3480c048:	0a00010b 	beq	3480c47c <parse_stream_outer+0x4d4>
#endif
		next = (ch == '\n') ? 0 : b_peek(input);
3480c04c:	e35a000a 	cmp	sl, #10
3480c050:	03a09000 	moveq	r9, #0
3480c054:	0a000003 	beq	3480c068 <parse_stream_outer+0xc0>
3480c058:	e5943010 	ldr	r3, [r4, #16]
3480c05c:	e1a00004 	mov	r0, r4
3480c060:	e12fff33 	blx	r3
3480c064:	e1a09000 	mov	r9, r0

		debug_printf("parse_stream: ch=%c (%d) m=%d quote=%d - %c\n",
			ch >= ' ' ? ch : '.', ch, m,
			dest->quote, ctx->stack == NULL ? '*' : '.');

		if (m==0 || ((m==1 || m==2) && dest->quote)) {
3480c068:	e35b0000 	cmp	fp, #0
3480c06c:	0a000005 	beq	3480c088 <parse_stream_outer+0xe0>
3480c070:	e24b3001 	sub	r3, fp, #1
3480c074:	e3530001 	cmp	r3, #1
3480c078:	8a000012 	bhi	3480c0c8 <parse_stream_outer+0x120>
3480c07c:	e59d3030 	ldr	r3, [sp, #48]	; 0x30
3480c080:	e3530000 	cmp	r3, #0
3480c084:	0a000002 	beq	3480c094 <parse_stream_outer+0xec>
			b_addqchr(dest, ch, dest->quote);
3480c088:	e1a00005 	mov	r0, r5
3480c08c:	e1a0100a 	mov	r1, sl
3480c090:	ea000042 	b	3480c1a0 <parse_stream_outer+0x1f8>
		} else {
			if (m==2) {  /* unquoted IFS */
3480c094:	e35b0002 	cmp	fp, #2
3480c098:	1a00000a 	bne	3480c0c8 <parse_stream_outer+0x120>
				if (done_word(dest, ctx)) {
3480c09c:	e1a00005 	mov	r0, r5
3480c0a0:	e1a01006 	mov	r1, r6
3480c0a4:	ebfffd00 	bl	3480b4ac <done_word>
3480c0a8:	e3500000 	cmp	r0, #0
3480c0ac:	1a0000f2 	bne	3480c47c <parse_stream_outer+0x4d4>
					return 1;
				}
				/* If we aren't performing a substitution, treat a newline as a
				 * command separator.  */
				if (end_trigger != '\0' && ch=='\n')
3480c0b0:	e35a000a 	cmp	sl, #10
3480c0b4:	1a0000e9 	bne	3480c460 <parse_stream_outer+0x4b8>
					done_pipe(ctx,PIPE_SEQ);
3480c0b8:	e1a00006 	mov	r0, r6
3480c0bc:	e3a01001 	mov	r1, #1
3480c0c0:	ebfffc7b 	bl	3480b2b4 <done_pipe>
3480c0c4:	ea000001 	b	3480c0d0 <parse_stream_outer+0x128>
			}
			if (ch == end_trigger && !dest->quote && ctx->w==RES_NONE) {
3480c0c8:	e35a000a 	cmp	sl, #10
3480c0cc:	1a000005 	bne	3480c0e8 <parse_stream_outer+0x140>
3480c0d0:	e59d3030 	ldr	r3, [sp, #48]	; 0x30
3480c0d4:	e3530000 	cmp	r3, #0
3480c0d8:	1a000002 	bne	3480c0e8 <parse_stream_outer+0x140>
3480c0dc:	e59d3014 	ldr	r3, [sp, #20]
3480c0e0:	e3530000 	cmp	r3, #0
3480c0e4:	0a000141 	beq	3480c5f0 <parse_stream_outer+0x648>
				done_pipe(ctx,PIPE_SEQ);
				run_list(ctx->list_head);
				initialize_context(ctx);
			}
#endif
			if (m!=2) switch (ch) {
3480c0e8:	e35b0002 	cmp	fp, #2
3480c0ec:	0a0000db 	beq	3480c460 <parse_stream_outer+0x4b8>
3480c0f0:	e35a0026 	cmp	sl, #38	; 0x26
3480c0f4:	0a0000af 	beq	3480c3b8 <parse_stream_outer+0x410>
3480c0f8:	8a00000a 	bhi	3480c128 <parse_stream_outer+0x180>
3480c0fc:	e35a0022 	cmp	sl, #34	; 0x22
3480c100:	0a00009f 	beq	3480c384 <parse_stream_outer+0x3dc>
3480c104:	8a000002 	bhi	3480c114 <parse_stream_outer+0x16c>
3480c108:	e35a0004 	cmp	sl, #4
3480c10c:	1a0000d1 	bne	3480c458 <parse_stream_outer+0x4b0>
3480c110:	ea0000bf 	b	3480c414 <parse_stream_outer+0x46c>
3480c114:	e35a0023 	cmp	sl, #35	; 0x23
3480c118:	0a00000d 	beq	3480c154 <parse_stream_outer+0x1ac>
3480c11c:	e35a0024 	cmp	sl, #36	; 0x24
3480c120:	1a0000cc 	bne	3480c458 <parse_stream_outer+0x4b0>
3480c124:	ea00002c 	b	3480c1dc <parse_stream_outer+0x234>
3480c128:	e35a003b 	cmp	sl, #59	; 0x3b
3480c12c:	0a00009b 	beq	3480c3a0 <parse_stream_outer+0x3f8>
3480c130:	8a000002 	bhi	3480c140 <parse_stream_outer+0x198>
3480c134:	e35a0027 	cmp	sl, #39	; 0x27
3480c138:	1a0000c6 	bne	3480c458 <parse_stream_outer+0x4b0>
3480c13c:	ea000080 	b	3480c344 <parse_stream_outer+0x39c>
3480c140:	e35a005c 	cmp	sl, #92	; 0x5c
3480c144:	0a000018 	beq	3480c1ac <parse_stream_outer+0x204>
3480c148:	e35a007c 	cmp	sl, #124	; 0x7c
3480c14c:	1a0000c1 	bne	3480c458 <parse_stream_outer+0x4b0>
3480c150:	ea0000a3 	b	3480c3e4 <parse_stream_outer+0x43c>
		case '#':
			if (dest->length == 0 && !dest->quote) {
3480c154:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
3480c158:	e3530000 	cmp	r3, #0
3480c15c:	1a00000d 	bne	3480c198 <parse_stream_outer+0x1f0>
3480c160:	e59d3030 	ldr	r3, [sp, #48]	; 0x30
3480c164:	e3530000 	cmp	r3, #0
3480c168:	0a000003 	beq	3480c17c <parse_stream_outer+0x1d4>
3480c16c:	ea000009 	b	3480c198 <parse_stream_outer+0x1f0>
				while(ch=b_peek(input),ch!=EOF && ch!='\n') { b_getch(input); }
3480c170:	e594300c 	ldr	r3, [r4, #12]
3480c174:	e1a00004 	mov	r0, r4
3480c178:	e12fff33 	blx	r3
3480c17c:	e5943010 	ldr	r3, [r4, #16]
3480c180:	e1a00004 	mov	r0, r4
3480c184:	e12fff33 	blx	r3
3480c188:	e350000a 	cmp	r0, #10
3480c18c:	13700001 	cmnne	r0, #1
3480c190:	1afffff6 	bne	3480c170 <parse_stream_outer+0x1c8>
3480c194:	ea0000b1 	b	3480c460 <parse_stream_outer+0x4b8>
			} else {
				b_addqchr(dest, ch, dest->quote);
3480c198:	e1a00005 	mov	r0, r5
3480c19c:	e3a01023 	mov	r1, #35	; 0x23
3480c1a0:	e59d2030 	ldr	r2, [sp, #48]	; 0x30
3480c1a4:	ebfffab8 	bl	3480ac8c <b_addqchr>
3480c1a8:	ea0000ac 	b	3480c460 <parse_stream_outer+0x4b8>
			}
			break;
		case '\\':
			if (next == EOF) {
3480c1ac:	e3790001 	cmn	r9, #1
3480c1b0:	0a0000a8 	beq	3480c458 <parse_stream_outer+0x4b0>
				syntax();
				return 1;
			}
			b_addqchr(dest, '\\', dest->quote);
3480c1b4:	e1a0100a 	mov	r1, sl
3480c1b8:	e59d2030 	ldr	r2, [sp, #48]	; 0x30
3480c1bc:	e1a00005 	mov	r0, r5
3480c1c0:	ebfffab1 	bl	3480ac8c <b_addqchr>
			b_addqchr(dest, b_getch(input), dest->quote);
3480c1c4:	e594300c 	ldr	r3, [r4, #12]
3480c1c8:	e1a00004 	mov	r0, r4
3480c1cc:	e12fff33 	blx	r3
3480c1d0:	e1a01000 	mov	r1, r0
3480c1d4:	e1a00005 	mov	r0, r5
3480c1d8:	eafffff0 	b	3480c1a0 <parse_stream_outer+0x1f8>
	int advance=0;
#endif
#ifndef __U_BOOT__
	char sep[]=" ";
#endif
	int ch = input->peek(input);  /* first character after the $ */
3480c1dc:	e5943010 	ldr	r3, [r4, #16]
3480c1e0:	e1a00004 	mov	r0, r4
3480c1e4:	e12fff33 	blx	r3
	debug_printf("handle_dollar: ch=%c\n",ch);
	if (isalpha(ch)) {
3480c1e8:	e59f241c 	ldr	r2, [pc, #1052]	; 3480c60c <parse_stream_outer+0x664>
3480c1ec:	e6ef3070 	uxtb	r3, r0
3480c1f0:	e7d23003 	ldrb	r3, [r2, r3]
	int advance=0;
#endif
#ifndef __U_BOOT__
	char sep[]=" ";
#endif
	int ch = input->peek(input);  /* first character after the $ */
3480c1f4:	e1a09000 	mov	r9, r0
	debug_printf("handle_dollar: ch=%c\n",ch);
	if (isalpha(ch)) {
3480c1f8:	e3130003 	tst	r3, #3
3480c1fc:	0a00001b 	beq	3480c270 <parse_stream_outer+0x2c8>
		b_addchr(dest, SPECIAL_VAR_SYMBOL);
3480c200:	e1a00005 	mov	r0, r5
3480c204:	e3a01003 	mov	r1, #3
3480c208:	ebfffa81 	bl	3480ac14 <b_addchr>
		ctx->child->sp++;
3480c20c:	e59d3008 	ldr	r3, [sp, #8]
3480c210:	e593200c 	ldr	r2, [r3, #12]
3480c214:	e2822001 	add	r2, r2, #1
3480c218:	e583200c 	str	r2, [r3, #12]
3480c21c:	ea000005 	b	3480c238 <parse_stream_outer+0x290>
		while(ch=b_peek(input),isalnum(ch) || ch=='_') {
			b_getch(input);
3480c220:	e594300c 	ldr	r3, [r4, #12]
3480c224:	e1a00004 	mov	r0, r4
3480c228:	e12fff33 	blx	r3
			b_addchr(dest,ch);
3480c22c:	e1a00005 	mov	r0, r5
3480c230:	e1a0100a 	mov	r1, sl
3480c234:	ebfffa76 	bl	3480ac14 <b_addchr>
	int ch = input->peek(input);  /* first character after the $ */
	debug_printf("handle_dollar: ch=%c\n",ch);
	if (isalpha(ch)) {
		b_addchr(dest, SPECIAL_VAR_SYMBOL);
		ctx->child->sp++;
		while(ch=b_peek(input),isalnum(ch) || ch=='_') {
3480c238:	e5943010 	ldr	r3, [r4, #16]
3480c23c:	e1a00004 	mov	r0, r4
3480c240:	e12fff33 	blx	r3
3480c244:	e59f23c0 	ldr	r2, [pc, #960]	; 3480c60c <parse_stream_outer+0x664>
3480c248:	e6ef3070 	uxtb	r3, r0
3480c24c:	e7d23003 	ldrb	r3, [r2, r3]
3480c250:	e1a0a000 	mov	sl, r0
3480c254:	e2133007 	ands	r3, r3, #7
3480c258:	13a03001 	movne	r3, #1
3480c25c:	e350005f 	cmp	r0, #95	; 0x5f
3480c260:	03833001 	orreq	r3, r3, #1
3480c264:	e3530000 	cmp	r3, #0
3480c268:	1affffec 	bne	3480c220 <parse_stream_outer+0x278>
3480c26c:	ea000030 	b	3480c334 <parse_stream_outer+0x38c>
		if (i<global_argc) {
			parse_string(dest, ctx, global_argv[i]); /* recursion */
		}
		advance = 1;
#endif
	} else switch (ch) {
3480c270:	e350003f 	cmp	r0, #63	; 0x3f
3480c274:	0a000004 	beq	3480c28c <parse_stream_outer+0x2e4>
3480c278:	e350007b 	cmp	r0, #123	; 0x7b
			error_msg("unhandled syntax: $%c",ch);
			return 1;
			break;
#endif
		default:
			b_addqchr(dest,'$',dest->quote);
3480c27c:	11a00005 	movne	r0, r5
3480c280:	13a01024 	movne	r1, #36	; 0x24
		if (i<global_argc) {
			parse_string(dest, ctx, global_argv[i]); /* recursion */
		}
		advance = 1;
#endif
	} else switch (ch) {
3480c284:	1affffc5 	bne	3480c1a0 <parse_stream_outer+0x1f8>
3480c288:	ea000013 	b	3480c2dc <parse_stream_outer+0x334>
#endif
		case '?':
#ifndef __U_BOOT__
			b_adduint(dest,last_return_code);
#else
			ctx->child->sp++;
3480c28c:	e59d3008 	ldr	r3, [sp, #8]
			b_addchr(dest, SPECIAL_VAR_SYMBOL);
3480c290:	e1a00005 	mov	r0, r5
#endif
		case '?':
#ifndef __U_BOOT__
			b_adduint(dest,last_return_code);
#else
			ctx->child->sp++;
3480c294:	e593200c 	ldr	r2, [r3, #12]
			b_addchr(dest, SPECIAL_VAR_SYMBOL);
3480c298:	e3a01003 	mov	r1, #3
#endif
		case '?':
#ifndef __U_BOOT__
			b_adduint(dest,last_return_code);
#else
			ctx->child->sp++;
3480c29c:	e2822001 	add	r2, r2, #1
3480c2a0:	e583200c 	str	r2, [r3, #12]
			b_addchr(dest, SPECIAL_VAR_SYMBOL);
3480c2a4:	ebfffa5a 	bl	3480ac14 <b_addchr>
			b_addchr(dest, '$');
3480c2a8:	e1a0100a 	mov	r1, sl
3480c2ac:	e1a00005 	mov	r0, r5
3480c2b0:	ebfffa57 	bl	3480ac14 <b_addchr>
			b_addchr(dest, '?');
3480c2b4:	e1a01009 	mov	r1, r9
3480c2b8:	e1a00005 	mov	r0, r5
3480c2bc:	ebfffa54 	bl	3480ac14 <b_addchr>
			b_addchr(dest, SPECIAL_VAR_SYMBOL);
3480c2c0:	e1a00005 	mov	r0, r5
3480c2c4:	e3a01003 	mov	r1, #3
3480c2c8:	ebfffa51 	bl	3480ac14 <b_addchr>
	/* Eat the character if the flag was set.  If the compiler
	 * is smart enough, we could substitute "b_getch(input);"
	 * for all the "advance = 1;" above, and also end up with
	 * a nice size-optimized program.  Hah!  That'll be the day.
	 */
	if (advance) b_getch(input);
3480c2cc:	e594300c 	ldr	r3, [r4, #12]
3480c2d0:	e1a00004 	mov	r0, r4
3480c2d4:	e12fff33 	blx	r3
3480c2d8:	ea000060 	b	3480c460 <parse_stream_outer+0x4b8>
			b_adduint(dest,global_argc ? global_argc-1 : 0);
			advance = 1;
			break;
#endif
		case '{':
			b_addchr(dest, SPECIAL_VAR_SYMBOL);
3480c2dc:	e1a00005 	mov	r0, r5
3480c2e0:	e3a01003 	mov	r1, #3
3480c2e4:	ebfffa4a 	bl	3480ac14 <b_addchr>
			ctx->child->sp++;
3480c2e8:	e59d3008 	ldr	r3, [sp, #8]
			b_getch(input);
3480c2ec:	e1a00004 	mov	r0, r4
			advance = 1;
			break;
#endif
		case '{':
			b_addchr(dest, SPECIAL_VAR_SYMBOL);
			ctx->child->sp++;
3480c2f0:	e593200c 	ldr	r2, [r3, #12]
3480c2f4:	e2822001 	add	r2, r2, #1
3480c2f8:	e583200c 	str	r2, [r3, #12]
			b_getch(input);
3480c2fc:	e594300c 	ldr	r3, [r4, #12]
3480c300:	e12fff33 	blx	r3
3480c304:	ea000001 	b	3480c310 <parse_stream_outer+0x368>
			/* XXX maybe someone will try to escape the '}' */
			while(ch=b_getch(input),ch!=EOF && ch!='}') {
				b_addchr(dest,ch);
3480c308:	e1a00005 	mov	r0, r5
3480c30c:	ebfffa40 	bl	3480ac14 <b_addchr>
		case '{':
			b_addchr(dest, SPECIAL_VAR_SYMBOL);
			ctx->child->sp++;
			b_getch(input);
			/* XXX maybe someone will try to escape the '}' */
			while(ch=b_getch(input),ch!=EOF && ch!='}') {
3480c310:	e594300c 	ldr	r3, [r4, #12]
3480c314:	e1a00004 	mov	r0, r4
3480c318:	e12fff33 	blx	r3
3480c31c:	e350007d 	cmp	r0, #125	; 0x7d
3480c320:	13700001 	cmnne	r0, #1
3480c324:	e1a01000 	mov	r1, r0
3480c328:	1afffff6 	bne	3480c308 <parse_stream_outer+0x360>
				b_addchr(dest,ch);
			}
			if (ch != '}') {
3480c32c:	e350007d 	cmp	r0, #125	; 0x7d
3480c330:	1a000048 	bne	3480c458 <parse_stream_outer+0x4b0>
				syntax();
				return 1;
			}
			b_addchr(dest, SPECIAL_VAR_SYMBOL);
3480c334:	e1a00005 	mov	r0, r5
3480c338:	e3a01003 	mov	r1, #3
3480c33c:	ebfffa34 	bl	3480ac14 <b_addchr>
3480c340:	ea000046 	b	3480c460 <parse_stream_outer+0x4b8>
			break;
		case '$':
			if (handle_dollar(dest, ctx, input)!=0) return 1;
			break;
		case '\'':
			dest->nonnull = 1;
3480c344:	e3a03001 	mov	r3, #1
3480c348:	e58d3034 	str	r3, [sp, #52]	; 0x34
3480c34c:	ea000004 	b	3480c364 <parse_stream_outer+0x3bc>
			while(ch=b_getch(input),ch!=EOF && ch!='\'') {
#ifdef __U_BOOT__
				if(input->__promptme == 0) return 1;
3480c350:	e5943004 	ldr	r3, [r4, #4]
3480c354:	e3530000 	cmp	r3, #0
3480c358:	0a000047 	beq	3480c47c <parse_stream_outer+0x4d4>
#endif
				b_addchr(dest,ch);
3480c35c:	e1a00005 	mov	r0, r5
3480c360:	ebfffa2b 	bl	3480ac14 <b_addchr>
		case '$':
			if (handle_dollar(dest, ctx, input)!=0) return 1;
			break;
		case '\'':
			dest->nonnull = 1;
			while(ch=b_getch(input),ch!=EOF && ch!='\'') {
3480c364:	e594300c 	ldr	r3, [r4, #12]
3480c368:	e1a00004 	mov	r0, r4
3480c36c:	e12fff33 	blx	r3
3480c370:	e3500027 	cmp	r0, #39	; 0x27
3480c374:	13700001 	cmnne	r0, #1
3480c378:	e1a01000 	mov	r1, r0
3480c37c:	1afffff3 	bne	3480c350 <parse_stream_outer+0x3a8>
3480c380:	ea000032 	b	3480c450 <parse_stream_outer+0x4a8>
				return 1;
			}
			break;
		case '"':
			dest->nonnull = 1;
			dest->quote = !dest->quote;
3480c384:	e59d3030 	ldr	r3, [sp, #48]	; 0x30
				syntax();
				return 1;
			}
			break;
		case '"':
			dest->nonnull = 1;
3480c388:	e3a02001 	mov	r2, #1
			dest->quote = !dest->quote;
3480c38c:	e2733001 	rsbs	r3, r3, #1
3480c390:	33a03000 	movcc	r3, #0
				syntax();
				return 1;
			}
			break;
		case '"':
			dest->nonnull = 1;
3480c394:	e58d2034 	str	r2, [sp, #52]	; 0x34
			dest->quote = !dest->quote;
3480c398:	e58d3030 	str	r3, [sp, #48]	; 0x30
3480c39c:	ea00002f 	b	3480c460 <parse_stream_outer+0x4b8>
			}
			setup_redirect(ctx, redir_fd, redir_style, input);
			break;
#endif
		case ';':
			done_word(dest, ctx);
3480c3a0:	e1a01006 	mov	r1, r6
3480c3a4:	e1a00005 	mov	r0, r5
3480c3a8:	ebfffc3f 	bl	3480b4ac <done_word>
			done_pipe(ctx,PIPE_SEQ);
3480c3ac:	e1a00006 	mov	r0, r6
3480c3b0:	e3a01001 	mov	r1, #1
3480c3b4:	ea000014 	b	3480c40c <parse_stream_outer+0x464>
			break;
		case '&':
			done_word(dest, ctx);
3480c3b8:	e1a00005 	mov	r0, r5
3480c3bc:	e1a01006 	mov	r1, r6
3480c3c0:	ebfffc39 	bl	3480b4ac <done_word>
			if (next=='&') {
3480c3c4:	e3590026 	cmp	r9, #38	; 0x26
3480c3c8:	1a000022 	bne	3480c458 <parse_stream_outer+0x4b0>
				b_getch(input);
3480c3cc:	e594300c 	ldr	r3, [r4, #12]
3480c3d0:	e1a00004 	mov	r0, r4
3480c3d4:	e12fff33 	blx	r3
				done_pipe(ctx,PIPE_AND);
3480c3d8:	e1a00006 	mov	r0, r6
3480c3dc:	e3a01002 	mov	r1, #2
3480c3e0:	ea000009 	b	3480c40c <parse_stream_outer+0x464>
				return 1;
#endif
			}
			break;
		case '|':
			done_word(dest, ctx);
3480c3e4:	e1a00005 	mov	r0, r5
3480c3e8:	e1a01006 	mov	r1, r6
3480c3ec:	ebfffc2e 	bl	3480b4ac <done_word>
			if (next=='|') {
3480c3f0:	e359007c 	cmp	r9, #124	; 0x7c
3480c3f4:	1a000017 	bne	3480c458 <parse_stream_outer+0x4b0>
				b_getch(input);
3480c3f8:	e594300c 	ldr	r3, [r4, #12]
3480c3fc:	e1a00004 	mov	r0, r4
3480c400:	e12fff33 	blx	r3
				done_pipe(ctx,PIPE_OR);
3480c404:	e1a00006 	mov	r0, r6
3480c408:	e3a01003 	mov	r1, #3
3480c40c:	ebfffba8 	bl	3480b2b4 <done_pipe>
3480c410:	ea000012 	b	3480c460 <parse_stream_outer+0x4b8>
			syntax();   /* Proper use of this character caught by end_trigger */
			return 1;
			break;
#endif
		case SUBSTED_VAR_SYMBOL:
			dest->nonnull = 1;
3480c414:	e3a03001 	mov	r3, #1
3480c418:	e58d3034 	str	r3, [sp, #52]	; 0x34
3480c41c:	ea000004 	b	3480c434 <parse_stream_outer+0x48c>
			while (ch = b_getch(input), ch != EOF &&
			    ch != SUBSTED_VAR_SYMBOL) {
				debug_printf("subst, pass=%d\n", ch);
				if (input->__promptme == 0)
3480c420:	e5943004 	ldr	r3, [r4, #4]
3480c424:	e3530000 	cmp	r3, #0
3480c428:	0a000013 	beq	3480c47c <parse_stream_outer+0x4d4>
					return 1;
				b_addchr(dest, ch);
3480c42c:	e1a00005 	mov	r0, r5
3480c430:	ebfff9f7 	bl	3480ac14 <b_addchr>
			return 1;
			break;
#endif
		case SUBSTED_VAR_SYMBOL:
			dest->nonnull = 1;
			while (ch = b_getch(input), ch != EOF &&
3480c434:	e594300c 	ldr	r3, [r4, #12]
3480c438:	e1a00004 	mov	r0, r4
3480c43c:	e12fff33 	blx	r3
3480c440:	e3500004 	cmp	r0, #4
3480c444:	13700001 	cmnne	r0, #1
3480c448:	e1a01000 	mov	r1, r0
3480c44c:	1afffff3 	bne	3480c420 <parse_stream_outer+0x478>
				if (input->__promptme == 0)
					return 1;
				b_addchr(dest, ch);
			}
			debug_printf("subst, term=%d\n", ch);
			if (ch == EOF) {
3480c450:	e3710001 	cmn	r1, #1
3480c454:	1a000001 	bne	3480c460 <parse_stream_outer+0x4b8>
				syntax();
				return 1;
			}
			break;
		default:
			syntax();   /* this is really an internal logic error */
3480c458:	ebfff8db 	bl	3480a7cc <syntax_err>
3480c45c:	ea000006 	b	3480c47c <parse_stream_outer+0x4d4>
	/* Only double-quote state is handled in the state variable dest->quote.
	 * A single-quote triggers a bypass of the main loop until its mate is
	 * found.  When recursing, quote state is passed in via dest->quote. */

	debug_printf("parse_stream, end_trigger=%d\n",end_trigger);
	while ((ch=b_getch(input))!=EOF) {
3480c460:	e594300c 	ldr	r3, [r4, #12]
3480c464:	e1a00004 	mov	r0, r4
3480c468:	e12fff33 	blx	r3
3480c46c:	e3700001 	cmn	r0, #1
3480c470:	e1a0a000 	mov	sl, r0
3480c474:	1afffeee 	bne	3480c034 <parse_stream_outer+0x8c>
3480c478:	ea00005d 	b	3480c5f4 <parse_stream_outer+0x64c>
		update_ifs_map();
		if (!(flag & FLAG_PARSE_SEMICOLON) || (flag & FLAG_REPARSING)) mapset((uchar *)";$&|", 0);
		inp->promptmode=1;
		rcode = parse_stream(&temp, &ctx, inp, '\n');
#ifdef __U_BOOT__
		if (rcode == 1) flag_repeat = 0;
3480c47c:	e59f2184 	ldr	r2, [pc, #388]	; 3480c608 <parse_stream_outer+0x660>
3480c480:	e3a03000 	mov	r3, #0
3480c484:	e5823004 	str	r3, [r2, #4]
3480c488:	e3a0a001 	mov	sl, #1
3480c48c:	ea000028 	b	3480c534 <parse_stream_outer+0x58c>
#endif
		if (rcode != 1 && ctx.old_flag != 0) {
			syntax();
3480c490:	ebfff8cd 	bl	3480a7cc <syntax_err>
#ifdef __U_BOOT__
			flag_repeat = 0;
3480c494:	e59f216c 	ldr	r2, [pc, #364]	; 3480c608 <parse_stream_outer+0x660>
3480c498:	e3a03000 	mov	r3, #0
3480c49c:	e5823004 	str	r3, [r2, #4]
3480c4a0:	ea00004e 	b	3480c5e0 <parse_stream_outer+0x638>
#endif
		}
		if (rcode != 1 && ctx.old_flag == 0) {
			done_word(&temp, &ctx);
3480c4a4:	e1a01006 	mov	r1, r6
3480c4a8:	e1a00005 	mov	r0, r5
3480c4ac:	ebfffbfe 	bl	3480b4ac <done_word>
			done_pipe(&ctx,PIPE_SEQ);
3480c4b0:	e3a01001 	mov	r1, #1
3480c4b4:	e1a00006 	mov	r0, r6
3480c4b8:	ebfffb7d 	bl	3480b2b4 <done_pipe>
#ifndef __U_BOOT__
			run_list(ctx.list_head);
#else
			code = run_list(ctx.list_head);
3480c4bc:	e59db00c 	ldr	fp, [sp, #12]
{
	int rcode=0;
#ifndef __U_BOOT__
	if (fake_mode==0) {
#endif
		rcode = run_list_real(pi);
3480c4c0:	e1a0000b 	mov	r0, fp
3480c4c4:	ebfffcbe 	bl	3480b7c4 <run_list_real>
	}
#endif
	/* free_pipe_list has the side effect of clearing memory
	 * In the long run that function can be merged with run_list_real,
	 * but doing that now would hobble the debugging effort. */
	free_pipe_list(pi,0);
3480c4c8:	e1a01009 	mov	r1, r9
{
	int rcode=0;
#ifndef __U_BOOT__
	if (fake_mode==0) {
#endif
		rcode = run_list_real(pi);
3480c4cc:	e1a07000 	mov	r7, r0
	}
#endif
	/* free_pipe_list has the side effect of clearing memory
	 * In the long run that function can be merged with run_list_real,
	 * but doing that now would hobble the debugging effort. */
	free_pipe_list(pi,0);
3480c4d0:	e1a0000b 	mov	r0, fp
3480c4d4:	ebfff96d 	bl	3480aa90 <free_pipe_list>
			done_pipe(&ctx,PIPE_SEQ);
#ifndef __U_BOOT__
			run_list(ctx.list_head);
#else
			code = run_list(ctx.list_head);
			if (code == -2) {	/* exit */
3480c4d8:	e3770002 	cmn	r7, #2
3480c4dc:	1a000010 	bne	3480c524 <parse_stream_outer+0x57c>

static void b_reset(o_string *o)
{
	o->length = 0;
	o->nonnull = 0;
	if (o->data != NULL) *o->data = '\0';
3480c4e0:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
	return 0;
}

static void b_reset(o_string *o)
{
	o->length = 0;
3480c4e4:	e58d9028 	str	r9, [sp, #40]	; 0x28
	o->nonnull = 0;
	if (o->data != NULL) *o->data = '\0';
3480c4e8:	e3530000 	cmp	r3, #0
}

static void b_reset(o_string *o)
{
	o->length = 0;
	o->nonnull = 0;
3480c4ec:	e58d9034 	str	r9, [sp, #52]	; 0x34
	if (o->data != NULL) *o->data = '\0';
3480c4f0:	15c39000 	strbne	r9, [r3]
}

static void b_free(o_string *o)
{
	b_reset(o);
	free(o->data);
3480c4f4:	e59d0024 	ldr	r0, [sp, #36]	; 0x24
3480c4f8:	ebfff3d1 	bl	34809444 <free>
			code = run_list(ctx.list_head);
			if (code == -2) {	/* exit */
				b_free(&temp);
				code = 0;
				/* XXX hackish way to not allow exit from main loop */
				if (inp->peek == file_peek) {
3480c4fc:	e5943010 	ldr	r3, [r4, #16]
3480c500:	e59f2108 	ldr	r2, [pc, #264]	; 3480c610 <parse_stream_outer+0x668>

static void b_free(o_string *o)
{
	b_reset(o);
	free(o->data);
	o->data = NULL;
3480c504:	e3a07000 	mov	r7, #0
			code = run_list(ctx.list_head);
			if (code == -2) {	/* exit */
				b_free(&temp);
				code = 0;
				/* XXX hackish way to not allow exit from main loop */
				if (inp->peek == file_peek) {
3480c508:	e1530002 	cmp	r3, r2

static void b_free(o_string *o)
{
	b_reset(o);
	free(o->data);
	o->data = NULL;
3480c50c:	e58d7024 	str	r7, [sp, #36]	; 0x24
	o->maxlen = 0;
3480c510:	e58d702c 	str	r7, [sp, #44]	; 0x2c
			code = run_list(ctx.list_head);
			if (code == -2) {	/* exit */
				b_free(&temp);
				code = 0;
				/* XXX hackish way to not allow exit from main loop */
				if (inp->peek == file_peek) {
3480c514:	1a00002d 	bne	3480c5d0 <parse_stream_outer+0x628>
					printf("exit not allowed from main input shell.\n");
3480c518:	e59f00f4 	ldr	r0, [pc, #244]	; 3480c614 <parse_stream_outer+0x66c>
3480c51c:	ebfff28a 	bl	34808f4c <printf>
					continue;
3480c520:	ea000025 	b	3480c5bc <parse_stream_outer+0x614>
				}
				break;
			}
			if (code == -1)
3480c524:	e3770001 	cmn	r7, #1
			    flag_repeat = 0;
3480c528:	059f30d8 	ldreq	r3, [pc, #216]	; 3480c608 <parse_stream_outer+0x660>
3480c52c:	05839004 	streq	r9, [r3, #4]
3480c530:	ea000016 	b	3480c590 <parse_stream_outer+0x5e8>
#endif
		} else {
			if (ctx.old_flag != 0) {
3480c534:	e59d3018 	ldr	r3, [sp, #24]
3480c538:	e3530000 	cmp	r3, #0
3480c53c:	0a000007 	beq	3480c560 <parse_stream_outer+0x5b8>
				free(ctx.stack);
3480c540:	e59d001c 	ldr	r0, [sp, #28]
3480c544:	ebfff3be 	bl	34809444 <free>

static void b_reset(o_string *o)
{
	o->length = 0;
	o->nonnull = 0;
	if (o->data != NULL) *o->data = '\0';
3480c548:	e59d2024 	ldr	r2, [sp, #36]	; 0x24
	return 0;
}

static void b_reset(o_string *o)
{
	o->length = 0;
3480c54c:	e3a03000 	mov	r3, #0
	o->nonnull = 0;
	if (o->data != NULL) *o->data = '\0';
3480c550:	e1520003 	cmp	r2, r3
	return 0;
}

static void b_reset(o_string *o)
{
	o->length = 0;
3480c554:	e58d3028 	str	r3, [sp, #40]	; 0x28
	o->nonnull = 0;
3480c558:	e58d3034 	str	r3, [sp, #52]	; 0x34
	if (o->data != NULL) *o->data = '\0';
3480c55c:	15c23000 	strbne	r3, [r2]
			if (ctx.old_flag != 0) {
				free(ctx.stack);
				b_reset(&temp);
			}
#ifdef __U_BOOT__
			if (inp->__promptme == 0) printf("<INTERRUPT>\n");
3480c560:	e5943004 	ldr	r3, [r4, #4]
3480c564:	e3530000 	cmp	r3, #0
3480c568:	1a000001 	bne	3480c574 <parse_stream_outer+0x5cc>
3480c56c:	e59f00a4 	ldr	r0, [pc, #164]	; 3480c618 <parse_stream_outer+0x670>
3480c570:	ebfff275 	bl	34808f4c <printf>
			inp->__promptme = 1;
#endif
			temp.nonnull = 0;
3480c574:	e3a01000 	mov	r1, #0
				free(ctx.stack);
				b_reset(&temp);
			}
#ifdef __U_BOOT__
			if (inp->__promptme == 0) printf("<INTERRUPT>\n");
			inp->__promptme = 1;
3480c578:	e3a03001 	mov	r3, #1
3480c57c:	e884000a 	stm	r4, {r1, r3}
#endif
			temp.nonnull = 0;
			temp.quote = 0;
			inp->p = NULL;
			free_pipe_list(ctx.list_head,0);
3480c580:	e59d000c 	ldr	r0, [sp, #12]
			}
#ifdef __U_BOOT__
			if (inp->__promptme == 0) printf("<INTERRUPT>\n");
			inp->__promptme = 1;
#endif
			temp.nonnull = 0;
3480c584:	e58d1034 	str	r1, [sp, #52]	; 0x34
			temp.quote = 0;
3480c588:	e58d1030 	str	r1, [sp, #48]	; 0x30
			inp->p = NULL;
			free_pipe_list(ctx.list_head,0);
3480c58c:	ebfff93f 	bl	3480aa90 <free_pipe_list>

static void b_reset(o_string *o)
{
	o->length = 0;
	o->nonnull = 0;
	if (o->data != NULL) *o->data = '\0';
3480c590:	e59d2024 	ldr	r2, [sp, #36]	; 0x24
	return 0;
}

static void b_reset(o_string *o)
{
	o->length = 0;
3480c594:	e3a03000 	mov	r3, #0
	o->nonnull = 0;
	if (o->data != NULL) *o->data = '\0';
3480c598:	e1520003 	cmp	r2, r3
	return 0;
}

static void b_reset(o_string *o)
{
	o->length = 0;
3480c59c:	e58d3028 	str	r3, [sp, #40]	; 0x28
	o->nonnull = 0;
3480c5a0:	e58d3034 	str	r3, [sp, #52]	; 0x34
	if (o->data != NULL) *o->data = '\0';
3480c5a4:	15c23000 	strbne	r3, [r2]
}

static void b_free(o_string *o)
{
	b_reset(o);
	free(o->data);
3480c5a8:	e59d0024 	ldr	r0, [sp, #36]	; 0x24
3480c5ac:	ebfff3a4 	bl	34809444 <free>
	o->data = NULL;
3480c5b0:	e3a03000 	mov	r3, #0
3480c5b4:	e58d3024 	str	r3, [sp, #36]	; 0x24
	o->maxlen = 0;
3480c5b8:	e58d302c 	str	r3, [sp, #44]	; 0x2c
			temp.quote = 0;
			inp->p = NULL;
			free_pipe_list(ctx.list_head,0);
		}
		b_free(&temp);
	} while (rcode != -1 && !(flag & FLAG_EXIT_FROM_LOOP));   /* loop on syntax errors, return on EOF */
3480c5bc:	e37a0001 	cmn	sl, #1
3480c5c0:	0a000002 	beq	3480c5d0 <parse_stream_outer+0x628>
3480c5c4:	e59d2004 	ldr	r2, [sp, #4]
3480c5c8:	e3120001 	tst	r2, #1
3480c5cc:	0afffe80 	beq	3480bfd4 <parse_stream_outer+0x2c>
#ifndef __U_BOOT__
	return 0;
#else
	return (code != 0) ? 1 : 0;
#endif /* __U_BOOT__ */
}
3480c5d0:	e2570000 	subs	r0, r7, #0
3480c5d4:	13a00001 	movne	r0, #1
3480c5d8:	e28dd038 	add	sp, sp, #56	; 0x38
3480c5dc:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
			syntax();
#ifdef __U_BOOT__
			flag_repeat = 0;
#endif
		}
		if (rcode != 1 && ctx.old_flag == 0) {
3480c5e0:	e59d9018 	ldr	r9, [sp, #24]
3480c5e4:	e3590000 	cmp	r9, #0
3480c5e8:	1affffd1 	bne	3480c534 <parse_stream_outer+0x58c>
3480c5ec:	eaffffac 	b	3480c4a4 <parse_stream_outer+0x4fc>
				if (end_trigger != '\0' && ch=='\n')
					done_pipe(ctx,PIPE_SEQ);
			}
			if (ch == end_trigger && !dest->quote && ctx->w==RES_NONE) {
				debug_printf("leaving parse_stream (triggered)\n");
				return 0;
3480c5f0:	e1a0a003 	mov	sl, r3
		inp->promptmode=1;
		rcode = parse_stream(&temp, &ctx, inp, '\n');
#ifdef __U_BOOT__
		if (rcode == 1) flag_repeat = 0;
#endif
		if (rcode != 1 && ctx.old_flag != 0) {
3480c5f4:	e59d3018 	ldr	r3, [sp, #24]
3480c5f8:	e3530000 	cmp	r3, #0
3480c5fc:	0afffff7 	beq	3480c5e0 <parse_stream_outer+0x638>
3480c600:	eaffffa2 	b	3480c490 <parse_stream_outer+0x4e8>
3480c604:	34826148 	.word	0x34826148
3480c608:	34829528 	.word	0x34829528
3480c60c:	34821fd4 	.word	0x34821fd4
3480c610:	3480a76c 	.word	0x3480a76c
3480c614:	3482614d 	.word	0x3482614d
3480c618:	34826176 	.word	0x34826176

3480c61c <parse_file_outer>:
#ifndef __U_BOOT__
static int parse_file_outer(FILE *f)
#else
int parse_file_outer(void)
#endif
{
3480c61c:	e92d407f 	push	{r0, r1, r2, r3, r4, r5, r6, lr}
static void setup_file_in_str(struct in_str *i, FILE *f)
#else
static void setup_file_in_str(struct in_str *i)
#endif
{
	i->peek = file_peek;
3480c620:	e59f3030 	ldr	r3, [pc, #48]	; 3480c658 <parse_file_outer+0x3c>
	i->__promptme=1;
	i->promptmode=1;
#ifndef __U_BOOT__
	i->file = f;
#endif
	i->p = NULL;
3480c624:	e28d0018 	add	r0, sp, #24
static void setup_file_in_str(struct in_str *i, FILE *f)
#else
static void setup_file_in_str(struct in_str *i)
#endif
{
	i->peek = file_peek;
3480c628:	e58d3014 	str	r3, [sp, #20]
	i->get = file_get;
3480c62c:	e59f3028 	ldr	r3, [pc, #40]	; 3480c65c <parse_file_outer+0x40>
#ifndef __U_BOOT__
	setup_file_in_str(&input, f);
#else
	setup_file_in_str(&input);
#endif
	rcode = parse_stream_outer(&input, FLAG_PARSE_SEMICOLON);
3480c630:	e3a01002 	mov	r1, #2
#else
static void setup_file_in_str(struct in_str *i)
#endif
{
	i->peek = file_peek;
	i->get = file_get;
3480c634:	e58d3010 	str	r3, [sp, #16]
	i->__promptme=1;
3480c638:	e3a03001 	mov	r3, #1
3480c63c:	e58d3008 	str	r3, [sp, #8]
	i->promptmode=1;
3480c640:	e58d300c 	str	r3, [sp, #12]
#ifndef __U_BOOT__
	i->file = f;
#endif
	i->p = NULL;
3480c644:	e3a03000 	mov	r3, #0
3480c648:	e5203014 	str	r3, [r0, #-20]!
#ifndef __U_BOOT__
	setup_file_in_str(&input, f);
#else
	setup_file_in_str(&input);
#endif
	rcode = parse_stream_outer(&input, FLAG_PARSE_SEMICOLON);
3480c64c:	ebfffe55 	bl	3480bfa8 <parse_stream_outer>
	return rcode;
}
3480c650:	e28dd01c 	add	sp, sp, #28
3480c654:	e8bd8000 	pop	{pc}
3480c658:	3480a76c 	.word	0x3480a76c
3480c65c:	3480a8e8 	.word	0x3480a8e8

3480c660 <u_boot_hush_start>:
	}
}
#endif

int u_boot_hush_start(void)
{
3480c660:	e92d4038 	push	{r3, r4, r5, lr}
	if (top_vars == NULL) {
3480c664:	e59f503c 	ldr	r5, [pc, #60]	; 3480c6a8 <u_boot_hush_start+0x48>
3480c668:	e5954000 	ldr	r4, [r5]
3480c66c:	e3540000 	cmp	r4, #0
3480c670:	1a00000a 	bne	3480c6a0 <u_boot_hush_start+0x40>
		top_vars = malloc(sizeof(struct variables));
3480c674:	e3a00014 	mov	r0, #20
3480c678:	ebfff3fa 	bl	34809668 <malloc>
		top_vars->name = "HUSH_VERSION";
3480c67c:	e59f3028 	ldr	r3, [pc, #40]	; 3480c6ac <u_boot_hush_start+0x4c>
#endif

int u_boot_hush_start(void)
{
	if (top_vars == NULL) {
		top_vars = malloc(sizeof(struct variables));
3480c680:	e5850000 	str	r0, [r5]
		top_vars->name = "HUSH_VERSION";
3480c684:	e5803000 	str	r3, [r0]
		top_vars->value = "0.01";
3480c688:	e59f3020 	ldr	r3, [pc, #32]	; 3480c6b0 <u_boot_hush_start+0x50>
		top_vars->next = 0;
3480c68c:	e5804010 	str	r4, [r0, #16]
int u_boot_hush_start(void)
{
	if (top_vars == NULL) {
		top_vars = malloc(sizeof(struct variables));
		top_vars->name = "HUSH_VERSION";
		top_vars->value = "0.01";
3480c690:	e5803004 	str	r3, [r0, #4]
		top_vars->next = 0;
		top_vars->flg_export = 0;
		top_vars->flg_read_only = 1;
3480c694:	e3a03001 	mov	r3, #1
	if (top_vars == NULL) {
		top_vars = malloc(sizeof(struct variables));
		top_vars->name = "HUSH_VERSION";
		top_vars->value = "0.01";
		top_vars->next = 0;
		top_vars->flg_export = 0;
3480c698:	e5804008 	str	r4, [r0, #8]
		top_vars->flg_read_only = 1;
3480c69c:	e580300c 	str	r3, [r0, #12]
#ifdef CONFIG_NEEDS_MANUAL_RELOC
		u_boot_hush_reloc();
#endif
	}
	return 0;
}
3480c6a0:	e3a00000 	mov	r0, #0
3480c6a4:	e8bd8038 	pop	{r3, r4, r5, pc}
3480c6a8:	34829528 	.word	0x34829528
3480c6ac:	34826183 	.word	0x34826183
3480c6b0:	34826190 	.word	0x34826190

3480c6b4 <__fswab32>:
3480c6b4:	e6bf0f30 	rev	r0, r0
3480c6b8:	e12fff1e 	bx	lr

3480c6bc <image_check_magic.clone.8>:
phys_size_t getenv_bootm_size(void);
phys_size_t getenv_bootm_mapsize(void);
void memmove_wd(void *to, void *from, size_t len, ulong chunksz);
#endif

static inline int image_check_magic(const image_header_t *hdr)
3480c6bc:	e92d4008 	push	{r3, lr}
#define image_get_hdr_l(f) \
	static inline uint32_t image_get_##f(const image_header_t *hdr) \
	{ \
		return uimage_to_cpu(hdr->ih_##f); \
	}
image_get_hdr_l(magic)		/* image_get_magic */
3480c6c0:	ebfffffb 	bl	3480c6b4 <__fswab32>
#endif

static inline int image_check_magic(const image_header_t *hdr)
{
	return (image_get_magic(hdr) == IH_MAGIC);
}
3480c6c4:	e59f300c 	ldr	r3, [pc, #12]	; 3480c6d8 <image_check_magic.clone.8+0x1c>
3480c6c8:	e1500003 	cmp	r0, r3
3480c6cc:	13a00000 	movne	r0, #0
3480c6d0:	03a00001 	moveq	r0, #1
3480c6d4:	e8bd8008 	pop	{r3, pc}
3480c6d8:	27051956 	.word	0x27051956

3480c6dc <image_get_data_size.clone.10>:
		return uimage_to_cpu(hdr->ih_##f); \
	}
image_get_hdr_l(magic)		/* image_get_magic */
image_get_hdr_l(hcrc)		/* image_get_hcrc */
image_get_hdr_l(time)		/* image_get_time */
image_get_hdr_l(size)		/* image_get_size */
3480c6dc:	eafffff4 	b	3480c6b4 <__fswab32>

3480c6e0 <image_check_hcrc>:

/*****************************************************************************/
/* Legacy format routines */
/*****************************************************************************/
int image_check_hcrc(const image_header_t *hdr)
{
3480c6e0:	e92d4030 	push	{r4, r5, lr}
3480c6e4:	e1a04000 	mov	r4, r0
3480c6e8:	e24dd044 	sub	sp, sp, #68	; 0x44
	ulong hcrc;
	ulong len = image_get_header_size();
	image_header_t header;

	/* Copy header so we can blank CRC field for re-calculation */
	memmove(&header, (char *)hdr, image_get_header_size());
3480c6ec:	e1a01004 	mov	r1, r4
3480c6f0:	e1a0000d 	mov	r0, sp
3480c6f4:	e3a02040 	mov	r2, #64	; 0x40
3480c6f8:	eb003201 	bl	34818f04 <memmove>
	image_set_hcrc(&header, 0);

	hcrc = crc32(0, (unsigned char *)&header, len);
3480c6fc:	e1a0100d 	mov	r1, sp
3480c700:	e3a02040 	mov	r2, #64	; 0x40
	static inline void image_set_##f(image_header_t *hdr, uint32_t val) \
	{ \
		hdr->ih_##f = cpu_to_uimage(val); \
	}
image_set_hdr_l(magic)		/* image_set_magic */
image_set_hdr_l(hcrc)		/* image_set_hcrc */
3480c704:	e3a00000 	mov	r0, #0
3480c708:	e58d0004 	str	r0, [sp, #4]
3480c70c:	eb002a5d 	bl	34817088 <crc32>
3480c710:	e1a05000 	mov	r5, r0
	static inline uint32_t image_get_##f(const image_header_t *hdr) \
	{ \
		return uimage_to_cpu(hdr->ih_##f); \
	}
image_get_hdr_l(magic)		/* image_get_magic */
image_get_hdr_l(hcrc)		/* image_get_hcrc */
3480c714:	e5940004 	ldr	r0, [r4, #4]
3480c718:	ebffffe5 	bl	3480c6b4 <__fswab32>

	return (hcrc == image_get_hcrc(hdr));
}
3480c71c:	e1550000 	cmp	r5, r0
3480c720:	13a00000 	movne	r0, #0
3480c724:	03a00001 	moveq	r0, #1
3480c728:	e28dd044 	add	sp, sp, #68	; 0x44
3480c72c:	e8bd8030 	pop	{r4, r5, pc}

3480c730 <image_check_dcrc>:

int image_check_dcrc(const image_header_t *hdr)
{
3480c730:	e92d4038 	push	{r3, r4, r5, lr}
3480c734:	e1a04000 	mov	r4, r0
	ulong data = image_get_data(hdr);
	ulong len = image_get_data_size(hdr);
3480c738:	e590000c 	ldr	r0, [r0, #12]
3480c73c:	ebffffe6 	bl	3480c6dc <image_get_data_size.clone.10>
	ulong dcrc = crc32_wd(0, (unsigned char *)data, len, CHUNKSZ_CRC32);
3480c740:	e2841040 	add	r1, r4, #64	; 0x40
}

int image_check_dcrc(const image_header_t *hdr)
{
	ulong data = image_get_data(hdr);
	ulong len = image_get_data_size(hdr);
3480c744:	e1a02000 	mov	r2, r0
	ulong dcrc = crc32_wd(0, (unsigned char *)data, len, CHUNKSZ_CRC32);
3480c748:	e3a03801 	mov	r3, #65536	; 0x10000
3480c74c:	e3a00000 	mov	r0, #0
3480c750:	eb002a51 	bl	3481709c <crc32_wd>
3480c754:	e1a05000 	mov	r5, r0
image_get_hdr_l(time)		/* image_get_time */
image_get_hdr_l(size)		/* image_get_size */
image_get_hdr_l(load)		/* image_get_load */
image_get_hdr_l(ep)		/* image_get_ep */
image_get_hdr_l(dcrc)		/* image_get_dcrc */
3480c758:	e5940018 	ldr	r0, [r4, #24]
3480c75c:	ebffffd4 	bl	3480c6b4 <__fswab32>

	return (dcrc == image_get_dcrc(hdr));
}
3480c760:	e1550000 	cmp	r5, r0
3480c764:	13a00000 	movne	r0, #0
3480c768:	03a00001 	moveq	r0, #1
3480c76c:	e8bd8038 	pop	{r3, r4, r5, pc}

3480c770 <image_multi_count>:
	/* get start of the image payload, which in case of multi
	 * component images that points to a table of component sizes */
	size = (uint32_t *)image_get_data(hdr);

	/* count non empty slots */
	for (i = 0; size[i]; ++i)
3480c770:	e280303c 	add	r3, r0, #60	; 0x3c
3480c774:	e3a00000 	mov	r0, #0
3480c778:	ea000000 	b	3480c780 <image_multi_count+0x10>
3480c77c:	e2800001 	add	r0, r0, #1
3480c780:	e5b32004 	ldr	r2, [r3, #4]!
3480c784:	e3520000 	cmp	r2, #0
3480c788:	1afffffb 	bne	3480c77c <image_multi_count+0xc>
		count++;

	return count;
}
3480c78c:	e12fff1e 	bx	lr

3480c790 <image_multi_getimg>:
 *     data address and size of the component, if idx is valid
 *     0 in data and len, if idx is out of range
 */
void image_multi_getimg(const image_header_t *hdr, ulong idx,
			ulong *data, ulong *len)
{
3480c790:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
3480c794:	e1a0a003 	mov	sl, r3
3480c798:	e1a05001 	mov	r5, r1
3480c79c:	e1a06002 	mov	r6, r2
3480c7a0:	e1a04000 	mov	r4, r0
	int i;
	uint32_t *size;
	ulong offset, count, img_data;

	/* get number of component */
	count = image_multi_count(hdr);
3480c7a4:	ebfffff1 	bl	3480c770 <image_multi_count>

	/* get address of the proper component data start, which means
	 * skipping sizes table (add 1 for last, null entry) */
	img_data = image_get_data(hdr) + (count + 1) * sizeof(uint32_t);

	if (idx < count) {
3480c7a8:	e1550000 	cmp	r5, r0
		}

		/* calculate idx-th component data address */
		*data = img_data + offset;
	} else {
		*len = 0;
3480c7ac:	23a03000 	movcs	r3, #0
3480c7b0:	258a3000 	strcs	r3, [sl]
	int i;
	uint32_t *size;
	ulong offset, count, img_data;

	/* get number of component */
	count = image_multi_count(hdr);
3480c7b4:	e1a0b000 	mov	fp, r0

		/* calculate idx-th component data address */
		*data = img_data + offset;
	} else {
		*len = 0;
		*data = 0;
3480c7b8:	25863000 	strcs	r3, [r6]

	/* get address of the proper component data start, which means
	 * skipping sizes table (add 1 for last, null entry) */
	img_data = image_get_data(hdr) + (count + 1) * sizeof(uint32_t);

	if (idx < count) {
3480c7bc:	28bd8ef0 	popcs	{r4, r5, r6, r7, r9, sl, fp, pc}
 * returns:
 *     image payload data start address
 */
static inline ulong image_get_data(const image_header_t *hdr)
{
	return ((ulong)hdr + image_get_header_size());
3480c7c0:	e2849040 	add	r9, r4, #64	; 0x40
		*len = uimage_to_cpu(size[idx]);
3480c7c4:	e7990105 	ldr	r0, [r9, r5, lsl #2]
3480c7c8:	ebffffb9 	bl	3480c6b4 <__fswab32>
		offset = 0;
3480c7cc:	e3a07000 	mov	r7, #0
	/* get address of the proper component data start, which means
	 * skipping sizes table (add 1 for last, null entry) */
	img_data = image_get_data(hdr) + (count + 1) * sizeof(uint32_t);

	if (idx < count) {
		*len = uimage_to_cpu(size[idx]);
3480c7d0:	e58a0000 	str	r0, [sl]
3480c7d4:	e284403c 	add	r4, r4, #60	; 0x3c
		offset = 0;

		/* go over all indices preceding requested component idx */
		for (i = 0; i < idx; i++) {
3480c7d8:	e1a0a007 	mov	sl, r7
3480c7dc:	ea000005 	b	3480c7f8 <image_multi_getimg+0x68>
			/* add up i-th component size, rounding up to 4 bytes */
			offset += (uimage_to_cpu(size[i]) + 3) & ~3 ;
3480c7e0:	e5b40004 	ldr	r0, [r4, #4]!
3480c7e4:	ebffffb2 	bl	3480c6b4 <__fswab32>
3480c7e8:	e2800003 	add	r0, r0, #3
3480c7ec:	e3c00003 	bic	r0, r0, #3
3480c7f0:	e0877000 	add	r7, r7, r0
	if (idx < count) {
		*len = uimage_to_cpu(size[idx]);
		offset = 0;

		/* go over all indices preceding requested component idx */
		for (i = 0; i < idx; i++) {
3480c7f4:	e28aa001 	add	sl, sl, #1
3480c7f8:	e15a0005 	cmp	sl, r5
3480c7fc:	1afffff7 	bne	3480c7e0 <image_multi_getimg+0x50>
	 * component images that points to a table of component sizes */
	size = (uint32_t *)image_get_data(hdr);

	/* get address of the proper component data start, which means
	 * skipping sizes table (add 1 for last, null entry) */
	img_data = image_get_data(hdr) + (count + 1) * sizeof(uint32_t);
3480c800:	e28bb001 	add	fp, fp, #1
3480c804:	e089910b 	add	r9, r9, fp, lsl #2
			/* add up i-th component size, rounding up to 4 bytes */
			offset += (uimage_to_cpu(size[i]) + 3) & ~3 ;
		}

		/* calculate idx-th component data address */
		*data = img_data + offset;
3480c808:	e0897007 	add	r7, r9, r7
3480c80c:	e5867000 	str	r7, [r6]
3480c810:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}

3480c814 <getenv_yesno>:
/*****************************************************************************/
/* Shared dual-format routines */
/*****************************************************************************/
#ifndef USE_HOSTCC
int getenv_yesno(char *var)
{
3480c814:	e92d4008 	push	{r3, lr}
	char *s = getenv(var);
3480c818:	ebffee87 	bl	3480823c <getenv>
	return (s && (*s == 'n')) ? 0 : 1;
3480c81c:	e3500000 	cmp	r0, #0
3480c820:	0a000003 	beq	3480c834 <getenv_yesno+0x20>
3480c824:	e5d00000 	ldrb	r0, [r0]
3480c828:	e250006e 	subs	r0, r0, #110	; 0x6e
3480c82c:	13a00001 	movne	r0, #1
3480c830:	e8bd8008 	pop	{r3, pc}
3480c834:	e3a00001 	mov	r0, #1
}
3480c838:	e8bd8008 	pop	{r3, pc}

3480c83c <getenv_bootm_low>:

ulong getenv_bootm_low(void)
{
3480c83c:	e92d4010 	push	{r4, lr}
	char *s = getenv("bootm_low");
3480c840:	e59f0020 	ldr	r0, [pc, #32]	; 3480c868 <getenv_bootm_low+0x2c>
3480c844:	ebffee7c 	bl	3480823c <getenv>
	if (s) {
3480c848:	e3500000 	cmp	r0, #0
3480c84c:	0a000003 	beq	3480c860 <getenv_bootm_low+0x24>
		ulong tmp = simple_strtoul(s, NULL, 16);
3480c850:	e3a01000 	mov	r1, #0
3480c854:	e3a02010 	mov	r2, #16
#elif defined(CONFIG_ARM)
	return gd->bd->bi_dram[0].start;
#else
	return 0;
#endif
}
3480c858:	e8bd4010 	pop	{r4, lr}

ulong getenv_bootm_low(void)
{
	char *s = getenv("bootm_low");
	if (s) {
		ulong tmp = simple_strtoul(s, NULL, 16);
3480c85c:	ea0034e5 	b	34819bf8 <simple_strtoul>
#elif defined(CONFIG_ARM)
	return gd->bd->bi_dram[0].start;
#else
	return 0;
#endif
}
3480c860:	e3a00202 	mov	r0, #536870912	; 0x20000000
3480c864:	e8bd8010 	pop	{r4, pc}
3480c868:	34826256 	.word	0x34826256

3480c86c <getenv_bootm_size>:

phys_size_t getenv_bootm_size(void)
{
3480c86c:	e92d4010 	push	{r4, lr}
	phys_size_t tmp;
	char *s = getenv("bootm_size");
3480c870:	e59f0048 	ldr	r0, [pc, #72]	; 3480c8c0 <getenv_bootm_size+0x54>
3480c874:	ebffee70 	bl	3480823c <getenv>
	if (s) {
3480c878:	e2504000 	subs	r4, r0, #0
3480c87c:	0a000003 	beq	3480c890 <getenv_bootm_size+0x24>
		tmp = (phys_size_t)simple_strtoull(s, NULL, 16);
3480c880:	e3a02010 	mov	r2, #16
3480c884:	e3a01000 	mov	r1, #0
3480c888:	eb00354a 	bl	34819db8 <simple_strtoull>
		return tmp;
3480c88c:	e8bd8010 	pop	{r4, pc}
	}
	s = getenv("bootm_low");
3480c890:	e59f002c 	ldr	r0, [pc, #44]	; 3480c8c4 <getenv_bootm_size+0x58>
3480c894:	ebffee68 	bl	3480823c <getenv>
	if (s)
3480c898:	e2503000 	subs	r3, r0, #0
		tmp = (phys_size_t)simple_strtoull(s, NULL, 16);
	else
		tmp = 0;
3480c89c:	01a00003 	moveq	r0, r3
	if (s) {
		tmp = (phys_size_t)simple_strtoull(s, NULL, 16);
		return tmp;
	}
	s = getenv("bootm_low");
	if (s)
3480c8a0:	0a000002 	beq	3480c8b0 <getenv_bootm_size+0x44>
		tmp = (phys_size_t)simple_strtoull(s, NULL, 16);
3480c8a4:	e1a01004 	mov	r1, r4
3480c8a8:	e3a02010 	mov	r2, #16
3480c8ac:	eb003541 	bl	34819db8 <simple_strtoull>
	else
		tmp = 0;


#if defined(CONFIG_ARM)
	return gd->bd->bi_dram[0].size - tmp;
3480c8b0:	e5983000 	ldr	r3, [r8]
3480c8b4:	e593301c 	ldr	r3, [r3, #28]
3480c8b8:	e0600003 	rsb	r0, r0, r3
#else
	return gd->bd->bi_memsize - tmp;
#endif
}
3480c8bc:	e8bd8010 	pop	{r4, pc}
3480c8c0:	34826260 	.word	0x34826260
3480c8c4:	34826256 	.word	0x34826256

3480c8c8 <getenv_bootm_mapsize>:

phys_size_t getenv_bootm_mapsize(void)
{
3480c8c8:	e92d4010 	push	{r4, lr}
	phys_size_t tmp;
	char *s = getenv("bootm_mapsize");
3480c8cc:	e59f0020 	ldr	r0, [pc, #32]	; 3480c8f4 <getenv_bootm_mapsize+0x2c>
3480c8d0:	ebffee59 	bl	3480823c <getenv>
	if (s) {
3480c8d4:	e3500000 	cmp	r0, #0
3480c8d8:	0a000003 	beq	3480c8ec <getenv_bootm_mapsize+0x24>
		tmp = (phys_size_t)simple_strtoull(s, NULL, 16);
3480c8dc:	e3a02010 	mov	r2, #16
3480c8e0:	e3a01000 	mov	r1, #0
3480c8e4:	eb003533 	bl	34819db8 <simple_strtoull>
#if defined(CONFIG_SYS_BOOTMAPSZ)
	return CONFIG_SYS_BOOTMAPSZ;
#else
	return getenv_bootm_size();
#endif
}
3480c8e8:	e8bd8010 	pop	{r4, pc}
3480c8ec:	e8bd4010 	pop	{r4, lr}
	}

#if defined(CONFIG_SYS_BOOTMAPSZ)
	return CONFIG_SYS_BOOTMAPSZ;
#else
	return getenv_bootm_size();
3480c8f0:	eaffffdd 	b	3480c86c <getenv_bootm_size>
3480c8f4:	3482626b 	.word	0x3482626b

3480c8f8 <memmove_wd>:
#endif
}

void memmove_wd(void *to, void *from, size_t len, ulong chunksz)
{
	if (to == from)
3480c8f8:	e1510000 	cmp	r1, r0
3480c8fc:	012fff1e 	bxeq	lr
		to += tail;
		from += tail;
		len -= tail;
	}
#else	/* !(CONFIG_HW_WATCHDOG || CONFIG_WATCHDOG) */
	memmove(to, from, len);
3480c900:	ea00317f 	b	34818f04 <memmove>

3480c904 <genimg_print_size>:
#endif	/* CONFIG_HW_WATCHDOG || CONFIG_WATCHDOG */
}
#endif /* !USE_HOSTCC */

void genimg_print_size(uint32_t size)
{
3480c904:	e92d4010 	push	{r4, lr}
3480c908:	e1a04000 	mov	r4, r0
#ifndef USE_HOSTCC
	printf("%d Bytes = ", size);
3480c90c:	e1a01004 	mov	r1, r4
3480c910:	e59f0014 	ldr	r0, [pc, #20]	; 3480c92c <genimg_print_size+0x28>
3480c914:	ebfff18c 	bl	34808f4c <printf>
	print_size(size, "\n");
3480c918:	e59f2010 	ldr	r2, [pc, #16]	; 3480c930 <genimg_print_size+0x2c>
3480c91c:	e1a00004 	mov	r0, r4
3480c920:	e3a01000 	mov	r1, #0
#else
	printf("%d Bytes = %.2f kB = %.2f MB\n",
			size, (double)size / 1.024e3,
			(double)size / 1.048576e6);
#endif
}
3480c924:	e8bd4010 	pop	{r4, lr}

void genimg_print_size(uint32_t size)
{
#ifndef USE_HOSTCC
	printf("%d Bytes = ", size);
	print_size(size, "\n");
3480c928:	ea0029ee 	b	348170e8 <print_size>
3480c92c:	34826279 	.word	0x34826279
3480c930:	348260f7 	.word	0x348260f7

3480c934 <get_table_entry_name>:
 * returns:
 *     long entry name if translation succeeds
 *     msg otherwise
 */
char *get_table_entry_name(const table_entry_t *table, char *msg, int id)
{
3480c934:	e1a03000 	mov	r3, r0
	for (; table->id >= 0; ++table) {
3480c938:	ea000003 	b	3480c94c <get_table_entry_name+0x18>
		if (table->id == id)
3480c93c:	e1500002 	cmp	r0, r2
#if defined(USE_HOSTCC) || !defined(CONFIG_NEEDS_MANUAL_RELOC)
			return table->lname;
3480c940:	05931008 	ldreq	r1, [r3, #8]
3480c944:	0a000003 	beq	3480c958 <get_table_entry_name+0x24>
 *     long entry name if translation succeeds
 *     msg otherwise
 */
char *get_table_entry_name(const table_entry_t *table, char *msg, int id)
{
	for (; table->id >= 0; ++table) {
3480c948:	e283300c 	add	r3, r3, #12
3480c94c:	e5930000 	ldr	r0, [r3]
3480c950:	e3500000 	cmp	r0, #0
3480c954:	aafffff8 	bge	3480c93c <get_table_entry_name+0x8>
#else
			return table->lname + gd->reloc_off;
#endif
	}
	return (msg);
}
3480c958:	e1a00001 	mov	r0, r1
3480c95c:	e12fff1e 	bx	lr

3480c960 <genimg_get_os_name>:

const char *genimg_get_os_name(uint8_t os)
{
3480c960:	e1a02000 	mov	r2, r0
	return (get_table_entry_name(uimage_os, "Unknown OS", os));
3480c964:	e59f1004 	ldr	r1, [pc, #4]	; 3480c970 <genimg_get_os_name+0x10>
3480c968:	e59f0004 	ldr	r0, [pc, #4]	; 3480c974 <genimg_get_os_name+0x14>
3480c96c:	eafffff0 	b	3480c934 <get_table_entry_name>
3480c970:	34826285 	.word	0x34826285
3480c974:	34821450 	.word	0x34821450

3480c978 <genimg_get_arch_name>:
}

const char *genimg_get_arch_name(uint8_t arch)
{
3480c978:	e1a02000 	mov	r2, r0
	return (get_table_entry_name(uimage_arch, "Unknown Architecture",
3480c97c:	e59f1004 	ldr	r1, [pc, #4]	; 3480c988 <genimg_get_arch_name+0x10>
3480c980:	e59f0004 	ldr	r0, [pc, #4]	; 3480c98c <genimg_get_arch_name+0x14>
3480c984:	eaffffea 	b	3480c934 <get_table_entry_name>
3480c988:	34826290 	.word	0x34826290
3480c98c:	348214a4 	.word	0x348214a4

3480c990 <genimg_get_type_name>:
					arch));
}

const char *genimg_get_type_name(uint8_t type)
{
3480c990:	e1a02000 	mov	r2, r0
	return (get_table_entry_name(uimage_type, "Unknown Image", type));
3480c994:	e59f1004 	ldr	r1, [pc, #4]	; 3480c9a0 <genimg_get_type_name+0x10>
3480c998:	e59f0004 	ldr	r0, [pc, #4]	; 3480c9a4 <genimg_get_type_name+0x14>
3480c99c:	eaffffe4 	b	3480c934 <get_table_entry_name>
3480c9a0:	348262a5 	.word	0x348262a5
3480c9a4:	348215a0 	.word	0x348215a0

3480c9a8 <genimg_get_comp_name>:
}

const char *genimg_get_comp_name(uint8_t comp)
{
3480c9a8:	e1a02000 	mov	r2, r0
	return (get_table_entry_name(uimage_comp, "Unknown Compression",
3480c9ac:	e59f1004 	ldr	r1, [pc, #4]	; 3480c9b8 <genimg_get_comp_name+0x10>
3480c9b0:	e59f0004 	ldr	r0, [pc, #4]	; 3480c9bc <genimg_get_comp_name+0x14>
3480c9b4:	eaffffde 	b	3480c934 <get_table_entry_name>
3480c9b8:	348262b3 	.word	0x348262b3
3480c9bc:	3482166c 	.word	0x3482166c

3480c9c0 <image_print_contents>:
 *
 * returns:
 *     no returned results
 */
void image_print_contents(const void *ptr)
{
3480c9c0:	e92d44ff 	push	{r0, r1, r2, r3, r4, r5, r6, r7, sl, lr}
3480c9c4:	e1a04000 	mov	r4, r0
	p = "";
#else
	p = "   ";
#endif

	printf("%sImage Name:   %.*s\n", p, IH_NMLEN, image_get_name(hdr));
3480c9c8:	e3a02020 	mov	r2, #32
3480c9cc:	e0843002 	add	r3, r4, r2
3480c9d0:	e59f1138 	ldr	r1, [pc, #312]	; 3480cb10 <image_print_contents+0x150>
3480c9d4:	e59f0138 	ldr	r0, [pc, #312]	; 3480cb14 <image_print_contents+0x154>
3480c9d8:	ebfff15b 	bl	34808f4c <printf>
#if defined(CONFIG_TIMESTAMP) || defined(CONFIG_CMD_DATE) || defined(USE_HOSTCC)
	printf("%sCreated:      ", p);
	genimg_print_time((time_t)image_get_time(hdr));
#endif
	printf("%sImage Type:   ", p);
3480c9dc:	e59f112c 	ldr	r1, [pc, #300]	; 3480cb10 <image_print_contents+0x150>
3480c9e0:	e59f0130 	ldr	r0, [pc, #304]	; 3480cb18 <image_print_contents+0x158>
3480c9e4:	ebfff158 	bl	34808f4c <printf>

static void image_print_type(const image_header_t *hdr)
{
	const char *os, *arch, *type, *comp;

	os = genimg_get_os_name(image_get_os(hdr));
3480c9e8:	e5d4001c 	ldrb	r0, [r4, #28]
3480c9ec:	ebffffdb 	bl	3480c960 <genimg_get_os_name>
3480c9f0:	e1a06000 	mov	r6, r0
	arch = genimg_get_arch_name(image_get_arch(hdr));
3480c9f4:	e5d4001d 	ldrb	r0, [r4, #29]
3480c9f8:	ebffffde 	bl	3480c978 <genimg_get_arch_name>
3480c9fc:	e1a07000 	mov	r7, r0
	type = genimg_get_type_name(image_get_type(hdr));
3480ca00:	e5d4001e 	ldrb	r0, [r4, #30]
3480ca04:	ebffffe1 	bl	3480c990 <genimg_get_type_name>
3480ca08:	e1a05000 	mov	r5, r0
	comp = genimg_get_comp_name(image_get_comp(hdr));
3480ca0c:	e5d4001f 	ldrb	r0, [r4, #31]
3480ca10:	ebffffe4 	bl	3480c9a8 <genimg_get_comp_name>

	printf("%s %s %s (%s)\n", arch, os, type, comp);
3480ca14:	e1a03005 	mov	r3, r5
3480ca18:	e1a02006 	mov	r2, r6
3480ca1c:	e58d0000 	str	r0, [sp]
3480ca20:	e1a01007 	mov	r1, r7
3480ca24:	e59f00f0 	ldr	r0, [pc, #240]	; 3480cb1c <image_print_contents+0x15c>
3480ca28:	ebfff147 	bl	34808f4c <printf>
	printf("%sCreated:      ", p);
	genimg_print_time((time_t)image_get_time(hdr));
#endif
	printf("%sImage Type:   ", p);
	image_print_type(hdr);
	printf("%sData Size:    ", p);
3480ca2c:	e59f10dc 	ldr	r1, [pc, #220]	; 3480cb10 <image_print_contents+0x150>
3480ca30:	e59f00e8 	ldr	r0, [pc, #232]	; 3480cb20 <image_print_contents+0x160>
3480ca34:	ebfff144 	bl	34808f4c <printf>
	genimg_print_size(image_get_data_size(hdr));
3480ca38:	e594000c 	ldr	r0, [r4, #12]
3480ca3c:	ebffff26 	bl	3480c6dc <image_get_data_size.clone.10>
3480ca40:	ebffffaf 	bl	3480c904 <genimg_print_size>
	}
image_get_hdr_l(magic)		/* image_get_magic */
image_get_hdr_l(hcrc)		/* image_get_hcrc */
image_get_hdr_l(time)		/* image_get_time */
image_get_hdr_l(size)		/* image_get_size */
image_get_hdr_l(load)		/* image_get_load */
3480ca44:	e5940010 	ldr	r0, [r4, #16]
3480ca48:	ebffff19 	bl	3480c6b4 <__fswab32>
	printf("%sLoad Address: %08x\n", p, image_get_load(hdr));
3480ca4c:	e59f10bc 	ldr	r1, [pc, #188]	; 3480cb10 <image_print_contents+0x150>
3480ca50:	e1a02000 	mov	r2, r0
3480ca54:	e59f00c8 	ldr	r0, [pc, #200]	; 3480cb24 <image_print_contents+0x164>
3480ca58:	ebfff13b 	bl	34808f4c <printf>
image_get_hdr_l(ep)		/* image_get_ep */
3480ca5c:	e5940014 	ldr	r0, [r4, #20]
3480ca60:	ebffff13 	bl	3480c6b4 <__fswab32>
	printf("%sEntry Point:  %08x\n", p, image_get_ep(hdr));
3480ca64:	e59f10a4 	ldr	r1, [pc, #164]	; 3480cb10 <image_print_contents+0x150>
3480ca68:	e1a02000 	mov	r2, r0
3480ca6c:	e59f00b4 	ldr	r0, [pc, #180]	; 3480cb28 <image_print_contents+0x168>
3480ca70:	ebfff135 	bl	34808f4c <printf>

	return 0;

error:
	return -1;
}
3480ca74:	e5d4301e 	ldrb	r3, [r4, #30]
	printf("%sData Size:    ", p);
	genimg_print_size(image_get_data_size(hdr));
	printf("%sLoad Address: %08x\n", p, image_get_load(hdr));
	printf("%sEntry Point:  %08x\n", p, image_get_ep(hdr));

	if (image_check_type(hdr, IH_TYPE_MULTI) ||
3480ca78:	e3530004 	cmp	r3, #4
3480ca7c:	0a000001 	beq	3480ca88 <image_print_contents+0xc8>
3480ca80:	e3530006 	cmp	r3, #6
3480ca84:	1a000020 	bne	3480cb0c <image_print_contents+0x14c>
			image_check_type(hdr, IH_TYPE_SCRIPT)) {
		int i;
		ulong data, len;
		ulong count = image_multi_count(hdr);
3480ca88:	e1a00004 	mov	r0, r4
3480ca8c:	ebffff37 	bl	3480c770 <image_multi_count>

		printf("%sContents:\n", p);
3480ca90:	e59f1078 	ldr	r1, [pc, #120]	; 3480cb10 <image_print_contents+0x150>

	if (image_check_type(hdr, IH_TYPE_MULTI) ||
			image_check_type(hdr, IH_TYPE_SCRIPT)) {
		int i;
		ulong data, len;
		ulong count = image_multi_count(hdr);
3480ca94:	e1a06000 	mov	r6, r0

		printf("%sContents:\n", p);
3480ca98:	e59f008c 	ldr	r0, [pc, #140]	; 3480cb2c <image_print_contents+0x16c>
3480ca9c:	ebfff12a 	bl	34808f4c <printf>
		for (i = 0; i < count; i++) {
3480caa0:	e3a05000 	mov	r5, #0
			image_multi_getimg(hdr, i, &data, &len);
3480caa4:	e28d700c 	add	r7, sp, #12
3480caa8:	e28da008 	add	sl, sp, #8
		int i;
		ulong data, len;
		ulong count = image_multi_count(hdr);

		printf("%sContents:\n", p);
		for (i = 0; i < count; i++) {
3480caac:	ea000014 	b	3480cb04 <image_print_contents+0x144>
			image_multi_getimg(hdr, i, &data, &len);
3480cab0:	e1a0300a 	mov	r3, sl
3480cab4:	e1a00004 	mov	r0, r4
3480cab8:	e1a01005 	mov	r1, r5
3480cabc:	e1a02007 	mov	r2, r7
3480cac0:	ebffff32 	bl	3480c790 <image_multi_getimg>

			printf("%s   Image %d: ", p, i);
3480cac4:	e59f1044 	ldr	r1, [pc, #68]	; 3480cb10 <image_print_contents+0x150>
3480cac8:	e1a02005 	mov	r2, r5
3480cacc:	e59f005c 	ldr	r0, [pc, #92]	; 3480cb30 <image_print_contents+0x170>
3480cad0:	ebfff11d 	bl	34808f4c <printf>
			genimg_print_size(len);
3480cad4:	e59d0008 	ldr	r0, [sp, #8]
3480cad8:	ebffff89 	bl	3480c904 <genimg_print_size>

			if (image_check_type(hdr, IH_TYPE_SCRIPT) && i > 0) {
3480cadc:	e5d4301e 	ldrb	r3, [r4, #30]
3480cae0:	e3530006 	cmp	r3, #6
3480cae4:	1a000005 	bne	3480cb00 <image_print_contents+0x140>
3480cae8:	e3550000 	cmp	r5, #0
3480caec:	0a000003 	beq	3480cb00 <image_print_contents+0x140>
				/*
				 * the user may need to know offsets
				 * if planning to do something with
				 * multiple files
				 */
				printf("%s    Offset = 0x%08lx\n", p, data);
3480caf0:	e59f003c 	ldr	r0, [pc, #60]	; 3480cb34 <image_print_contents+0x174>
3480caf4:	e59f1014 	ldr	r1, [pc, #20]	; 3480cb10 <image_print_contents+0x150>
3480caf8:	e59d200c 	ldr	r2, [sp, #12]
3480cafc:	ebfff112 	bl	34808f4c <printf>
		int i;
		ulong data, len;
		ulong count = image_multi_count(hdr);

		printf("%sContents:\n", p);
		for (i = 0; i < count; i++) {
3480cb00:	e2855001 	add	r5, r5, #1
3480cb04:	e1550006 	cmp	r5, r6
3480cb08:	3affffe8 	bcc	3480cab0 <image_print_contents+0xf0>
				 */
				printf("%s    Offset = 0x%08lx\n", p, data);
			}
		}
	}
}
3480cb0c:	e8bd84ff 	pop	{r0, r1, r2, r3, r4, r5, r6, r7, sl, pc}
3480cb10:	3482630a 	.word	0x3482630a
3480cb14:	348262c7 	.word	0x348262c7
3480cb18:	348262dd 	.word	0x348262dd
3480cb1c:	348262ee 	.word	0x348262ee
3480cb20:	348262fd 	.word	0x348262fd
3480cb24:	3482630e 	.word	0x3482630e
3480cb28:	34826324 	.word	0x34826324
3480cb2c:	3482633a 	.word	0x3482633a
3480cb30:	34826347 	.word	0x34826347
3480cb34:	34826357 	.word	0x34826357

3480cb38 <get_table_entry_id>:
 *     entry id if translation succeeds
 *     -1 otherwise
 */
int get_table_entry_id(const table_entry_t *table,
		const char *table_name, const char *name)
{
3480cb38:	e92d4038 	push	{r3, r4, r5, lr}
3480cb3c:	e1a05002 	mov	r5, r2
		fprintf(stderr, "%c %s", (first) ? ':' : ',', t->sname);
		first = 0;
	}
	fprintf(stderr, "\n");
#else
	for (t = table; t->id >= 0; ++t) {
3480cb40:	e1a04000 	mov	r4, r0
3480cb44:	ea000009 	b	3480cb70 <get_table_entry_id+0x38>
#ifdef CONFIG_NEEDS_MANUAL_RELOC
		if (t->sname && strcmp(t->sname + gd->reloc_off, name) == 0)
#else
		if (t->sname && strcmp(t->sname, name) == 0)
3480cb48:	e5940004 	ldr	r0, [r4, #4]
3480cb4c:	e3500000 	cmp	r0, #0
3480cb50:	0a000005 	beq	3480cb6c <get_table_entry_id+0x34>
3480cb54:	e1a01005 	mov	r1, r5
3480cb58:	eb002fd4 	bl	34818ab0 <strcmp>
3480cb5c:	e3500000 	cmp	r0, #0
3480cb60:	1a000001 	bne	3480cb6c <get_table_entry_id+0x34>
#endif
			return (t->id);
3480cb64:	e5940000 	ldr	r0, [r4]
3480cb68:	e8bd8038 	pop	{r3, r4, r5, pc}
		fprintf(stderr, "%c %s", (first) ? ':' : ',', t->sname);
		first = 0;
	}
	fprintf(stderr, "\n");
#else
	for (t = table; t->id >= 0; ++t) {
3480cb6c:	e284400c 	add	r4, r4, #12
3480cb70:	e5943000 	ldr	r3, [r4]
3480cb74:	e3530000 	cmp	r3, #0
3480cb78:	aafffff2 	bge	3480cb48 <get_table_entry_id+0x10>
#endif
			return (t->id);
	}
	debug("Invalid %s Type: %s\n", table_name, name);
#endif /* USE_HOSTCC */
	return (-1);
3480cb7c:	e3e00000 	mvn	r0, #0
}
3480cb80:	e8bd8038 	pop	{r3, r4, r5, pc}

3480cb84 <genimg_get_os_id>:

int genimg_get_os_id(const char *name)
{
3480cb84:	e1a02000 	mov	r2, r0
	return (get_table_entry_id(uimage_os, "OS", name));
3480cb88:	e59f1004 	ldr	r1, [pc, #4]	; 3480cb94 <genimg_get_os_id+0x10>
3480cb8c:	e59f0004 	ldr	r0, [pc, #4]	; 3480cb98 <genimg_get_os_id+0x14>
3480cb90:	eaffffe8 	b	3480cb38 <get_table_entry_id>
3480cb94:	3482678a 	.word	0x3482678a
3480cb98:	34821450 	.word	0x34821450

3480cb9c <genimg_get_arch_id>:
}

int genimg_get_arch_id(const char *name)
{
3480cb9c:	e1a02000 	mov	r2, r0
	return (get_table_entry_id(uimage_arch, "CPU", name));
3480cba0:	e59f1004 	ldr	r1, [pc, #4]	; 3480cbac <genimg_get_arch_id+0x10>
3480cba4:	e59f0004 	ldr	r0, [pc, #4]	; 3480cbb0 <genimg_get_arch_id+0x14>
3480cba8:	eaffffe2 	b	3480cb38 <get_table_entry_id>
3480cbac:	348230ca 	.word	0x348230ca
3480cbb0:	348214a4 	.word	0x348214a4

3480cbb4 <genimg_get_type_id>:
}

int genimg_get_type_id(const char *name)
{
3480cbb4:	e1a02000 	mov	r2, r0
	return (get_table_entry_id(uimage_type, "Image", name));
3480cbb8:	e59f1004 	ldr	r1, [pc, #4]	; 3480cbc4 <genimg_get_type_id+0x10>
3480cbbc:	e59f0004 	ldr	r0, [pc, #4]	; 3480cbc8 <genimg_get_type_id+0x14>
3480cbc0:	eaffffdc 	b	3480cb38 <get_table_entry_id>
3480cbc4:	348265cd 	.word	0x348265cd
3480cbc8:	348215a0 	.word	0x348215a0

3480cbcc <genimg_get_comp_id>:
}

int genimg_get_comp_id(const char *name)
{
3480cbcc:	e1a02000 	mov	r2, r0
	return (get_table_entry_id(uimage_comp, "Compression", name));
3480cbd0:	e59f1004 	ldr	r1, [pc, #4]	; 3480cbdc <genimg_get_comp_id+0x10>
3480cbd4:	e59f0004 	ldr	r0, [pc, #4]	; 3480cbe0 <genimg_get_comp_id+0x14>
3480cbd8:	eaffffd6 	b	3480cb38 <get_table_entry_id>
3480cbdc:	348262bb 	.word	0x348262bb
3480cbe0:	3482166c 	.word	0x3482166c

3480cbe4 <genimg_get_format>:
 *
 * returns:
 *     image format type or IMAGE_FORMAT_INVALID if no image is present
 */
int genimg_get_format(void *img_addr)
{
3480cbe4:	e92d4008 	push	{r3, lr}
#if defined(CONFIG_FIT) || defined(CONFIG_OF_LIBFDT)
	char *fit_hdr;
#endif

	hdr = (const image_header_t *)img_addr;
	if (image_check_magic(hdr))
3480cbe8:	e5900000 	ldr	r0, [r0]
3480cbec:	ebfffeb2 	bl	3480c6bc <image_check_magic.clone.8>
			format = IMAGE_FORMAT_FIT;
	}
#endif

	return format;
}
3480cbf0:	e2500000 	subs	r0, r0, #0
3480cbf4:	13a00001 	movne	r0, #1
3480cbf8:	e8bd8008 	pop	{r3, pc}

3480cbfc <genimg_get_image>:

	}
#endif /* CONFIG_HAS_DATAFLASH */

	return ram_addr;
}
3480cbfc:	e12fff1e 	bx	lr

3480cc00 <genimg_has_config>:
#if defined(CONFIG_FIT)
	if (images->fit_uname_cfg)
		return 1;
#endif
	return 0;
}
3480cc00:	e3a00000 	mov	r0, #0
3480cc04:	e12fff1e 	bx	lr

3480cc08 <boot_get_ramdisk>:
 *     1, if ramdisk image is found but corrupted, or invalid
 *     rd_start and rd_end are set to 0 if no ramdisk exists
 */
int boot_get_ramdisk(int argc, char * const argv[], bootm_headers_t *images,
		uint8_t arch, ulong *rd_start, ulong *rd_end)
{
3480cc08:	e92d46f7 	push	{r0, r1, r2, r4, r5, r6, r7, r9, sl, lr}
3480cc0c:	e59d7028 	ldr	r7, [sp, #40]	; 0x28
3480cc10:	e59d502c 	ldr	r5, [sp, #44]	; 0x2c
	int		cfg_noffset;
	const void	*data;
	size_t		size;
#endif

	*rd_start = 0;
3480cc14:	e3a09000 	mov	r9, #0

	/*
	 * Look for a '-' which indicates to ignore the
	 * ramdisk argument
	 */
	if ((argc >= 3) && (strcmp(argv[2], "-") ==  0)) {
3480cc18:	e3500002 	cmp	r0, #2
	int		cfg_noffset;
	const void	*data;
	size_t		size;
#endif

	*rd_start = 0;
3480cc1c:	e5879000 	str	r9, [r7]
 *     1, if ramdisk image is found but corrupted, or invalid
 *     rd_start and rd_end are set to 0 if no ramdisk exists
 */
int boot_get_ramdisk(int argc, char * const argv[], bootm_headers_t *images,
		uint8_t arch, ulong *rd_start, ulong *rd_end)
{
3480cc20:	e1a06001 	mov	r6, r1
3480cc24:	e1a04002 	mov	r4, r2
3480cc28:	e1a0a003 	mov	sl, r3
	const void	*data;
	size_t		size;
#endif

	*rd_start = 0;
	*rd_end = 0;
3480cc2c:	e5859000 	str	r9, [r5]

	/*
	 * Look for a '-' which indicates to ignore the
	 * ramdisk argument
	 */
	if ((argc >= 3) && (strcmp(argv[2], "-") ==  0)) {
3480cc30:	da000006 	ble	3480cc50 <boot_get_ramdisk+0x48>
3480cc34:	e5910008 	ldr	r0, [r1, #8]
3480cc38:	e59f11d0 	ldr	r1, [pc, #464]	; 3480ce10 <boot_get_ramdisk+0x208>
3480cc3c:	eb002f9b 	bl	34818ab0 <strcmp>
3480cc40:	e3500000 	cmp	r0, #0
		debug("## Skipping init Ramdisk\n");
		rd_len = rd_data = 0;
3480cc44:	058d0004 	streq	r0, [sp, #4]

	/*
	 * Look for a '-' which indicates to ignore the
	 * ramdisk argument
	 */
	if ((argc >= 3) && (strcmp(argv[2], "-") ==  0)) {
3480cc48:	0a000044 	beq	3480cd60 <boot_get_ramdisk+0x158>
3480cc4c:	ea000065 	b	3480cde8 <boot_get_ramdisk+0x1e0>
				puts("Wrong Ramdisk Image Format\n");
				rd_data = rd_len = rd_load = 0;
				return 1;
			}
		}
	} else if (images->legacy_hdr_valid &&
3480cc50:	e5923044 	ldr	r3, [r2, #68]	; 0x44
3480cc54:	e3530000 	cmp	r3, #0
3480cc58:	1a000046 	bne	3480cd78 <boot_get_ramdisk+0x170>
3480cc5c:	ea000053 	b	3480cdb0 <boot_get_ramdisk+0x1a8>
		 * address provided in the second bootm argument
		 * check image type, for FIT images get FIT node.
		 */
		switch (genimg_get_format((void *)rd_addr)) {
		case IMAGE_FORMAT_LEGACY:
			printf("## Loading init Ramdisk from Legacy "
3480cc60:	e1a01006 	mov	r1, r6
3480cc64:	e59f01a8 	ldr	r0, [pc, #424]	; 3480ce14 <boot_get_ramdisk+0x20c>
3480cc68:	ebfff0b7 	bl	34808f4c <printf>
3480cc6c:	e3a00009 	mov	r0, #9
3480cc70:	eb00012c 	bl	3480d128 <__show_boot_progress>
static const image_header_t *image_get_ramdisk(ulong rd_addr, uint8_t arch,
						int verify)
{
	const image_header_t *rd_hdr = (const image_header_t *)rd_addr;

	if (!image_check_magic(rd_hdr)) {
3480cc74:	e5960000 	ldr	r0, [r6]
3480cc78:	ebfffe8f 	bl	3480c6bc <image_check_magic.clone.8>
3480cc7c:	e3500000 	cmp	r0, #0
		case IMAGE_FORMAT_LEGACY:
			printf("## Loading init Ramdisk from Legacy "
					"Image at %08lx ...\n", rd_addr);

			bootstage_mark(BOOTSTAGE_ID_CHECK_RAMDISK);
			rd_hdr = image_get_ramdisk(rd_addr, arch,
3480cc80:	e5944084 	ldr	r4, [r4, #132]	; 0x84
static const image_header_t *image_get_ramdisk(ulong rd_addr, uint8_t arch,
						int verify)
{
	const image_header_t *rd_hdr = (const image_header_t *)rd_addr;

	if (!image_check_magic(rd_hdr)) {
3480cc84:	1a000003 	bne	3480cc98 <boot_get_ramdisk+0x90>
		puts("Bad Magic Number\n");
3480cc88:	e59f0188 	ldr	r0, [pc, #392]	; 3480ce18 <boot_get_ramdisk+0x210>
3480cc8c:	ebfff0a4 	bl	34808f24 <puts>
	return 0;
}

static inline ulong bootstage_error(enum bootstage_id id)
{
	show_boot_progress(-id);
3480cc90:	e3e00009 	mvn	r0, #9
3480cc94:	ea000006 	b	3480ccb4 <boot_get_ramdisk+0xac>
		bootstage_error(BOOTSTAGE_ID_RD_MAGIC);
		return NULL;
	}

	if (!image_check_hcrc(rd_hdr)) {
3480cc98:	e1a00006 	mov	r0, r6
3480cc9c:	ebfffe8f 	bl	3480c6e0 <image_check_hcrc>
3480cca0:	e3500000 	cmp	r0, #0
3480cca4:	1a000004 	bne	3480ccbc <boot_get_ramdisk+0xb4>
		puts("Bad Header Checksum\n");
3480cca8:	e59f016c 	ldr	r0, [pc, #364]	; 3480ce1c <boot_get_ramdisk+0x214>
3480ccac:	ebfff09c 	bl	34808f24 <puts>
3480ccb0:	e3e0000a 	mvn	r0, #10
3480ccb4:	eb00011b 	bl	3480d128 <__show_boot_progress>
3480ccb8:	ea000048 	b	3480cde0 <boot_get_ramdisk+0x1d8>
 * and won't even do that unless CONFIG_SHOW_BOOT_PROGRESS is defined
 */

static inline ulong bootstage_mark(enum bootstage_id id)
{
	show_boot_progress(id);
3480ccbc:	e3a0000a 	mov	r0, #10
3480ccc0:	eb000118 	bl	3480d128 <__show_boot_progress>
		bootstage_error(BOOTSTAGE_ID_RD_HDR_CHECKSUM);
		return NULL;
	}

	bootstage_mark(BOOTSTAGE_ID_RD_MAGIC);
	image_print_contents(rd_hdr);
3480ccc4:	e1a00006 	mov	r0, r6
3480ccc8:	ebffff3c 	bl	3480c9c0 <image_print_contents>

	if (verify) {
3480cccc:	e3540000 	cmp	r4, #0
3480ccd0:	0a00000b 	beq	3480cd04 <boot_get_ramdisk+0xfc>
		puts("   Verifying Checksum ... ");
3480ccd4:	e59f0144 	ldr	r0, [pc, #324]	; 3480ce20 <boot_get_ramdisk+0x218>
3480ccd8:	ebfff091 	bl	34808f24 <puts>
		if (!image_check_dcrc(rd_hdr)) {
3480ccdc:	e1a00006 	mov	r0, r6
3480cce0:	ebfffe92 	bl	3480c730 <image_check_dcrc>
3480cce4:	e3500000 	cmp	r0, #0
3480cce8:	1a000003 	bne	3480ccfc <boot_get_ramdisk+0xf4>
			puts("Bad Data CRC\n");
3480ccec:	e59f0130 	ldr	r0, [pc, #304]	; 3480ce24 <boot_get_ramdisk+0x21c>
3480ccf0:	ebfff08b 	bl	34808f24 <puts>
	return 0;
}

static inline ulong bootstage_error(enum bootstage_id id)
{
	show_boot_progress(-id);
3480ccf4:	e3e0000b 	mvn	r0, #11
3480ccf8:	eaffffed 	b	3480ccb4 <boot_get_ramdisk+0xac>
			bootstage_error(BOOTSTAGE_ID_RD_CHECKSUM);
			return NULL;
		}
		puts("OK\n");
3480ccfc:	e59f0124 	ldr	r0, [pc, #292]	; 3480ce28 <boot_get_ramdisk+0x220>
3480cd00:	ebfff087 	bl	34808f24 <puts>
 * and won't even do that unless CONFIG_SHOW_BOOT_PROGRESS is defined
 */

static inline ulong bootstage_mark(enum bootstage_id id)
{
	show_boot_progress(id);
3480cd04:	e3a0000b 	mov	r0, #11
3480cd08:	eb000106 	bl	3480d128 <__show_boot_progress>
	}

	bootstage_mark(BOOTSTAGE_ID_RD_HDR_CHECKSUM);

	if (!image_check_os(rd_hdr, IH_OS_LINUX) ||
3480cd0c:	e5d6301c 	ldrb	r3, [r6, #28]
3480cd10:	e3530005 	cmp	r3, #5
3480cd14:	1a000005 	bne	3480cd30 <boot_get_ramdisk+0x128>
3480cd18:	e5d6301d 	ldrb	r3, [r6, #29]
3480cd1c:	e153000a 	cmp	r3, sl
3480cd20:	1a000002 	bne	3480cd30 <boot_get_ramdisk+0x128>
	    !image_check_arch(rd_hdr, arch) ||
3480cd24:	e5d6301e 	ldrb	r3, [r6, #30]
3480cd28:	e3530003 	cmp	r3, #3
3480cd2c:	0a000007 	beq	3480cd50 <boot_get_ramdisk+0x148>
	    !image_check_type(rd_hdr, IH_TYPE_RAMDISK)) {
		printf("No Linux %s Ramdisk Image\n",
3480cd30:	e1a0000a 	mov	r0, sl
3480cd34:	ebffff0f 	bl	3480c978 <genimg_get_arch_name>
3480cd38:	e1a01000 	mov	r1, r0
3480cd3c:	e59f00e8 	ldr	r0, [pc, #232]	; 3480ce2c <boot_get_ramdisk+0x224>
3480cd40:	ebfff081 	bl	34808f4c <printf>
	return 0;
}

static inline ulong bootstage_error(enum bootstage_id id)
{
	show_boot_progress(-id);
3480cd44:	e3e0000c 	mvn	r0, #12
3480cd48:	eb0000f6 	bl	3480d128 <__show_boot_progress>
3480cd4c:	ea000007 	b	3480cd70 <boot_get_ramdisk+0x168>
 * returns:
 *     image payload data start address
 */
static inline ulong image_get_data(const image_header_t *hdr)
{
	return ((ulong)hdr + image_get_header_size());
3480cd50:	e2863040 	add	r3, r6, #64	; 0x40

			if (rd_hdr == NULL)
				return 1;

			rd_data = image_get_data(rd_hdr);
			rd_len = image_get_data_size(rd_hdr);
3480cd54:	e596000c 	ldr	r0, [r6, #12]
							images->verify);

			if (rd_hdr == NULL)
				return 1;

			rd_data = image_get_data(rd_hdr);
3480cd58:	e58d3004 	str	r3, [sp, #4]
			rd_len = image_get_data_size(rd_hdr);
3480cd5c:	ebfffe5e 	bl	3480c6dc <image_get_data_size.clone.10>
3480cd60:	e58d0000 	str	r0, [sp]
				puts("Wrong Ramdisk Image Format\n");
				rd_data = rd_len = rd_load = 0;
				return 1;
			}
		}
	} else if (images->legacy_hdr_valid &&
3480cd64:	ea000016 	b	3480cdc4 <boot_get_ramdisk+0x1bc>
				rd_len = simple_strtoul(++end, NULL, 16);
				rd_data = rd_addr;
			} else
#endif
			{
				puts("Wrong Ramdisk Image Format\n");
3480cd68:	e59f00c0 	ldr	r0, [pc, #192]	; 3480ce30 <boot_get_ramdisk+0x228>
3480cd6c:	ebfff06c 	bl	34808f24 <puts>
				rd_data = rd_len = rd_load = 0;
				return 1;
3480cd70:	e3a09001 	mov	r9, #1
3480cd74:	ea000019 	b	3480cde0 <boot_get_ramdisk+0x1d8>
			}
		}
	} else if (images->legacy_hdr_valid &&
3480cd78:	e5d23022 	ldrb	r3, [r2, #34]	; 0x22
3480cd7c:	e3530004 	cmp	r3, #4
3480cd80:	1a00000a 	bne	3480cdb0 <boot_get_ramdisk+0x1a8>
 * and won't even do that unless CONFIG_SHOW_BOOT_PROGRESS is defined
 */

static inline ulong bootstage_mark(enum bootstage_id id)
{
	show_boot_progress(id);
3480cd84:	e3a0000d 	mov	r0, #13
3480cd88:	eb0000e6 	bl	3480d128 <__show_boot_progress>
		/*
		 * Now check if we have a legacy mult-component image,
		 * get second entry data start address and len.
		 */
		bootstage_mark(BOOTSTAGE_ID_RAMDISK);
		printf("## Loading init Ramdisk from multi component "
3480cd8c:	e5941000 	ldr	r1, [r4]
3480cd90:	e59f009c 	ldr	r0, [pc, #156]	; 3480ce34 <boot_get_ramdisk+0x22c>
3480cd94:	ebfff06c 	bl	34808f4c <printf>
				"Legacy Image at %08lx ...\n",
				(ulong)images->legacy_hdr_os);

		image_multi_getimg(images->legacy_hdr_os, 1, &rd_data, &rd_len);
3480cd98:	e5940000 	ldr	r0, [r4]
3480cd9c:	e3a01001 	mov	r1, #1
3480cda0:	e28d2004 	add	r2, sp, #4
3480cda4:	e1a0300d 	mov	r3, sp
3480cda8:	ebfffe78 	bl	3480c790 <image_multi_getimg>
3480cdac:	ea000004 	b	3480cdc4 <boot_get_ramdisk+0x1bc>
3480cdb0:	e3a0000e 	mov	r0, #14
3480cdb4:	eb0000db 	bl	3480d128 <__show_boot_progress>
	} else {
		/*
		 * no initrd image
		 */
		bootstage_mark(BOOTSTAGE_ID_NO_RAMDISK);
		rd_len = rd_data = 0;
3480cdb8:	e3a03000 	mov	r3, #0
3480cdbc:	e58d3004 	str	r3, [sp, #4]
3480cdc0:	e58d3000 	str	r3, [sp]
	}

	if (!rd_data) {
3480cdc4:	e59d9004 	ldr	r9, [sp, #4]
3480cdc8:	e3590000 	cmp	r9, #0
		debug("## No init Ramdisk\n");
	} else {
		*rd_start = rd_data;
3480cdcc:	15879000 	strne	r9, [r7]
		*rd_end = rd_data + rd_len;
3480cdd0:	159d3000 	ldrne	r3, [sp]
3480cdd4:	10839009 	addne	r9, r3, r9
3480cdd8:	15859000 	strne	r9, [r5]
	}
	debug("   ramdisk start = 0x%08lx, ramdisk end = 0x%08lx\n",
			*rd_start, *rd_end);

	return 0;
3480cddc:	13a09000 	movne	r9, #0
}
3480cde0:	e1a00009 	mov	r0, r9
3480cde4:	e8bd86fe 	pop	{r1, r2, r3, r4, r5, r6, r7, r9, sl, pc}
						"0x%08lx\n",
						fit_uname_ramdisk, rd_addr);
			} else
#endif
			{
				rd_addr = simple_strtoul(argv[2], NULL, 16);
3480cde8:	e1a01009 	mov	r1, r9
3480cdec:	e5960008 	ldr	r0, [r6, #8]
3480cdf0:	e3a02010 	mov	r2, #16
3480cdf4:	eb00337f 	bl	34819bf8 <simple_strtoul>
3480cdf8:	e1a06000 	mov	r6, r0
		/*
		 * Check if there is an initrd image at the
		 * address provided in the second bootm argument
		 * check image type, for FIT images get FIT node.
		 */
		switch (genimg_get_format((void *)rd_addr)) {
3480cdfc:	ebffff78 	bl	3480cbe4 <genimg_get_format>
3480ce00:	e3500001 	cmp	r0, #1
3480ce04:	e1a09000 	mov	r9, r0
3480ce08:	1affffd6 	bne	3480cd68 <boot_get_ramdisk+0x160>
3480ce0c:	eaffff93 	b	3480cc60 <boot_get_ramdisk+0x58>
3480ce10:	3482636f 	.word	0x3482636f
3480ce14:	34826371 	.word	0x34826371
3480ce18:	34823193 	.word	0x34823193
3480ce1c:	348231a8 	.word	0x348231a8
3480ce20:	348231bd 	.word	0x348231bd
3480ce24:	348231db 	.word	0x348231db
3480ce28:	348231e9 	.word	0x348231e9
3480ce2c:	348263a9 	.word	0x348263a9
3480ce30:	348263c4 	.word	0x348263c4
3480ce34:	348263e0 	.word	0x348263e0

3480ce38 <boot_ramdisk_high>:
 *      0 - success
 *     -1 - failure
 */
int boot_ramdisk_high(struct lmb *lmb, ulong rd_data, ulong rd_len,
		  ulong *initrd_start, ulong *initrd_end)
{
3480ce38:	e92d46f8 	push	{r3, r4, r5, r6, r7, r9, sl, lr}
3480ce3c:	e1a0a000 	mov	sl, r0
	char	*s;
	ulong	initrd_high;
	int	initrd_copy_to_ram = 1;

	if ((s = getenv("initrd_high")) != NULL) {
3480ce40:	e59f010c 	ldr	r0, [pc, #268]	; 3480cf54 <boot_ramdisk_high+0x11c>
 *      0 - success
 *     -1 - failure
 */
int boot_ramdisk_high(struct lmb *lmb, ulong rd_data, ulong rd_len,
		  ulong *initrd_start, ulong *initrd_end)
{
3480ce44:	e1a05003 	mov	r5, r3
3480ce48:	e1a04001 	mov	r4, r1
3480ce4c:	e1a06002 	mov	r6, r2
3480ce50:	e59d9020 	ldr	r9, [sp, #32]
	char	*s;
	ulong	initrd_high;
	int	initrd_copy_to_ram = 1;

	if ((s = getenv("initrd_high")) != NULL) {
3480ce54:	ebffecf8 	bl	3480823c <getenv>
3480ce58:	e3500000 	cmp	r0, #0
int boot_ramdisk_high(struct lmb *lmb, ulong rd_data, ulong rd_len,
		  ulong *initrd_start, ulong *initrd_end)
{
	char	*s;
	ulong	initrd_high;
	int	initrd_copy_to_ram = 1;
3480ce5c:	03a07001 	moveq	r7, #1
		initrd_high = simple_strtoul(s, NULL, 16);
		if (initrd_high == ~0)
			initrd_copy_to_ram = 0;
	} else {
		/* not set, no restrictions to load high */
		initrd_high = ~0;
3480ce60:	03e03000 	mvneq	r3, #0
{
	char	*s;
	ulong	initrd_high;
	int	initrd_copy_to_ram = 1;

	if ((s = getenv("initrd_high")) != NULL) {
3480ce64:	0a000005 	beq	3480ce80 <boot_ramdisk_high+0x48>
		/* a value of "no" or a similar string will act like 0,
		 * turning the "load high" feature off. This is intentional.
		 */
		initrd_high = simple_strtoul(s, NULL, 16);
3480ce68:	e3a01000 	mov	r1, #0
3480ce6c:	e3a02010 	mov	r2, #16
3480ce70:	eb003360 	bl	34819bf8 <simple_strtoul>
3480ce74:	e1a03000 	mov	r3, r0
int boot_ramdisk_high(struct lmb *lmb, ulong rd_data, ulong rd_len,
		  ulong *initrd_start, ulong *initrd_end)
{
	char	*s;
	ulong	initrd_high;
	int	initrd_copy_to_ram = 1;
3480ce78:	e2907001 	adds	r7, r0, #1
3480ce7c:	13a07001 	movne	r7, #1
#endif

	debug("## initrd_high = 0x%08lx, copy_to_ram = %d\n",
			initrd_high, initrd_copy_to_ram);

	if (rd_data) {
3480ce80:	e3540000 	cmp	r4, #0
3480ce84:	0a00002e 	beq	3480cf44 <boot_ramdisk_high+0x10c>
		if (!initrd_copy_to_ram) {	/* zero-copy ramdisk support */
3480ce88:	e3570000 	cmp	r7, #0
3480ce8c:	1a000008 	bne	3480ceb4 <boot_ramdisk_high+0x7c>
			debug("   in-place initrd\n");
			*initrd_start = rd_data;
			*initrd_end = rd_data + rd_len;
3480ce90:	e0863004 	add	r3, r6, r4
			initrd_high, initrd_copy_to_ram);

	if (rd_data) {
		if (!initrd_copy_to_ram) {	/* zero-copy ramdisk support */
			debug("   in-place initrd\n");
			*initrd_start = rd_data;
3480ce94:	e5854000 	str	r4, [r5]
			*initrd_end = rd_data + rd_len;
			lmb_reserve(lmb, rd_data, rd_len);
3480ce98:	e1a0000a 	mov	r0, sl

	if (rd_data) {
		if (!initrd_copy_to_ram) {	/* zero-copy ramdisk support */
			debug("   in-place initrd\n");
			*initrd_start = rd_data;
			*initrd_end = rd_data + rd_len;
3480ce9c:	e5893000 	str	r3, [r9]
			lmb_reserve(lmb, rd_data, rd_len);
3480cea0:	e1a01004 	mov	r1, r4
3480cea4:	e1a02006 	mov	r2, r6
3480cea8:	eb002deb 	bl	3481865c <lmb_reserve>
		*initrd_end = 0;
	}
	debug("   ramdisk load start = 0x%08lx, ramdisk load end = 0x%08lx\n",
			*initrd_start, *initrd_end);

	return 0;
3480ceac:	e1a00007 	mov	r0, r7
3480ceb0:	e8bd86f8 	pop	{r3, r4, r5, r6, r7, r9, sl, pc}
			debug("   in-place initrd\n");
			*initrd_start = rd_data;
			*initrd_end = rd_data + rd_len;
			lmb_reserve(lmb, rd_data, rd_len);
		} else {
			if (initrd_high)
3480ceb4:	e3530000 	cmp	r3, #0
3480ceb8:	0a000004 	beq	3480ced0 <boot_ramdisk_high+0x98>
				*initrd_start = (ulong)lmb_alloc_base(lmb,
3480cebc:	e1a0000a 	mov	r0, sl
3480cec0:	e1a01006 	mov	r1, r6
3480cec4:	e3a02a01 	mov	r2, #4096	; 0x1000
3480cec8:	eb002e46 	bl	348187e8 <lmb_alloc_base>
3480cecc:	ea000003 	b	3480cee0 <boot_ramdisk_high+0xa8>
						rd_len, 0x1000, initrd_high);
			else
				*initrd_start = (ulong)lmb_alloc(lmb, rd_len,
3480ced0:	e1a0000a 	mov	r0, sl
3480ced4:	e1a01006 	mov	r1, r6
3480ced8:	e3a02a01 	mov	r2, #4096	; 0x1000
3480cedc:	eb002e4e 	bl	3481881c <lmb_alloc>
3480cee0:	e5850000 	str	r0, [r5]
								 0x1000);

			if (*initrd_start == 0) {
3480cee4:	e5953000 	ldr	r3, [r5]
3480cee8:	e3530000 	cmp	r3, #0
3480ceec:	1a000003 	bne	3480cf00 <boot_ramdisk_high+0xc8>
				puts("ramdisk - allocation error\n");
3480cef0:	e59f0060 	ldr	r0, [pc, #96]	; 3480cf58 <boot_ramdisk_high+0x120>
3480cef4:	ebfff00a 	bl	34808f24 <puts>
			*initrd_start, *initrd_end);

	return 0;

error:
	return -1;
3480cef8:	e3e00000 	mvn	r0, #0
				*initrd_start = (ulong)lmb_alloc(lmb, rd_len,
								 0x1000);

			if (*initrd_start == 0) {
				puts("ramdisk - allocation error\n");
				goto error;
3480cefc:	e8bd86f8 	pop	{r3, r4, r5, r6, r7, r9, sl, pc}
3480cf00:	e3a0000c 	mov	r0, #12
3480cf04:	eb000087 	bl	3480d128 <__show_boot_progress>
			}
			bootstage_mark(BOOTSTAGE_ID_COPY_RAMDISK);

			*initrd_end = *initrd_start + rd_len;
3480cf08:	e5952000 	ldr	r2, [r5]
			printf("   Loading Ramdisk to %08lx, end %08lx ... ",
3480cf0c:	e59f0048 	ldr	r0, [pc, #72]	; 3480cf5c <boot_ramdisk_high+0x124>
				puts("ramdisk - allocation error\n");
				goto error;
			}
			bootstage_mark(BOOTSTAGE_ID_COPY_RAMDISK);

			*initrd_end = *initrd_start + rd_len;
3480cf10:	e0862002 	add	r2, r6, r2
3480cf14:	e5892000 	str	r2, [r9]
			printf("   Loading Ramdisk to %08lx, end %08lx ... ",
3480cf18:	e5951000 	ldr	r1, [r5]
3480cf1c:	ebfff00a 	bl	34808f4c <printf>
					*initrd_start, *initrd_end);

			memmove_wd((void *)*initrd_start,
3480cf20:	e5950000 	ldr	r0, [r5]
3480cf24:	e1a01004 	mov	r1, r4
3480cf28:	e1a02006 	mov	r2, r6
3480cf2c:	e3a03801 	mov	r3, #65536	; 0x10000
3480cf30:	ebfffe70 	bl	3480c8f8 <memmove_wd>
			 * AMP boot scenarios in which we might not be
			 * HW cache coherent
			 */
			flush_cache((unsigned long)*initrd_start, rd_len);
#endif
			puts("OK\n");
3480cf34:	e59f0024 	ldr	r0, [pc, #36]	; 3480cf60 <boot_ramdisk_high+0x128>
3480cf38:	ebffeff9 	bl	34808f24 <puts>
		*initrd_end = 0;
	}
	debug("   ramdisk load start = 0x%08lx, ramdisk load end = 0x%08lx\n",
			*initrd_start, *initrd_end);

	return 0;
3480cf3c:	e3a00000 	mov	r0, #0
3480cf40:	e8bd86f8 	pop	{r3, r4, r5, r6, r7, r9, sl, pc}
			flush_cache((unsigned long)*initrd_start, rd_len);
#endif
			puts("OK\n");
		}
	} else {
		*initrd_start = 0;
3480cf44:	e5854000 	str	r4, [r5]
		*initrd_end = 0;
	}
	debug("   ramdisk load start = 0x%08lx, ramdisk load end = 0x%08lx\n",
			*initrd_start, *initrd_end);

	return 0;
3480cf48:	e1a00004 	mov	r0, r4
#endif
			puts("OK\n");
		}
	} else {
		*initrd_start = 0;
		*initrd_end = 0;
3480cf4c:	e5894000 	str	r4, [r9]

	return 0;

error:
	return -1;
}
3480cf50:	e8bd86f8 	pop	{r3, r4, r5, r6, r7, r9, sl, pc}
3480cf54:	34826428 	.word	0x34826428
3480cf58:	34826434 	.word	0x34826434
3480cf5c:	34826450 	.word	0x34826450
3480cf60:	348231e9 	.word	0x348231e9

3480cf64 <delete_char>:
}

/****************************************************************************/

static char * delete_char (char *buffer, char *p, int *colp, int *np, int plen)
{
3480cf64:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
3480cf68:	e1a07003 	mov	r7, r3
	char *s;

	if (*np == 0) {
3480cf6c:	e5933000 	ldr	r3, [r3]
}

/****************************************************************************/

static char * delete_char (char *buffer, char *p, int *colp, int *np, int plen)
{
3480cf70:	e1a04000 	mov	r4, r0
	char *s;

	if (*np == 0) {
3480cf74:	e3530000 	cmp	r3, #0
}

/****************************************************************************/

static char * delete_char (char *buffer, char *p, int *colp, int *np, int plen)
{
3480cf78:	e1a05001 	mov	r5, r1
3480cf7c:	e1a06002 	mov	r6, r2
3480cf80:	e59da018 	ldr	sl, [sp, #24]
	char *s;

	if (*np == 0) {
3480cf84:	0a000028 	beq	3480d02c <delete_char+0xc8>
		return (p);
	}

	if (*(--p) == '\t') {			/* will retype the whole line	*/
3480cf88:	e5753001 	ldrb	r3, [r5, #-1]!
3480cf8c:	e3530009 	cmp	r3, #9
3480cf90:	1a00001d 	bne	3480d00c <delete_char+0xa8>
3480cf94:	ea000004 	b	3480cfac <delete_char+0x48>
		while (*colp > plen) {
			puts (erase_seq);
3480cf98:	e59f0094 	ldr	r0, [pc, #148]	; 3480d034 <delete_char+0xd0>
3480cf9c:	ebffefe0 	bl	34808f24 <puts>
			(*colp)--;
3480cfa0:	e5963000 	ldr	r3, [r6]
3480cfa4:	e2433001 	sub	r3, r3, #1
3480cfa8:	e5863000 	str	r3, [r6]
	if (*np == 0) {
		return (p);
	}

	if (*(--p) == '\t') {			/* will retype the whole line	*/
		while (*colp > plen) {
3480cfac:	e5963000 	ldr	r3, [r6]
3480cfb0:	e153000a 	cmp	r3, sl
3480cfb4:	cafffff7 	bgt	3480cf98 <delete_char+0x34>
			puts (erase_seq);
			(*colp)--;
		}
		for (s=buffer; s<p; ++s) {
			if (*s == '\t') {
				puts (tab_seq+((*colp) & 07));
3480cfb8:	e59fa078 	ldr	sl, [pc, #120]	; 3480d038 <delete_char+0xd4>
3480cfbc:	ea00000f 	b	3480d000 <delete_char+0x9c>
		while (*colp > plen) {
			puts (erase_seq);
			(*colp)--;
		}
		for (s=buffer; s<p; ++s) {
			if (*s == '\t') {
3480cfc0:	e4d43001 	ldrb	r3, [r4], #1
3480cfc4:	e5960000 	ldr	r0, [r6]
3480cfc8:	e3530009 	cmp	r3, #9
3480cfcc:	1a000007 	bne	3480cff0 <delete_char+0x8c>
				puts (tab_seq+((*colp) & 07));
3480cfd0:	e2000007 	and	r0, r0, #7
3480cfd4:	e08a0000 	add	r0, sl, r0
3480cfd8:	ebffefd1 	bl	34808f24 <puts>
				*colp += 8 - ((*colp) & 07);
3480cfdc:	e5963000 	ldr	r3, [r6]
3480cfe0:	e3c33007 	bic	r3, r3, #7
3480cfe4:	e2833008 	add	r3, r3, #8
3480cfe8:	e5863000 	str	r3, [r6]
3480cfec:	ea000003 	b	3480d000 <delete_char+0x9c>
			} else {
				++(*colp);
3480cff0:	e2800001 	add	r0, r0, #1
3480cff4:	e5860000 	str	r0, [r6]
				putc (*s);
3480cff8:	e5540001 	ldrb	r0, [r4, #-1]
3480cffc:	ebffefbe 	bl	34808efc <putc>
	if (*(--p) == '\t') {			/* will retype the whole line	*/
		while (*colp > plen) {
			puts (erase_seq);
			(*colp)--;
		}
		for (s=buffer; s<p; ++s) {
3480d000:	e1550004 	cmp	r5, r4
3480d004:	8affffed 	bhi	3480cfc0 <delete_char+0x5c>
3480d008:	ea000004 	b	3480d020 <delete_char+0xbc>
				++(*colp);
				putc (*s);
			}
		}
	} else {
		puts (erase_seq);
3480d00c:	e59f0020 	ldr	r0, [pc, #32]	; 3480d034 <delete_char+0xd0>
3480d010:	ebffefc3 	bl	34808f24 <puts>
		(*colp)--;
3480d014:	e5963000 	ldr	r3, [r6]
3480d018:	e2433001 	sub	r3, r3, #1
3480d01c:	e5863000 	str	r3, [r6]
	}
	(*np)--;
3480d020:	e5973000 	ldr	r3, [r7]
3480d024:	e2433001 	sub	r3, r3, #1
3480d028:	e5873000 	str	r3, [r7]
	return (p);
}
3480d02c:	e1a00005 	mov	r0, r5
3480d030:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
3480d034:	348216b4 	.word	0x348216b4
3480d038:	348216b8 	.word	0x348216b8

3480d03c <cread_add_char>:
	}					\
}

static void cread_add_char(char ichar, int insert, unsigned long *num,
	       unsigned long *eol_num, char *buf, unsigned long len)
{
3480d03c:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
	unsigned long wlen;

	/* room ??? */
	if (insert || *num == *eol_num) {
3480d040:	e3510000 	cmp	r1, #0
	}					\
}

static void cread_add_char(char ichar, int insert, unsigned long *num,
	       unsigned long *eol_num, char *buf, unsigned long len)
{
3480d044:	e1a04002 	mov	r4, r2
3480d048:	e1a05000 	mov	r5, r0
3480d04c:	e59d6018 	ldr	r6, [sp, #24]
3480d050:	e59d201c 	ldr	r2, [sp, #28]
	unsigned long wlen;

	/* room ??? */
	if (insert || *num == *eol_num) {
3480d054:	1a000003 	bne	3480d068 <cread_add_char+0x2c>
3480d058:	e594c000 	ldr	ip, [r4]
3480d05c:	e5930000 	ldr	r0, [r3]
3480d060:	e15c0000 	cmp	ip, r0
3480d064:	1a000023 	bne	3480d0f8 <cread_add_char+0xbc>
		if (*eol_num > len - 1) {
3480d068:	e5937000 	ldr	r7, [r3]
3480d06c:	e2422001 	sub	r2, r2, #1
3480d070:	e1570002 	cmp	r7, r2
3480d074:	9a000002 	bls	3480d084 <cread_add_char+0x48>
			getcmd_cbeep();
3480d078:	e3a00007 	mov	r0, #7
		wlen = 1;
		buf[*num] = ichar;
		putnstr(buf + *num, wlen);
		(*num)++;
	}
}
3480d07c:	e8bd41f0 	pop	{r4, r5, r6, r7, r8, lr}
	unsigned long wlen;

	/* room ??? */
	if (insert || *num == *eol_num) {
		if (*eol_num > len - 1) {
			getcmd_cbeep();
3480d080:	eaffef9d 	b	34808efc <putc>
			return;
		}
		(*eol_num)++;
3480d084:	e2877001 	add	r7, r7, #1
	}

	if (insert) {
3480d088:	e3510000 	cmp	r1, #0
	if (insert || *num == *eol_num) {
		if (*eol_num > len - 1) {
			getcmd_cbeep();
			return;
		}
		(*eol_num)++;
3480d08c:	e5837000 	str	r7, [r3]
	}

	if (insert) {
3480d090:	0a000018 	beq	3480d0f8 <cread_add_char+0xbc>
		wlen = *eol_num - *num;
3480d094:	e5941000 	ldr	r1, [r4]
3480d098:	e0617007 	rsb	r7, r1, r7
		if (wlen > 1) {
3480d09c:	e3570001 	cmp	r7, #1
3480d0a0:	9a000004 	bls	3480d0b8 <cread_add_char+0x7c>
			memmove(&buf[*num+1], &buf[*num], wlen-1);
3480d0a4:	e2810001 	add	r0, r1, #1
3480d0a8:	e0860000 	add	r0, r6, r0
3480d0ac:	e0861001 	add	r1, r6, r1
3480d0b0:	e2472001 	sub	r2, r7, #1
3480d0b4:	eb002f92 	bl	34818f04 <memmove>
		}

		buf[*num] = ichar;
3480d0b8:	e5943000 	ldr	r3, [r4]
		putnstr(buf + *num, wlen);
3480d0bc:	e59f0060 	ldr	r0, [pc, #96]	; 3480d124 <cread_add_char+0xe8>
		wlen = *eol_num - *num;
		if (wlen > 1) {
			memmove(&buf[*num+1], &buf[*num], wlen-1);
		}

		buf[*num] = ichar;
3480d0c0:	e7c65003 	strb	r5, [r6, r3]
		putnstr(buf + *num, wlen);
3480d0c4:	e5942000 	ldr	r2, [r4]
3480d0c8:	e1a01007 	mov	r1, r7
3480d0cc:	e0862002 	add	r2, r6, r2
3480d0d0:	ebffef9d 	bl	34808f4c <printf>
		(*num)++;
3480d0d4:	e5943000 	ldr	r3, [r4]
3480d0d8:	e2833001 	add	r3, r3, #1
3480d0dc:	e5843000 	str	r3, [r4]
		while (--wlen) {
3480d0e0:	ea000001 	b	3480d0ec <cread_add_char+0xb0>
			getcmd_putch(CTL_BACKSPACE);
3480d0e4:	e3a00008 	mov	r0, #8
3480d0e8:	ebffef83 	bl	34808efc <putc>
		}

		buf[*num] = ichar;
		putnstr(buf + *num, wlen);
		(*num)++;
		while (--wlen) {
3480d0ec:	e2577001 	subs	r7, r7, #1
3480d0f0:	1afffffb 	bne	3480d0e4 <cread_add_char+0xa8>
3480d0f4:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
			getcmd_putch(CTL_BACKSPACE);
		}
	} else {
		/* echo the character */
		wlen = 1;
		buf[*num] = ichar;
3480d0f8:	e5943000 	ldr	r3, [r4]
		putnstr(buf + *num, wlen);
3480d0fc:	e59f0020 	ldr	r0, [pc, #32]	; 3480d124 <cread_add_char+0xe8>
			getcmd_putch(CTL_BACKSPACE);
		}
	} else {
		/* echo the character */
		wlen = 1;
		buf[*num] = ichar;
3480d100:	e7c65003 	strb	r5, [r6, r3]
		putnstr(buf + *num, wlen);
3480d104:	e5942000 	ldr	r2, [r4]
3480d108:	e3a01001 	mov	r1, #1
3480d10c:	e0862002 	add	r2, r6, r2
3480d110:	ebffef8d 	bl	34808f4c <printf>
		(*num)++;
3480d114:	e5943000 	ldr	r3, [r4]
3480d118:	e2833001 	add	r3, r3, #1
3480d11c:	e5843000 	str	r3, [r4]
3480d120:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
3480d124:	348267ce 	.word	0x348267ce

3480d128 <__show_boot_progress>:
#endif

/*
 * Board-specific Platform code can reimplement show_boot_progress () if needed
 */
void inline __show_boot_progress (int val) {}
3480d128:	e12fff1e 	bx	lr

3480d12c <readline_into_buffer>:
	return readline_into_buffer(prompt, console_buffer, 0);
}


int readline_into_buffer(const char *const prompt, char *buffer, int timeout)
{
3480d12c:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	 * History uses a global array which is not
	 * writable until after relocation to RAM.
	 * Revert to non-history version if still
	 * running from flash.
	 */
	if (gd->flags & GD_FLG_RELOC) {
3480d130:	e5983004 	ldr	r3, [r8, #4]
	return readline_into_buffer(prompt, console_buffer, 0);
}


int readline_into_buffer(const char *const prompt, char *buffer, int timeout)
{
3480d134:	e24dd040 	sub	sp, sp, #64	; 0x40
	 * History uses a global array which is not
	 * writable until after relocation to RAM.
	 * Revert to non-history version if still
	 * running from flash.
	 */
	if (gd->flags & GD_FLG_RELOC) {
3480d138:	e2133001 	ands	r3, r3, #1
	return readline_into_buffer(prompt, console_buffer, 0);
}


int readline_into_buffer(const char *const prompt, char *buffer, int timeout)
{
3480d13c:	e1a06000 	mov	r6, r0
3480d140:	e1a04001 	mov	r4, r1
3480d144:	e58d201c 	str	r2, [sp, #28]
	 * History uses a global array which is not
	 * writable until after relocation to RAM.
	 * Revert to non-history version if still
	 * running from flash.
	 */
	if (gd->flags & GD_FLG_RELOC) {
3480d148:	0a0001b7 	beq	3480d82c <readline_into_buffer+0x700>
		if (!initted) {
3480d14c:	e59f28a0 	ldr	r2, [pc, #2208]	; 3480d9f4 <readline_into_buffer+0x8c8>
3480d150:	e5923000 	ldr	r3, [r2]
3480d154:	e3530000 	cmp	r3, #0
3480d158:	1a000010 	bne	3480d1a0 <readline_into_buffer+0x74>
{
	int i;

	hist_max = 0;
	hist_add_idx = 0;
	hist_cur = -1;
3480d15c:	e59f1894 	ldr	r1, [pc, #2196]	; 3480d9f8 <readline_into_buffer+0x8cc>
3480d160:	e3e00000 	mvn	r0, #0
3480d164:	e5810000 	str	r0, [r1]
	hist_num = 0;
3480d168:	e59f188c 	ldr	r1, [pc, #2188]	; 3480d9fc <readline_into_buffer+0x8d0>

	return readline_into_buffer(prompt, console_buffer, 0);
}


int readline_into_buffer(const char *const prompt, char *buffer, int timeout)
3480d16c:	e59f088c 	ldr	r0, [pc, #2188]	; 3480da00 <readline_into_buffer+0x8d4>

static void hist_init(void)
{
	int i;

	hist_max = 0;
3480d170:	e5823004 	str	r3, [r2, #4]
	hist_add_idx = 0;
3480d174:	e5823008 	str	r3, [r2, #8]
	hist_cur = -1;
	hist_num = 0;
3480d178:	e582300c 	str	r3, [r2, #12]

	for (i = 0; i < HIST_MAX; i++) {
		hist_list[i] = hist_lines[i];
3480d17c:	e2822010 	add	r2, r2, #16
3480d180:	e5a12004 	str	r2, [r1, #4]!
		hist_list[i][0] = '\0';
3480d184:	e4c23100 	strb	r3, [r2], #256	; 0x100
3480d188:	e2822001 	add	r2, r2, #1
	hist_max = 0;
	hist_add_idx = 0;
	hist_cur = -1;
	hist_num = 0;

	for (i = 0; i < HIST_MAX; i++) {
3480d18c:	e1520000 	cmp	r2, r0
3480d190:	1afffffa 	bne	3480d180 <readline_into_buffer+0x54>
	 * running from flash.
	 */
	if (gd->flags & GD_FLG_RELOC) {
		if (!initted) {
			hist_init();
			initted = 1;
3480d194:	e59f3858 	ldr	r3, [pc, #2136]	; 3480d9f4 <readline_into_buffer+0x8c8>
3480d198:	e3a02001 	mov	r2, #1
3480d19c:	e5832000 	str	r2, [r3]
		}

		if (prompt)
3480d1a0:	e3560000 	cmp	r6, #0
3480d1a4:	0a000001 	beq	3480d1b0 <readline_into_buffer+0x84>
			puts (prompt);
3480d1a8:	e1a00006 	mov	r0, r6
3480d1ac:	ebffef5c 	bl	34808f24 <puts>
}

static int cread_line(const char *const prompt, char *buf, unsigned int *len,
		int timeout)
{
	unsigned long num = 0;
3480d1b0:	e3a03000 	mov	r3, #0
	unsigned long wlen;
	char ichar;
	int insert = 1;
	int esc_len = 0;
	char esc_save[8];
	int init_len = strlen(buf);
3480d1b4:	e1a00004 	mov	r0, r4
}

static int cread_line(const char *const prompt, char *buf, unsigned int *len,
		int timeout)
{
	unsigned long num = 0;
3480d1b8:	e58d3034 	str	r3, [sp, #52]	; 0x34
	unsigned long eol_num = 0;
3480d1bc:	e58d3030 	str	r3, [sp, #48]	; 0x30
	unsigned long wlen;
	char ichar;
	int insert = 1;
	int esc_len = 0;
	char esc_save[8];
	int init_len = strlen(buf);
3480d1c0:	eb002e6e 	bl	34818b80 <strlen>
	int first = 1;

	if (init_len)
3480d1c4:	e2505000 	subs	r5, r0, #0
3480d1c8:	1a000011 	bne	3480d214 <readline_into_buffer+0xe8>
				return (-2);	/* timed out */
			WATCHDOG_RESET();
		}
#endif
		if (first && timeout) {
			uint64_t etime = endtick(timeout);
3480d1cc:	e59d101c 	ldr	r1, [sp, #28]
				esc_len = 0;
			}
			break;

		case CTL_CH('a'):
			BEGINNING_OF_LINE();
3480d1d0:	e3a0b001 	mov	fp, #1
				return (-2);	/* timed out */
			WATCHDOG_RESET();
		}
#endif
		if (first && timeout) {
			uint64_t etime = endtick(timeout);
3480d1d4:	e1a00001 	mov	r0, r1
3480d1d8:	e1a01fc0 	asr	r1, r0, #31
				esc_len = 0;
			}
			break;

		case CTL_CH('a'):
			BEGINNING_OF_LINE();
3480d1dc:	e3a0a000 	mov	sl, #0
3480d1e0:	e1a0700b 	mov	r7, fp
				return (-2);	/* timed out */
			WATCHDOG_RESET();
		}
#endif
		if (first && timeout) {
			uint64_t etime = endtick(timeout);
3480d1e4:	e1cd02f0 	strd	r0, [sp, #32]

static char* hist_next(void)
{
	char *ret;

	if (hist_cur < 0)
3480d1e8:	e59f5808 	ldr	r5, [pc, #2056]	; 3480d9f8 <readline_into_buffer+0x8cc>
		return NULL;

	if (hist_cur == hist_add_idx)
3480d1ec:	e59f6800 	ldr	r6, [pc, #2048]	; 3480d9f4 <readline_into_buffer+0x8c8>
3480d1f0:	ea00000f 	b	3480d234 <readline_into_buffer+0x108>

static void cread_add_str(char *str, int strsize, int insert, unsigned long *num,
	      unsigned long *eol_num, char *buf, unsigned long len)
{
	while (strsize--) {
		cread_add_char(*str, insert, num, eol_num, buf, len);
3480d1f4:	e4d60001 	ldrb	r0, [r6], #1
3480d1f8:	e3a01001 	mov	r1, #1
3480d1fc:	e1a02007 	mov	r2, r7
3480d200:	e1a0300a 	mov	r3, sl
3480d204:	e88d0210 	stm	sp, {r4, r9}
		str++;
3480d208:	e2455001 	sub	r5, r5, #1

static void cread_add_str(char *str, int strsize, int insert, unsigned long *num,
	      unsigned long *eol_num, char *buf, unsigned long len)
{
	while (strsize--) {
		cread_add_char(*str, insert, num, eol_num, buf, len);
3480d20c:	ebffff8a 	bl	3480d03c <cread_add_char>
3480d210:	ea000003 	b	3480d224 <readline_into_buffer+0xf8>
	int esc_len = 0;
	char esc_save[8];
	int init_len = strlen(buf);
	int first = 1;

	if (init_len)
3480d214:	e1a06004 	mov	r6, r4
		cread_add_str(buf, init_len, 1, &num, &eol_num, buf, *len);
3480d218:	e28d7034 	add	r7, sp, #52	; 0x34
3480d21c:	e28da030 	add	sl, sp, #48	; 0x30

static void cread_add_str(char *str, int strsize, int insert, unsigned long *num,
	      unsigned long *eol_num, char *buf, unsigned long len)
{
	while (strsize--) {
		cread_add_char(*str, insert, num, eol_num, buf, len);
3480d220:	e3a09c01 	mov	r9, #256	; 0x100
}

static void cread_add_str(char *str, int strsize, int insert, unsigned long *num,
	      unsigned long *eol_num, char *buf, unsigned long len)
{
	while (strsize--) {
3480d224:	e3550000 	cmp	r5, #0
3480d228:	1afffff1 	bne	3480d1f4 <readline_into_buffer+0xc8>
3480d22c:	eaffffe6 	b	3480d1cc <readline_into_buffer+0xa0>
		case CTL_CH('p'):
		case CTL_CH('n'):
		{
			char * hline;

			esc_len = 0;
3480d230:	e3a0a000 	mov	sl, #0
			if (retry_time >= 0 && get_ticks() > endtime)
				return (-2);	/* timed out */
			WATCHDOG_RESET();
		}
#endif
		if (first && timeout) {
3480d234:	e59d201c 	ldr	r2, [sp, #28]
3480d238:	e3520000 	cmp	r2, #0
3480d23c:	03a03000 	moveq	r3, #0
3480d240:	120b3001 	andne	r3, fp, #1
3480d244:	e3530000 	cmp	r3, #0
3480d248:	0a000017 	beq	3480d2ac <readline_into_buffer+0x180>
			uint64_t etime = endtick(timeout);
3480d24c:	ebffd024 	bl	348012e4 <get_ticks>
3480d250:	e1cd01f0 	strd	r0, [sp, #16]
3480d254:	ebffd026 	bl	348012f4 <get_tbclk>
3480d258:	e59d101c 	ldr	r1, [sp, #28]
3480d25c:	e0832190 	umull	r2, r3, r0, r1
3480d260:	e59d1024 	ldr	r1, [sp, #36]	; 0x24
3480d264:	e0233190 	mla	r3, r0, r1, r3
3480d268:	e1cd01d0 	ldrd	r0, [sp, #16]
3480d26c:	e0900002 	adds	r0, r0, r2
3480d270:	e0a11003 	adc	r1, r1, r3
3480d274:	e1cd01f0 	strd	r0, [sp, #16]
3480d278:	ea000007 	b	3480d29c <readline_into_buffer+0x170>

			while (!tstc()) {	/* while no incoming data */
				if (get_ticks() >= etime)
3480d27c:	ebffd018 	bl	348012e4 <get_ticks>
3480d280:	e59d2014 	ldr	r2, [sp, #20]
3480d284:	e1520001 	cmp	r2, r1
3480d288:	8a000003 	bhi	3480d29c <readline_into_buffer+0x170>
3480d28c:	1a000164 	bne	3480d824 <readline_into_buffer+0x6f8>
3480d290:	e59d3010 	ldr	r3, [sp, #16]
3480d294:	e1530000 	cmp	r3, r0
3480d298:	9a000161 	bls	3480d824 <readline_into_buffer+0x6f8>
		}
#endif
		if (first && timeout) {
			uint64_t etime = endtick(timeout);

			while (!tstc()) {	/* while no incoming data */
3480d29c:	ebffef0d 	bl	34808ed8 <tstc>
3480d2a0:	e3500000 	cmp	r0, #0
3480d2a4:	0afffff4 	beq	3480d27c <readline_into_buffer+0x150>
				if (get_ticks() >= etime)
					return -2;	/* timed out */
				WATCHDOG_RESET();
			}
			first = 0;
3480d2a8:	e3a0b000 	mov	fp, #0
		}

		ichar = getcmd_getch();
3480d2ac:	ebffef00 	bl	34808eb4 <getc>
3480d2b0:	e6ef0070 	uxtb	r0, r0

		if ((ichar == '\n') || (ichar == '\r')) {
3480d2b4:	e350000a 	cmp	r0, #10
3480d2b8:	1350000d 	cmpne	r0, #13
3480d2bc:	13a09000 	movne	r9, #0
3480d2c0:	03a09001 	moveq	r9, #1
3480d2c4:	1a000009 	bne	3480d2f0 <readline_into_buffer+0x1c4>
			putc('\n');
3480d2c8:	e3a0000a 	mov	r0, #10
3480d2cc:	ebffef0a 	bl	34808efc <putc>
		default:
			cread_add_char(ichar, insert, &num, &eol_num, buf, *len);
			break;
		}
	}
	*len = eol_num;
3480d2d0:	e59d6030 	ldr	r6, [sp, #48]	; 0x30
	buf[eol_num] = '\0';	/* lose the newline */
3480d2d4:	e3a03000 	mov	r3, #0
3480d2d8:	e7c43006 	strb	r3, [r4, r6]

	if (buf[0] && buf[0] != CREAD_HIST_CHAR)
3480d2dc:	e5d43000 	ldrb	r3, [r4]
3480d2e0:	e3530021 	cmp	r3, #33	; 0x21
3480d2e4:	13530000 	cmpne	r3, #0
3480d2e8:	0a000147 	beq	3480d80c <readline_into_buffer+0x6e0>
3480d2ec:	ea000134 	b	3480d7c4 <readline_into_buffer+0x698>
		}

		/*
		 * handle standard linux xterm esc sequences for arrow key, etc.
		 */
		if (esc_len != 0) {
3480d2f0:	e35a0000 	cmp	sl, #0
3480d2f4:	0a000032 	beq	3480d3c4 <readline_into_buffer+0x298>
			if (esc_len == 1) {
3480d2f8:	e35a0001 	cmp	sl, #1
3480d2fc:	1a00000d 	bne	3480d338 <readline_into_buffer+0x20c>
				if (ichar == '[') {
3480d300:	e350005b 	cmp	r0, #91	; 0x5b
					esc_save[esc_len] = ichar;
3480d304:	05cd0029 	strbeq	r0, [sp, #41]	; 0x29
					esc_len = 2;
3480d308:	03a0a002 	moveq	sl, #2
		/*
		 * handle standard linux xterm esc sequences for arrow key, etc.
		 */
		if (esc_len != 0) {
			if (esc_len == 1) {
				if (ichar == '[') {
3480d30c:	0affffc8 	beq	3480d234 <readline_into_buffer+0x108>

static void cread_add_str(char *str, int strsize, int insert, unsigned long *num,
	      unsigned long *eol_num, char *buf, unsigned long len)
{
	while (strsize--) {
		cread_add_char(*str, insert, num, eol_num, buf, len);
3480d310:	e3a03c01 	mov	r3, #256	; 0x100
3480d314:	e58d3004 	str	r3, [sp, #4]
3480d318:	e5dd0028 	ldrb	r0, [sp, #40]	; 0x28
3480d31c:	e1a01007 	mov	r1, r7
3480d320:	e28d2034 	add	r2, sp, #52	; 0x34
3480d324:	e28d3030 	add	r3, sp, #48	; 0x30
3480d328:	e58d4000 	str	r4, [sp]
					esc_save[esc_len] = ichar;
					esc_len = 2;
				} else {
					cread_add_str(esc_save, esc_len, insert,
						      &num, &eol_num, buf, *len);
					esc_len = 0;
3480d32c:	e1a0a009 	mov	sl, r9

static void cread_add_str(char *str, int strsize, int insert, unsigned long *num,
	      unsigned long *eol_num, char *buf, unsigned long len)
{
	while (strsize--) {
		cread_add_char(*str, insert, num, eol_num, buf, len);
3480d330:	ebffff41 	bl	3480d03c <cread_add_char>
3480d334:	eaffffbe 	b	3480d234 <readline_into_buffer+0x108>
					esc_len = 0;
				}
				continue;
			}

			switch (ichar) {
3480d338:	e2403041 	sub	r3, r0, #65	; 0x41
3480d33c:	e3530007 	cmp	r3, #7
3480d340:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
3480d344:	ea000007 	b	3480d368 <readline_into_buffer+0x23c>
3480d348:	3480d65c 	.word	0x3480d65c
3480d34c:	3480d6a0 	.word	0x3480d6a0
3480d350:	3480d3b8 	.word	0x3480d3b8
3480d354:	3480d4b8 	.word	0x3480d4b8
3480d358:	3480d368 	.word	0x3480d368
3480d35c:	3480d368 	.word	0x3480d368
3480d360:	3480d368 	.word	0x3480d368
3480d364:	3480d484 	.word	0x3480d484
			case 'B':	/* down arrow */
				ichar = CTL_CH('n');
				esc_len = 0;
				break;	/* pass off to ^N handler */
			default:
				esc_save[esc_len++] = ichar;
3480d368:	e28d1040 	add	r1, sp, #64	; 0x40
3480d36c:	e081300a 	add	r3, r1, sl
3480d370:	e5430018 	strb	r0, [r3, #-24]
3480d374:	e28aa001 	add	sl, sl, #1
				cread_add_str(esc_save, esc_len, insert,
3480d378:	e28d9028 	add	r9, sp, #40	; 0x28

static void cread_add_str(char *str, int strsize, int insert, unsigned long *num,
	      unsigned long *eol_num, char *buf, unsigned long len)
{
	while (strsize--) {
		cread_add_char(*str, insert, num, eol_num, buf, len);
3480d37c:	e3a0cc01 	mov	ip, #256	; 0x100
3480d380:	ea000009 	b	3480d3ac <readline_into_buffer+0x280>
3480d384:	e4d90001 	ldrb	r0, [r9], #1
3480d388:	e1a01007 	mov	r1, r7
3480d38c:	e28d2034 	add	r2, sp, #52	; 0x34
3480d390:	e28d3030 	add	r3, sp, #48	; 0x30
3480d394:	e58dc004 	str	ip, [sp, #4]
3480d398:	e58dc00c 	str	ip, [sp, #12]
3480d39c:	e58d4000 	str	r4, [sp]
3480d3a0:	ebffff25 	bl	3480d03c <cread_add_char>
		str++;
3480d3a4:	e59dc00c 	ldr	ip, [sp, #12]
3480d3a8:	e24aa001 	sub	sl, sl, #1
}

static void cread_add_str(char *str, int strsize, int insert, unsigned long *num,
	      unsigned long *eol_num, char *buf, unsigned long len)
{
	while (strsize--) {
3480d3ac:	e35a0000 	cmp	sl, #0
3480d3b0:	1afffff3 	bne	3480d384 <readline_into_buffer+0x258>
3480d3b4:	eaffff9e 	b	3480d234 <readline_into_buffer+0x108>
			case 'D':	/* <- key */
				ichar = CTL_CH('b');
				esc_len = 0;
				break;
			case 'C':	/* -> key */
				ichar = CTL_CH('f');
3480d3b8:	e3a00006 	mov	r0, #6
3480d3bc:	e350000b 	cmp	r0, #11
3480d3c0:	ea000001 	b	3480d3cc <readline_into_buffer+0x2a0>
				esc_len = 0;
				continue;
			}
		}

		switch (ichar) {
3480d3c4:	e350000b 	cmp	r0, #11
3480d3c8:	0a00005e 	beq	3480d548 <readline_into_buffer+0x41c>
3480d3cc:	8a00000f 	bhi	3480d410 <readline_into_buffer+0x2e4>
3480d3d0:	e3500004 	cmp	r0, #4
3480d3d4:	0a00003f 	beq	3480d4d8 <readline_into_buffer+0x3ac>
3480d3d8:	8a000005 	bhi	3480d3f4 <readline_into_buffer+0x2c8>
3480d3dc:	e3500002 	cmp	r0, #2
3480d3e0:	0a000034 	beq	3480d4b8 <readline_into_buffer+0x38c>
3480d3e4:	8a00013e 	bhi	3480d8e4 <readline_into_buffer+0x7b8>
3480d3e8:	e3500001 	cmp	r0, #1
3480d3ec:	1a0000ec 	bne	3480d7a4 <readline_into_buffer+0x678>
3480d3f0:	ea000023 	b	3480d484 <readline_into_buffer+0x358>
3480d3f4:	e3500006 	cmp	r0, #6
3480d3f8:	0a000025 	beq	3480d494 <readline_into_buffer+0x368>
			break;
		case CTL_CH('k'):
			ERASE_TO_EOL();
			break;
		case CTL_CH('e'):
			REFRESH_TO_EOL();
3480d3fc:	359d2034 	ldrcc	r2, [sp, #52]	; 0x34
3480d400:	359d1030 	ldrcc	r1, [sp, #48]	; 0x30
				esc_len = 0;
				continue;
			}
		}

		switch (ichar) {
3480d404:	3a0000dd 	bcc	3480d780 <readline_into_buffer+0x654>
3480d408:	e3500008 	cmp	r0, #8
3480d40c:	ea000015 	b	3480d468 <readline_into_buffer+0x33c>
3480d410:	e3500015 	cmp	r0, #21
3480d414:	0a000061 	beq	3480d5a0 <readline_into_buffer+0x474>
3480d418:	8a000007 	bhi	3480d43c <readline_into_buffer+0x310>
3480d41c:	e350000f 	cmp	r0, #15
			break;
		case CTL_CH('e'):
			REFRESH_TO_EOL();
			break;
		case CTL_CH('o'):
			insert = !insert;
3480d420:	02277001 	eoreq	r7, r7, #1
				esc_len = 0;
				continue;
			}
		}

		switch (ichar) {
3480d424:	0affff81 	beq	3480d230 <readline_into_buffer+0x104>
3480d428:	e3500010 	cmp	r0, #16
3480d42c:	0a00008a 	beq	3480d65c <readline_into_buffer+0x530>
3480d430:	e350000e 	cmp	r0, #14
3480d434:	1a0000da 	bne	3480d7a4 <readline_into_buffer+0x678>
3480d438:	ea000098 	b	3480d6a0 <readline_into_buffer+0x574>
3480d43c:	e350001b 	cmp	r0, #27
		case 0x1b:
			if (esc_len == 0) {
				esc_save[esc_len] = ichar;
3480d440:	05cd0028 	strbeq	r0, [sp, #40]	; 0x28
				esc_len = 1;
3480d444:	03a0a001 	moveq	sl, #1
				esc_len = 0;
				continue;
			}
		}

		switch (ichar) {
3480d448:	0affff79 	beq	3480d234 <readline_into_buffer+0x108>
3480d44c:	8a000002 	bhi	3480d45c <readline_into_buffer+0x330>
3480d450:	e3500018 	cmp	r0, #24
3480d454:	1a0000d2 	bne	3480d7a4 <readline_into_buffer+0x678>
3480d458:	ea000050 	b	3480d5a0 <readline_into_buffer+0x474>
3480d45c:	e350007f 	cmp	r0, #127	; 0x7f
3480d460:	0a000061 	beq	3480d5ec <readline_into_buffer+0x4c0>
3480d464:	e35000ff 	cmp	r0, #255	; 0xff
3480d468:	1a0000cd 	bne	3480d7a4 <readline_into_buffer+0x678>
3480d46c:	ea00005e 	b	3480d5ec <readline_into_buffer+0x4c0>
				esc_len = 0;
			}
			break;

		case CTL_CH('a'):
			BEGINNING_OF_LINE();
3480d470:	e3a00008 	mov	r0, #8
3480d474:	ebffeea0 	bl	34808efc <putc>
3480d478:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
3480d47c:	e2433001 	sub	r3, r3, #1
3480d480:	e58d3034 	str	r3, [sp, #52]	; 0x34
3480d484:	e59da034 	ldr	sl, [sp, #52]	; 0x34
3480d488:	e35a0000 	cmp	sl, #0
3480d48c:	1afffff7 	bne	3480d470 <readline_into_buffer+0x344>
3480d490:	eaffff67 	b	3480d234 <readline_into_buffer+0x108>
			break;
		case CTL_CH('c'):	/* ^C - break */
			*buf = '\0';	/* discard input */
			return (-1);
		case CTL_CH('f'):
			if (num < eol_num) {
3480d494:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
3480d498:	e59d2030 	ldr	r2, [sp, #48]	; 0x30
3480d49c:	e1530002 	cmp	r3, r2
3480d4a0:	2affff62 	bcs	3480d230 <readline_into_buffer+0x104>
				getcmd_putch(buf[num]);
3480d4a4:	e7d40003 	ldrb	r0, [r4, r3]
3480d4a8:	ebffee93 	bl	34808efc <putc>
				num++;
3480d4ac:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
3480d4b0:	e2833001 	add	r3, r3, #1
3480d4b4:	ea0000b8 	b	3480d79c <readline_into_buffer+0x670>
			}
			break;
		case CTL_CH('b'):
			if (num) {
3480d4b8:	e59da034 	ldr	sl, [sp, #52]	; 0x34
3480d4bc:	e35a0000 	cmp	sl, #0
3480d4c0:	0affff5b 	beq	3480d234 <readline_into_buffer+0x108>
				getcmd_putch(CTL_BACKSPACE);
3480d4c4:	e3a00008 	mov	r0, #8
3480d4c8:	ebffee8b 	bl	34808efc <putc>
				num--;
3480d4cc:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
3480d4d0:	e2433001 	sub	r3, r3, #1
3480d4d4:	ea0000b0 	b	3480d79c <readline_into_buffer+0x670>
			}
			break;
		case CTL_CH('d'):
			if (num < eol_num) {
3480d4d8:	e59d0034 	ldr	r0, [sp, #52]	; 0x34
3480d4dc:	e59da030 	ldr	sl, [sp, #48]	; 0x30
3480d4e0:	e150000a 	cmp	r0, sl
3480d4e4:	2affff51 	bcs	3480d230 <readline_into_buffer+0x104>
				wlen = eol_num - num - 1;
3480d4e8:	e24aa001 	sub	sl, sl, #1
				if (wlen) {
3480d4ec:	e05aa000 	subs	sl, sl, r0
3480d4f0:	0a000009 	beq	3480d51c <readline_into_buffer+0x3f0>
					memmove(&buf[num], &buf[num+1], wlen);
3480d4f4:	e2801001 	add	r1, r0, #1
3480d4f8:	e0841001 	add	r1, r4, r1
3480d4fc:	e1a0200a 	mov	r2, sl
3480d500:	e0840000 	add	r0, r4, r0
3480d504:	eb002e7e 	bl	34818f04 <memmove>
					putnstr(buf + num, wlen);
3480d508:	e59d2034 	ldr	r2, [sp, #52]	; 0x34
3480d50c:	e59f04f0 	ldr	r0, [pc, #1264]	; 3480da04 <readline_into_buffer+0x8d8>
3480d510:	e1a0100a 	mov	r1, sl
3480d514:	e0842002 	add	r2, r4, r2
3480d518:	ebffee8b 	bl	34808f4c <printf>
				}

				getcmd_putch(' ');
3480d51c:	e3a00020 	mov	r0, #32
3480d520:	ebffee75 	bl	34808efc <putc>
				do {
					getcmd_putch(CTL_BACKSPACE);
3480d524:	e3a00008 	mov	r0, #8
3480d528:	ebffee73 	bl	34808efc <putc>
				} while (wlen--);
3480d52c:	e25aa001 	subs	sl, sl, #1
3480d530:	2afffffb 	bcs	3480d524 <readline_into_buffer+0x3f8>
				eol_num--;
3480d534:	e59d3030 	ldr	r3, [sp, #48]	; 0x30
3480d538:	e28aa001 	add	sl, sl, #1
3480d53c:	e2433001 	sub	r3, r3, #1
3480d540:	e58d3030 	str	r3, [sp, #48]	; 0x30
3480d544:	eaffff3a 	b	3480d234 <readline_into_buffer+0x108>
			}
			break;
		case CTL_CH('k'):
			ERASE_TO_EOL();
3480d548:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
3480d54c:	e59d1030 	ldr	r1, [sp, #48]	; 0x30
3480d550:	e1530001 	cmp	r3, r1
3480d554:	2affff36 	bcs	3480d234 <readline_into_buffer+0x108>
3480d558:	e59f04a8 	ldr	r0, [pc, #1192]	; 3480da08 <readline_into_buffer+0x8dc>
3480d55c:	e0631001 	rsb	r1, r3, r1
3480d560:	e59f24a4 	ldr	r2, [pc, #1188]	; 3480da0c <readline_into_buffer+0x8e0>
3480d564:	ebffee78 	bl	34808f4c <printf>
3480d568:	e3a00008 	mov	r0, #8
3480d56c:	ebffee62 	bl	34808efc <putc>
3480d570:	e59d3030 	ldr	r3, [sp, #48]	; 0x30
3480d574:	e59d2034 	ldr	r2, [sp, #52]	; 0x34
3480d578:	e2433001 	sub	r3, r3, #1
3480d57c:	e1530002 	cmp	r3, r2
3480d580:	e58d3030 	str	r3, [sp, #48]	; 0x30
3480d584:	8afffff7 	bhi	3480d568 <readline_into_buffer+0x43c>
3480d588:	eaffff28 	b	3480d230 <readline_into_buffer+0x104>
		case CTL_CH('o'):
			insert = !insert;
			break;
		case CTL_CH('x'):
		case CTL_CH('u'):
			BEGINNING_OF_LINE();
3480d58c:	e3a00008 	mov	r0, #8
3480d590:	ebffee59 	bl	34808efc <putc>
3480d594:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
3480d598:	e2433001 	sub	r3, r3, #1
3480d59c:	e58d3034 	str	r3, [sp, #52]	; 0x34
3480d5a0:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
3480d5a4:	e3530000 	cmp	r3, #0
3480d5a8:	1afffff7 	bne	3480d58c <readline_into_buffer+0x460>
			ERASE_TO_EOL();
3480d5ac:	e59d1030 	ldr	r1, [sp, #48]	; 0x30
3480d5b0:	e3510000 	cmp	r1, #0
3480d5b4:	01a0a001 	moveq	sl, r1
3480d5b8:	0affff1d 	beq	3480d234 <readline_into_buffer+0x108>
3480d5bc:	e59f0444 	ldr	r0, [pc, #1092]	; 3480da08 <readline_into_buffer+0x8dc>
3480d5c0:	e59f2444 	ldr	r2, [pc, #1092]	; 3480da0c <readline_into_buffer+0x8e0>
3480d5c4:	ebffee60 	bl	34808f4c <printf>
3480d5c8:	e3a00008 	mov	r0, #8
3480d5cc:	ebffee4a 	bl	34808efc <putc>
3480d5d0:	e59d3030 	ldr	r3, [sp, #48]	; 0x30
3480d5d4:	e59d2034 	ldr	r2, [sp, #52]	; 0x34
3480d5d8:	e2433001 	sub	r3, r3, #1
3480d5dc:	e1530002 	cmp	r3, r2
3480d5e0:	e58d3030 	str	r3, [sp, #48]	; 0x30
3480d5e4:	8afffff7 	bhi	3480d5c8 <readline_into_buffer+0x49c>
3480d5e8:	eaffff10 	b	3480d230 <readline_into_buffer+0x104>
			break;
		case DEL:
		case DEL7:
		case 8:
			if (num) {
3480d5ec:	e59da034 	ldr	sl, [sp, #52]	; 0x34
3480d5f0:	e35a0000 	cmp	sl, #0
3480d5f4:	0affff0e 	beq	3480d234 <readline_into_buffer+0x108>
				wlen = eol_num - num;
3480d5f8:	e59d9030 	ldr	r9, [sp, #48]	; 0x30
				num--;
3480d5fc:	e24a0001 	sub	r0, sl, #1
			break;
		case DEL:
		case DEL7:
		case 8:
			if (num) {
				wlen = eol_num - num;
3480d600:	e06a9009 	rsb	r9, sl, r9
				num--;
				memmove(&buf[num], &buf[num+1], wlen);
3480d604:	e084100a 	add	r1, r4, sl
3480d608:	e1a02009 	mov	r2, r9
		case DEL:
		case DEL7:
		case 8:
			if (num) {
				wlen = eol_num - num;
				num--;
3480d60c:	e58d0034 	str	r0, [sp, #52]	; 0x34
				memmove(&buf[num], &buf[num+1], wlen);
3480d610:	e0840000 	add	r0, r4, r0
3480d614:	eb002e3a 	bl	34818f04 <memmove>
				getcmd_putch(CTL_BACKSPACE);
3480d618:	e3a00008 	mov	r0, #8
3480d61c:	ebffee36 	bl	34808efc <putc>
				putnstr(buf + num, wlen);
3480d620:	e59d2034 	ldr	r2, [sp, #52]	; 0x34
3480d624:	e59f03d8 	ldr	r0, [pc, #984]	; 3480da04 <readline_into_buffer+0x8d8>
3480d628:	e1a01009 	mov	r1, r9
3480d62c:	e0842002 	add	r2, r4, r2
3480d630:	ebffee45 	bl	34808f4c <printf>
				getcmd_putch(' ');
3480d634:	e3a00020 	mov	r0, #32
3480d638:	ebffee2f 	bl	34808efc <putc>
				do {
					getcmd_putch(CTL_BACKSPACE);
3480d63c:	e3a00008 	mov	r0, #8
3480d640:	ebffee2d 	bl	34808efc <putc>
				} while (wlen--);
3480d644:	e2599001 	subs	r9, r9, #1
3480d648:	2afffffb 	bcs	3480d63c <readline_into_buffer+0x510>
				eol_num--;
3480d64c:	e59d3030 	ldr	r3, [sp, #48]	; 0x30
3480d650:	e2433001 	sub	r3, r3, #1
3480d654:	e58d3030 	str	r3, [sp, #48]	; 0x30
3480d658:	eafffef4 	b	3480d230 <readline_into_buffer+0x104>
static char* hist_prev(void)
{
	char *ret;
	int old_cur;

	if (hist_cur < 0)
3480d65c:	e5953000 	ldr	r3, [r5]
3480d660:	e3530000 	cmp	r3, #0
3480d664:	ba000024 	blt	3480d6fc <readline_into_buffer+0x5d0>
		return NULL;

	old_cur = hist_cur;
	if (--hist_cur < 0)
3480d668:	e2432001 	sub	r2, r3, #1
3480d66c:	e3720001 	cmn	r2, #1
3480d670:	e5852000 	str	r2, [r5]
		hist_cur = hist_max;
3480d674:	05962004 	ldreq	r2, [r6, #4]

	if (hist_cur == hist_add_idx) {
3480d678:	e5961008 	ldr	r1, [r6, #8]
	if (hist_cur < 0)
		return NULL;

	old_cur = hist_cur;
	if (--hist_cur < 0)
		hist_cur = hist_max;
3480d67c:	05852000 	streq	r2, [r5]

	if (hist_cur == hist_add_idx) {
3480d680:	e5952000 	ldr	r2, [r5]
3480d684:	e1520001 	cmp	r2, r1
		hist_cur = old_cur;
3480d688:	05853000 	streq	r3, [r5]

	old_cur = hist_cur;
	if (--hist_cur < 0)
		hist_cur = hist_max;

	if (hist_cur == hist_add_idx) {
3480d68c:	0a00001a 	beq	3480d6fc <readline_into_buffer+0x5d0>
		hist_cur = old_cur;
		ret = NULL;
	} else
		ret = hist_list[hist_cur];
3480d690:	e59f3378 	ldr	r3, [pc, #888]	; 3480da10 <readline_into_buffer+0x8e4>
3480d694:	e0832102 	add	r2, r3, r2, lsl #2
3480d698:	e512abd4 	ldr	sl, [r2, #-3028]	; 0xbd4
3480d69c:	ea000011 	b	3480d6e8 <readline_into_buffer+0x5bc>

static char* hist_next(void)
{
	char *ret;

	if (hist_cur < 0)
3480d6a0:	e5953000 	ldr	r3, [r5]
3480d6a4:	e3530000 	cmp	r3, #0
3480d6a8:	ba000013 	blt	3480d6fc <readline_into_buffer+0x5d0>
		return NULL;

	if (hist_cur == hist_add_idx)
3480d6ac:	e5962008 	ldr	r2, [r6, #8]
3480d6b0:	e1530002 	cmp	r3, r2
3480d6b4:	0a000010 	beq	3480d6fc <readline_into_buffer+0x5d0>
		return NULL;

	if (++hist_cur > hist_max)
3480d6b8:	e5961004 	ldr	r1, [r6, #4]
3480d6bc:	e2833001 	add	r3, r3, #1
3480d6c0:	e1530001 	cmp	r3, r1
		hist_cur = 0;
3480d6c4:	c3a00000 	movgt	r0, #0
		return NULL;

	if (hist_cur == hist_add_idx)
		return NULL;

	if (++hist_cur > hist_max)
3480d6c8:	e5853000 	str	r3, [r5]
		hist_cur = 0;
3480d6cc:	c5850000 	strgt	r0, [r5]

	if (hist_cur == hist_add_idx) {
3480d6d0:	e5953000 	ldr	r3, [r5]
3480d6d4:	e1530002 	cmp	r3, r2
3480d6d8:	0a000005 	beq	3480d6f4 <readline_into_buffer+0x5c8>
		ret = "";
	} else
		ret = hist_list[hist_cur];
3480d6dc:	e59f132c 	ldr	r1, [pc, #812]	; 3480da10 <readline_into_buffer+0x8e4>
3480d6e0:	e0813103 	add	r3, r1, r3, lsl #2
3480d6e4:	e513abd4 	ldr	sl, [r3, #-3028]	; 0xbd4
			if (ichar == CTL_CH('p'))
				hline = hist_prev();
			else
				hline = hist_next();

			if (!hline) {
3480d6e8:	e35a0000 	cmp	sl, #0
3480d6ec:	1a00000a 	bne	3480d71c <readline_into_buffer+0x5f0>
3480d6f0:	ea000001 	b	3480d6fc <readline_into_buffer+0x5d0>

	if (++hist_cur > hist_max)
		hist_cur = 0;

	if (hist_cur == hist_add_idx) {
		ret = "";
3480d6f4:	e59fa310 	ldr	sl, [pc, #784]	; 3480da0c <readline_into_buffer+0x8e0>
3480d6f8:	ea000007 	b	3480d71c <readline_into_buffer+0x5f0>
				hline = hist_prev();
			else
				hline = hist_next();

			if (!hline) {
				getcmd_cbeep();
3480d6fc:	e3a00007 	mov	r0, #7
3480d700:	ebffedfd 	bl	34808efc <putc>
3480d704:	eafffec9 	b	3480d230 <readline_into_buffer+0x104>
				continue;
			}

			/* nuke the current line */
			/* first, go home */
			BEGINNING_OF_LINE();
3480d708:	e3a00008 	mov	r0, #8
3480d70c:	ebffedfa 	bl	34808efc <putc>
3480d710:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
3480d714:	e2433001 	sub	r3, r3, #1
3480d718:	e58d3034 	str	r3, [sp, #52]	; 0x34
3480d71c:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
3480d720:	e3530000 	cmp	r3, #0
3480d724:	1afffff7 	bne	3480d708 <readline_into_buffer+0x5dc>

			/* erase to end of line */
			ERASE_TO_EOL();
3480d728:	e59d1030 	ldr	r1, [sp, #48]	; 0x30
3480d72c:	e3510000 	cmp	r1, #0
3480d730:	0a00000a 	beq	3480d760 <readline_into_buffer+0x634>
3480d734:	e59f02cc 	ldr	r0, [pc, #716]	; 3480da08 <readline_into_buffer+0x8dc>
3480d738:	e59f22cc 	ldr	r2, [pc, #716]	; 3480da0c <readline_into_buffer+0x8e0>
3480d73c:	ebffee02 	bl	34808f4c <printf>
3480d740:	e3a00008 	mov	r0, #8
3480d744:	ebffedec 	bl	34808efc <putc>
3480d748:	e59d3030 	ldr	r3, [sp, #48]	; 0x30
3480d74c:	e59d2034 	ldr	r2, [sp, #52]	; 0x34
3480d750:	e2433001 	sub	r3, r3, #1
3480d754:	e1530002 	cmp	r3, r2
3480d758:	e58d3030 	str	r3, [sp, #48]	; 0x30
3480d75c:	8afffff7 	bhi	3480d740 <readline_into_buffer+0x614>

			/* copy new line into place and display */
			strcpy(buf, hline);
3480d760:	e1a0100a 	mov	r1, sl
3480d764:	e1a00004 	mov	r0, r4
3480d768:	eb002c9f 	bl	348189ec <strcpy>
			eol_num = strlen(buf);
3480d76c:	e1a00004 	mov	r0, r4
3480d770:	eb002d02 	bl	34818b80 <strlen>
			REFRESH_TO_EOL();
3480d774:	e59d2034 	ldr	r2, [sp, #52]	; 0x34
			/* erase to end of line */
			ERASE_TO_EOL();

			/* copy new line into place and display */
			strcpy(buf, hline);
			eol_num = strlen(buf);
3480d778:	e1a01000 	mov	r1, r0
3480d77c:	e58d0030 	str	r0, [sp, #48]	; 0x30
			REFRESH_TO_EOL();
3480d780:	e1520001 	cmp	r2, r1
3480d784:	2afffea9 	bcs	3480d230 <readline_into_buffer+0x104>
3480d788:	e0621001 	rsb	r1, r2, r1
3480d78c:	e59f0270 	ldr	r0, [pc, #624]	; 3480da04 <readline_into_buffer+0x8d8>
3480d790:	e0842002 	add	r2, r4, r2
3480d794:	ebffedec 	bl	34808f4c <printf>
3480d798:	e59d3030 	ldr	r3, [sp, #48]	; 0x30
3480d79c:	e58d3034 	str	r3, [sp, #52]	; 0x34
3480d7a0:	eafffea2 	b	3480d230 <readline_into_buffer+0x104>
			}
			break;
		}
#endif
		default:
			cread_add_char(ichar, insert, &num, &eol_num, buf, *len);
3480d7a4:	e3a03c01 	mov	r3, #256	; 0x100
3480d7a8:	e58d3004 	str	r3, [sp, #4]
3480d7ac:	e1a01007 	mov	r1, r7
3480d7b0:	e28d2034 	add	r2, sp, #52	; 0x34
3480d7b4:	e28d3030 	add	r3, sp, #48	; 0x30
3480d7b8:	e58d4000 	str	r4, [sp]
3480d7bc:	ebfffe1e 	bl	3480d03c <cread_add_char>
3480d7c0:	eafffe9a 	b	3480d230 <readline_into_buffer+0x104>
	}
}

static void cread_add_to_hist(char *line)
{
	strcpy(hist_list[hist_add_idx], line);
3480d7c4:	e59f5228 	ldr	r5, [pc, #552]	; 3480d9f4 <readline_into_buffer+0x8c8>
3480d7c8:	e59f3240 	ldr	r3, [pc, #576]	; 3480da10 <readline_into_buffer+0x8e4>
3480d7cc:	e5952008 	ldr	r2, [r5, #8]
3480d7d0:	e1a01004 	mov	r1, r4
3480d7d4:	e0833102 	add	r3, r3, r2, lsl #2
3480d7d8:	e5130bd4 	ldr	r0, [r3, #-3028]	; 0xbd4
3480d7dc:	eb002c82 	bl	348189ec <strcpy>

	if (++hist_add_idx >= HIST_MAX)
3480d7e0:	e995000c 	ldmib	r5, {r2, r3}
3480d7e4:	e2833001 	add	r3, r3, #1
		hist_add_idx = 0;
3480d7e8:	e3530013 	cmp	r3, #19
3480d7ec:	c3a03000 	movgt	r3, #0

	if (hist_add_idx > hist_max)
3480d7f0:	e1530002 	cmp	r3, r2
static void cread_add_to_hist(char *line)
{
	strcpy(hist_list[hist_add_idx], line);

	if (++hist_add_idx >= HIST_MAX)
		hist_add_idx = 0;
3480d7f4:	e5853008 	str	r3, [r5, #8]

	if (hist_add_idx > hist_max)
		hist_max = hist_add_idx;
3480d7f8:	c5853004 	strgt	r3, [r5, #4]

	hist_num++;
3480d7fc:	e59f31f0 	ldr	r3, [pc, #496]	; 3480d9f4 <readline_into_buffer+0x8c8>
3480d800:	e593200c 	ldr	r2, [r3, #12]
3480d804:	e2822001 	add	r2, r2, #1
3480d808:	e583200c 	str	r2, [r3, #12]
	*len = eol_num;
	buf[eol_num] = '\0';	/* lose the newline */

	if (buf[0] && buf[0] != CREAD_HIST_CHAR)
		cread_add_to_hist(buf);
	hist_cur = hist_add_idx;
3480d80c:	e59f31e0 	ldr	r3, [pc, #480]	; 3480d9f4 <readline_into_buffer+0x8c8>

		if (prompt)
			puts (prompt);

		rc = cread_line(prompt, p, &len, timeout);
		return rc < 0 ? rc : len;
3480d810:	e1a00006 	mov	r0, r6
	*len = eol_num;
	buf[eol_num] = '\0';	/* lose the newline */

	if (buf[0] && buf[0] != CREAD_HIST_CHAR)
		cread_add_to_hist(buf);
	hist_cur = hist_add_idx;
3480d814:	e5932008 	ldr	r2, [r3, #8]
3480d818:	e59f31d8 	ldr	r3, [pc, #472]	; 3480d9f8 <readline_into_buffer+0x8cc>
3480d81c:	e5832000 	str	r2, [r3]
3480d820:	ea000071 	b	3480d9ec <readline_into_buffer+0x8c0>
		if (first && timeout) {
			uint64_t etime = endtick(timeout);

			while (!tstc()) {	/* while no incoming data */
				if (get_ticks() >= etime)
					return -2;	/* timed out */
3480d824:	e3e00001 	mvn	r0, #1
3480d828:	ea00006f 	b	3480d9ec <readline_into_buffer+0x8c0>
	int	plen = 0;			/* prompt length	*/
	int	col;				/* output column cnt	*/
	char	c;

	/* print prompt */
	if (prompt) {
3480d82c:	e3500000 	cmp	r0, #0
		return rc < 0 ? rc : len;

	} else {
#endif	/* CONFIG_CMDLINE_EDITING */
	char * p_buf = p;
	int	n = 0;				/* buffer index		*/
3480d830:	e58d303c 	str	r3, [sp, #60]	; 0x3c
	int	plen = 0;			/* prompt length	*/
3480d834:	01a05000 	moveq	r5, r0
	int	col;				/* output column cnt	*/
	char	c;

	/* print prompt */
	if (prompt) {
3480d838:	0a000003 	beq	3480d84c <readline_into_buffer+0x720>
		plen = strlen (prompt);
3480d83c:	eb002ccf 	bl	34818b80 <strlen>
3480d840:	e1a05000 	mov	r5, r0
		puts (prompt);
3480d844:	e1a00006 	mov	r0, r6
3480d848:	ebffedb5 	bl	34808f24 <puts>
	}
	col = plen;
3480d84c:	e28d6040 	add	r6, sp, #64	; 0x40
					if (cmd_auto_complete(prompt, console_buffer, &n, &col)) {
						p = p_buf + n;	/* reset */
						continue;
					}
#endif
					puts (tab_seq+(col&07));
3480d850:	e59fa1bc 	ldr	sl, [pc, #444]	; 3480da14 <readline_into_buffer+0x8e8>
	/* print prompt */
	if (prompt) {
		plen = strlen (prompt);
		puts (prompt);
	}
	col = plen;
3480d854:	e5265008 	str	r5, [r6, #-8]!
			}
			continue;

		case 0x08:				/* ^H  - backspace	*/
		case 0x7F:				/* DEL - backspace	*/
			p=delete_char(p_buf, p, &col, &n, plen);
3480d858:	e28d703c 	add	r7, sp, #60	; 0x3c
			while (col > plen) {
				puts (erase_seq);
				--col;
			}
			p = p_buf;
			n = 0;
3480d85c:	e3a09000 	mov	r9, #0
3480d860:	e1a01004 	mov	r1, r4
		while (!tstc()) {
			show_activity(0);
			WATCHDOG_RESET();
		}
#endif
		c = getc();
3480d864:	e58d100c 	str	r1, [sp, #12]
3480d868:	ebffed91 	bl	34808eb4 <getc>
3480d86c:	e6efb070 	uxtb	fp, r0

		/*
		 * Special character handling
		 */
		switch (c) {
3480d870:	e35b000a 	cmp	fp, #10
3480d874:	e59d100c 	ldr	r1, [sp, #12]
3480d878:	0a000012 	beq	3480d8c8 <readline_into_buffer+0x79c>
3480d87c:	8a000006 	bhi	3480d89c <readline_into_buffer+0x770>
3480d880:	e35b0003 	cmp	fp, #3
3480d884:	0a000016 	beq	3480d8e4 <readline_into_buffer+0x7b8>
3480d888:	e35b0008 	cmp	fp, #8
3480d88c:	0a000030 	beq	3480d954 <readline_into_buffer+0x828>
3480d890:	e35b0000 	cmp	fp, #0
3480d894:	0afffff2 	beq	3480d864 <readline_into_buffer+0x738>
3480d898:	ea000034 	b	3480d970 <readline_into_buffer+0x844>
3480d89c:	e35b0015 	cmp	fp, #21
3480d8a0:	0a000018 	beq	3480d908 <readline_into_buffer+0x7dc>
3480d8a4:	8a000002 	bhi	3480d8b4 <readline_into_buffer+0x788>
3480d8a8:	e35b000d 	cmp	fp, #13
3480d8ac:	1a00002f 	bne	3480d970 <readline_into_buffer+0x844>
3480d8b0:	ea000004 	b	3480d8c8 <readline_into_buffer+0x79c>
3480d8b4:	e35b0017 	cmp	fp, #23
3480d8b8:	0a000018 	beq	3480d920 <readline_into_buffer+0x7f4>
3480d8bc:	e35b007f 	cmp	fp, #127	; 0x7f
3480d8c0:	1a00002a 	bne	3480d970 <readline_into_buffer+0x844>
3480d8c4:	ea000022 	b	3480d954 <readline_into_buffer+0x828>
		case '\r':				/* Enter		*/
		case '\n':
			*p = '\0';
3480d8c8:	e3a03000 	mov	r3, #0
3480d8cc:	e1a0b001 	mov	fp, r1
			puts ("\r\n");
3480d8d0:	e59f0140 	ldr	r0, [pc, #320]	; 3480da18 <readline_into_buffer+0x8ec>
		 * Special character handling
		 */
		switch (c) {
		case '\r':				/* Enter		*/
		case '\n':
			*p = '\0';
3480d8d4:	e5c13000 	strb	r3, [r1]
			puts ("\r\n");
3480d8d8:	ebffed91 	bl	34808f24 <puts>
			return (p - p_buf);
3480d8dc:	e064000b 	rsb	r0, r4, fp
3480d8e0:	ea000041 	b	3480d9ec <readline_into_buffer+0x8c0>

		case '\0':				/* nul			*/
			continue;

		case 0x03:				/* ^C - break		*/
			p_buf[0] = '\0';	/* discard input */
3480d8e4:	e3a03000 	mov	r3, #0
3480d8e8:	e5c43000 	strb	r3, [r4]
			return (-1);
3480d8ec:	e3e00000 	mvn	r0, #0
3480d8f0:	ea00003d 	b	3480d9ec <readline_into_buffer+0x8c0>

		case 0x15:				/* ^U - erase line	*/
			while (col > plen) {
				puts (erase_seq);
3480d8f4:	e59f0120 	ldr	r0, [pc, #288]	; 3480da1c <readline_into_buffer+0x8f0>
3480d8f8:	ebffed89 	bl	34808f24 <puts>
				--col;
3480d8fc:	e59d3038 	ldr	r3, [sp, #56]	; 0x38
3480d900:	e2433001 	sub	r3, r3, #1
3480d904:	e58d3038 	str	r3, [sp, #56]	; 0x38
		case 0x03:				/* ^C - break		*/
			p_buf[0] = '\0';	/* discard input */
			return (-1);

		case 0x15:				/* ^U - erase line	*/
			while (col > plen) {
3480d908:	e59d3038 	ldr	r3, [sp, #56]	; 0x38
3480d90c:	e1530005 	cmp	r3, r5
3480d910:	cafffff7 	bgt	3480d8f4 <readline_into_buffer+0x7c8>
				puts (erase_seq);
				--col;
			}
			p = p_buf;
			n = 0;
3480d914:	e58d903c 	str	r9, [sp, #60]	; 0x3c
			continue;
3480d918:	e1a01004 	mov	r1, r4
3480d91c:	eaffffd0 	b	3480d864 <readline_into_buffer+0x738>

		case 0x17:				/* ^W - erase word	*/
			p=delete_char(p_buf, p, &col, &n, plen);
			while ((n > 0) && (*p != ' ')) {
				p=delete_char(p_buf, p, &col, &n, plen);
3480d920:	e1a03007 	mov	r3, r7
3480d924:	e1a00004 	mov	r0, r4
3480d928:	e1a02006 	mov	r2, r6
3480d92c:	e58d5000 	str	r5, [sp]
3480d930:	ebfffd8b 	bl	3480cf64 <delete_char>
			n = 0;
			continue;

		case 0x17:				/* ^W - erase word	*/
			p=delete_char(p_buf, p, &col, &n, plen);
			while ((n > 0) && (*p != ' ')) {
3480d934:	e59d303c 	ldr	r3, [sp, #60]	; 0x3c
				p=delete_char(p_buf, p, &col, &n, plen);
3480d938:	e1a01000 	mov	r1, r0
			n = 0;
			continue;

		case 0x17:				/* ^W - erase word	*/
			p=delete_char(p_buf, p, &col, &n, plen);
			while ((n > 0) && (*p != ' ')) {
3480d93c:	e3530000 	cmp	r3, #0
3480d940:	daffffc7 	ble	3480d864 <readline_into_buffer+0x738>
3480d944:	e5d03000 	ldrb	r3, [r0]
3480d948:	e3530020 	cmp	r3, #32
3480d94c:	1afffff3 	bne	3480d920 <readline_into_buffer+0x7f4>
3480d950:	eaffffc3 	b	3480d864 <readline_into_buffer+0x738>
			}
			continue;

		case 0x08:				/* ^H  - backspace	*/
		case 0x7F:				/* DEL - backspace	*/
			p=delete_char(p_buf, p, &col, &n, plen);
3480d954:	e1a00004 	mov	r0, r4
3480d958:	e1a02006 	mov	r2, r6
3480d95c:	e1a03007 	mov	r3, r7
3480d960:	e58d5000 	str	r5, [sp]
3480d964:	ebfffd7e 	bl	3480cf64 <delete_char>
3480d968:	e1a01000 	mov	r1, r0
			continue;
3480d96c:	eaffffbc 	b	3480d864 <readline_into_buffer+0x738>

		default:
			/*
			 * Must be a normal character then
			 */
			if (n < CONFIG_SYS_CBSIZE-2) {
3480d970:	e59d303c 	ldr	r3, [sp, #60]	; 0x3c
3480d974:	e35300fd 	cmp	r3, #253	; 0xfd
3480d978:	ca000016 	bgt	3480d9d8 <readline_into_buffer+0x8ac>
				if (c == '\t') {	/* expand TABs		*/
3480d97c:	e35b0009 	cmp	fp, #9
3480d980:	e59d0038 	ldr	r0, [sp, #56]	; 0x38
3480d984:	1a000008 	bne	3480d9ac <readline_into_buffer+0x880>
					if (cmd_auto_complete(prompt, console_buffer, &n, &col)) {
						p = p_buf + n;	/* reset */
						continue;
					}
#endif
					puts (tab_seq+(col&07));
3480d988:	e2000007 	and	r0, r0, #7
3480d98c:	e08a0000 	add	r0, sl, r0
3480d990:	e58d100c 	str	r1, [sp, #12]
3480d994:	ebffed62 	bl	34808f24 <puts>
					col += 8 - (col&07);
3480d998:	e59d3038 	ldr	r3, [sp, #56]	; 0x38
3480d99c:	e3c33007 	bic	r3, r3, #7
3480d9a0:	e2833008 	add	r3, r3, #8
3480d9a4:	e58d3038 	str	r3, [sp, #56]	; 0x38
3480d9a8:	ea000004 	b	3480d9c0 <readline_into_buffer+0x894>
				} else {
					++col;		/* echo input		*/
3480d9ac:	e2800001 	add	r0, r0, #1
3480d9b0:	e58d0038 	str	r0, [sp, #56]	; 0x38
					putc (c);
3480d9b4:	e1a0000b 	mov	r0, fp
3480d9b8:	e58d100c 	str	r1, [sp, #12]
3480d9bc:	ebffed4e 	bl	34808efc <putc>
3480d9c0:	e59d100c 	ldr	r1, [sp, #12]
				}
				*p++ = c;
3480d9c4:	e4c1b001 	strb	fp, [r1], #1
				++n;
3480d9c8:	e59d303c 	ldr	r3, [sp, #60]	; 0x3c
3480d9cc:	e2833001 	add	r3, r3, #1
3480d9d0:	e58d303c 	str	r3, [sp, #60]	; 0x3c
3480d9d4:	eaffffa2 	b	3480d864 <readline_into_buffer+0x738>
			} else {			/* Buffer full		*/
				putc ('\a');
3480d9d8:	e3a00007 	mov	r0, #7
3480d9dc:	e58d100c 	str	r1, [sp, #12]
3480d9e0:	ebffed45 	bl	34808efc <putc>
3480d9e4:	e59d100c 	ldr	r1, [sp, #12]
3480d9e8:	eaffff9d 	b	3480d864 <readline_into_buffer+0x738>
		}
	}
#ifdef CONFIG_CMDLINE_EDITING
	}
#endif
}
3480d9ec:	e28dd040 	add	sp, sp, #64	; 0x40
3480d9f0:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
3480d9f4:	34829768 	.word	0x34829768
3480d9f8:	34828870 	.word	0x34828870
3480d9fc:	3482ab88 	.word	0x3482ab88
3480da00:	3482ab8c 	.word	0x3482ab8c
3480da04:	348267ce 	.word	0x348267ce
3480da08:	348267d3 	.word	0x348267d3
3480da0c:	34824054 	.word	0x34824054
3480da10:	3482b760 	.word	0x3482b760
3480da14:	348216b8 	.word	0x348216b8
3480da18:	348267d7 	.word	0x348267d7
3480da1c:	348216b4 	.word	0x348216b4

3480da20 <readline>:
{
	/*
	 * If console_buffer isn't 0-length the user will be prompted to modify
	 * it instead of entering it from scratch as desired.
	 */
	console_buffer[0] = '\0';
3480da20:	e59f300c 	ldr	r3, [pc, #12]	; 3480da34 <readline+0x14>

	return readline_into_buffer(prompt, console_buffer, 0);
3480da24:	e59f100c 	ldr	r1, [pc, #12]	; 3480da38 <readline+0x18>
{
	/*
	 * If console_buffer isn't 0-length the user will be prompted to modify
	 * it instead of entering it from scratch as desired.
	 */
	console_buffer[0] = '\0';
3480da28:	e3a02000 	mov	r2, #0
3480da2c:	e5432b84 	strb	r2, [r3, #-2948]	; 0xb84

	return readline_into_buffer(prompt, console_buffer, 0);
3480da30:	eafffdbd 	b	3480d12c <readline_into_buffer>
3480da34:	3482b760 	.word	0x3482b760
3480da38:	3482abdc 	.word	0x3482abdc

3480da3c <parse_line>:
}

/****************************************************************************/

int parse_line (char *line, char *argv[])
{
3480da3c:	e92d4010 	push	{r4, lr}
	int nargs = 0;
3480da40:	e1a0c001 	mov	ip, r1
3480da44:	e3a04000 	mov	r4, #0
3480da48:	e1a02000 	mov	r2, r0
	printf ("parse_line: \"%s\"\n", line);
#endif
	while (nargs < CONFIG_SYS_MAXARGS) {

		/* skip any white space */
		while (isblank(*line))
3480da4c:	e4d03001 	ldrb	r3, [r0], #1
3480da50:	e3530020 	cmp	r3, #32
3480da54:	13530009 	cmpne	r3, #9
3480da58:	0afffffa 	beq	3480da48 <parse_line+0xc>
			++line;

		if (*line == '\0') {	/* end of line, no more args	*/
3480da5c:	e3530000 	cmp	r3, #0
3480da60:	0a000005 	beq	3480da7c <parse_line+0x40>
		printf ("parse_line: nargs=%d\n", nargs);
#endif
			return (nargs);
		}

		argv[nargs++] = line;	/* begin of argument string	*/
3480da64:	e48c2004 	str	r2, [ip], #4
3480da68:	e2844001 	add	r4, r4, #1

		/* find end of string */
		while (*line && !isblank(*line))
3480da6c:	e1a00002 	mov	r0, r2
3480da70:	e4d23001 	ldrb	r3, [r2], #1
3480da74:	e3530000 	cmp	r3, #0
3480da78:	1a000001 	bne	3480da84 <parse_line+0x48>
			++line;

		if (*line == '\0') {	/* end of line, no more args	*/
			argv[nargs] = NULL;
3480da7c:	e7813104 	str	r3, [r1, r4, lsl #2]
#ifdef DEBUG_PARSER
		printf ("parse_line: nargs=%d\n", nargs);
#endif
			return (nargs);
3480da80:	ea00000b 	b	3480dab4 <parse_line+0x78>
		}

		argv[nargs++] = line;	/* begin of argument string	*/

		/* find end of string */
		while (*line && !isblank(*line))
3480da84:	e3530009 	cmp	r3, #9
3480da88:	13530020 	cmpne	r3, #32
3480da8c:	03a03000 	moveq	r3, #0
3480da90:	13a03001 	movne	r3, #1
3480da94:	1afffff4 	bne	3480da6c <parse_line+0x30>
	int nargs = 0;

#ifdef DEBUG_PARSER
	printf ("parse_line: \"%s\"\n", line);
#endif
	while (nargs < CONFIG_SYS_MAXARGS) {
3480da98:	e3540010 	cmp	r4, #16
		printf ("parse_line: nargs=%d\n", nargs);
#endif
			return (nargs);
		}

		*line++ = '\0';		/* terminate current arg	 */
3480da9c:	e5c03000 	strb	r3, [r0]
3480daa0:	12800001 	addne	r0, r0, #1
3480daa4:	1affffe7 	bne	3480da48 <parse_line+0xc>
	}

	printf ("** Too many args (max. %d) **\n", CONFIG_SYS_MAXARGS);
3480daa8:	e59f000c 	ldr	r0, [pc, #12]	; 3480dabc <parse_line+0x80>
3480daac:	e1a01004 	mov	r1, r4
3480dab0:	ebffed25 	bl	34808f4c <printf>

#ifdef DEBUG_PARSER
	printf ("parse_line: nargs=%d\n", nargs);
#endif
	return (nargs);
}
3480dab4:	e1a00004 	mov	r0, r4
3480dab8:	e8bd8010 	pop	{r4, pc}
3480dabc:	348267da 	.word	0x348267da

3480dac0 <run_command>:
	if (builtin_run_command(cmd, flag) == -1)
		return 1;

	return 0;
#else
	return parse_string_outer(cmd,
3480dac0:	e3a01003 	mov	r1, #3
3480dac4:	eafff702 	b	3480b6d4 <parse_string_outer>

3480dac8 <run_command_list>:
{
	int need_buff = 1;
	char *buff = (char *)cmd;	/* cast away const */
	int rcode = 0;

	if (len == -1) {
3480dac8:	e3710001 	cmn	r1, #1
	return rcode;
}
#endif

int run_command_list(const char *cmd, int len, int flag)
{
3480dacc:	e92d4070 	push	{r4, r5, r6, lr}
3480dad0:	e1a06000 	mov	r6, r0
3480dad4:	e1a04001 	mov	r4, r1
	int need_buff = 1;
	char *buff = (char *)cmd;	/* cast away const */
	int rcode = 0;

	if (len == -1) {
3480dad8:	1a000002 	bne	3480dae8 <run_command_list+0x20>
		len = strlen(cmd);
3480dadc:	eb002c27 	bl	34818b80 <strlen>
#endif

int run_command_list(const char *cmd, int len, int flag)
{
	int need_buff = 1;
	char *buff = (char *)cmd;	/* cast away const */
3480dae0:	e1a05006 	mov	r5, r6
3480dae4:	ea000008 	b	3480db0c <run_command_list+0x44>
		/* the built-in parser will change our string if it sees \n */
		need_buff = strchr(cmd, '\n') != NULL;
#endif
	}
	if (need_buff) {
		buff = malloc(len + 1);
3480dae8:	e2810001 	add	r0, r1, #1
3480daec:	ebffeedd 	bl	34809668 <malloc>
		if (!buff)
3480daf0:	e2505000 	subs	r5, r0, #0
3480daf4:	0a000008 	beq	3480db1c <run_command_list+0x54>
			return 1;
		memcpy(buff, cmd, len);
3480daf8:	e1a01006 	mov	r1, r6
3480dafc:	e1a02004 	mov	r2, r4
3480db00:	eb002ce2 	bl	34818e90 <memcpy>
		buff[len] = '\0';
3480db04:	e3a03000 	mov	r3, #0
3480db08:	e7c53004 	strb	r3, [r5, r4]
	}
#ifdef CONFIG_SYS_HUSH_PARSER
	rcode = parse_string_outer(buff, FLAG_PARSE_SEMICOLON);
3480db0c:	e1a00005 	mov	r0, r5
3480db10:	e3a01002 	mov	r1, #2
	if (need_buff)
		free(buff);
#endif

	return rcode;
}
3480db14:	e8bd4070 	pop	{r4, r5, r6, lr}
			return 1;
		memcpy(buff, cmd, len);
		buff[len] = '\0';
	}
#ifdef CONFIG_SYS_HUSH_PARSER
	rcode = parse_string_outer(buff, FLAG_PARSE_SEMICOLON);
3480db18:	eafff6ed 	b	3480b6d4 <parse_string_outer>
	if (need_buff)
		free(buff);
#endif

	return rcode;
}
3480db1c:	e3a00001 	mov	r0, #1
3480db20:	e8bd8070 	pop	{r4, r5, r6, pc}

3480db24 <main_loop>:
#endif	/* CONFIG_BOOTDELAY >= 0  */

/****************************************************************************/

void main_loop (void)
{
3480db24:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
		setenv ("ver", version_string);  /* set version variable */
	}
#endif /* CONFIG_VERSION_VARIABLE */

#ifdef CONFIG_SYS_HUSH_PARSER
	u_boot_hush_start ();
3480db28:	ebfffacc 	bl	3480c660 <u_boot_hush_start>
#if defined(CONFIG_UPDATE_TFTP)
	update_tftp (0UL);
#endif /* CONFIG_UPDATE_TFTP */

#if defined(CONFIG_BOOTDELAY) && (CONFIG_BOOTDELAY >= 0)
	s = getenv ("bootdelay");
3480db2c:	e59f00fc 	ldr	r0, [pc, #252]	; 3480dc30 <main_loop+0x10c>
3480db30:	ebffe9c1 	bl	3480823c <getenv>
	bootdelay = s ? (int)simple_strtol(s, NULL, 10) : CONFIG_BOOTDELAY;
3480db34:	e3500000 	cmp	r0, #0
3480db38:	03a04003 	moveq	r4, #3
3480db3c:	0a000003 	beq	3480db50 <main_loop+0x2c>
3480db40:	e3a01000 	mov	r1, #0
3480db44:	e3a0200a 	mov	r2, #10
3480db48:	eb003073 	bl	34819d1c <simple_strtol>
3480db4c:	e1a04000 	mov	r4, r0
		        (unsigned)bootlimit);
		s = getenv ("altbootcmd");
	}
	else
#endif /* CONFIG_BOOTCOUNT_LIMIT */
		s = getenv ("bootcmd");
3480db50:	e59f00dc 	ldr	r0, [pc, #220]	; 3480dc34 <main_loop+0x110>
3480db54:	ebffe9b8 	bl	3480823c <getenv>

	debug ("### main_loop: bootcmd=\"%s\"\n", s ? s : "<UNDEFINED>");

	if (bootdelay != -1 && s && !abortboot(bootdelay)) {
3480db58:	e3500000 	cmp	r0, #0
3480db5c:	13740001 	cmnne	r4, #1
3480db60:	e1a06000 	mov	r6, r0
3480db64:	0a00002f 	beq	3480dc28 <main_loop+0x104>
	int abort = 0;

#ifdef CONFIG_MENUPROMPT
	printf(CONFIG_MENUPROMPT);
#else
	if (bootdelay >= 0)
3480db68:	e3540000 	cmp	r4, #0
#ifndef CONFIG_MENU
static inline
#endif
int abortboot(int bootdelay)
{
	int abort = 0;
3480db6c:	b3a05000 	movlt	r5, #0

#ifdef CONFIG_MENUPROMPT
	printf(CONFIG_MENUPROMPT);
#else
	if (bootdelay >= 0)
3480db70:	ba00001d 	blt	3480dbec <main_loop+0xc8>
		printf("Hit any key to stop autoboot: %2d ", bootdelay);
3480db74:	e1a01004 	mov	r1, r4
3480db78:	e59f00b8 	ldr	r0, [pc, #184]	; 3480dc38 <main_loop+0x114>
3480db7c:	ebffecf2 	bl	34808f4c <printf>
	/*
	 * Check if key already pressed
	 * Don't check if bootdelay < 0
	 */
	if (bootdelay >= 0) {
		if (tstc()) {	/* we got a key press	*/
3480db80:	ebffecd4 	bl	34808ed8 <tstc>
3480db84:	e2505000 	subs	r5, r0, #0
3480db88:	0a000017 	beq	3480dbec <main_loop+0xc8>
			(void) getc();  /* consume input	*/
3480db8c:	ebffecc8 	bl	34808eb4 <getc>
			puts ("\b\b\b 0");
3480db90:	e59f00a4 	ldr	r0, [pc, #164]	; 3480dc3c <main_loop+0x118>
3480db94:	ebffece2 	bl	34808f24 <puts>
			abort = 1;	/* don't auto boot	*/
3480db98:	e3a05001 	mov	r5, #1
3480db9c:	ea000012 	b	3480dbec <main_loop+0xc8>
		int i;

		--bootdelay;
		/* delay 100 * 10ms */
		for (i=0; !abort && i<100; ++i) {
			if (tstc()) {	/* we got a key press	*/
3480dba0:	ebffeccc 	bl	34808ed8 <tstc>
3480dba4:	e3500000 	cmp	r0, #0
3480dba8:	0a000003 	beq	3480dbbc <main_loop+0x98>
				abort  = 1;	/* don't auto boot	*/
				bootdelay = 0;	/* no more delay	*/
# ifdef CONFIG_MENUKEY
				menukey = getc();
# else
				(void) getc();  /* consume input	*/
3480dbac:	ebffecc0 	bl	34808eb4 <getc>

		--bootdelay;
		/* delay 100 * 10ms */
		for (i=0; !abort && i<100; ++i) {
			if (tstc()) {	/* we got a key press	*/
				abort  = 1;	/* don't auto boot	*/
3480dbb0:	e3a05001 	mov	r5, #1
				bootdelay = 0;	/* no more delay	*/
3480dbb4:	e3a04000 	mov	r4, #0
3480dbb8:	ea000008 	b	3480dbe0 <main_loop+0xbc>
# else
				(void) getc();  /* consume input	*/
# endif
				break;
			}
			udelay(10000);
3480dbbc:	e3020710 	movw	r0, #10000	; 0x2710
3480dbc0:	eb002d3d 	bl	348190bc <udelay>
	while ((bootdelay > 0) && (!abort)) {
		int i;

		--bootdelay;
		/* delay 100 * 10ms */
		for (i=0; !abort && i<100; ++i) {
3480dbc4:	e2877001 	add	r7, r7, #1
3480dbc8:	e3570063 	cmp	r7, #99	; 0x63
3480dbcc:	c3a05000 	movgt	r5, #0
3480dbd0:	d3a05001 	movle	r5, #1
3480dbd4:	e3550000 	cmp	r5, #0
3480dbd8:	1afffff0 	bne	3480dba0 <main_loop+0x7c>
#endif

	while ((bootdelay > 0) && (!abort)) {
		int i;

		--bootdelay;
3480dbdc:	e2444001 	sub	r4, r4, #1
				break;
			}
			udelay(10000);
		}

		printf("\b\b\b%2d ", bootdelay);
3480dbe0:	e59f0058 	ldr	r0, [pc, #88]	; 3480dc40 <main_loop+0x11c>
3480dbe4:	e1a01004 	mov	r1, r4
3480dbe8:	ebffecd7 	bl	34808f4c <printf>
			abort = 1;	/* don't auto boot	*/
		}
	}
#endif

	while ((bootdelay > 0) && (!abort)) {
3480dbec:	e2753001 	rsbs	r3, r5, #1
3480dbf0:	33a03000 	movcc	r3, #0
3480dbf4:	e3540000 	cmp	r4, #0
3480dbf8:	d3a03000 	movle	r3, #0
3480dbfc:	e3530000 	cmp	r3, #0
3480dc00:	13a07000 	movne	r7, #0
3480dc04:	1affffef 	bne	3480dbc8 <main_loop+0xa4>
		}

		printf("\b\b\b%2d ", bootdelay);
	}

	putc('\n');
3480dc08:	e3a0000a 	mov	r0, #10
3480dc0c:	ebffecba 	bl	34808efc <putc>
#endif /* CONFIG_BOOTCOUNT_LIMIT */
		s = getenv ("bootcmd");

	debug ("### main_loop: bootcmd=\"%s\"\n", s ? s : "<UNDEFINED>");

	if (bootdelay != -1 && s && !abortboot(bootdelay)) {
3480dc10:	e3550000 	cmp	r5, #0
3480dc14:	1a000003 	bne	3480dc28 <main_loop+0x104>
# ifdef CONFIG_AUTOBOOT_KEYED
		int prev = disable_ctrlc(1);	/* disable Control C checking */
# endif

		run_command_list(s, -1, 0);
3480dc18:	e1a00006 	mov	r0, r6
3480dc1c:	e3e01000 	mvn	r1, #0
3480dc20:	e1a02005 	mov	r2, r5
3480dc24:	ebffffa7 	bl	3480dac8 <run_command_list>

	/*
	 * Main Loop for Monitor Command Processing
	 */
#ifdef CONFIG_SYS_HUSH_PARSER
	parse_file_outer();
3480dc28:	ebfffa7b 	bl	3480c61c <parse_file_outer>
3480dc2c:	eafffffe 	b	3480dc2c <main_loop+0x108>
3480dc30:	348267f9 	.word	0x348267f9
3480dc34:	348230ce 	.word	0x348230ce
3480dc38:	34826803 	.word	0x34826803
3480dc3c:	34826826 	.word	0x34826826
3480dc40:	3482682c 	.word	0x3482682c

3480dc44 <do_run>:
#if defined(CONFIG_CMD_RUN)
int do_run (cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
{
	int i;

	if (argc < 2)
3480dc44:	e3520001 	cmp	r2, #1

/****************************************************************************/

#if defined(CONFIG_CMD_RUN)
int do_run (cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
{
3480dc48:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
	int i;

	if (argc < 2)
		return CMD_RET_USAGE;
3480dc4c:	d3e00000 	mvnle	r0, #0

/****************************************************************************/

#if defined(CONFIG_CMD_RUN)
int do_run (cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
{
3480dc50:	e1a04002 	mov	r4, r2
	int i;

	if (argc < 2)
3480dc54:	d8bd80f8 	pople	{r3, r4, r5, r6, r7, pc}
}

/****************************************************************************/

#if defined(CONFIG_CMD_RUN)
int do_run (cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
3480dc58:	e2836004 	add	r6, r3, #4
3480dc5c:	e3a05001 	mov	r5, #1
{
	int i;

	if (argc < 2)
3480dc60:	e1a07006 	mov	r7, r6
		return CMD_RET_USAGE;

	for (i=1; i<argc; ++i) {
		char *arg;

		if ((arg = getenv (argv[i])) == NULL) {
3480dc64:	e4960004 	ldr	r0, [r6], #4
3480dc68:	ebffe973 	bl	3480823c <getenv>
3480dc6c:	e3500000 	cmp	r0, #0
3480dc70:	1a000004 	bne	3480dc88 <do_run+0x44>
			printf ("## Error: \"%s\" not defined\n", argv[i]);
3480dc74:	e59f0034 	ldr	r0, [pc, #52]	; 3480dcb0 <do_run+0x6c>
3480dc78:	e5971000 	ldr	r1, [r7]
3480dc7c:	ebffecb2 	bl	34808f4c <printf>
			return 1;
3480dc80:	e3a00001 	mov	r0, #1
3480dc84:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
	if (builtin_run_command(cmd, flag) == -1)
		return 1;

	return 0;
#else
	return parse_string_outer(cmd,
3480dc88:	e3a01003 	mov	r1, #3
3480dc8c:	ebfff690 	bl	3480b6d4 <parse_string_outer>
		if ((arg = getenv (argv[i])) == NULL) {
			printf ("## Error: \"%s\" not defined\n", argv[i]);
			return 1;
		}

		if (run_command(arg, flag) != 0)
3480dc90:	e3500000 	cmp	r0, #0
3480dc94:	1a000003 	bne	3480dca8 <do_run+0x64>
	int i;

	if (argc < 2)
		return CMD_RET_USAGE;

	for (i=1; i<argc; ++i) {
3480dc98:	e2855001 	add	r5, r5, #1
3480dc9c:	e1550004 	cmp	r5, r4
3480dca0:	baffffee 	blt	3480dc60 <do_run+0x1c>
3480dca4:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
			printf ("## Error: \"%s\" not defined\n", argv[i]);
			return 1;
		}

		if (run_command(arg, flag) != 0)
			return 1;
3480dca8:	e3a00001 	mov	r0, #1
	}
	return 0;
}
3480dcac:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
3480dcb0:	348256c4 	.word	0x348256c4

3480dcb4 <get_ram_size>:
 * Check memory range for valid RAM. A simple memory test determines
 * the actually available RAM size between addresses `base' and
 * `base + maxsize'.
 */
long get_ram_size(long *base, long maxsize)
{
3480dcb4:	e92d40f0 	push	{r4, r5, r6, r7, lr}
3480dcb8:	e24dd084 	sub	sp, sp, #132	; 0x84
3480dcbc:	e1a03000 	mov	r3, r0
	long           cnt;
	long           val;
	long           size;
	int            i = 0;

	for (cnt = (maxsize / sizeof (long)) >> 1; cnt > 0; cnt >>= 1) {
3480dcc0:	e1a04121 	lsr	r4, r1, #2
3480dcc4:	e1a021a1 	lsr	r2, r1, #3
3480dcc8:	e24d0004 	sub	r0, sp, #4
	volatile long *addr;
	long           save[32];
	long           cnt;
	long           val;
	long           size;
	int            i = 0;
3480dccc:	e3a0c000 	mov	ip, #0

	for (cnt = (maxsize / sizeof (long)) >> 1; cnt > 0; cnt >>= 1) {
3480dcd0:	ea000005 	b	3480dcec <get_ram_size+0x38>
		addr = base + cnt;	/* pointer arith! */
		sync ();
		save[i++] = *addr;
3480dcd4:	e7935102 	ldr	r5, [r3, r2, lsl #2]
3480dcd8:	e28cc001 	add	ip, ip, #1
3480dcdc:	e5a05004 	str	r5, [r0, #4]!
		sync ();
		*addr = ~cnt;
3480dce0:	e1e05002 	mvn	r5, r2
3480dce4:	e7835102 	str	r5, [r3, r2, lsl #2]
	long           cnt;
	long           val;
	long           size;
	int            i = 0;

	for (cnt = (maxsize / sizeof (long)) >> 1; cnt > 0; cnt >>= 1) {
3480dce8:	e1a020c2 	asr	r2, r2, #1
3480dcec:	e3520000 	cmp	r2, #0
3480dcf0:	1afffff7 	bne	3480dcd4 <get_ram_size+0x20>
		*addr = ~cnt;
	}

	addr = base;
	sync ();
	save[i] = *addr;
3480dcf4:	e5935000 	ldr	r5, [r3]
3480dcf8:	e1a0010c 	lsl	r0, ip, #2
3480dcfc:	e28d7080 	add	r7, sp, #128	; 0x80
3480dd00:	e0876000 	add	r6, r7, r0
3480dd04:	e5065080 	str	r5, [r6, #-128]	; 0x80
	sync ();
	*addr = 0;
3480dd08:	e5832000 	str	r2, [r3]

	sync ();
	if ((val = *addr) != 0) {
3480dd0c:	e5932000 	ldr	r2, [r3]
3480dd10:	e3520000 	cmp	r2, #0
3480dd14:	e1a0200d 	mov	r2, sp
/*
 * Check memory range for valid RAM. A simple memory test determines
 * the actually available RAM size between addresses `base' and
 * `base + maxsize'.
 */
long get_ram_size(long *base, long maxsize)
3480dd18:	10820000 	addne	r0, r2, r0
3480dd1c:	008d5000 	addeq	r5, sp, r0
3480dd20:	03a02001 	moveq	r2, #1
	sync ();
	if ((val = *addr) != 0) {
		/* Restore the original data before leaving the function.
		 */
		sync ();
		*addr = save[i];
3480dd24:	15835000 	strne	r5, [r3]
		for (cnt = 1; cnt < maxsize / sizeof(long); cnt <<= 1) {
3480dd28:	13a02001 	movne	r2, #1
	save[i] = *addr;
	sync ();
	*addr = 0;

	sync ();
	if ((val = *addr) != 0) {
3480dd2c:	1a000003 	bne	3480dd40 <get_ram_size+0x8c>
3480dd30:	ea000018 	b	3480dd98 <get_ram_size+0xe4>
		sync ();
		*addr = save[i];
		for (cnt = 1; cnt < maxsize / sizeof(long); cnt <<= 1) {
			addr  = base + cnt;
			sync ();
			*addr = save[--i];
3480dd34:	e5301004 	ldr	r1, [r0, #-4]!
3480dd38:	e7831102 	str	r1, [r3, r2, lsl #2]
	if ((val = *addr) != 0) {
		/* Restore the original data before leaving the function.
		 */
		sync ();
		*addr = save[i];
		for (cnt = 1; cnt < maxsize / sizeof(long); cnt <<= 1) {
3480dd3c:	e1a02082 	lsl	r2, r2, #1
3480dd40:	e1520004 	cmp	r2, r4
3480dd44:	3afffffa 	bcc	3480dd34 <get_ram_size+0x80>
			addr  = base + cnt;
			sync ();
			*addr = save[--i];
		}
		return (0);
3480dd48:	e3a00000 	mov	r0, #0
3480dd4c:	ea000014 	b	3480dda4 <get_ram_size+0xf0>
	}

	for (cnt = 1; cnt < maxsize / sizeof (long); cnt <<= 1) {
		addr = base + cnt;	/* pointer arith! */
		val = *addr;
		*addr = save[--i];
3480dd50:	e5356004 	ldr	r6, [r5, #-4]!
		return (0);
	}

	for (cnt = 1; cnt < maxsize / sizeof (long); cnt <<= 1) {
		addr = base + cnt;	/* pointer arith! */
		val = *addr;
3480dd54:	e7937102 	ldr	r7, [r3, r2, lsl #2]
		*addr = save[--i];
3480dd58:	e7836102 	str	r6, [r3, r2, lsl #2]
		if (val != ~cnt) {
3480dd5c:	e1e06002 	mvn	r6, r2
3480dd60:	e1570006 	cmp	r7, r6
		}
		return (0);
	}

	for (cnt = 1; cnt < maxsize / sizeof (long); cnt <<= 1) {
		addr = base + cnt;	/* pointer arith! */
3480dd64:	e1a00102 	lsl	r0, r2, #2
		val = *addr;
		*addr = save[--i];
3480dd68:	e24cc001 	sub	ip, ip, #1
3480dd6c:	e1a02082 	lsl	r2, r2, #1
		if (val != ~cnt) {
3480dd70:	0a000008 	beq	3480dd98 <get_ram_size+0xe4>
/*
 * Check memory range for valid RAM. A simple memory test determines
 * the actually available RAM size between addresses `base' and
 * `base + maxsize'.
 */
long get_ram_size(long *base, long maxsize)
3480dd74:	e1a0100d 	mov	r1, sp
3480dd78:	e081c10c 	add	ip, r1, ip, lsl #2
		*addr = save[--i];
		if (val != ~cnt) {
			size = cnt * sizeof (long);
			/* Restore the original data before leaving the function.
			 */
			for (cnt <<= 1; cnt < maxsize / sizeof (long); cnt <<= 1) {
3480dd7c:	ea000002 	b	3480dd8c <get_ram_size+0xd8>
				addr  = base + cnt;
				*addr = save[--i];
3480dd80:	e53c1004 	ldr	r1, [ip, #-4]!
3480dd84:	e7831102 	str	r1, [r3, r2, lsl #2]
		*addr = save[--i];
		if (val != ~cnt) {
			size = cnt * sizeof (long);
			/* Restore the original data before leaving the function.
			 */
			for (cnt <<= 1; cnt < maxsize / sizeof (long); cnt <<= 1) {
3480dd88:	e1a02082 	lsl	r2, r2, #1
3480dd8c:	e1520004 	cmp	r2, r4
3480dd90:	3afffffa 	bcc	3480dd80 <get_ram_size+0xcc>
3480dd94:	ea000002 	b	3480dda4 <get_ram_size+0xf0>
			*addr = save[--i];
		}
		return (0);
	}

	for (cnt = 1; cnt < maxsize / sizeof (long); cnt <<= 1) {
3480dd98:	e1520004 	cmp	r2, r4
3480dd9c:	3affffeb 	bcc	3480dd50 <get_ram_size+0x9c>
			}
			return (size);
		}
	}

	return (maxsize);
3480dda0:	e1a00001 	mov	r0, r1
}
3480dda4:	e28dd084 	add	sp, sp, #132	; 0x84
3480dda8:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}

3480ddac <hex1_bin>:
	return (srec_type);
}

static int hex1_bin (char c)
{
	if (c >= '0' && c <= '9')
3480ddac:	e2403030 	sub	r3, r0, #48	; 0x30
3480ddb0:	e6ef2073 	uxtb	r2, r3
3480ddb4:	e3520009 	cmp	r2, #9
		return (c - '0');
3480ddb8:	91a00003 	movls	r0, r3
	return (srec_type);
}

static int hex1_bin (char c)
{
	if (c >= '0' && c <= '9')
3480ddbc:	912fff1e 	bxls	lr
		return (c - '0');
	if (c >= 'a' && c <= 'f')
3480ddc0:	e2403061 	sub	r3, r0, #97	; 0x61
3480ddc4:	e6ef3073 	uxtb	r3, r3
3480ddc8:	e3530005 	cmp	r3, #5
		return (c + 10 - 'a');
3480ddcc:	92400057 	subls	r0, r0, #87	; 0x57

static int hex1_bin (char c)
{
	if (c >= '0' && c <= '9')
		return (c - '0');
	if (c >= 'a' && c <= 'f')
3480ddd0:	912fff1e 	bxls	lr
		return (c + 10 - 'a');
	if (c >= 'A' && c <= 'F')
3480ddd4:	e2403041 	sub	r3, r0, #65	; 0x41
3480ddd8:	e6ef3073 	uxtb	r3, r3
3480dddc:	e3530005 	cmp	r3, #5
		return (c + 10 - 'A');
3480dde0:	92400037 	subls	r0, r0, #55	; 0x37
	return (-1);
3480dde4:	83e00000 	mvnhi	r0, #0
}
3480dde8:	e12fff1e 	bx	lr

3480ddec <hex2_bin>:

static int hex2_bin (char *s)
{
3480ddec:	e92d4038 	push	{r3, r4, r5, lr}
3480ddf0:	e1a04000 	mov	r4, r0
	int i, j;

	if ((i = hex1_bin(*s++)) < 0) {
3480ddf4:	e5d00000 	ldrb	r0, [r0]
3480ddf8:	ebffffeb 	bl	3480ddac <hex1_bin>
3480ddfc:	e2505000 	subs	r5, r0, #0
		return (-1);
3480de00:	b3e00000 	mvnlt	r0, #0

static int hex2_bin (char *s)
{
	int i, j;

	if ((i = hex1_bin(*s++)) < 0) {
3480de04:	b8bd8038 	poplt	{r3, r4, r5, pc}
		return (-1);
	}
	if ((j = hex1_bin(*s)) < 0) {
3480de08:	e5d40001 	ldrb	r0, [r4, #1]
3480de0c:	ebffffe6 	bl	3480ddac <hex1_bin>
3480de10:	e3500000 	cmp	r0, #0
		return (-1);
	}

	return ((i<<4) + j);
3480de14:	a0800205 	addge	r0, r0, r5, lsl #4

	if ((i = hex1_bin(*s++)) < 0) {
		return (-1);
	}
	if ((j = hex1_bin(*s)) < 0) {
		return (-1);
3480de18:	b3e00000 	mvnlt	r0, #0
	}

	return ((i<<4) + j);
}
3480de1c:	e8bd8038 	pop	{r3, r4, r5, pc}

3480de20 <srec_decode>:

static int hex1_bin (char  c);
static int hex2_bin (char *s);

int srec_decode (char *input, int *count, ulong *addr, char *data)
{
3480de20:	e92d4ef3 	push	{r0, r1, r4, r5, r6, r7, r9, sl, fp, lr}
3480de24:	e1a04001 	mov	r4, r1
3480de28:	e1a05002 	mov	r5, r2
3480de2c:	e1a09003 	mov	r9, r3

	/* skip anything before 'S', and the 'S' itself.
	 * Return error if not found
	 */

	for (; *input; ++input) {
3480de30:	ea000002 	b	3480de40 <srec_decode+0x20>
		if (*input == 'S') {		/* skip 'S' */
3480de34:	e3530053 	cmp	r3, #83	; 0x53
			++input;
3480de38:	01a07000 	moveq	r7, r0
			break;
3480de3c:	0a000004 	beq	3480de54 <srec_decode+0x34>

	/* skip anything before 'S', and the 'S' itself.
	 * Return error if not found
	 */

	for (; *input; ++input) {
3480de40:	e5d03000 	ldrb	r3, [r0]
		if (*input == 'S') {		/* skip 'S' */
			++input;
			break;
3480de44:	e1a07000 	mov	r7, r0

	/* skip anything before 'S', and the 'S' itself.
	 * Return error if not found
	 */

	for (; *input; ++input) {
3480de48:	e3530000 	cmp	r3, #0
3480de4c:	e2800001 	add	r0, r0, #1
3480de50:	1afffff7 	bne	3480de34 <srec_decode+0x14>
		if (*input == 'S') {		/* skip 'S' */
			++input;
			break;
		}
	}
	if (*input == '\0') {			/* no more data?	*/
3480de54:	e5d7b000 	ldrb	fp, [r7]
3480de58:	e35b0000 	cmp	fp, #0
		return (SREC_EMPTY);
3480de5c:	03a0600a 	moveq	r6, #10
		if (*input == 'S') {		/* skip 'S' */
			++input;
			break;
		}
	}
	if (*input == '\0') {			/* no more data?	*/
3480de60:	0a000088 	beq	3480e088 <srec_decode+0x268>
		return (SREC_EMPTY);
	}

	v = *input++;				/* record type		*/
3480de64:	e2877001 	add	r7, r7, #1

	if ((*count = hex2_bin(input)) < 0) {
3480de68:	e1a00007 	mov	r0, r7
3480de6c:	ebffffde 	bl	3480ddec <hex2_bin>
3480de70:	e3500000 	cmp	r0, #0
3480de74:	e5840000 	str	r0, [r4]
3480de78:	ba000081 	blt	3480e084 <srec_decode+0x264>
	}

	chksum += *count;
	input  += 2;

	switch (v) {				/* record type		*/
3480de7c:	e24b3030 	sub	r3, fp, #48	; 0x30
3480de80:	e3530009 	cmp	r3, #9
3480de84:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
3480de88:	ea00007b 	b	3480e07c <srec_decode+0x25c>
3480de8c:	3480deb4 	.word	0x3480deb4
3480de90:	3480dec4 	.word	0x3480dec4
3480de94:	3480ded4 	.word	0x3480ded4
3480de98:	3480dee4 	.word	0x3480dee4
3480de9c:	3480e07c 	.word	0x3480e07c
3480dea0:	3480def4 	.word	0x3480def4
3480dea4:	3480e07c 	.word	0x3480e07c
3480dea8:	3480df04 	.word	0x3480df04
3480deac:	3480df14 	.word	0x3480df14
3480deb0:	3480df24 	.word	0x3480df24

	case '0':				/* start record		*/
		srec_type = SREC_START;		/* 2 byte addr field	*/
		*count   -= 3;			/* - checksum and addr	*/
3480deb4:	e2403003 	sub	r3, r0, #3
3480deb8:	e5843000 	str	r3, [r4]
	input  += 2;

	switch (v) {				/* record type		*/

	case '0':				/* start record		*/
		srec_type = SREC_START;		/* 2 byte addr field	*/
3480debc:	e3a06000 	mov	r6, #0
		*count   -= 3;			/* - checksum and addr	*/
		break;
3480dec0:	ea00001a 	b	3480df30 <srec_decode+0x110>
	case '1':
		srec_type = SREC_DATA2;		/* 2 byte addr field	*/
		*count   -= 3;			/* - checksum and addr	*/
3480dec4:	e2403003 	sub	r3, r0, #3
3480dec8:	e5843000 	str	r3, [r4]
	case '0':				/* start record		*/
		srec_type = SREC_START;		/* 2 byte addr field	*/
		*count   -= 3;			/* - checksum and addr	*/
		break;
	case '1':
		srec_type = SREC_DATA2;		/* 2 byte addr field	*/
3480decc:	e3a06001 	mov	r6, #1
		*count   -= 3;			/* - checksum and addr	*/
		break;
3480ded0:	ea000016 	b	3480df30 <srec_decode+0x110>
	case '2':
		srec_type = SREC_DATA3;		/* 3 byte addr field	*/
		*count   -= 4;			/* - checksum and addr	*/
3480ded4:	e2403004 	sub	r3, r0, #4
3480ded8:	e5843000 	str	r3, [r4]
	case '1':
		srec_type = SREC_DATA2;		/* 2 byte addr field	*/
		*count   -= 3;			/* - checksum and addr	*/
		break;
	case '2':
		srec_type = SREC_DATA3;		/* 3 byte addr field	*/
3480dedc:	e3a06002 	mov	r6, #2
		*count   -= 4;			/* - checksum and addr	*/
		break;
3480dee0:	ea000012 	b	3480df30 <srec_decode+0x110>
	case '3':				/* data record with a	*/
		srec_type = SREC_DATA4;		/* 4 byte addr field	*/
		*count   -= 5;			/* - checksum and addr	*/
3480dee4:	e2403005 	sub	r3, r0, #5
3480dee8:	e5843000 	str	r3, [r4]
	case '2':
		srec_type = SREC_DATA3;		/* 3 byte addr field	*/
		*count   -= 4;			/* - checksum and addr	*/
		break;
	case '3':				/* data record with a	*/
		srec_type = SREC_DATA4;		/* 4 byte addr field	*/
3480deec:	e3a06003 	mov	r6, #3
		*count   -= 5;			/* - checksum and addr	*/
		break;
3480def0:	ea00000e 	b	3480df30 <srec_decode+0x110>
/***	case '4'  ***/
	case '5':			/* count record, addr field contains */
		srec_type = SREC_COUNT;	/* a 2 byte record counter	*/
		*count    = 0;			/* no data		*/
3480def4:	e3a03000 	mov	r3, #0
3480def8:	e5843000 	str	r3, [r4]
		srec_type = SREC_DATA4;		/* 4 byte addr field	*/
		*count   -= 5;			/* - checksum and addr	*/
		break;
/***	case '4'  ***/
	case '5':			/* count record, addr field contains */
		srec_type = SREC_COUNT;	/* a 2 byte record counter	*/
3480defc:	e3a06005 	mov	r6, #5
		*count    = 0;			/* no data		*/
		break;
3480df00:	ea00000a 	b	3480df30 <srec_decode+0x110>
/***	case '6' -- not used  ***/
	case '7':				/* end record with a	*/
		srec_type = SREC_END4;		/* 4 byte addr field	*/
		*count   -= 5;			/* - checksum and addr	*/
3480df04:	e2403005 	sub	r3, r0, #5
3480df08:	e5843000 	str	r3, [r4]
		srec_type = SREC_COUNT;	/* a 2 byte record counter	*/
		*count    = 0;			/* no data		*/
		break;
/***	case '6' -- not used  ***/
	case '7':				/* end record with a	*/
		srec_type = SREC_END4;		/* 4 byte addr field	*/
3480df0c:	e3a06007 	mov	r6, #7
		*count   -= 5;			/* - checksum and addr	*/
		break;
3480df10:	ea000006 	b	3480df30 <srec_decode+0x110>
	case '8':				/* end record with a	*/
		srec_type = SREC_END3;		/* 3 byte addr field	*/
		*count   -= 4;			/* - checksum and addr	*/
3480df14:	e2403004 	sub	r3, r0, #4
3480df18:	e5843000 	str	r3, [r4]
	case '7':				/* end record with a	*/
		srec_type = SREC_END4;		/* 4 byte addr field	*/
		*count   -= 5;			/* - checksum and addr	*/
		break;
	case '8':				/* end record with a	*/
		srec_type = SREC_END3;		/* 3 byte addr field	*/
3480df1c:	e3a06008 	mov	r6, #8
		*count   -= 4;			/* - checksum and addr	*/
		break;
3480df20:	ea000002 	b	3480df30 <srec_decode+0x110>
	case '9':				/* end record with a	*/
		srec_type = SREC_END2;		/* 2 byte addr field	*/
		*count   -= 3;			/* - checksum and addr	*/
3480df24:	e2403003 	sub	r3, r0, #3
3480df28:	e5843000 	str	r3, [r4]
	case '8':				/* end record with a	*/
		srec_type = SREC_END3;		/* 3 byte addr field	*/
		*count   -= 4;			/* - checksum and addr	*/
		break;
	case '9':				/* end record with a	*/
		srec_type = SREC_END2;		/* 2 byte addr field	*/
3480df2c:	e3a06009 	mov	r6, #9
	default:
		return (SREC_E_BADTYPE);
	}

	/* read address field */
	*addr = 0;
3480df30:	e3a03000 	mov	r3, #0

	switch (v) {
3480df34:	e24bb030 	sub	fp, fp, #48	; 0x30
	default:
		return (SREC_E_BADTYPE);
	}

	/* read address field */
	*addr = 0;
3480df38:	e5853000 	str	r3, [r5]

	switch (v) {
3480df3c:	e6ef307b 	uxtb	r3, fp
3480df40:	e3530009 	cmp	r3, #9

	if ((*count = hex2_bin(input)) < 0) {
		return (SREC_E_NOSREC);
	}

	chksum += *count;
3480df44:	e6efa070 	uxtb	sl, r0
	input  += 2;
3480df48:	e2877002 	add	r7, r7, #2
	}

	/* read address field */
	*addr = 0;

	switch (v) {
3480df4c:	8a00004a 	bhi	3480e07c <srec_decode+0x25c>
3480df50:	e3a03001 	mov	r3, #1
3480df54:	e6afb07b 	sxtb	fp, fp
3480df58:	e1a0bb13 	lsl	fp, r3, fp
3480df5c:	e3003223 	movw	r3, #547	; 0x223
3480df60:	e00b3003 	and	r3, fp, r3
3480df64:	e3530000 	cmp	r3, #0
3480df68:	1a000016 	bne	3480dfc8 <srec_decode+0x1a8>
3480df6c:	e31b0088 	tst	fp, #136	; 0x88
3480df70:	1a000002 	bne	3480df80 <srec_decode+0x160>
3480df74:	e31b0f41 	tst	fp, #260	; 0x104
3480df78:	1a000008 	bne	3480dfa0 <srec_decode+0x180>
3480df7c:	ea00003e 	b	3480e07c <srec_decode+0x25c>
	case '3':				/* 4 byte addr field	*/
	case '7':
		if ((v = hex2_bin(input)) < 0) {
3480df80:	e1a00007 	mov	r0, r7
3480df84:	ebffff98 	bl	3480ddec <hex2_bin>
3480df88:	e3500000 	cmp	r0, #0
3480df8c:	ba00003c 	blt	3480e084 <srec_decode+0x264>
			return (SREC_E_NOSREC);
		}
		*addr  += v;
		chksum += v;
3480df90:	e08aa000 	add	sl, sl, r0
	case '3':				/* 4 byte addr field	*/
	case '7':
		if ((v = hex2_bin(input)) < 0) {
			return (SREC_E_NOSREC);
		}
		*addr  += v;
3480df94:	e5850000 	str	r0, [r5]
		chksum += v;
3480df98:	e6efa07a 	uxtb	sl, sl
		input  += 2;
3480df9c:	e2877002 	add	r7, r7, #2
		/* FALL THRU */
	case '2':				/* 3 byte addr field	*/
	case '8':
		if ((v = hex2_bin(input)) < 0) {
3480dfa0:	e1a00007 	mov	r0, r7
3480dfa4:	ebffff90 	bl	3480ddec <hex2_bin>
3480dfa8:	e3500000 	cmp	r0, #0
3480dfac:	ba000034 	blt	3480e084 <srec_decode+0x264>
			return (SREC_E_NOSREC);
		}
		*addr <<= 8;
3480dfb0:	e5953000 	ldr	r3, [r5]
		*addr  += v;
		chksum += v;
3480dfb4:	e08aa000 	add	sl, sl, r0
	case '8':
		if ((v = hex2_bin(input)) < 0) {
			return (SREC_E_NOSREC);
		}
		*addr <<= 8;
		*addr  += v;
3480dfb8:	e0803403 	add	r3, r0, r3, lsl #8
3480dfbc:	e5853000 	str	r3, [r5]
		chksum += v;
3480dfc0:	e6efa07a 	uxtb	sl, sl
		input  += 2;
3480dfc4:	e2877002 	add	r7, r7, #2
		/* FALL THRU */
	case '0':				/* 2 byte addr field	*/
	case '1':
	case '5':
	case '9':
		if ((v = hex2_bin(input)) < 0) {
3480dfc8:	e1a00007 	mov	r0, r7
3480dfcc:	ebffff86 	bl	3480ddec <hex2_bin>
3480dfd0:	e250b000 	subs	fp, r0, #0
3480dfd4:	ba00002a 	blt	3480e084 <srec_decode+0x264>
			return (SREC_E_NOSREC);
		}
		*addr <<= 8;
3480dfd8:	e5953000 	ldr	r3, [r5]
		*addr  += v;
		chksum += v;
		input  += 2;
3480dfdc:	e2877002 	add	r7, r7, #2
	case '9':
		if ((v = hex2_bin(input)) < 0) {
			return (SREC_E_NOSREC);
		}
		*addr <<= 8;
		*addr  += v;
3480dfe0:	e08b3403 	add	r3, fp, r3, lsl #8
3480dfe4:	e5853000 	str	r3, [r5]
		chksum += v;
		input  += 2;

		if ((v = hex2_bin(input)) < 0) {
3480dfe8:	e1a00007 	mov	r0, r7
3480dfec:	e58d3004 	str	r3, [sp, #4]
3480dff0:	ebffff7d 	bl	3480ddec <hex2_bin>
3480dff4:	e3500000 	cmp	r0, #0
3480dff8:	e59d3004 	ldr	r3, [sp, #4]
3480dffc:	ba000020 	blt	3480e084 <srec_decode+0x264>
		if ((v = hex2_bin(input)) < 0) {
			return (SREC_E_NOSREC);
		}
		*addr <<= 8;
		*addr  += v;
		chksum += v;
3480e000:	e08aa00b 	add	sl, sl, fp

		if ((v = hex2_bin(input)) < 0) {
			return (SREC_E_NOSREC);
		}
		*addr <<= 8;
		*addr  += v;
3480e004:	e0803403 	add	r3, r0, r3, lsl #8
		chksum += v;
3480e008:	e6e0a07a 	uxtab	sl, r0, sl

		if ((v = hex2_bin(input)) < 0) {
			return (SREC_E_NOSREC);
		}
		*addr <<= 8;
		*addr  += v;
3480e00c:	e5853000 	str	r3, [r5]
		chksum += v;
3480e010:	e6efa07a 	uxtb	sl, sl
		input  += 2;
3480e014:	e2877002 	add	r7, r7, #2
	default:
		return (SREC_E_BADTYPE);
	}

	/* convert data and calculate checksum */
	for (i=0; i < *count; ++i) {
3480e018:	e3a05000 	mov	r5, #0
3480e01c:	ea000009 	b	3480e048 <srec_decode+0x228>
		if ((v = hex2_bin(input)) < 0) {
3480e020:	e1a00007 	mov	r0, r7
3480e024:	ebffff70 	bl	3480ddec <hex2_bin>
3480e028:	e3500000 	cmp	r0, #0
3480e02c:	ba000014 	blt	3480e084 <srec_decode+0x264>
			return (SREC_E_NOSREC);
		}
		data[i] = v;
3480e030:	e6ef0070 	uxtb	r0, r0
		chksum += v;
3480e034:	e080a00a 	add	sl, r0, sl
	/* convert data and calculate checksum */
	for (i=0; i < *count; ++i) {
		if ((v = hex2_bin(input)) < 0) {
			return (SREC_E_NOSREC);
		}
		data[i] = v;
3480e038:	e7c90005 	strb	r0, [r9, r5]
		chksum += v;
3480e03c:	e6efa07a 	uxtb	sl, sl
		input  += 2;
3480e040:	e2877002 	add	r7, r7, #2
	default:
		return (SREC_E_BADTYPE);
	}

	/* convert data and calculate checksum */
	for (i=0; i < *count; ++i) {
3480e044:	e2855001 	add	r5, r5, #1
3480e048:	e5943000 	ldr	r3, [r4]
3480e04c:	e1550003 	cmp	r5, r3
3480e050:	bafffff2 	blt	3480e020 <srec_decode+0x200>
		chksum += v;
		input  += 2;
	}

	/* read anc check checksum */
	if ((v = hex2_bin(input)) < 0) {
3480e054:	e1a00007 	mov	r0, r7
3480e058:	ebffff63 	bl	3480ddec <hex2_bin>
3480e05c:	e3500000 	cmp	r0, #0
3480e060:	ba000007 	blt	3480e084 <srec_decode+0x264>
		return (SREC_E_NOSREC);
	}

	if ((unsigned char)v != (unsigned char)~chksum) {
3480e064:	e1e0a00a 	mvn	sl, sl
3480e068:	e6ef0070 	uxtb	r0, r0
3480e06c:	e6efa07a 	uxtb	sl, sl
		return (SREC_E_BADCHKS);
3480e070:	e150000a 	cmp	r0, sl
3480e074:	13e06002 	mvnne	r6, #2
3480e078:	ea000002 	b	3480e088 <srec_decode+0x268>
		chksum += v;
		input  += 2;

		break;
	default:
		return (SREC_E_BADTYPE);
3480e07c:	e3e06000 	mvn	r6, #0
3480e080:	ea000000 	b	3480e088 <srec_decode+0x268>
		input  += 2;
	}

	/* read anc check checksum */
	if ((v = hex2_bin(input)) < 0) {
		return (SREC_E_NOSREC);
3480e084:	e3e06001 	mvn	r6, #1
	if ((unsigned char)v != (unsigned char)~chksum) {
		return (SREC_E_BADCHKS);
	}

	return (srec_type);
}
3480e088:	e1a00006 	mov	r0, r6
3480e08c:	e8bd8efc 	pop	{r2, r3, r4, r5, r6, r7, r9, sl, fp, pc}

3480e090 <get_current>:
	for (s = serial_devices; s; s = s->next)
		s->init();
}

static struct serial_device *get_current(void)
{
3480e090:	e92d4008 	push	{r3, lr}
	struct serial_device *dev;

	if (!(gd->flags & GD_FLG_RELOC) || !serial_current) {
3480e094:	e5983004 	ldr	r3, [r8, #4]
3480e098:	e3130001 	tst	r3, #1
3480e09c:	0a000003 	beq	3480e0b0 <get_current+0x20>
3480e0a0:	e59f301c 	ldr	r3, [pc, #28]	; 3480e0c4 <get_current+0x34>
3480e0a4:	e5930000 	ldr	r0, [r3]
3480e0a8:	e3500000 	cmp	r0, #0
3480e0ac:	18bd8008 	popne	{r3, pc}
		dev = default_serial_console();
3480e0b0:	eb001ba6 	bl	34814f50 <default_serial_console>

		/* We must have a console device */
		if (!dev)
3480e0b4:	e3500000 	cmp	r0, #0
3480e0b8:	18bd8008 	popne	{r3, pc}
			panic("Cannot find console");
3480e0bc:	e59f0004 	ldr	r0, [pc, #4]	; 3480e0c8 <get_current+0x38>
3480e0c0:	eb002f7b 	bl	34819eb4 <panic>
3480e0c4:	3482ace0 	.word	0x3482ace0
3480e0c8:	34826834 	.word	0x34826834

3480e0cc <serial_register>:
	dev->tstc += gd->reloc_off;
	dev->putc += gd->reloc_off;
	dev->puts += gd->reloc_off;
#endif

	dev->next = serial_devices;
3480e0cc:	e59f300c 	ldr	r3, [pc, #12]	; 3480e0e0 <serial_register+0x14>
3480e0d0:	e5932004 	ldr	r2, [r3, #4]
	serial_devices = dev;
3480e0d4:	e5830004 	str	r0, [r3, #4]
	dev->tstc += gd->reloc_off;
	dev->putc += gd->reloc_off;
	dev->puts += gd->reloc_off;
#endif

	dev->next = serial_devices;
3480e0d8:	e580202c 	str	r2, [r0, #44]	; 0x2c
	serial_devices = dev;
}
3480e0dc:	e12fff1e 	bx	lr
3480e0e0:	3482ace0 	.word	0x3482ace0

3480e0e4 <serial_stdio_init>:
#endif
	serial_assign(default_serial_console()->name);
}

void serial_stdio_init(void)
{
3480e0e4:	e92d40f0 	push	{r4, r5, r6, r7, lr}
	struct stdio_dev dev;
	struct serial_device *s = serial_devices;
3480e0e8:	e59f3080 	ldr	r3, [pc, #128]	; 3480e170 <serial_stdio_init+0x8c>
#endif
	serial_assign(default_serial_console()->name);
}

void serial_stdio_init(void)
{
3480e0ec:	e24dd044 	sub	sp, sp, #68	; 0x44
	struct stdio_dev dev;
	struct serial_device *s = serial_devices;

	while (s) {
		memset(&dev, 0, sizeof(dev));
3480e0f0:	e28d5004 	add	r5, sp, #4
}

void serial_stdio_init(void)
{
	struct stdio_dev dev;
	struct serial_device *s = serial_devices;
3480e0f4:	e5934004 	ldr	r4, [r3, #4]

	while (s) {
		memset(&dev, 0, sizeof(dev));

		strcpy(dev.name, s->name);
3480e0f8:	e2857008 	add	r7, r5, #8
		dev.flags = DEV_FLAGS_OUTPUT | DEV_FLAGS_INPUT;
3480e0fc:	e3a06003 	mov	r6, #3
void serial_stdio_init(void)
{
	struct stdio_dev dev;
	struct serial_device *s = serial_devices;

	while (s) {
3480e100:	ea000016 	b	3480e160 <serial_stdio_init+0x7c>
		memset(&dev, 0, sizeof(dev));
3480e104:	e3a0203c 	mov	r2, #60	; 0x3c
3480e108:	e3a01000 	mov	r1, #0
3480e10c:	e1a00005 	mov	r0, r5
3480e110:	eb002b3a 	bl	34818e00 <memset>

		strcpy(dev.name, s->name);
3480e114:	e1a01004 	mov	r1, r4
3480e118:	e1a00007 	mov	r0, r7
3480e11c:	eb002a32 	bl	348189ec <strcpy>
		dev.flags = DEV_FLAGS_OUTPUT | DEV_FLAGS_INPUT;

		dev.start = s->init;
3480e120:	e5943010 	ldr	r3, [r4, #16]
		dev.putc = s->putc;
		dev.puts = s->puts;
		dev.getc = s->getc;
		dev.tstc = s->tstc;

		stdio_register(&dev);
3480e124:	e1a00005 	mov	r0, r5
		memset(&dev, 0, sizeof(dev));

		strcpy(dev.name, s->name);
		dev.flags = DEV_FLAGS_OUTPUT | DEV_FLAGS_INPUT;

		dev.start = s->init;
3480e128:	e58d301c 	str	r3, [sp, #28]
		dev.stop = s->uninit;
3480e12c:	e5943014 	ldr	r3, [r4, #20]

	while (s) {
		memset(&dev, 0, sizeof(dev));

		strcpy(dev.name, s->name);
		dev.flags = DEV_FLAGS_OUTPUT | DEV_FLAGS_INPUT;
3480e130:	e58d6004 	str	r6, [sp, #4]

		dev.start = s->init;
		dev.stop = s->uninit;
3480e134:	e58d3020 	str	r3, [sp, #32]
		dev.putc = s->putc;
3480e138:	e5943024 	ldr	r3, [r4, #36]	; 0x24
3480e13c:	e58d3024 	str	r3, [sp, #36]	; 0x24
		dev.puts = s->puts;
3480e140:	e5943028 	ldr	r3, [r4, #40]	; 0x28
3480e144:	e58d3028 	str	r3, [sp, #40]	; 0x28
		dev.getc = s->getc;
3480e148:	e594301c 	ldr	r3, [r4, #28]
3480e14c:	e58d3030 	str	r3, [sp, #48]	; 0x30
		dev.tstc = s->tstc;
3480e150:	e5943020 	ldr	r3, [r4, #32]
3480e154:	e58d302c 	str	r3, [sp, #44]	; 0x2c

		stdio_register(&dev);
3480e158:	eb000083 	bl	3480e36c <stdio_register>

		s = s->next;
3480e15c:	e594402c 	ldr	r4, [r4, #44]	; 0x2c
void serial_stdio_init(void)
{
	struct stdio_dev dev;
	struct serial_device *s = serial_devices;

	while (s) {
3480e160:	e3540000 	cmp	r4, #0
3480e164:	1affffe6 	bne	3480e104 <serial_stdio_init+0x20>

		stdio_register(&dev);

		s = s->next;
	}
}
3480e168:	e28dd044 	add	sp, sp, #68	; 0x44
3480e16c:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
3480e170:	3482ace0 	.word	0x3482ace0

3480e174 <serial_assign>:

int serial_assign(const char *name)
{
3480e174:	e92d4038 	push	{r3, r4, r5, lr}
	struct serial_device *s;

	for (s = serial_devices; s; s = s->next) {
3480e178:	e59f303c 	ldr	r3, [pc, #60]	; 3480e1bc <serial_assign+0x48>
		s = s->next;
	}
}

int serial_assign(const char *name)
{
3480e17c:	e1a05000 	mov	r5, r0
	struct serial_device *s;

	for (s = serial_devices; s; s = s->next) {
3480e180:	e5934004 	ldr	r4, [r3, #4]
3480e184:	ea000008 	b	3480e1ac <serial_assign+0x38>
		if (strcmp(s->name, name) == 0) {
3480e188:	e1a00004 	mov	r0, r4
3480e18c:	e1a01005 	mov	r1, r5
3480e190:	eb002a46 	bl	34818ab0 <strcmp>
3480e194:	e3500000 	cmp	r0, #0
3480e198:	1a000002 	bne	3480e1a8 <serial_assign+0x34>
			serial_current = s;
3480e19c:	e59f3018 	ldr	r3, [pc, #24]	; 3480e1bc <serial_assign+0x48>
3480e1a0:	e5834000 	str	r4, [r3]
			return 0;
3480e1a4:	e8bd8038 	pop	{r3, r4, r5, pc}

int serial_assign(const char *name)
{
	struct serial_device *s;

	for (s = serial_devices; s; s = s->next) {
3480e1a8:	e594402c 	ldr	r4, [r4, #44]	; 0x2c
3480e1ac:	e3540000 	cmp	r4, #0
3480e1b0:	1afffff4 	bne	3480e188 <serial_assign+0x14>
			serial_current = s;
			return 0;
		}
	}

	return 1;
3480e1b4:	e3a00001 	mov	r0, #1
}
3480e1b8:	e8bd8038 	pop	{r3, r4, r5, pc}
3480e1bc:	3482ace0 	.word	0x3482ace0

3480e1c0 <serial_initialize>:
	dev->tstc += gd->reloc_off;
	dev->putc += gd->reloc_off;
	dev->puts += gd->reloc_off;
#endif

	dev->next = serial_devices;
3480e1c0:	e59f3034 	ldr	r3, [pc, #52]	; 3480e1fc <serial_initialize+0x3c>
3480e1c4:	e59f1034 	ldr	r1, [pc, #52]	; 3480e200 <serial_initialize+0x40>
3480e1c8:	e5932004 	ldr	r2, [r3, #4]
	serial_devices = dev;
}

void serial_initialize(void)
{
3480e1cc:	e92d4010 	push	{r4, lr}
	dev->tstc += gd->reloc_off;
	dev->putc += gd->reloc_off;
	dev->puts += gd->reloc_off;
#endif

	dev->next = serial_devices;
3480e1d0:	e581202c 	str	r2, [r1, #44]	; 0x2c
3480e1d4:	e59f2028 	ldr	r2, [pc, #40]	; 3480e204 <serial_initialize+0x44>
3480e1d8:	e582102c 	str	r1, [r2, #44]	; 0x2c
3480e1dc:	e59f1024 	ldr	r1, [pc, #36]	; 3480e208 <serial_initialize+0x48>
3480e1e0:	e581202c 	str	r2, [r1, #44]	; 0x2c
3480e1e4:	e59f2020 	ldr	r2, [pc, #32]	; 3480e20c <serial_initialize+0x4c>
3480e1e8:	e582102c 	str	r1, [r2, #44]	; 0x2c
	serial_devices = dev;
3480e1ec:	e5832004 	str	r2, [r3, #4]
# endif
# ifdef CONFIG_ZYNQ_SERIAL_BASEADDR1
	serial_register(&uart_zynq_serial1_device);
# endif
#endif
	serial_assign(default_serial_console()->name);
3480e1f0:	eb001b56 	bl	34814f50 <default_serial_console>
}
3480e1f4:	e8bd4010 	pop	{r4, lr}
# endif
# ifdef CONFIG_ZYNQ_SERIAL_BASEADDR1
	serial_register(&uart_zynq_serial1_device);
# endif
#endif
	serial_assign(default_serial_console()->name);
3480e1f8:	eaffffdd 	b	3480e174 <serial_assign>
3480e1fc:	3482ace0 	.word	0x3482ace0
3480e200:	34828950 	.word	0x34828950
3480e204:	34828980 	.word	0x34828980
3480e208:	348289b0 	.word	0x348289b0
3480e20c:	348289e0 	.word	0x348289e0

3480e210 <serial_reinit_all>:

void serial_reinit_all(void)
{
	struct serial_device *s;

	for (s = serial_devices; s; s = s->next)
3480e210:	e59f3020 	ldr	r3, [pc, #32]	; 3480e238 <serial_reinit_all+0x28>

	return 1;
}

void serial_reinit_all(void)
{
3480e214:	e92d4010 	push	{r4, lr}
	struct serial_device *s;

	for (s = serial_devices; s; s = s->next)
3480e218:	e5934004 	ldr	r4, [r3, #4]
3480e21c:	ea000002 	b	3480e22c <serial_reinit_all+0x1c>
		s->init();
3480e220:	e5943010 	ldr	r3, [r4, #16]
3480e224:	e12fff33 	blx	r3

void serial_reinit_all(void)
{
	struct serial_device *s;

	for (s = serial_devices; s; s = s->next)
3480e228:	e594402c 	ldr	r4, [r4, #44]	; 0x2c
3480e22c:	e3540000 	cmp	r4, #0
3480e230:	1afffffa 	bne	3480e220 <serial_reinit_all+0x10>
		s->init();
}
3480e234:	e8bd8010 	pop	{r4, pc}
3480e238:	3482ace0 	.word	0x3482ace0

3480e23c <serial_init>:
		dev = serial_current;
	return dev;
}

int serial_init(void)
{
3480e23c:	e92d4008 	push	{r3, lr}
	return get_current()->init();
3480e240:	ebffff92 	bl	3480e090 <get_current>
3480e244:	e5903010 	ldr	r3, [r0, #16]
3480e248:	e12fff33 	blx	r3
}
3480e24c:	e8bd8008 	pop	{r3, pc}

3480e250 <serial_setbrg>:

void serial_setbrg(void)
{
3480e250:	e92d4008 	push	{r3, lr}
	get_current()->setbrg();
3480e254:	ebffff8d 	bl	3480e090 <get_current>
3480e258:	e5903018 	ldr	r3, [r0, #24]
3480e25c:	e12fff33 	blx	r3
}
3480e260:	e8bd8008 	pop	{r3, pc}

3480e264 <serial_getc>:

int serial_getc(void)
{
3480e264:	e92d4008 	push	{r3, lr}
	return get_current()->getc();
3480e268:	ebffff88 	bl	3480e090 <get_current>
3480e26c:	e590301c 	ldr	r3, [r0, #28]
3480e270:	e12fff33 	blx	r3
}
3480e274:	e8bd8008 	pop	{r3, pc}

3480e278 <serial_tstc>:

int serial_tstc(void)
{
3480e278:	e92d4008 	push	{r3, lr}
	return get_current()->tstc();
3480e27c:	ebffff83 	bl	3480e090 <get_current>
3480e280:	e5903020 	ldr	r3, [r0, #32]
3480e284:	e12fff33 	blx	r3
}
3480e288:	e8bd8008 	pop	{r3, pc}

3480e28c <serial_putc>:

void serial_putc(const char c)
{
3480e28c:	e92d4010 	push	{r4, lr}
3480e290:	e1a04000 	mov	r4, r0
	get_current()->putc(c);
3480e294:	ebffff7d 	bl	3480e090 <get_current>
3480e298:	e5903024 	ldr	r3, [r0, #36]	; 0x24
3480e29c:	e1a00004 	mov	r0, r4
3480e2a0:	e12fff33 	blx	r3
}
3480e2a4:	e8bd8010 	pop	{r4, pc}

3480e2a8 <serial_puts>:

void serial_puts(const char *s)
{
3480e2a8:	e92d4010 	push	{r4, lr}
3480e2ac:	e1a04000 	mov	r4, r0
	get_current()->puts(s);
3480e2b0:	ebffff76 	bl	3480e090 <get_current>
3480e2b4:	e5903028 	ldr	r3, [r0, #40]	; 0x28
3480e2b8:	e1a00004 	mov	r0, r4
3480e2bc:	e12fff33 	blx	r3
}
3480e2c0:	e8bd8010 	pop	{r4, pc}

3480e2c4 <stdio_get_list>:
 **************************************************************************
 */
struct list_head* stdio_get_list(void)
{
	return &(devs.list);
}
3480e2c4:	e59f0000 	ldr	r0, [pc, #0]	; 3480e2cc <stdio_get_list+0x8>
3480e2c8:	e12fff1e 	bx	lr
3480e2cc:	3482ad1c 	.word	0x3482ad1c

3480e2d0 <stdio_get_by_name>:

struct stdio_dev* stdio_get_by_name(const char *name)
{
3480e2d0:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
	struct list_head *pos;
	struct stdio_dev *dev;

	if(!name)
3480e2d4:	e2507000 	subs	r7, r0, #0
		return NULL;

	list_for_each(pos, &(devs.list)) {
3480e2d8:	159f6040 	ldrne	r6, [pc, #64]	; 3480e320 <stdio_get_by_name+0x50>
3480e2dc:	15b65034 	ldrne	r5, [r6, #52]!	; 0x34
struct stdio_dev* stdio_get_by_name(const char *name)
{
	struct list_head *pos;
	struct stdio_dev *dev;

	if(!name)
3480e2e0:	0a00000b 	beq	3480e314 <stdio_get_by_name+0x44>
3480e2e4:	ea000006 	b	3480e304 <stdio_get_by_name+0x34>
		return NULL;

	list_for_each(pos, &(devs.list)) {
		dev = list_entry(pos, struct stdio_dev, list);
3480e2e8:	e2454034 	sub	r4, r5, #52	; 0x34
		if(strcmp(dev->name, name) == 0)
3480e2ec:	e2840008 	add	r0, r4, #8
3480e2f0:	e1a01007 	mov	r1, r7
3480e2f4:	eb0029ed 	bl	34818ab0 <strcmp>
3480e2f8:	e3500000 	cmp	r0, #0
3480e2fc:	0a000005 	beq	3480e318 <stdio_get_by_name+0x48>
	struct stdio_dev *dev;

	if(!name)
		return NULL;

	list_for_each(pos, &(devs.list)) {
3480e300:	e5955000 	ldr	r5, [r5]
3480e304:	e1550006 	cmp	r5, r6
3480e308:	1afffff6 	bne	3480e2e8 <stdio_get_by_name+0x18>
		dev = list_entry(pos, struct stdio_dev, list);
		if(strcmp(dev->name, name) == 0)
			return dev;
	}

	return NULL;
3480e30c:	e3a04000 	mov	r4, #0
3480e310:	ea000000 	b	3480e318 <stdio_get_by_name+0x48>
{
	struct list_head *pos;
	struct stdio_dev *dev;

	if(!name)
		return NULL;
3480e314:	e1a04007 	mov	r4, r7
		if(strcmp(dev->name, name) == 0)
			return dev;
	}

	return NULL;
}
3480e318:	e1a00004 	mov	r0, r4
3480e31c:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
3480e320:	3482ace8 	.word	0x3482ace8

3480e324 <stdio_clone>:

struct stdio_dev* stdio_clone(struct stdio_dev *dev)
{
3480e324:	e92d4038 	push	{r3, r4, r5, lr}
	struct stdio_dev *_dev;

	if(!dev)
3480e328:	e2505000 	subs	r5, r0, #0
		return NULL;
3480e32c:	01a04005 	moveq	r4, r5

struct stdio_dev* stdio_clone(struct stdio_dev *dev)
{
	struct stdio_dev *_dev;

	if(!dev)
3480e330:	0a00000b 	beq	3480e364 <stdio_clone+0x40>
		return NULL;

	_dev = calloc(1, sizeof(struct stdio_dev));
3480e334:	e3a00001 	mov	r0, #1
3480e338:	e3a0103c 	mov	r1, #60	; 0x3c
3480e33c:	ebffee36 	bl	34809c1c <calloc>

	if(!_dev)
3480e340:	e2504000 	subs	r4, r0, #0
3480e344:	0a000006 	beq	3480e364 <stdio_clone+0x40>
		return NULL;

	memcpy(_dev, dev, sizeof(struct stdio_dev));
3480e348:	e1a01005 	mov	r1, r5
3480e34c:	e3a0203c 	mov	r2, #60	; 0x3c
3480e350:	eb002ace 	bl	34818e90 <memcpy>
	strncpy(_dev->name, dev->name, 16);
3480e354:	e2840008 	add	r0, r4, #8
3480e358:	e2851008 	add	r1, r5, #8
3480e35c:	e3a02010 	mov	r2, #16
3480e360:	eb0029a8 	bl	34818a08 <strncpy>

	return _dev;
}
3480e364:	e1a00004 	mov	r0, r4
3480e368:	e8bd8038 	pop	{r3, r4, r5, pc}

3480e36c <stdio_register>:

int stdio_register (struct stdio_dev * dev)
{
3480e36c:	e92d4008 	push	{r3, lr}
	struct stdio_dev *_dev;

	_dev = stdio_clone(dev);
3480e370:	ebffffeb 	bl	3480e324 <stdio_clone>
	if(!_dev)
3480e374:	e3500000 	cmp	r0, #0
3480e378:	0a000009 	beq	3480e3a4 <stdio_register+0x38>
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
3480e37c:	e59f3028 	ldr	r3, [pc, #40]	; 3480e3ac <stdio_register+0x40>
		return -1;
	list_add_tail(&(_dev->list), &(devs.list));
3480e380:	e2801034 	add	r1, r0, #52	; 0x34
3480e384:	e5932038 	ldr	r2, [r3, #56]	; 0x38
 */
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
3480e388:	e5831038 	str	r1, [r3, #56]	; 0x38
	new->next = next;
3480e38c:	e2833034 	add	r3, r3, #52	; 0x34
3480e390:	e5803034 	str	r3, [r0, #52]	; 0x34
	new->prev = prev;
3480e394:	e5802038 	str	r2, [r0, #56]	; 0x38
	prev->next = new;
3480e398:	e5821000 	str	r1, [r2]
	return 0;
3480e39c:	e3a00000 	mov	r0, #0
3480e3a0:	e8bd8008 	pop	{r3, pc}
{
	struct stdio_dev *_dev;

	_dev = stdio_clone(dev);
	if(!_dev)
		return -1;
3480e3a4:	e3e00000 	mvn	r0, #0
	list_add_tail(&(_dev->list), &(devs.list));
	return 0;
}
3480e3a8:	e8bd8008 	pop	{r3, pc}
3480e3ac:	3482ace8 	.word	0x3482ace8

3480e3b0 <stdio_init>:
	return 0;
}
#endif	/* CONFIG_SYS_STDIO_DEREGISTER */

int stdio_init (void)
{
3480e3b0:	e92d4010 	push	{r4, lr}
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
3480e3b4:	e59f3078 	ldr	r3, [pc, #120]	; 3480e434 <stdio_init+0x84>
3480e3b8:	e24dd040 	sub	sp, sp, #64	; 0x40
3480e3bc:	e2832034 	add	r2, r3, #52	; 0x34
3480e3c0:	e5832034 	str	r2, [r3, #52]	; 0x34
	list->prev = list;
3480e3c4:	e5832038 	str	r2, [r3, #56]	; 0x38

static void drv_system_init (void)
{
	struct stdio_dev dev;

	memset (&dev, 0, sizeof (dev));
3480e3c8:	e28d4004 	add	r4, sp, #4

#ifdef CONFIG_ARM_DCC_MULTI
	drv_arm_dcc_init ();
#endif
#if defined(CONFIG_HARD_I2C) || defined(CONFIG_SOFT_I2C)
	i2c_init (CONFIG_SYS_I2C_SPEED, CONFIG_SYS_I2C_SLAVE);
3480e3cc:	e30c0350 	movw	r0, #50000	; 0xc350
3480e3d0:	e3a010fe 	mov	r1, #254	; 0xfe
3480e3d4:	eb000654 	bl	3480fd2c <i2c_init>

static void drv_system_init (void)
{
	struct stdio_dev dev;

	memset (&dev, 0, sizeof (dev));
3480e3d8:	e3a0203c 	mov	r2, #60	; 0x3c
3480e3dc:	e1a00004 	mov	r0, r4
3480e3e0:	e3a01000 	mov	r1, #0
3480e3e4:	eb002a85 	bl	34818e00 <memset>

	strcpy (dev.name, "serial");
3480e3e8:	e59f1048 	ldr	r1, [pc, #72]	; 3480e438 <stdio_init+0x88>
3480e3ec:	e2840008 	add	r0, r4, #8
3480e3f0:	eb00297d 	bl	348189ec <strcpy>
	dev.flags = DEV_FLAGS_OUTPUT | DEV_FLAGS_INPUT | DEV_FLAGS_SYSTEM;
3480e3f4:	e3a0310e 	mov	r3, #-2147483645	; 0x80000003
3480e3f8:	e58d3004 	str	r3, [sp, #4]
	dev.putc = serial_putc;
3480e3fc:	e59f3038 	ldr	r3, [pc, #56]	; 3480e43c <stdio_init+0x8c>
	dev.puts = serial_puts;
	dev.getc = serial_getc;
	dev.tstc = serial_tstc;
	stdio_register (&dev);
3480e400:	e1a00004 	mov	r0, r4

	memset (&dev, 0, sizeof (dev));

	strcpy (dev.name, "serial");
	dev.flags = DEV_FLAGS_OUTPUT | DEV_FLAGS_INPUT | DEV_FLAGS_SYSTEM;
	dev.putc = serial_putc;
3480e404:	e58d3024 	str	r3, [sp, #36]	; 0x24
	dev.puts = serial_puts;
3480e408:	e59f3030 	ldr	r3, [pc, #48]	; 3480e440 <stdio_init+0x90>
3480e40c:	e58d3028 	str	r3, [sp, #40]	; 0x28
	dev.getc = serial_getc;
3480e410:	e59f302c 	ldr	r3, [pc, #44]	; 3480e444 <stdio_init+0x94>
3480e414:	e58d3030 	str	r3, [sp, #48]	; 0x30
	dev.tstc = serial_tstc;
3480e418:	e59f3028 	ldr	r3, [pc, #40]	; 3480e448 <stdio_init+0x98>
3480e41c:	e58d302c 	str	r3, [sp, #44]	; 0x2c
	stdio_register (&dev);
3480e420:	ebffffd1 	bl	3480e36c <stdio_register>
#ifdef CONFIG_LOGBUFFER
	drv_logbuff_init ();
#endif
	drv_system_init ();
#ifdef CONFIG_SERIAL_MULTI
	serial_stdio_init ();
3480e424:	ebffff2e 	bl	3480e0e4 <serial_stdio_init>
#ifdef CONFIG_JTAG_CONSOLE
	drv_jtag_console_init ();
#endif

	return (0);
}
3480e428:	e3a00000 	mov	r0, #0
3480e42c:	e28dd040 	add	sp, sp, #64	; 0x40
3480e430:	e8bd8010 	pop	{r4, pc}
3480e434:	3482ace8 	.word	0x3482ace8
3480e438:	34825f97 	.word	0x34825f97
3480e43c:	3480e28c 	.word	0x3480e28c
3480e440:	3480e2a8 	.word	0x3480e2a8
3480e444:	3480e264 	.word	0x3480e264
3480e448:	3480e278 	.word	0x3480e278

3480e44c <CYGACC_COMM_IF_GETC_TIMEOUT>:

#ifndef REDBOOT			/*SB */
typedef int cyg_int32;
int
CYGACC_COMM_IF_GETC_TIMEOUT (char chan, char *c)
{
3480e44c:	e92d4070 	push	{r4, r5, r6, lr}
3480e450:	e1a05001 	mov	r5, r1
#define DELAY 20
  unsigned long counter = 0;
3480e454:	e3a04000 	mov	r4, #0
  while (!tstc () && (counter < xyzModem_CHAR_TIMEOUT * 1000 / DELAY))
3480e458:	e59f603c 	ldr	r6, [pc, #60]	; 3480e49c <CYGACC_COMM_IF_GETC_TIMEOUT+0x50>
3480e45c:	ea000002 	b	3480e46c <CYGACC_COMM_IF_GETC_TIMEOUT+0x20>
    {
      udelay (DELAY);
3480e460:	e3a00014 	mov	r0, #20
3480e464:	eb002b14 	bl	348190bc <udelay>
      counter++;
3480e468:	e2844001 	add	r4, r4, #1
int
CYGACC_COMM_IF_GETC_TIMEOUT (char chan, char *c)
{
#define DELAY 20
  unsigned long counter = 0;
  while (!tstc () && (counter < xyzModem_CHAR_TIMEOUT * 1000 / DELAY))
3480e46c:	ebffea99 	bl	34808ed8 <tstc>
3480e470:	e3500000 	cmp	r0, #0
3480e474:	1a000001 	bne	3480e480 <CYGACC_COMM_IF_GETC_TIMEOUT+0x34>
3480e478:	e1540006 	cmp	r4, r6
3480e47c:	1afffff7 	bne	3480e460 <CYGACC_COMM_IF_GETC_TIMEOUT+0x14>
    {
      udelay (DELAY);
      counter++;
    }
  if (tstc ())
3480e480:	ebffea94 	bl	34808ed8 <tstc>
3480e484:	e3500000 	cmp	r0, #0
3480e488:	08bd8070 	popeq	{r4, r5, r6, pc}
    {
      *c = getc ();
3480e48c:	ebffea88 	bl	34808eb4 <getc>
3480e490:	e5c50000 	strb	r0, [r5]
      return 1;
3480e494:	e3a00001 	mov	r0, #1
    }
  return 0;
}
3480e498:	e8bd8070 	pop	{r4, r5, r6, pc}
3480e49c:	000186a0 	.word	0x000186a0

3480e4a0 <xyzModem_flush>:
#endif

/* Wait for the line to go idle */
static void
xyzModem_flush (void)
{
3480e4a0:	e92d4037 	push	{r0, r1, r2, r4, r5, lr}
  int res;
  char c;
  while (true)
    {
      res = CYGACC_COMM_IF_GETC_TIMEOUT (*xyz.__chan, &c);
3480e4a4:	e59f501c 	ldr	r5, [pc, #28]	; 3480e4c8 <xyzModem_flush+0x28>
3480e4a8:	e28d4007 	add	r4, sp, #7
3480e4ac:	e5953000 	ldr	r3, [r5]
3480e4b0:	e1a01004 	mov	r1, r4
3480e4b4:	e5d30000 	ldrb	r0, [r3]
3480e4b8:	ebffffe3 	bl	3480e44c <CYGACC_COMM_IF_GETC_TIMEOUT>
      if (!res)
3480e4bc:	e3500000 	cmp	r0, #0
3480e4c0:	1afffff9 	bne	3480e4ac <xyzModem_flush+0xc>
	return;
    }
}
3480e4c4:	e8bd803e 	pop	{r1, r2, r3, r4, r5, pc}
3480e4c8:	3482ad30 	.word	0x3482ad30

3480e4cc <xyzModem_get_hdr>:

static int
xyzModem_get_hdr (void)
{
3480e4cc:	e92d44f3 	push	{r0, r1, r4, r5, r6, r7, sl, lr}
  ZM_DEBUG (zm_new ());
  /* Find the start of a header */
  can_total = 0;
  hdr_chars = 0;

  if (xyz.tx_ack)
3480e4d0:	e59f4250 	ldr	r4, [pc, #592]	; 3480e728 <xyzModem_get_hdr+0x25c>
3480e4d4:	e5943430 	ldr	r3, [r4, #1072]	; 0x430
3480e4d8:	e3530000 	cmp	r3, #0
3480e4dc:	0a000003 	beq	3480e4f0 <xyzModem_get_hdr+0x24>
}

void
CYGACC_COMM_IF_PUTC (char x, char y)
{
  putc (y);
3480e4e0:	e3a00006 	mov	r0, #6
3480e4e4:	ebffea84 	bl	34808efc <putc>
  hdr_chars = 0;

  if (xyz.tx_ack)
    {
      CYGACC_COMM_IF_PUTC (*xyz.__chan, ACK);
      xyz.tx_ack = false;
3480e4e8:	e3a03000 	mov	r3, #0
3480e4ec:	e5843430 	str	r3, [r4, #1072]	; 0x430
    }
}

static int
xyzModem_get_hdr (void)
{
3480e4f0:	e3a05000 	mov	r5, #0
      CYGACC_COMM_IF_PUTC (*xyz.__chan, ACK);
      xyz.tx_ack = false;
    }
  while (!hdr_found)
    {
      res = CYGACC_COMM_IF_GETC_TIMEOUT (*xyz.__chan, &c);
3480e4f4:	e59f622c 	ldr	r6, [pc, #556]	; 3480e728 <xyzModem_get_hdr+0x25c>
    }
}

static int
xyzModem_get_hdr (void)
{
3480e4f8:	e1a07005 	mov	r7, r5
      CYGACC_COMM_IF_PUTC (*xyz.__chan, ACK);
      xyz.tx_ack = false;
    }
  while (!hdr_found)
    {
      res = CYGACC_COMM_IF_GETC_TIMEOUT (*xyz.__chan, &c);
3480e4fc:	e28da007 	add	sl, sp, #7
3480e500:	e5963000 	ldr	r3, [r6]
3480e504:	e1a0100a 	mov	r1, sl
3480e508:	e5d30000 	ldrb	r0, [r3]
3480e50c:	ebffffce 	bl	3480e44c <CYGACC_COMM_IF_GETC_TIMEOUT>
      ZM_DEBUG (zm_save (c));
      if (res)
3480e510:	e3500000 	cmp	r0, #0
      CYGACC_COMM_IF_PUTC (*xyz.__chan, ACK);
      xyz.tx_ack = false;
    }
  while (!hdr_found)
    {
      res = CYGACC_COMM_IF_GETC_TIMEOUT (*xyz.__chan, &c);
3480e514:	e59f420c 	ldr	r4, [pc, #524]	; 3480e728 <xyzModem_get_hdr+0x25c>
      ZM_DEBUG (zm_save (c));
      if (res)
3480e518:	0a000021 	beq	3480e5a4 <xyzModem_get_hdr+0xd8>
	{
	  hdr_chars++;
	  switch (c)
3480e51c:	e5dd3007 	ldrb	r3, [sp, #7]
    {
      res = CYGACC_COMM_IF_GETC_TIMEOUT (*xyz.__chan, &c);
      ZM_DEBUG (zm_save (c));
      if (res)
	{
	  hdr_chars++;
3480e520:	e2855001 	add	r5, r5, #1
	  switch (c)
3480e524:	e3530002 	cmp	r3, #2
3480e528:	0a00000c 	beq	3480e560 <xyzModem_get_hdr+0x94>
3480e52c:	8a000002 	bhi	3480e53c <xyzModem_get_hdr+0x70>
3480e530:	e3530001 	cmp	r3, #1
3480e534:	1afffff1 	bne	3480e500 <xyzModem_get_hdr+0x34>
3480e538:	ea000004 	b	3480e550 <xyzModem_get_hdr+0x84>
3480e53c:	e3530004 	cmp	r3, #4
3480e540:	0a000011 	beq	3480e58c <xyzModem_get_hdr+0xc0>
3480e544:	e3530018 	cmp	r3, #24
3480e548:	1affffec 	bne	3480e500 <xyzModem_get_hdr+0x34>
3480e54c:	ea000007 	b	3480e570 <xyzModem_get_hdr+0xa4>
	    {
	    case SOH:
	      xyz.total_SOH++;
3480e550:	e594341c 	ldr	r3, [r4, #1052]	; 0x41c
3480e554:	e2833001 	add	r3, r3, #1
3480e558:	e584341c 	str	r3, [r4, #1052]	; 0x41c
3480e55c:	ea000069 	b	3480e708 <xyzModem_get_hdr+0x23c>
	    case STX:
	      if (c == STX)
		xyz.total_STX++;
3480e560:	e5943420 	ldr	r3, [r4, #1056]	; 0x420
3480e564:	e2833001 	add	r3, r3, #1
3480e568:	e5843420 	str	r3, [r4, #1056]	; 0x420
3480e56c:	ea000065 	b	3480e708 <xyzModem_get_hdr+0x23c>
	      hdr_found = true;
	      break;
	    case CAN:
	      xyz.total_CAN++;
3480e570:	e5963424 	ldr	r3, [r6, #1060]	; 0x424
	      ZM_DEBUG (zm_dump (__LINE__));
	      if (++can_total == xyzModem_CAN_COUNT)
3480e574:	e2877001 	add	r7, r7, #1
	      if (c == STX)
		xyz.total_STX++;
	      hdr_found = true;
	      break;
	    case CAN:
	      xyz.total_CAN++;
3480e578:	e2833001 	add	r3, r3, #1
	      ZM_DEBUG (zm_dump (__LINE__));
	      if (++can_total == xyzModem_CAN_COUNT)
3480e57c:	e3570003 	cmp	r7, #3
	      if (c == STX)
		xyz.total_STX++;
	      hdr_found = true;
	      break;
	    case CAN:
	      xyz.total_CAN++;
3480e580:	e5863424 	str	r3, [r6, #1060]	; 0x424
	      ZM_DEBUG (zm_dump (__LINE__));
	      if (++can_total == xyzModem_CAN_COUNT)
3480e584:	1affffdd 	bne	3480e500 <xyzModem_get_hdr+0x34>
3480e588:	ea00005a 	b	3480e6f8 <xyzModem_get_hdr+0x22c>
		  /* Wait for multiple CAN to avoid early quits */
		  break;
		}
	    case EOT:
	      /* EOT only supported if no noise */
	      if (hdr_chars == 1)
3480e58c:	e3550001 	cmp	r5, #1
3480e590:	1affffda 	bne	3480e500 <xyzModem_get_hdr+0x34>
}

void
CYGACC_COMM_IF_PUTC (char x, char y)
{
  putc (y);
3480e594:	e3a00006 	mov	r0, #6
3480e598:	ebffea57 	bl	34808efc <putc>
	      if (hdr_chars == 1)
		{
		  CYGACC_COMM_IF_PUTC (*xyz.__chan, ACK);
		  ZM_DEBUG (zm_dprintf ("ACK on EOT #%d\n", __LINE__));
		  ZM_DEBUG (zm_dump (__LINE__));
		  return xyzModem_eof;
3480e59c:	e3e00003 	mvn	r0, #3
3480e5a0:	ea000057 	b	3480e704 <xyzModem_get_hdr+0x238>
	    }
	}
      else
	{
	  /* Data stream timed out */
	  xyzModem_flush ();	/* Toss any current input */
3480e5a4:	ebffffbd 	bl	3480e4a0 <xyzModem_flush>
	  ZM_DEBUG (zm_dump (__LINE__));
	  CYGACC_CALL_IF_DELAY_US ((cyg_int32) 250000);
3480e5a8:	e59f017c 	ldr	r0, [pc, #380]	; 3480e72c <xyzModem_get_hdr+0x260>
3480e5ac:	eb002ac2 	bl	348190bc <udelay>
3480e5b0:	ea000052 	b	3480e700 <xyzModem_get_hdr+0x234>
  if (!res)
    {
      ZM_DEBUG (zm_dump (__LINE__));
      return xyzModem_timeout;
    }
  res = CYGACC_COMM_IF_GETC_TIMEOUT (*xyz.__chan, (char *) &xyz.cblk);
3480e5b4:	e5943000 	ldr	r3, [r4]
3480e5b8:	e59f1170 	ldr	r1, [pc, #368]	; 3480e730 <xyzModem_get_hdr+0x264>
3480e5bc:	e5d30000 	ldrb	r0, [r3]
3480e5c0:	ebffffa1 	bl	3480e44c <CYGACC_COMM_IF_GETC_TIMEOUT>
  ZM_DEBUG (zm_save (xyz.cblk));
  if (!res)
3480e5c4:	e3500000 	cmp	r0, #0
3480e5c8:	0a00004c 	beq	3480e700 <xyzModem_get_hdr+0x234>
    {
      ZM_DEBUG (zm_dump (__LINE__));
      return xyzModem_timeout;
    }
  xyz.len = (c == SOH) ? 128 : 1024;
3480e5cc:	e28d7008 	add	r7, sp, #8
3480e5d0:	e5773001 	ldrb	r3, [r7, #-1]!
  xyz.bufp = xyz.pkt;
  for (i = 0; i < xyz.len; i++)
3480e5d4:	e3a05000 	mov	r5, #0
  if (!res)
    {
      ZM_DEBUG (zm_dump (__LINE__));
      return xyzModem_timeout;
    }
  xyz.len = (c == SOH) ? 128 : 1024;
3480e5d8:	e3530001 	cmp	r3, #1
3480e5dc:	13a03b01 	movne	r3, #1024	; 0x400
3480e5e0:	03a03080 	moveq	r3, #128	; 0x80
3480e5e4:	e5843410 	str	r3, [r4, #1040]	; 0x410
  xyz.bufp = xyz.pkt;
3480e5e8:	e2843004 	add	r3, r4, #4
3480e5ec:	e5843404 	str	r3, [r4, #1028]	; 0x404
  for (i = 0; i < xyz.len; i++)
3480e5f0:	ea000009 	b	3480e61c <xyzModem_get_hdr+0x150>
    {
      res = CYGACC_COMM_IF_GETC_TIMEOUT (*xyz.__chan, &c);
3480e5f4:	e5943000 	ldr	r3, [r4]
3480e5f8:	e1a01007 	mov	r1, r7
3480e5fc:	e5d30000 	ldrb	r0, [r3]
3480e600:	ebffff91 	bl	3480e44c <CYGACC_COMM_IF_GETC_TIMEOUT>
      ZM_DEBUG (zm_save (c));
      if (res)
3480e604:	e3500000 	cmp	r0, #0
3480e608:	0a00003c 	beq	3480e700 <xyzModem_get_hdr+0x234>
	{
	  xyz.pkt[i] = c;
3480e60c:	e5dd2007 	ldrb	r2, [sp, #7]
	return;
    }
}

static int
xyzModem_get_hdr (void)
3480e610:	e0843005 	add	r3, r4, r5
    {
      res = CYGACC_COMM_IF_GETC_TIMEOUT (*xyz.__chan, &c);
      ZM_DEBUG (zm_save (c));
      if (res)
	{
	  xyz.pkt[i] = c;
3480e614:	e5c32004 	strb	r2, [r3, #4]
      ZM_DEBUG (zm_dump (__LINE__));
      return xyzModem_timeout;
    }
  xyz.len = (c == SOH) ? 128 : 1024;
  xyz.bufp = xyz.pkt;
  for (i = 0; i < xyz.len; i++)
3480e618:	e2855001 	add	r5, r5, #1
3480e61c:	e5943410 	ldr	r3, [r4, #1040]	; 0x410
3480e620:	e59f6100 	ldr	r6, [pc, #256]	; 3480e728 <xyzModem_get_hdr+0x25c>
3480e624:	e1550003 	cmp	r5, r3
3480e628:	bafffff1 	blt	3480e5f4 <xyzModem_get_hdr+0x128>
	{
	  ZM_DEBUG (zm_dump (__LINE__));
	  return xyzModem_timeout;
	}
    }
  res = CYGACC_COMM_IF_GETC_TIMEOUT (*xyz.__chan, (char *) &xyz.crc1);
3480e62c:	e5963000 	ldr	r3, [r6]
3480e630:	e59f10fc 	ldr	r1, [pc, #252]	; 3480e734 <xyzModem_get_hdr+0x268>
3480e634:	e5d30000 	ldrb	r0, [r3]
3480e638:	ebffff83 	bl	3480e44c <CYGACC_COMM_IF_GETC_TIMEOUT>
  ZM_DEBUG (zm_save (xyz.crc1));
  if (!res)
3480e63c:	e3500000 	cmp	r0, #0
3480e640:	0a00002e 	beq	3480e700 <xyzModem_get_hdr+0x234>
    {
      ZM_DEBUG (zm_dump (__LINE__));
      return xyzModem_timeout;
    }
  if (xyz.crc_mode)
3480e644:	e5963428 	ldr	r3, [r6, #1064]	; 0x428
3480e648:	e3530000 	cmp	r3, #0
3480e64c:	0a000005 	beq	3480e668 <xyzModem_get_hdr+0x19c>
    {
      res = CYGACC_COMM_IF_GETC_TIMEOUT (*xyz.__chan, (char *) &xyz.crc2);
3480e650:	e5963000 	ldr	r3, [r6]
3480e654:	e59f10dc 	ldr	r1, [pc, #220]	; 3480e738 <xyzModem_get_hdr+0x26c>
3480e658:	e5d30000 	ldrb	r0, [r3]
3480e65c:	ebffff7a 	bl	3480e44c <CYGACC_COMM_IF_GETC_TIMEOUT>
      ZM_DEBUG (zm_save (xyz.crc2));
      if (!res)
3480e660:	e3500000 	cmp	r0, #0
3480e664:	0a000025 	beq	3480e700 <xyzModem_get_hdr+0x234>
	  return xyzModem_timeout;
	}
    }
  ZM_DEBUG (zm_dump (__LINE__));
  /* Validate the message */
  if ((xyz.blk ^ xyz.cblk) != (unsigned char) 0xFF)
3480e668:	e59f40b8 	ldr	r4, [pc, #184]	; 3480e728 <xyzModem_get_hdr+0x25c>
3480e66c:	e5d42409 	ldrb	r2, [r4, #1033]	; 0x409
3480e670:	e5d43408 	ldrb	r3, [r4, #1032]	; 0x408
3480e674:	e0223003 	eor	r3, r2, r3
3480e678:	e35300ff 	cmp	r3, #255	; 0xff
3480e67c:	0a000002 	beq	3480e68c <xyzModem_get_hdr+0x1c0>
    {
      ZM_DEBUG (zm_dprintf
		("Framing error - blk: %x/%x/%x\n", xyz.blk, xyz.cblk,
		 (xyz.blk ^ xyz.cblk)));
      ZM_DEBUG (zm_dump_buf (xyz.pkt, xyz.len));
      xyzModem_flush ();
3480e680:	ebffff86 	bl	3480e4a0 <xyzModem_flush>
      return xyzModem_frame;
3480e684:	e3e00005 	mvn	r0, #5
3480e688:	ea00001d 	b	3480e704 <xyzModem_get_hdr+0x238>
    }
  /* Verify checksum/CRC */
  if (xyz.crc_mode)
3480e68c:	e5943428 	ldr	r3, [r4, #1064]	; 0x428
3480e690:	e3530000 	cmp	r3, #0
	}
    }
  else
    {
      cksum = 0;
      for (i = 0; i < xyz.len; i++)
3480e694:	05941410 	ldreq	r1, [r4, #1040]	; 0x410
3480e698:	01a02003 	moveq	r2, r3
      ZM_DEBUG (zm_dump_buf (xyz.pkt, xyz.len));
      xyzModem_flush ();
      return xyzModem_frame;
    }
  /* Verify checksum/CRC */
  if (xyz.crc_mode)
3480e69c:	0a00000c 	beq	3480e6d4 <xyzModem_get_hdr+0x208>
    {
      cksum = cyg_crc16 (xyz.pkt, xyz.len);
3480e6a0:	e2840004 	add	r0, r4, #4
3480e6a4:	e5941410 	ldr	r1, [r4, #1040]	; 0x410
3480e6a8:	eb00222b 	bl	34816f5c <cyg_crc16>
      if (cksum != ((xyz.crc1 << 8) | xyz.crc2))
3480e6ac:	e5d4240a 	ldrb	r2, [r4, #1034]	; 0x40a
3480e6b0:	e5d4340b 	ldrb	r3, [r4, #1035]	; 0x40b
3480e6b4:	e1833402 	orr	r3, r3, r2, lsl #8
		     cksum & 0xFF));
	  return xyzModem_cksum;
	}
    }
  /* If we get here, the message passes [structural] muster */
  return 0;
3480e6b8:	e1500003 	cmp	r0, r3
3480e6bc:	ea00000a 	b	3480e6ec <xyzModem_get_hdr+0x220>
	return;
    }
}

static int
xyzModem_get_hdr (void)
3480e6c0:	e0840002 	add	r0, r4, r2
  else
    {
      cksum = 0;
      for (i = 0; i < xyz.len; i++)
	{
	  cksum += xyz.pkt[i];
3480e6c4:	e5d00004 	ldrb	r0, [r0, #4]
	}
    }
  else
    {
      cksum = 0;
      for (i = 0; i < xyz.len; i++)
3480e6c8:	e2822001 	add	r2, r2, #1
	{
	  cksum += xyz.pkt[i];
3480e6cc:	e0833000 	add	r3, r3, r0
3480e6d0:	e6ff3073 	uxth	r3, r3
	}
    }
  else
    {
      cksum = 0;
      for (i = 0; i < xyz.len; i++)
3480e6d4:	e1520001 	cmp	r2, r1
3480e6d8:	bafffff8 	blt	3480e6c0 <xyzModem_get_hdr+0x1f4>
	{
	  cksum += xyz.pkt[i];
	}
      if (xyz.crc1 != (cksum & 0xFF))
3480e6dc:	e59f2044 	ldr	r2, [pc, #68]	; 3480e728 <xyzModem_get_hdr+0x25c>
3480e6e0:	e20330ff 	and	r3, r3, #255	; 0xff
3480e6e4:	e5d2240a 	ldrb	r2, [r2, #1034]	; 0x40a
		     cksum & 0xFF));
	  return xyzModem_cksum;
	}
    }
  /* If we get here, the message passes [structural] muster */
  return 0;
3480e6e8:	e1520003 	cmp	r2, r3
3480e6ec:	13e00006 	mvnne	r0, #6
3480e6f0:	03a00000 	moveq	r0, #0
3480e6f4:	ea000002 	b	3480e704 <xyzModem_get_hdr+0x238>
	    case CAN:
	      xyz.total_CAN++;
	      ZM_DEBUG (zm_dump (__LINE__));
	      if (++can_total == xyzModem_CAN_COUNT)
		{
		  return xyzModem_cancel;
3480e6f8:	e3e00004 	mvn	r0, #4
3480e6fc:	ea000000 	b	3480e704 <xyzModem_get_hdr+0x238>
  res = CYGACC_COMM_IF_GETC_TIMEOUT (*xyz.__chan, (char *) &xyz.blk);
  ZM_DEBUG (zm_save (xyz.blk));
  if (!res)
    {
      ZM_DEBUG (zm_dump (__LINE__));
      return xyzModem_timeout;
3480e700:	e3e00002 	mvn	r0, #2
	  return xyzModem_cksum;
	}
    }
  /* If we get here, the message passes [structural] muster */
  return 0;
}
3480e704:	e8bd84fc 	pop	{r2, r3, r4, r5, r6, r7, sl, pc}
	  return xyzModem_timeout;
	}
    }

  /* Header found, now read the data */
  res = CYGACC_COMM_IF_GETC_TIMEOUT (*xyz.__chan, (char *) &xyz.blk);
3480e708:	e59f4018 	ldr	r4, [pc, #24]	; 3480e728 <xyzModem_get_hdr+0x25c>
3480e70c:	e59f1028 	ldr	r1, [pc, #40]	; 3480e73c <xyzModem_get_hdr+0x270>
3480e710:	e5943000 	ldr	r3, [r4]
3480e714:	e5d30000 	ldrb	r0, [r3]
3480e718:	ebffff4b 	bl	3480e44c <CYGACC_COMM_IF_GETC_TIMEOUT>
  ZM_DEBUG (zm_save (xyz.blk));
  if (!res)
3480e71c:	e3500000 	cmp	r0, #0
3480e720:	0afffff6 	beq	3480e700 <xyzModem_get_hdr+0x234>
3480e724:	eaffffa2 	b	3480e5b4 <xyzModem_get_hdr+0xe8>
3480e728:	3482ad30 	.word	0x3482ad30
3480e72c:	0003d090 	.word	0x0003d090
3480e730:	3482b139 	.word	0x3482b139
3480e734:	3482b13a 	.word	0x3482b13a
3480e738:	3482b13b 	.word	0x3482b13b
3480e73c:	3482b138 	.word	0x3482b138

3480e740 <CYGACC_COMM_IF_PUTC>:
}

void
CYGACC_COMM_IF_PUTC (char x, char y)
{
  putc (y);
3480e740:	e1a00001 	mov	r0, r1
3480e744:	eaffe9ec 	b	34808efc <putc>

3480e748 <parse_num>:
}

/* Parse (scan) a number */
bool
parse_num (char *s, unsigned long *val, char **es, char *delim)
{
3480e748:	e92d46f0 	push	{r4, r5, r6, r7, r9, sl, lr}
  int radix = 10;
  char c;
  unsigned long result = 0;
  int digit;

  while (*s == ' ')
3480e74c:	e5d04000 	ldrb	r4, [r0]
3480e750:	e1a0c000 	mov	ip, r0
3480e754:	e3540020 	cmp	r4, #32
3480e758:	e2800001 	add	r0, r0, #1
3480e75c:	0afffffa 	beq	3480e74c <parse_num+0x4>
3480e760:	e3a05000 	mov	r5, #0
3480e764:	e3a0600a 	mov	r6, #10
3480e768:	e3a00001 	mov	r0, #1
3480e76c:	ea000037 	b	3480e850 <parse_num+0x108>
    s++;
  while (*s)
    {
      if (first && (s[0] == '0') && (_tolower (s[1]) == 'x'))
3480e770:	e3500000 	cmp	r0, #0
3480e774:	0a00000a 	beq	3480e7a4 <parse_num+0x5c>
3480e778:	e3540030 	cmp	r4, #48	; 0x30
3480e77c:	1a000008 	bne	3480e7a4 <parse_num+0x5c>
3480e780:	e5dc0001 	ldrb	r0, [ip, #1]

/* Convert a character to lower case */
__inline__ static char
_tolower (char c)
{
  if ((c >= 'A') && (c <= 'Z'))
3480e784:	e2404041 	sub	r4, r0, #65	; 0x41
3480e788:	e6ef4074 	uxtb	r4, r4
3480e78c:	e3540019 	cmp	r4, #25
    {
      c = (c - 'A') + 'a';
3480e790:	92800020 	addls	r0, r0, #32
3480e794:	96ef0070 	uxtbls	r0, r0

  while (*s == ' ')
    s++;
  while (*s)
    {
      if (first && (s[0] == '0') && (_tolower (s[1]) == 'x'))
3480e798:	e3500078 	cmp	r0, #120	; 0x78
	{
	  radix = 16;
	  s += 2;
3480e79c:	028cc002 	addeq	ip, ip, #2
    s++;
  while (*s)
    {
      if (first && (s[0] == '0') && (_tolower (s[1]) == 'x'))
	{
	  radix = 16;
3480e7a0:	03a06010 	moveq	r6, #16
	  s += 2;
	}
      first = false;
      c = *s++;
3480e7a4:	e4dc4001 	ldrb	r4, [ip], #1

/* Validate a hex character */
__inline__ static bool
_is_hex (char c)
{
  return (((c >= '0') && (c <= '9')) ||
3480e7a8:	e2447030 	sub	r7, r4, #48	; 0x30
	  ((c >= 'A') && (c <= 'F')) || ((c >= 'a') && (c <= 'f')));
3480e7ac:	e2440041 	sub	r0, r4, #65	; 0x41

/* Validate a hex character */
__inline__ static bool
_is_hex (char c)
{
  return (((c >= '0') && (c <= '9')) ||
3480e7b0:	e6efa077 	uxtb	sl, r7
	  ((c >= 'A') && (c <= 'F')) || ((c >= 'a') && (c <= 'f')));
3480e7b4:	e6ef0070 	uxtb	r0, r0

/* Validate a hex character */
__inline__ static bool
_is_hex (char c)
{
  return (((c >= '0') && (c <= '9')) ||
3480e7b8:	e35a0009 	cmp	sl, #9
3480e7bc:	83a0a000 	movhi	sl, #0
3480e7c0:	93a0a001 	movls	sl, #1
	  ((c >= 'A') && (c <= 'F')) || ((c >= 'a') && (c <= 'f')));
3480e7c4:	e3500005 	cmp	r0, #5
3480e7c8:	83a00000 	movhi	r0, #0
3480e7cc:	93a00001 	movls	r0, #1

/* Validate a hex character */
__inline__ static bool
_is_hex (char c)
{
  return (((c >= '0') && (c <= '9')) ||
3480e7d0:	e190900a 	orrs	r9, r0, sl
3480e7d4:	1a000004 	bne	3480e7ec <parse_num+0xa4>
	  ((c >= 'A') && (c <= 'F')) || ((c >= 'a') && (c <= 'f')));
3480e7d8:	e2447061 	sub	r7, r4, #97	; 0x61
3480e7dc:	e6ef7077 	uxtb	r7, r7
3480e7e0:	e3570005 	cmp	r7, #5
3480e7e4:	9a000003 	bls	3480e7f8 <parse_num+0xb0>
3480e7e8:	ea00000f 	b	3480e82c <parse_num+0xe4>
__inline__ static int
_from_hex (char c)
{
  int ret = 0;

  if ((c >= '0') && (c <= '9'))
3480e7ec:	e35a0000 	cmp	sl, #0
    {
      ret = (c - '0');
3480e7f0:	11a00007 	movne	r0, r7
__inline__ static int
_from_hex (char c)
{
  int ret = 0;

  if ((c >= '0') && (c <= '9'))
3480e7f4:	1a000009 	bne	3480e820 <parse_num+0xd8>
    {
      ret = (c - '0');
    }
  else if ((c >= 'a') && (c <= 'f'))
3480e7f8:	e2447061 	sub	r7, r4, #97	; 0x61
3480e7fc:	e6ef7077 	uxtb	r7, r7
3480e800:	e3570005 	cmp	r7, #5
    {
      ret = (c - 'a' + 0x0a);
3480e804:	92440057 	subls	r0, r4, #87	; 0x57

  if ((c >= '0') && (c <= '9'))
    {
      ret = (c - '0');
    }
  else if ((c >= 'a') && (c <= 'f'))
3480e808:	9a000002 	bls	3480e818 <parse_num+0xd0>
    {
      ret = (c - 'a' + 0x0a);
    }
  else if ((c >= 'A') && (c <= 'F'))
3480e80c:	e3500000 	cmp	r0, #0
3480e810:	0a000002 	beq	3480e820 <parse_num+0xd8>
    {
      ret = (c - 'A' + 0x0A);
3480e814:	e2440037 	sub	r0, r4, #55	; 0x37
	  radix = 16;
	  s += 2;
	}
      first = false;
      c = *s++;
      if (_is_hex (c) && ((digit = _from_hex (c)) < radix))
3480e818:	e1500006 	cmp	r0, r6
3480e81c:	aa000002 	bge	3480e82c <parse_num+0xe4>
	    result = result << 4;
	  else
	    result = 10 * result;
	  result += digit;
#else
	  result = (result * radix) + digit;
3480e820:	e0250695 	mla	r5, r5, r6, r0
      if (first && (s[0] == '0') && (_tolower (s[1]) == 'x'))
	{
	  radix = 16;
	  s += 2;
	}
      first = false;
3480e824:	e3a00000 	mov	r0, #0
	    result = result << 4;
	  else
	    result = 10 * result;
	  result += digit;
#else
	  result = (result * radix) + digit;
3480e828:	ea000008 	b	3480e850 <parse_num+0x108>
#endif
	}
      else
	{
	  if (delim != (char *) 0)
3480e82c:	e3530000 	cmp	r3, #0
	      while (*dp && (c != *dp))
		dp++;
	      if (*dp)
		break;		/* Found a good delimiter */
	    }
	  return false;		/* Malformatted number */
3480e830:	01a00003 	moveq	r0, r3
	  result = (result * radix) + digit;
#endif
	}
      else
	{
	  if (delim != (char *) 0)
3480e834:	08bd86f0 	popeq	{r4, r5, r6, r7, r9, sl, pc}
	    {
	      /* See if this character is one of the delimiters */
	      char *dp = delim;
	      while (*dp && (c != *dp))
3480e838:	e4d30001 	ldrb	r0, [r3], #1
3480e83c:	e3500000 	cmp	r0, #0
3480e840:	08bd86f0 	popeq	{r4, r5, r6, r7, r9, sl, pc}
3480e844:	e1540000 	cmp	r4, r0
3480e848:	1afffffa 	bne	3480e838 <parse_num+0xf0>
3480e84c:	ea000002 	b	3480e85c <parse_num+0x114>
  unsigned long result = 0;
  int digit;

  while (*s == ' ')
    s++;
  while (*s)
3480e850:	e5dc4000 	ldrb	r4, [ip]
3480e854:	e3540000 	cmp	r4, #0
3480e858:	1affffc4 	bne	3480e770 <parse_num+0x28>
	    }
	  return false;		/* Malformatted number */
	}
    }
  *val = result;
  if (es != (char **) 0)
3480e85c:	e3520000 	cmp	r2, #0
		break;		/* Found a good delimiter */
	    }
	  return false;		/* Malformatted number */
	}
    }
  *val = result;
3480e860:	e5815000 	str	r5, [r1]
  if (es != (char **) 0)
    {
      *es = s;
    }
  return true;
3480e864:	13a00001 	movne	r0, #1
	}
    }
  *val = result;
  if (es != (char **) 0)
    {
      *es = s;
3480e868:	1582c000 	strne	ip, [r2]
    }
  return true;
3480e86c:	03a00001 	moveq	r0, #1
}
3480e870:	e8bd86f0 	pop	{r4, r5, r6, r7, r9, sl, pc}

3480e874 <xyzModem_stream_open>:
  return 0;
}

int
xyzModem_stream_open (connection_info_t * info, int *err)
{
3480e874:	e92d46f7 	push	{r0, r1, r2, r4, r5, r6, r7, r9, sl, lr}
  CYGACC_COMM_IF_CONTROL (*xyz.__chan, __COMMCTL_SET_TIMEOUT,
			  xyzModem_CHAR_TIMEOUT);
#else
/* TODO: CHECK ! */
  int dummy = 0;
  xyz.__chan = &dummy;
3480e878:	e59f412c 	ldr	r4, [pc, #300]	; 3480e9ac <xyzModem_stream_open+0x138>
  CYGACC_CALL_IF_SET_CONSOLE_COMM (console_chan);
  CYGACC_COMM_IF_CONTROL (*xyz.__chan, __COMMCTL_SET_TIMEOUT,
			  xyzModem_CHAR_TIMEOUT);
#else
/* TODO: CHECK ! */
  int dummy = 0;
3480e87c:	e3a05000 	mov	r5, #0
3480e880:	e28d3008 	add	r3, sp, #8
3480e884:	e5235004 	str	r5, [r3, #-4]!
  xyz.__chan = &dummy;
3480e888:	e5843000 	str	r3, [r4]
#endif
  xyz.len = 0;
  xyz.crc_mode = true;
3480e88c:	e3a03001 	mov	r3, #1
3480e890:	e5843428 	str	r3, [r4, #1064]	; 0x428
  xyz.at_eof = false;
  xyz.tx_ack = false;
  xyz.mode = info->mode;
3480e894:	e5903004 	ldr	r3, [r0, #4]
}

void
CYGACC_COMM_IF_PUTC (char x, char y)
{
  putc (y);
3480e898:	e3a00043 	mov	r0, #67	; 0x43
#endif
  xyz.len = 0;
  xyz.crc_mode = true;
  xyz.at_eof = false;
  xyz.tx_ack = false;
  xyz.mode = info->mode;
3480e89c:	e5843414 	str	r3, [r4, #1044]	; 0x414
  return 0;
}

int
xyzModem_stream_open (connection_info_t * info, int *err)
{
3480e8a0:	e1a0a001 	mov	sl, r1
#else
/* TODO: CHECK ! */
  int dummy = 0;
  xyz.__chan = &dummy;
#endif
  xyz.len = 0;
3480e8a4:	e5845410 	str	r5, [r4, #1040]	; 0x410
  xyz.crc_mode = true;
  xyz.at_eof = false;
3480e8a8:	e584542c 	str	r5, [r4, #1068]	; 0x42c
  xyz.tx_ack = false;
3480e8ac:	e5845430 	str	r5, [r4, #1072]	; 0x430
  xyz.mode = info->mode;
  xyz.total_retries = 0;
3480e8b0:	e5845418 	str	r5, [r4, #1048]	; 0x418
  xyz.total_SOH = 0;
3480e8b4:	e584541c 	str	r5, [r4, #1052]	; 0x41c
  xyz.total_STX = 0;
3480e8b8:	e5845420 	str	r5, [r4, #1056]	; 0x420
  xyz.total_CAN = 0;
3480e8bc:	e5845424 	str	r5, [r4, #1060]	; 0x424
#ifdef USE_YMODEM_LENGTH
  xyz.read_length = 0;
3480e8c0:	e5845438 	str	r5, [r4, #1080]	; 0x438
  xyz.file_length = 0;
3480e8c4:	e5845434 	str	r5, [r4, #1076]	; 0x434
}

void
CYGACC_COMM_IF_PUTC (char x, char y)
{
  putc (y);
3480e8c8:	ebffe98b 	bl	34808efc <putc>
  xyz.file_length = 0;
#endif

  CYGACC_COMM_IF_PUTC (*xyz.__chan, (xyz.crc_mode ? 'C' : NAK));

  if (xyz.mode == xyzModem_xmodem)
3480e8cc:	e5943414 	ldr	r3, [r4, #1044]	; 0x414
3480e8d0:	e3530001 	cmp	r3, #1
3480e8d4:	13a0700a 	movne	r7, #10
3480e8d8:	13a06014 	movne	r6, #20
	  return 0;
	}
      else if (stat == xyzModem_timeout)
	{
	  if (--crc_retries <= 0)
	    xyz.crc_mode = false;
3480e8dc:	11a09005 	movne	r9, r5
  CYGACC_COMM_IF_PUTC (*xyz.__chan, (xyz.crc_mode ? 'C' : NAK));

  if (xyz.mode == xyzModem_xmodem)
    {
      /* X-modem doesn't have an information header - exit here */
      xyz.next_blk = 1;
3480e8e0:	05c4340c 	strbeq	r3, [r4, #1036]	; 0x40c
      return 0;
3480e8e4:	01a00005 	moveq	r0, r5
  xyz.file_length = 0;
#endif

  CYGACC_COMM_IF_PUTC (*xyz.__chan, (xyz.crc_mode ? 'C' : NAK));

  if (xyz.mode == xyzModem_xmodem)
3480e8e8:	1a00002a 	bne	3480e998 <xyzModem_stream_open+0x124>
3480e8ec:	ea00002d 	b	3480e9a8 <xyzModem_stream_open+0x134>
      return 0;
    }

  while (retries-- > 0)
    {
      stat = xyzModem_get_hdr ();
3480e8f0:	ebfffef5 	bl	3480e4cc <xyzModem_get_hdr>
      if (stat == 0)
3480e8f4:	e2505000 	subs	r5, r0, #0
3480e8f8:	1a000014 	bne	3480e950 <xyzModem_stream_open+0xdc>
	{
	  /* Y-modem file information header */
	  if (xyz.blk == 0)
3480e8fc:	e59f30a8 	ldr	r3, [pc, #168]	; 3480e9ac <xyzModem_stream_open+0x138>
3480e900:	e5d32408 	ldrb	r2, [r3, #1032]	; 0x408
3480e904:	e3520000 	cmp	r2, #0
3480e908:	1a00000a 	bne	3480e938 <xyzModem_stream_open+0xc4>
	    {
#ifdef USE_YMODEM_LENGTH
	      /* skip filename */
	      while (*xyz.bufp++);
3480e90c:	e5930404 	ldr	r0, [r3, #1028]	; 0x404
3480e910:	e4d02001 	ldrb	r2, [r0], #1
3480e914:	e3520000 	cmp	r2, #0
3480e918:	e5830404 	str	r0, [r3, #1028]	; 0x404
3480e91c:	1afffffa 	bne	3480e90c <xyzModem_stream_open+0x98>
	      /* get the length */
	      parse_num ((char *) xyz.bufp, &xyz.file_length, NULL, " ");
3480e920:	e59f3088 	ldr	r3, [pc, #136]	; 3480e9b0 <xyzModem_stream_open+0x13c>
3480e924:	e59f1088 	ldr	r1, [pc, #136]	; 3480e9b4 <xyzModem_stream_open+0x140>
3480e928:	ebffff86 	bl	3480e748 <parse_num>
#endif
	      /* The rest of the file name data block quietly discarded */
	      xyz.tx_ack = true;
3480e92c:	e59f3078 	ldr	r3, [pc, #120]	; 3480e9ac <xyzModem_stream_open+0x138>
3480e930:	e3a02001 	mov	r2, #1
3480e934:	e5832430 	str	r2, [r3, #1072]	; 0x430
	    }
	  xyz.next_blk = 1;
3480e938:	e59f306c 	ldr	r3, [pc, #108]	; 3480e9ac <xyzModem_stream_open+0x138>
3480e93c:	e3a02001 	mov	r2, #1
	  xyz.len = 0;
3480e940:	e3a00000 	mov	r0, #0
	      parse_num ((char *) xyz.bufp, &xyz.file_length, NULL, " ");
#endif
	      /* The rest of the file name data block quietly discarded */
	      xyz.tx_ack = true;
	    }
	  xyz.next_blk = 1;
3480e944:	e5c3240c 	strb	r2, [r3, #1036]	; 0x40c
	  xyz.len = 0;
3480e948:	e5830410 	str	r0, [r3, #1040]	; 0x410
	  return 0;
3480e94c:	ea000015 	b	3480e9a8 <xyzModem_stream_open+0x134>
	}
      else if (stat == xyzModem_timeout)
3480e950:	e3750003 	cmn	r5, #3
3480e954:	1a00000d 	bne	3480e990 <xyzModem_stream_open+0x11c>
	{
	  if (--crc_retries <= 0)
3480e958:	e2477001 	sub	r7, r7, #1
3480e95c:	e3570000 	cmp	r7, #0
	    xyz.crc_mode = false;
	  CYGACC_CALL_IF_DELAY_US (5 * 100000);	/* Extra delay for startup */
3480e960:	e59f0050 	ldr	r0, [pc, #80]	; 3480e9b8 <xyzModem_stream_open+0x144>
	  return 0;
	}
      else if (stat == xyzModem_timeout)
	{
	  if (--crc_retries <= 0)
	    xyz.crc_mode = false;
3480e964:	d5849428 	strle	r9, [r4, #1064]	; 0x428
	  CYGACC_CALL_IF_DELAY_US (5 * 100000);	/* Extra delay for startup */
3480e968:	eb0029d3 	bl	348190bc <udelay>
	  CYGACC_COMM_IF_PUTC (*xyz.__chan, (xyz.crc_mode ? 'C' : NAK));
3480e96c:	e5940428 	ldr	r0, [r4, #1064]	; 0x428
}

void
CYGACC_COMM_IF_PUTC (char x, char y)
{
  putc (y);
3480e970:	e3500000 	cmp	r0, #0
3480e974:	03a00015 	moveq	r0, #21
3480e978:	13a00043 	movne	r0, #67	; 0x43
3480e97c:	ebffe95e 	bl	34808efc <putc>
	{
	  if (--crc_retries <= 0)
	    xyz.crc_mode = false;
	  CYGACC_CALL_IF_DELAY_US (5 * 100000);	/* Extra delay for startup */
	  CYGACC_COMM_IF_PUTC (*xyz.__chan, (xyz.crc_mode ? 'C' : NAK));
	  xyz.total_retries++;
3480e980:	e5943418 	ldr	r3, [r4, #1048]	; 0x418
3480e984:	e2833001 	add	r3, r3, #1
3480e988:	e5843418 	str	r3, [r4, #1048]	; 0x418
3480e98c:	ea000001 	b	3480e998 <xyzModem_stream_open+0x124>
	  ZM_DEBUG (zm_dprintf ("NAK (%d)\n", __LINE__));
	}
      if (stat == xyzModem_cancel)
3480e990:	e3750005 	cmn	r5, #5
3480e994:	0a000001 	beq	3480e9a0 <xyzModem_stream_open+0x12c>
      /* X-modem doesn't have an information header - exit here */
      xyz.next_blk = 1;
      return 0;
    }

  while (retries-- > 0)
3480e998:	e2566001 	subs	r6, r6, #1
3480e99c:	2affffd3 	bcs	3480e8f0 <xyzModem_stream_open+0x7c>
      if (stat == xyzModem_cancel)
	{
	  break;
	}
    }
  *err = stat;
3480e9a0:	e58a5000 	str	r5, [sl]
  ZM_DEBUG (zm_flush ());
  return -1;
3480e9a4:	e3e00000 	mvn	r0, #0
}
3480e9a8:	e8bd86fe 	pop	{r1, r2, r3, r4, r5, r6, r7, r9, sl, pc}
3480e9ac:	3482ad30 	.word	0x3482ad30
3480e9b0:	34827f20 	.word	0x34827f20
3480e9b4:	3482b164 	.word	0x3482b164
3480e9b8:	0007a120 	.word	0x0007a120

3480e9bc <xyzModem_stream_read>:

int
xyzModem_stream_read (char *buf, int size, int *err)
{
3480e9bc:	e92d4ef3 	push	{r0, r1, r4, r5, r6, r7, r9, sl, fp, lr}
  int retries;

  total = 0;
  stat = xyzModem_cancel;
  /* Try and get 'size' bytes into the buffer */
  while (!xyz.at_eof && (size > 0))
3480e9c0:	e59f4240 	ldr	r4, [pc, #576]	; 3480ec08 <xyzModem_stream_read+0x24c>
  return -1;
}

int
xyzModem_stream_read (char *buf, int size, int *err)
{
3480e9c4:	e1a09000 	mov	r9, r0
3480e9c8:	e1a0a001 	mov	sl, r1
3480e9cc:	e58d2004 	str	r2, [sp, #4]
  int stat, total, len;
  int retries;

  total = 0;
3480e9d0:	e3a0b000 	mov	fp, #0
  stat = xyzModem_cancel;
3480e9d4:	e3e05004 	mvn	r5, #4
		      ZM_DEBUG (zm_dprintf ("FINAL ACK (%d)\n", __LINE__));
		    }
		  xyz.at_eof = true;
		  break;
		}
	      CYGACC_COMM_IF_PUTC (*xyz.__chan, (xyz.crc_mode ? 'C' : NAK));
3480e9d8:	e1a07004 	mov	r7, r4
  int retries;

  total = 0;
  stat = xyzModem_cancel;
  /* Try and get 'size' bytes into the buffer */
  while (!xyz.at_eof && (size > 0))
3480e9dc:	ea00007f 	b	3480ebe0 <xyzModem_stream_read+0x224>
    {
      if (xyz.len == 0)
3480e9e0:	e5943410 	ldr	r3, [r4, #1040]	; 0x410
3480e9e4:	e3530000 	cmp	r3, #0
3480e9e8:	03a06014 	moveq	r6, #20
3480e9ec:	0a00005d 	beq	3480eb68 <xyzModem_stream_read+0x1ac>
3480e9f0:	ea000066 	b	3480eb90 <xyzModem_stream_read+0x1d4>
	{
	  retries = xyzModem_MAX_RETRIES;
	  while (retries-- > 0)
	    {
	      stat = xyzModem_get_hdr ();
3480e9f4:	ebfffeb4 	bl	3480e4cc <xyzModem_get_hdr>
	      if (stat == 0)
3480e9f8:	e2505000 	subs	r5, r0, #0
3480e9fc:	1a000039 	bne	3480eae8 <xyzModem_stream_read+0x12c>
		{
		  if (xyz.blk == xyz.next_blk)
3480ea00:	e5d43408 	ldrb	r3, [r4, #1032]	; 0x408
3480ea04:	e5d4240c 	ldrb	r2, [r4, #1036]	; 0x40c
3480ea08:	e1530002 	cmp	r3, r2
3480ea0c:	1a00002d 	bne	3480eac8 <xyzModem_stream_read+0x10c>
		    {
		      xyz.tx_ack = true;
3480ea10:	e3a02001 	mov	r2, #1
		      ZM_DEBUG (zm_dprintf
				("ACK block %d (%d)\n", xyz.blk, __LINE__));
		      xyz.next_blk = (xyz.next_blk + 1) & 0xFF;
3480ea14:	e0833002 	add	r3, r3, r2
	      stat = xyzModem_get_hdr ();
	      if (stat == 0)
		{
		  if (xyz.blk == xyz.next_blk)
		    {
		      xyz.tx_ack = true;
3480ea18:	e5872430 	str	r2, [r7, #1072]	; 0x430
		      ZM_DEBUG (zm_dprintf
				("ACK block %d (%d)\n", xyz.blk, __LINE__));
		      xyz.next_blk = (xyz.next_blk + 1) & 0xFF;

#if defined(xyzModem_zmodem) || defined(USE_YMODEM_LENGTH)
		      if (xyz.mode == xyzModem_xmodem || xyz.file_length == 0)
3480ea1c:	e5972414 	ldr	r2, [r7, #1044]	; 0x414
		  if (xyz.blk == xyz.next_blk)
		    {
		      xyz.tx_ack = true;
		      ZM_DEBUG (zm_dprintf
				("ACK block %d (%d)\n", xyz.blk, __LINE__));
		      xyz.next_blk = (xyz.next_blk + 1) & 0xFF;
3480ea20:	e5c7340c 	strb	r3, [r7, #1036]	; 0x40c

#if defined(xyzModem_zmodem) || defined(USE_YMODEM_LENGTH)
		      if (xyz.mode == xyzModem_xmodem || xyz.file_length == 0)
3480ea24:	e3520001 	cmp	r2, #1
3480ea28:	0a000002 	beq	3480ea38 <xyzModem_stream_read+0x7c>
3480ea2c:	e5973434 	ldr	r3, [r7, #1076]	; 0x434
3480ea30:	e3530000 	cmp	r3, #0
3480ea34:	1a000017 	bne	3480ea98 <xyzModem_stream_read+0xdc>
		      if (1)
			{
#endif
			  /* Data blocks can be padded with ^Z (EOF) characters */
			  /* This code tries to detect and remove them */
			  if ((xyz.bufp[xyz.len - 1] == EOF) &&
3480ea38:	e5941404 	ldr	r1, [r4, #1028]	; 0x404
3480ea3c:	e5943410 	ldr	r3, [r4, #1040]	; 0x410
3480ea40:	e0813003 	add	r3, r1, r3
3480ea44:	e5530001 	ldrb	r0, [r3, #-1]
3480ea48:	e350001a 	cmp	r0, #26
3480ea4c:	1a00000f 	bne	3480ea90 <xyzModem_stream_read+0xd4>
3480ea50:	e5530002 	ldrb	r0, [r3, #-2]
3480ea54:	e350001a 	cmp	r0, #26
3480ea58:	1a00000c 	bne	3480ea90 <xyzModem_stream_read+0xd4>
			      (xyz.bufp[xyz.len - 2] == EOF) &&
3480ea5c:	e5533003 	ldrb	r3, [r3, #-3]
3480ea60:	e353001a 	cmp	r3, #26
3480ea64:	1a000009 	bne	3480ea90 <xyzModem_stream_read+0xd4>
3480ea68:	ea000001 	b	3480ea74 <xyzModem_stream_read+0xb8>
			      (xyz.bufp[xyz.len - 3] == EOF))
			    {
			      while (xyz.len
				     && (xyz.bufp[xyz.len - 1] == EOF))
				{
				  xyz.len--;
3480ea6c:	e2433001 	sub	r3, r3, #1
3480ea70:	e5843410 	str	r3, [r4, #1040]	; 0x410
			  /* This code tries to detect and remove them */
			  if ((xyz.bufp[xyz.len - 1] == EOF) &&
			      (xyz.bufp[xyz.len - 2] == EOF) &&
			      (xyz.bufp[xyz.len - 3] == EOF))
			    {
			      while (xyz.len
3480ea74:	e5943410 	ldr	r3, [r4, #1040]	; 0x410
3480ea78:	e3530000 	cmp	r3, #0
3480ea7c:	0a000003 	beq	3480ea90 <xyzModem_stream_read+0xd4>
				     && (xyz.bufp[xyz.len - 1] == EOF))
3480ea80:	e0810003 	add	r0, r1, r3
3480ea84:	e5500001 	ldrb	r0, [r0, #-1]
3480ea88:	e350001a 	cmp	r0, #26
3480ea8c:	0afffff6 	beq	3480ea6c <xyzModem_stream_read+0xb0>
		       * See if accumulated length exceeds that of the file.
		       * If so, reduce size (i.e., cut out pad bytes)
		       * Only do this for Y-modem (and Z-modem should it ever
		       * be supported since it can fall back to Y-modem mode).
		       */
		      if (xyz.mode != xyzModem_xmodem && 0 != xyz.file_length)
3480ea90:	e3520001 	cmp	r2, #1
3480ea94:	0a00003d 	beq	3480eb90 <xyzModem_stream_read+0x1d4>
3480ea98:	e5942434 	ldr	r2, [r4, #1076]	; 0x434
3480ea9c:	e3520000 	cmp	r2, #0
3480eaa0:	0a00003a 	beq	3480eb90 <xyzModem_stream_read+0x1d4>
			{
			  xyz.read_length += xyz.len;
3480eaa4:	e5941410 	ldr	r1, [r4, #1040]	; 0x410
3480eaa8:	e5943438 	ldr	r3, [r4, #1080]	; 0x438
3480eaac:	e0813003 	add	r3, r1, r3
			  if (xyz.read_length > xyz.file_length)
3480eab0:	e1530002 	cmp	r3, r2
			    {
			      xyz.len -= (xyz.read_length - xyz.file_length);
3480eab4:	80812002 	addhi	r2, r1, r2
		       * Only do this for Y-modem (and Z-modem should it ever
		       * be supported since it can fall back to Y-modem mode).
		       */
		      if (xyz.mode != xyzModem_xmodem && 0 != xyz.file_length)
			{
			  xyz.read_length += xyz.len;
3480eab8:	e5843438 	str	r3, [r4, #1080]	; 0x438
			  if (xyz.read_length > xyz.file_length)
			    {
			      xyz.len -= (xyz.read_length - xyz.file_length);
3480eabc:	80633002 	rsbhi	r3, r3, r2
3480eac0:	85843410 	strhi	r3, [r4, #1040]	; 0x410
3480eac4:	ea000031 	b	3480eb90 <xyzModem_stream_read+0x1d4>
			    }
			}
#endif
		      break;
		    }
		  else if (xyz.blk == ((xyz.next_blk - 1) & 0xFF))
3480eac8:	e2422001 	sub	r2, r2, #1
3480eacc:	e20220ff 	and	r2, r2, #255	; 0xff
3480ead0:	e1530002 	cmp	r3, r2
		      CYGACC_COMM_IF_PUTC (*xyz.__chan, ACK);
		      continue;	/* Need new header */
		    }
		  else
		    {
		      stat = xyzModem_sequence;
3480ead4:	13e05007 	mvnne	r5, #7
			    }
			}
#endif
		      break;
		    }
		  else if (xyz.blk == ((xyz.next_blk - 1) & 0xFF))
3480ead8:	1a00001a 	bne	3480eb48 <xyzModem_stream_read+0x18c>
}

void
CYGACC_COMM_IF_PUTC (char x, char y)
{
  putc (y);
3480eadc:	e3a00006 	mov	r0, #6
3480eae0:	ebffe905 	bl	34808efc <putc>
		    }
		  else if (xyz.blk == ((xyz.next_blk - 1) & 0xFF))
		    {
		      /* Just re-ACK this so sender will get on with it */
		      CYGACC_COMM_IF_PUTC (*xyz.__chan, ACK);
		      continue;	/* Need new header */
3480eae4:	ea00001f 	b	3480eb68 <xyzModem_stream_read+0x1ac>
		  else
		    {
		      stat = xyzModem_sequence;
		    }
		}
	      if (stat == xyzModem_cancel)
3480eae8:	e3750005 	cmn	r5, #5
3480eaec:	0a000021 	beq	3480eb78 <xyzModem_stream_read+0x1bc>
		{
		  break;
		}
	      if (stat == xyzModem_eof)
3480eaf0:	e3750004 	cmn	r5, #4
3480eaf4:	1a000013 	bne	3480eb48 <xyzModem_stream_read+0x18c>
}

void
CYGACC_COMM_IF_PUTC (char x, char y)
{
  putc (y);
3480eaf8:	e3a00006 	mov	r0, #6
3480eafc:	ebffe8fe 	bl	34808efc <putc>
		}
	      if (stat == xyzModem_eof)
		{
		  CYGACC_COMM_IF_PUTC (*xyz.__chan, ACK);
		  ZM_DEBUG (zm_dprintf ("ACK (%d)\n", __LINE__));
		  if (xyz.mode == xyzModem_ymodem)
3480eb00:	e5943414 	ldr	r3, [r4, #1044]	; 0x414
3480eb04:	e3530002 	cmp	r3, #2
3480eb08:	1a00000b 	bne	3480eb3c <xyzModem_stream_read+0x180>
		    {
		      CYGACC_COMM_IF_PUTC (*xyz.__chan,
3480eb0c:	e5940428 	ldr	r0, [r4, #1064]	; 0x428
}

void
CYGACC_COMM_IF_PUTC (char x, char y)
{
  putc (y);
3480eb10:	e3500000 	cmp	r0, #0
3480eb14:	03a00015 	moveq	r0, #21
3480eb18:	13a00043 	movne	r0, #67	; 0x43
3480eb1c:	ebffe8f6 	bl	34808efc <putc>
		  ZM_DEBUG (zm_dprintf ("ACK (%d)\n", __LINE__));
		  if (xyz.mode == xyzModem_ymodem)
		    {
		      CYGACC_COMM_IF_PUTC (*xyz.__chan,
					   (xyz.crc_mode ? 'C' : NAK));
		      xyz.total_retries++;
3480eb20:	e5943418 	ldr	r3, [r4, #1048]	; 0x418
3480eb24:	e2833001 	add	r3, r3, #1
3480eb28:	e5843418 	str	r3, [r4, #1048]	; 0x418
		      ZM_DEBUG (zm_dprintf ("Reading Final Header\n"));
		      stat = xyzModem_get_hdr ();
3480eb2c:	ebfffe66 	bl	3480e4cc <xyzModem_get_hdr>
3480eb30:	e1a05000 	mov	r5, r0
}

void
CYGACC_COMM_IF_PUTC (char x, char y)
{
  putc (y);
3480eb34:	e3a00006 	mov	r0, #6
3480eb38:	ebffe8ef 	bl	34808efc <putc>
		      ZM_DEBUG (zm_dprintf ("Reading Final Header\n"));
		      stat = xyzModem_get_hdr ();
		      CYGACC_COMM_IF_PUTC (*xyz.__chan, ACK);
		      ZM_DEBUG (zm_dprintf ("FINAL ACK (%d)\n", __LINE__));
		    }
		  xyz.at_eof = true;
3480eb3c:	e3a03001 	mov	r3, #1
3480eb40:	e584342c 	str	r3, [r4, #1068]	; 0x42c
		  break;
3480eb44:	ea000009 	b	3480eb70 <xyzModem_stream_read+0x1b4>
		}
	      CYGACC_COMM_IF_PUTC (*xyz.__chan, (xyz.crc_mode ? 'C' : NAK));
3480eb48:	e5940428 	ldr	r0, [r4, #1064]	; 0x428
}

void
CYGACC_COMM_IF_PUTC (char x, char y)
{
  putc (y);
3480eb4c:	e3500000 	cmp	r0, #0
3480eb50:	03a00015 	moveq	r0, #21
3480eb54:	13a00043 	movne	r0, #67	; 0x43
3480eb58:	ebffe8e7 	bl	34808efc <putc>
		    }
		  xyz.at_eof = true;
		  break;
		}
	      CYGACC_COMM_IF_PUTC (*xyz.__chan, (xyz.crc_mode ? 'C' : NAK));
	      xyz.total_retries++;
3480eb5c:	e5943418 	ldr	r3, [r4, #1048]	; 0x418
3480eb60:	e2833001 	add	r3, r3, #1
3480eb64:	e5843418 	str	r3, [r4, #1048]	; 0x418
  while (!xyz.at_eof && (size > 0))
    {
      if (xyz.len == 0)
	{
	  retries = xyzModem_MAX_RETRIES;
	  while (retries-- > 0)
3480eb68:	e2566001 	subs	r6, r6, #1
3480eb6c:	2affffa0 	bcs	3480e9f4 <xyzModem_stream_read+0x38>
		}
	      CYGACC_COMM_IF_PUTC (*xyz.__chan, (xyz.crc_mode ? 'C' : NAK));
	      xyz.total_retries++;
	      ZM_DEBUG (zm_dprintf ("NAK (%d)\n", __LINE__));
	    }
	  if (stat < 0)
3480eb70:	e3550000 	cmp	r5, #0
3480eb74:	aa000005 	bge	3480eb90 <xyzModem_stream_read+0x1d4>
	    {
	      *err = stat;
3480eb78:	e59d2004 	ldr	r2, [sp, #4]
	      xyz.len = -1;
3480eb7c:	e59f3084 	ldr	r3, [pc, #132]	; 3480ec08 <xyzModem_stream_read+0x24c>
	      xyz.total_retries++;
	      ZM_DEBUG (zm_dprintf ("NAK (%d)\n", __LINE__));
	    }
	  if (stat < 0)
	    {
	      *err = stat;
3480eb80:	e5825000 	str	r5, [r2]
	      xyz.len = -1;
3480eb84:	e3e02000 	mvn	r2, #0
3480eb88:	e5832410 	str	r2, [r3, #1040]	; 0x410
	      return total;
3480eb8c:	ea00001b 	b	3480ec00 <xyzModem_stream_read+0x244>
	    }
	}
      /* Don't "read" data from the EOF protocol package */
      if (!xyz.at_eof)
3480eb90:	e594342c 	ldr	r3, [r4, #1068]	; 0x42c
3480eb94:	e3530000 	cmp	r3, #0
3480eb98:	1a000010 	bne	3480ebe0 <xyzModem_stream_read+0x224>
	{
	  len = xyz.len;
3480eb9c:	e5946410 	ldr	r6, [r4, #1040]	; 0x410
	  if (size < len)
	    len = size;
	  memcpy (buf, xyz.bufp, len);
3480eba0:	e1a00009 	mov	r0, r9
	    }
	}
      /* Don't "read" data from the EOF protocol package */
      if (!xyz.at_eof)
	{
	  len = xyz.len;
3480eba4:	e15a0006 	cmp	sl, r6
3480eba8:	b1a0600a 	movlt	r6, sl
3480ebac:	a1a06006 	movge	r6, r6
	  if (size < len)
	    len = size;
	  memcpy (buf, xyz.bufp, len);
3480ebb0:	e1a02006 	mov	r2, r6
3480ebb4:	e5941404 	ldr	r1, [r4, #1028]	; 0x404
3480ebb8:	eb0028b4 	bl	34818e90 <memcpy>
	  size -= len;
	  buf += len;
	  total += len;
	  xyz.len -= len;
3480ebbc:	e5943410 	ldr	r3, [r4, #1040]	; 0x410
	{
	  len = xyz.len;
	  if (size < len)
	    len = size;
	  memcpy (buf, xyz.bufp, len);
	  size -= len;
3480ebc0:	e066a00a 	rsb	sl, r6, sl
	  buf += len;
	  total += len;
	  xyz.len -= len;
3480ebc4:	e0663003 	rsb	r3, r6, r3
3480ebc8:	e5843410 	str	r3, [r4, #1040]	; 0x410
	  xyz.bufp += len;
3480ebcc:	e5943404 	ldr	r3, [r4, #1028]	; 0x404
	  len = xyz.len;
	  if (size < len)
	    len = size;
	  memcpy (buf, xyz.bufp, len);
	  size -= len;
	  buf += len;
3480ebd0:	e0899006 	add	r9, r9, r6
	  total += len;
3480ebd4:	e08bb006 	add	fp, fp, r6
	  xyz.len -= len;
	  xyz.bufp += len;
3480ebd8:	e0836006 	add	r6, r3, r6
3480ebdc:	e5846404 	str	r6, [r4, #1028]	; 0x404
  int retries;

  total = 0;
  stat = xyzModem_cancel;
  /* Try and get 'size' bytes into the buffer */
  while (!xyz.at_eof && (size > 0))
3480ebe0:	e594242c 	ldr	r2, [r4, #1068]	; 0x42c
3480ebe4:	e35a0000 	cmp	sl, #0
3480ebe8:	d3a03000 	movle	r3, #0
3480ebec:	c3a03001 	movgt	r3, #1
3480ebf0:	e3520000 	cmp	r2, #0
3480ebf4:	13a03000 	movne	r3, #0
3480ebf8:	e3530000 	cmp	r3, #0
3480ebfc:	1affff77 	bne	3480e9e0 <xyzModem_stream_read+0x24>
	  xyz.len -= len;
	  xyz.bufp += len;
	}
    }
  return total;
}
3480ec00:	e1a0000b 	mov	r0, fp
3480ec04:	e8bd8efc 	pop	{r2, r3, r4, r5, r6, r7, r9, sl, fp, pc}
3480ec08:	3482ad30 	.word	0x3482ad30

3480ec0c <xyzModem_stream_close>:

void
xyzModem_stream_close (int *err)
{
3480ec0c:	e92d4007 	push	{r0, r1, r2, lr}
  diag_printf
    ("xyzModem - %s mode, %d(SOH)/%d(STX)/%d(CAN) packets, %d retries\n",
     xyz.crc_mode ? "CRC" : "Cksum", xyz.total_SOH, xyz.total_STX,
3480ec10:	e59f3034 	ldr	r3, [pc, #52]	; 3480ec4c <xyzModem_stream_close+0x40>

void
xyzModem_stream_close (int *err)
{
  diag_printf
    ("xyzModem - %s mode, %d(SOH)/%d(STX)/%d(CAN) packets, %d retries\n",
3480ec14:	e59f1034 	ldr	r1, [pc, #52]	; 3480ec50 <xyzModem_stream_close+0x44>
3480ec18:	e5932424 	ldr	r2, [r3, #1060]	; 0x424
3480ec1c:	e593c428 	ldr	ip, [r3, #1064]	; 0x428
3480ec20:	e58d2000 	str	r2, [sp]
3480ec24:	e5932418 	ldr	r2, [r3, #1048]	; 0x418
3480ec28:	e35c0000 	cmp	ip, #0
3480ec2c:	e58d2004 	str	r2, [sp, #4]
3480ec30:	e59f201c 	ldr	r2, [pc, #28]	; 3480ec54 <xyzModem_stream_close+0x48>
3480ec34:	e59f001c 	ldr	r0, [pc, #28]	; 3480ec58 <xyzModem_stream_close+0x4c>
3480ec38:	11a01002 	movne	r1, r2
3480ec3c:	e593241c 	ldr	r2, [r3, #1052]	; 0x41c
3480ec40:	e5933420 	ldr	r3, [r3, #1056]	; 0x420
3480ec44:	ebffe8c0 	bl	34808f4c <printf>
     xyz.crc_mode ? "CRC" : "Cksum", xyz.total_SOH, xyz.total_STX,
     xyz.total_CAN, xyz.total_retries);
  ZM_DEBUG (zm_flush ());
}
3480ec48:	e8bd800e 	pop	{r1, r2, r3, pc}
3480ec4c:	3482ad30 	.word	0x3482ad30
3480ec50:	34826848 	.word	0x34826848
3480ec54:	34825ffa 	.word	0x34825ffa
3480ec58:	3482684e 	.word	0x3482684e

3480ec5c <xyzModem_stream_terminate>:
void
xyzModem_stream_terminate (bool abort, int (*getc) (void))
{
  int c;

  if (abort)
3480ec5c:	e3500000 	cmp	r0, #0

/* Need to be able to clean out the input buffer, so have to take the */
/* getc */
void
xyzModem_stream_terminate (bool abort, int (*getc) (void))
{
3480ec60:	e92d4010 	push	{r4, lr}
3480ec64:	e1a04001 	mov	r4, r1
  int c;

  if (abort)
3480ec68:	0a000018 	beq	3480ecd0 <xyzModem_stream_terminate+0x74>
    {
      ZM_DEBUG (zm_dprintf ("!!!! TRANSFER ABORT !!!!\n"));
      switch (xyz.mode)
3480ec6c:	e59f4074 	ldr	r4, [pc, #116]	; 3480ece8 <xyzModem_stream_terminate+0x8c>
3480ec70:	e5943414 	ldr	r3, [r4, #1044]	; 0x414
3480ec74:	e2433001 	sub	r3, r3, #1
3480ec78:	e3530001 	cmp	r3, #1
3480ec7c:	88bd8010 	pophi	{r4, pc}
}

void
CYGACC_COMM_IF_PUTC (char x, char y)
{
  putc (y);
3480ec80:	e3a00018 	mov	r0, #24
3480ec84:	ebffe89c 	bl	34808efc <putc>
3480ec88:	e3a00018 	mov	r0, #24
3480ec8c:	ebffe89a 	bl	34808efc <putc>
3480ec90:	e3a00018 	mov	r0, #24
3480ec94:	ebffe898 	bl	34808efc <putc>
3480ec98:	e3a00018 	mov	r0, #24
3480ec9c:	ebffe896 	bl	34808efc <putc>
3480eca0:	e3a00008 	mov	r0, #8
3480eca4:	ebffe894 	bl	34808efc <putc>
3480eca8:	e3a00008 	mov	r0, #8
3480ecac:	ebffe892 	bl	34808efc <putc>
3480ecb0:	e3a00008 	mov	r0, #8
3480ecb4:	ebffe890 	bl	34808efc <putc>
3480ecb8:	e3a00008 	mov	r0, #8
3480ecbc:	ebffe88e 	bl	34808efc <putc>
	  CYGACC_COMM_IF_PUTC (*xyz.__chan, BSP);
	  CYGACC_COMM_IF_PUTC (*xyz.__chan, BSP);
	  CYGACC_COMM_IF_PUTC (*xyz.__chan, BSP);
	  /* Now consume the rest of what's waiting on the line. */
	  ZM_DEBUG (zm_dprintf ("Flushing serial line.\n"));
	  xyzModem_flush ();
3480ecc0:	ebfffdf6 	bl	3480e4a0 <xyzModem_flush>
	  xyz.at_eof = true;
3480ecc4:	e3a03001 	mov	r3, #1
3480ecc8:	e584342c 	str	r3, [r4, #1068]	; 0x42c
3480eccc:	e8bd8010 	pop	{r4, pc}
       * previous received blocks. Since very few files are an exact multiple
       * of the transfer block size, there will almost always be some gunk here.
       * If we don't eat it now, RedBoot will think the user typed it.
       */
      ZM_DEBUG (zm_dprintf ("Trailing gunk:\n"));
      while ((c = (*getc) ()) > -1);
3480ecd0:	e12fff34 	blx	r4
3480ecd4:	e3500000 	cmp	r0, #0
3480ecd8:	aafffffc 	bge	3480ecd0 <xyzModem_stream_terminate+0x74>
      /*
       * Make a small delay to give terminal programs like minicom
       * time to get control again after their file transfer program
       * exits.
       */
      CYGACC_CALL_IF_DELAY_US ((cyg_int32) 250000);
3480ecdc:	e59f0008 	ldr	r0, [pc, #8]	; 3480ecec <xyzModem_stream_terminate+0x90>
    }
}
3480ece0:	e8bd4010 	pop	{r4, lr}
      /*
       * Make a small delay to give terminal programs like minicom
       * time to get control again after their file transfer program
       * exits.
       */
      CYGACC_CALL_IF_DELAY_US ((cyg_int32) 250000);
3480ece4:	ea0028f4 	b	348190bc <udelay>
3480ece8:	3482ad30 	.word	0x3482ad30
3480ecec:	0003d090 	.word	0x0003d090

3480ecf0 <xyzModem_error>:
    }
}

char *
xyzModem_error (int err)
{
3480ecf0:	e2800008 	add	r0, r0, #8
3480ecf4:	e3500007 	cmp	r0, #7
3480ecf8:	959f3008 	ldrls	r3, [pc, #8]	; 3480ed08 <xyzModem_error+0x18>
3480ecfc:	859f0008 	ldrhi	r0, [pc, #8]	; 3480ed0c <xyzModem_error+0x1c>
3480ed00:	97930100 	ldrls	r0, [r3, r0, lsl #2]
      break;
    default:
      return "Unknown error";
      break;
    }
}
3480ed04:	e12fff1e 	bx	lr
3480ed08:	348216c4 	.word	0x348216c4
3480ed0c:	3482688f 	.word	0x3482688f

3480ed10 <get_dev>:
};

DECLARE_GLOBAL_DATA_PTR;

block_dev_desc_t *get_dev(const char *ifname, int dev)
{
3480ed10:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
	const struct block_drvr *drvr = block_drvr;
	block_dev_desc_t* (*reloc_get_dev)(int dev);
	char *name;

	if (!ifname)
3480ed14:	e2505000 	subs	r5, r0, #0
};

DECLARE_GLOBAL_DATA_PTR;

block_dev_desc_t *get_dev(const char *ifname, int dev)
{
3480ed18:	e1a07001 	mov	r7, r1
	const struct block_drvr *drvr = block_drvr;
	block_dev_desc_t* (*reloc_get_dev)(int dev);
	char *name;

	if (!ifname)
3480ed1c:	159f4054 	ldrne	r4, [pc, #84]	; 3480ed78 <get_dev+0x68>
3480ed20:	0a000012 	beq	3480ed70 <get_dev+0x60>
3480ed24:	ea00000c 	b	3480ed5c <get_dev+0x4c>
		reloc_get_dev = drvr->get_dev;
#ifdef CONFIG_NEEDS_MANUAL_RELOC
		name += gd->reloc_off;
		reloc_get_dev += gd->reloc_off;
#endif
		if (strncmp(ifname, name, strlen(name)) == 0)
3480ed28:	e1a0000a 	mov	r0, sl
#ifdef CONFIG_NEEDS_MANUAL_RELOC
	name += gd->reloc_off;
#endif
	while (drvr->name) {
		name = drvr->name;
		reloc_get_dev = drvr->get_dev;
3480ed2c:	e5146004 	ldr	r6, [r4, #-4]
#ifdef CONFIG_NEEDS_MANUAL_RELOC
		name += gd->reloc_off;
		reloc_get_dev += gd->reloc_off;
#endif
		if (strncmp(ifname, name, strlen(name)) == 0)
3480ed30:	eb002792 	bl	34818b80 <strlen>
3480ed34:	e1a0100a 	mov	r1, sl
3480ed38:	e1a02000 	mov	r2, r0
3480ed3c:	e1a00005 	mov	r0, r5
3480ed40:	eb002766 	bl	34818ae0 <strncmp>
3480ed44:	e3500000 	cmp	r0, #0
3480ed48:	e2844008 	add	r4, r4, #8
3480ed4c:	1a000002 	bne	3480ed5c <get_dev+0x4c>
			return reloc_get_dev(dev);
3480ed50:	e1a00007 	mov	r0, r7
3480ed54:	e12fff36 	blx	r6
3480ed58:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}

	name = drvr->name;
#ifdef CONFIG_NEEDS_MANUAL_RELOC
	name += gd->reloc_off;
#endif
	while (drvr->name) {
3480ed5c:	e514a008 	ldr	sl, [r4, #-8]
3480ed60:	e35a0000 	cmp	sl, #0
3480ed64:	1affffef 	bne	3480ed28 <get_dev+0x18>
#endif
		if (strncmp(ifname, name, strlen(name)) == 0)
			return reloc_get_dev(dev);
		drvr++;
	}
	return NULL;
3480ed68:	e1a0000a 	mov	r0, sl
3480ed6c:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
	const struct block_drvr *drvr = block_drvr;
	block_dev_desc_t* (*reloc_get_dev)(int dev);
	char *name;

	if (!ifname)
		return NULL;
3480ed70:	e1a00005 	mov	r0, r5
		if (strncmp(ifname, name, strlen(name)) == 0)
			return reloc_get_dev(dev);
		drvr++;
	}
	return NULL;
}
3480ed74:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
3480ed78:	348216ec 	.word	0x348216ec

3480ed7c <dev_print>:
	bc_rem  = block_count - div_by * bc_quot;
	return bc_quot * mul_by + (bc_rem * mul_by) / div_by;
}

void dev_print (block_dev_desc_t *dev_desc)
{
3480ed7c:	e92d46f0 	push	{r4, r5, r6, r7, r9, sl, lr}
	lba512_t lba512; /* number of blocks if 512bytes block size */

	if (dev_desc->type == DEV_TYPE_UNKNOWN) {
3480ed80:	e5d0300b 	ldrb	r3, [r0, #11]
	bc_rem  = block_count - div_by * bc_quot;
	return bc_quot * mul_by + (bc_rem * mul_by) / div_by;
}

void dev_print (block_dev_desc_t *dev_desc)
{
3480ed84:	e1a04000 	mov	r4, r0
	lba512_t lba512; /* number of blocks if 512bytes block size */

	if (dev_desc->type == DEV_TYPE_UNKNOWN) {
3480ed88:	e35300ff 	cmp	r3, #255	; 0xff
	bc_rem  = block_count - div_by * bc_quot;
	return bc_quot * mul_by + (bc_rem * mul_by) / div_by;
}

void dev_print (block_dev_desc_t *dev_desc)
{
3480ed8c:	e24dd014 	sub	sp, sp, #20
	lba512_t lba512; /* number of blocks if 512bytes block size */

	if (dev_desc->type == DEV_TYPE_UNKNOWN) {
		puts ("not available\n");
3480ed90:	059f01b0 	ldreq	r0, [pc, #432]	; 3480ef48 <dev_print+0x1cc>

void dev_print (block_dev_desc_t *dev_desc)
{
	lba512_t lba512; /* number of blocks if 512bytes block size */

	if (dev_desc->type == DEV_TYPE_UNKNOWN) {
3480ed94:	0a000068 	beq	3480ef3c <dev_print+0x1c0>
		puts ("not available\n");
		return;
	}

	switch (dev_desc->if_type) {
3480ed98:	e5941000 	ldr	r1, [r4]
3480ed9c:	e3510008 	cmp	r1, #8
3480eda0:	979ff101 	ldrls	pc, [pc, r1, lsl #2]
3480eda4:	ea00001e 	b	3480ee24 <dev_print+0xa8>
3480eda8:	3480ee1c 	.word	0x3480ee1c
3480edac:	3480edf4 	.word	0x3480edf4
3480edb0:	3480edcc 	.word	0x3480edcc
3480edb4:	3480edf4 	.word	0x3480edf4
3480edb8:	3480edfc 	.word	0x3480edfc
3480edbc:	3480ee14 	.word	0x3480ee14
3480edc0:	3480edfc 	.word	0x3480edfc
3480edc4:	3480edfc 	.word	0x3480edfc
3480edc8:	3480edf4 	.word	0x3480edf4
	case IF_TYPE_SCSI:
		printf ("(%d:%d) Vendor: %s Prod.: %s Rev: %s\n",
3480edcc:	e2843041 	add	r3, r4, #65	; 0x41
3480edd0:	e5d41009 	ldrb	r1, [r4, #9]
3480edd4:	e5d4200a 	ldrb	r2, [r4, #10]
3480edd8:	e58d3000 	str	r3, [sp]
3480eddc:	e2843056 	add	r3, r4, #86	; 0x56
3480ede0:	e58d3004 	str	r3, [sp, #4]
3480ede4:	e59f0160 	ldr	r0, [pc, #352]	; 3480ef4c <dev_print+0x1d0>
3480ede8:	e2843018 	add	r3, r4, #24
3480edec:	ebffe856 	bl	34808f4c <printf>
			dev_desc->target,dev_desc->lun,
			dev_desc->vendor,
			dev_desc->product,
			dev_desc->revision);
		break;
3480edf0:	ea00000f 	b	3480ee34 <dev_print+0xb8>
	case IF_TYPE_ATAPI:
	case IF_TYPE_IDE:
	case IF_TYPE_SATA:
		printf ("Model: %s Firm: %s Ser#: %s\n",
3480edf4:	e59f0154 	ldr	r0, [pc, #340]	; 3480ef50 <dev_print+0x1d4>
3480edf8:	ea000000 	b	3480ee00 <dev_print+0x84>
			dev_desc->product);
		break;
	case IF_TYPE_SD:
	case IF_TYPE_MMC:
	case IF_TYPE_USB:
		printf ("Vendor: %s Rev: %s Prod: %s\n",
3480edfc:	e59f0150 	ldr	r0, [pc, #336]	; 3480ef54 <dev_print+0x1d8>
3480ee00:	e2841018 	add	r1, r4, #24
3480ee04:	e2842056 	add	r2, r4, #86	; 0x56
3480ee08:	e2843041 	add	r3, r4, #65	; 0x41
3480ee0c:	ebffe84e 	bl	34808f4c <printf>
			dev_desc->vendor,
			dev_desc->revision,
			dev_desc->product);
		break;
3480ee10:	ea000007 	b	3480ee34 <dev_print+0xb8>
	case IF_TYPE_DOC:
		puts("device type DOC\n");
3480ee14:	e59f013c 	ldr	r0, [pc, #316]	; 3480ef58 <dev_print+0x1dc>
3480ee18:	ea000047 	b	3480ef3c <dev_print+0x1c0>
		return;
	case IF_TYPE_UNKNOWN:
		puts("device type unknown\n");
3480ee1c:	e59f0138 	ldr	r0, [pc, #312]	; 3480ef5c <dev_print+0x1e0>
3480ee20:	ea000045 	b	3480ef3c <dev_print+0x1c0>
		return;
	default:
		printf("Unhandled device type: %i\n", dev_desc->if_type);
3480ee24:	e59f0134 	ldr	r0, [pc, #308]	; 3480ef60 <dev_print+0x1e4>
			dev_desc->blksz);
#endif
	} else {
		puts ("            Capacity: not available\n");
	}
}
3480ee28:	e28dd014 	add	sp, sp, #20
3480ee2c:	e8bd46f0 	pop	{r4, r5, r6, r7, r9, sl, lr}
		return;
	case IF_TYPE_UNKNOWN:
		puts("device type unknown\n");
		return;
	default:
		printf("Unhandled device type: %i\n", dev_desc->if_type);
3480ee30:	eaffe845 	b	34808f4c <printf>
		return;
	}
	puts ("            Type: ");
3480ee34:	e59f0128 	ldr	r0, [pc, #296]	; 3480ef64 <dev_print+0x1e8>
3480ee38:	ebffe839 	bl	34808f24 <puts>
	if (dev_desc->removable)
3480ee3c:	e5d4300c 	ldrb	r3, [r4, #12]
3480ee40:	e3530000 	cmp	r3, #0
3480ee44:	0a000001 	beq	3480ee50 <dev_print+0xd4>
		puts ("Removable ");
3480ee48:	e59f0118 	ldr	r0, [pc, #280]	; 3480ef68 <dev_print+0x1ec>
3480ee4c:	ebffe834 	bl	34808f24 <puts>
	switch (dev_desc->type & 0x1F) {
3480ee50:	e5d4100b 	ldrb	r1, [r4, #11]
3480ee54:	e201101f 	and	r1, r1, #31
3480ee58:	e3510007 	cmp	r1, #7
3480ee5c:	979ff101 	ldrls	pc, [pc, r1, lsl #2]
3480ee60:	ea000010 	b	3480eea8 <dev_print+0x12c>
3480ee64:	3480ee84 	.word	0x3480ee84
3480ee68:	3480eea0 	.word	0x3480eea0
3480ee6c:	3480eea8 	.word	0x3480eea8
3480ee70:	3480eea8 	.word	0x3480eea8
3480ee74:	3480eea8 	.word	0x3480eea8
3480ee78:	3480ee8c 	.word	0x3480ee8c
3480ee7c:	3480eea8 	.word	0x3480eea8
3480ee80:	3480ee98 	.word	0x3480ee98
	case DEV_TYPE_HARDDISK:
		puts ("Hard Disk");
3480ee84:	e59f00e0 	ldr	r0, [pc, #224]	; 3480ef6c <dev_print+0x1f0>
3480ee88:	ea000000 	b	3480ee90 <dev_print+0x114>
		break;
	case DEV_TYPE_CDROM:
		puts ("CD ROM");
3480ee8c:	e59f00dc 	ldr	r0, [pc, #220]	; 3480ef70 <dev_print+0x1f4>
3480ee90:	ebffe823 	bl	34808f24 <puts>
		break;
3480ee94:	ea000005 	b	3480eeb0 <dev_print+0x134>
	case DEV_TYPE_OPDISK:
		puts ("Optical Device");
3480ee98:	e59f00d4 	ldr	r0, [pc, #212]	; 3480ef74 <dev_print+0x1f8>
3480ee9c:	eafffffb 	b	3480ee90 <dev_print+0x114>
		break;
	case DEV_TYPE_TAPE:
		puts ("Tape");
3480eea0:	e59f00d0 	ldr	r0, [pc, #208]	; 3480ef78 <dev_print+0x1fc>
3480eea4:	eafffff9 	b	3480ee90 <dev_print+0x114>
		break;
	default:
		printf ("# %02X #", dev_desc->type & 0x1F);
3480eea8:	e59f00cc 	ldr	r0, [pc, #204]	; 3480ef7c <dev_print+0x200>
3480eeac:	ebffe826 	bl	34808f4c <printf>
		break;
	}
	puts ("\n");
3480eeb0:	e59f00c8 	ldr	r0, [pc, #200]	; 3480ef80 <dev_print+0x204>
3480eeb4:	ebffe81a 	bl	34808f24 <puts>
	if ((dev_desc->lba * dev_desc->blksz)>0L) {
3480eeb8:	e5947010 	ldr	r7, [r4, #16]
3480eebc:	e5946014 	ldr	r6, [r4, #20]
3480eec0:	e0130697 	muls	r3, r7, r6
			gb_quot, gb_rem,
			(ulong)lba,
			dev_desc->blksz);
#endif
	} else {
		puts ("            Capacity: not available\n");
3480eec4:	059f00b8 	ldreq	r0, [pc, #184]	; 3480ef84 <dev_print+0x208>
	default:
		printf ("# %02X #", dev_desc->type & 0x1F);
		break;
	}
	puts ("\n");
	if ((dev_desc->lba * dev_desc->blksz)>0L) {
3480eec8:	0a00001b 	beq	3480ef3c <dev_print+0x1c0>
		ulong mb, mb_quot, mb_rem, gb, gb_quot, gb_rem;
		lbaint_t lba;

		lba = dev_desc->lba;

		lba512 = (lba * (dev_desc->blksz/512));
3480eecc:	e1a024a6 	lsr	r2, r6, #9
3480eed0:	e0020297 	mul	r2, r7, r2
static lba512_t lba512_muldiv (lba512_t block_count, lba512_t mul_by, lba512_t div_by)
{
	lba512_t bc_quot, bc_rem;

	/* x * m / d == x / d * m + (x % d) * m / d */
	bc_quot = block_count / div_by;
3480eed4:	e1a035a2 	lsr	r3, r2, #11
	bc_rem  = block_count - div_by * bc_quot;
3480eed8:	e1a05583 	lsl	r5, r3, #11
	return bc_quot * mul_by + (bc_rem * mul_by) / div_by;
3480eedc:	e3a0400a 	mov	r4, #10
{
	lba512_t bc_quot, bc_rem;

	/* x * m / d == x / d * m + (x % d) * m / d */
	bc_quot = block_count / div_by;
	bc_rem  = block_count - div_by * bc_quot;
3480eee0:	e0655002 	rsb	r5, r5, r2
	return bc_quot * mul_by + (bc_rem * mul_by) / div_by;
3480eee4:	e0030394 	mul	r3, r4, r3
3480eee8:	e0050594 	mul	r5, r4, r5
3480eeec:	e08355a5 	add	r5, r3, r5, lsr #11

		lba512 = (lba * (dev_desc->blksz/512));
		/* round to 1 digit */
		mb = lba512_muldiv(lba512, 10, 2048);	/* 2048 = (1024 * 1024) / 512 MB */

		mb_quot	= mb / 10;
3480eef0:	e1a01004 	mov	r1, r4
3480eef4:	e1a00005 	mov	r0, r5
3480eef8:	eb0043e9 	bl	3481fea4 <__udivsi3>
		mb_rem	= mb - (10 * mb_quot);

		gb = mb / 1024;
3480eefc:	e1a0a435 	lsr	sl, r5, r4

		lba512 = (lba * (dev_desc->blksz/512));
		/* round to 1 digit */
		mb = lba512_muldiv(lba512, 10, 2048);	/* 2048 = (1024 * 1024) / 512 MB */

		mb_quot	= mb / 10;
3480ef00:	e1a09000 	mov	r9, r0
		mb_rem	= mb - (10 * mb_quot);

		gb = mb / 1024;
		gb_quot	= gb / 10;
3480ef04:	e1a01004 	mov	r1, r4
3480ef08:	e1a0000a 	mov	r0, sl
3480ef0c:	eb0043e4 	bl	3481fea4 <__udivsi3>
		gb_rem	= gb - (10 * gb_quot);
3480ef10:	e06aa094 	mls	sl, r4, r0, sl

		mb_quot	= mb / 10;
		mb_rem	= mb - (10 * mb_quot);

		gb = mb / 1024;
		gb_quot	= gb / 10;
3480ef14:	e1a03000 	mov	r3, r0
			mb_quot, mb_rem,
			gb_quot, gb_rem,
			lba,
			dev_desc->blksz);
#else
		printf ("            Capacity: %ld.%ld MB = %ld.%ld GB (%ld x %ld)\n",
3480ef18:	e1a01009 	mov	r1, r9
3480ef1c:	e0625994 	mls	r2, r4, r9, r5
3480ef20:	e59f0060 	ldr	r0, [pc, #96]	; 3480ef88 <dev_print+0x20c>
3480ef24:	e58da000 	str	sl, [sp]
3480ef28:	e58d7004 	str	r7, [sp, #4]
3480ef2c:	e58d6008 	str	r6, [sp, #8]
3480ef30:	ebffe805 	bl	34808f4c <printf>
			dev_desc->blksz);
#endif
	} else {
		puts ("            Capacity: not available\n");
	}
}
3480ef34:	e28dd014 	add	sp, sp, #20
3480ef38:	e8bd86f0 	pop	{r4, r5, r6, r7, r9, sl, pc}
3480ef3c:	e28dd014 	add	sp, sp, #20
3480ef40:	e8bd46f0 	pop	{r4, r5, r6, r7, r9, sl, lr}
			gb_quot, gb_rem,
			(ulong)lba,
			dev_desc->blksz);
#endif
	} else {
		puts ("            Capacity: not available\n");
3480ef44:	eaffe7f6 	b	34808f24 <puts>
3480ef48:	34826a65 	.word	0x34826a65
3480ef4c:	34826927 	.word	0x34826927
3480ef50:	3482694d 	.word	0x3482694d
3480ef54:	3482696a 	.word	0x3482696a
3480ef58:	34826987 	.word	0x34826987
3480ef5c:	34826998 	.word	0x34826998
3480ef60:	348269ad 	.word	0x348269ad
3480ef64:	348269c8 	.word	0x348269c8
3480ef68:	348269db 	.word	0x348269db
3480ef6c:	348269e6 	.word	0x348269e6
3480ef70:	348269f0 	.word	0x348269f0
3480ef74:	348269f7 	.word	0x348269f7
3480ef78:	34826a06 	.word	0x34826a06
3480ef7c:	34826a0b 	.word	0x34826a0b
3480ef80:	348260f7 	.word	0x348260f7
3480ef84:	34826a4f 	.word	0x34826a4f
3480ef88:	34826a14 	.word	0x34826a14

3480ef8c <init_part>:
    defined(CONFIG_ISO_PARTITION) || \
    defined(CONFIG_AMIGA_PARTITION) || \
    defined(CONFIG_EFI_PARTITION)

void init_part (block_dev_desc_t * dev_desc)
{
3480ef8c:	e92d4010 	push	{r4, lr}
3480ef90:	e1a04000 	mov	r4, r0
		return;
	}
#endif

#ifdef CONFIG_DOS_PARTITION
	if (test_part_dos(dev_desc) == 0) {
3480ef94:	eb000259 	bl	3480f900 <test_part_dos>
3480ef98:	e3500000 	cmp	r0, #0
		dev_desc->part_type = PART_TYPE_DOS;
3480ef9c:	03a03002 	moveq	r3, #2
	if (test_part_amiga(dev_desc) == 0) {
	    dev_desc->part_type = PART_TYPE_AMIGA;
	    return;
	}
#endif
	dev_desc->part_type = PART_TYPE_UNKNOWN;
3480efa0:	13a03000 	movne	r3, #0
3480efa4:	e5c43008 	strb	r3, [r4, #8]
3480efa8:	e8bd8010 	pop	{r4, pc}

3480efac <print_part>:
	printf (" device %d  --   Partition Type: %s\n\n",
			dev_desc->dev, type);
}

void print_part (block_dev_desc_t * dev_desc)
{
3480efac:	e92d4010 	push	{r4, lr}

		switch (dev_desc->part_type) {
3480efb0:	e5d03008 	ldrb	r3, [r0, #8]
	printf (" device %d  --   Partition Type: %s\n\n",
			dev_desc->dev, type);
}

void print_part (block_dev_desc_t * dev_desc)
{
3480efb4:	e1a04000 	mov	r4, r0

		switch (dev_desc->part_type) {
3480efb8:	e3530002 	cmp	r3, #2
3480efbc:	1a000025 	bne	3480f058 <print_part+0xac>
}


static void print_part_header (const char *type, block_dev_desc_t * dev_desc)
{
	puts ("\nPartition Map for ");
3480efc0:	e59f009c 	ldr	r0, [pc, #156]	; 3480f064 <print_part+0xb8>
3480efc4:	ebffe7d6 	bl	34808f24 <puts>
	switch (dev_desc->if_type) {
3480efc8:	e5943000 	ldr	r3, [r4]
3480efcc:	e2433001 	sub	r3, r3, #1
3480efd0:	e3530007 	cmp	r3, #7
3480efd4:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
3480efd8:	ea000015 	b	3480f034 <print_part+0x88>
3480efdc:	3480effc 	.word	0x3480effc
3480efe0:	3480f00c 	.word	0x3480f00c
3480efe4:	3480f014 	.word	0x3480f014
3480efe8:	3480f01c 	.word	0x3480f01c
3480efec:	3480f024 	.word	0x3480f024
3480eff0:	3480f02c 	.word	0x3480f02c
3480eff4:	3480f034 	.word	0x3480f034
3480eff8:	3480f004 	.word	0x3480f004
	case IF_TYPE_IDE:
		puts ("IDE");
3480effc:	e59f0064 	ldr	r0, [pc, #100]	; 3480f068 <print_part+0xbc>
3480f000:	ea00000c 	b	3480f038 <print_part+0x8c>
		break;
	case IF_TYPE_SATA:
		puts ("SATA");
3480f004:	e59f0060 	ldr	r0, [pc, #96]	; 3480f06c <print_part+0xc0>
3480f008:	ea00000a 	b	3480f038 <print_part+0x8c>
		break;
	case IF_TYPE_SCSI:
		puts ("SCSI");
3480f00c:	e59f005c 	ldr	r0, [pc, #92]	; 3480f070 <print_part+0xc4>
3480f010:	ea000008 	b	3480f038 <print_part+0x8c>
		break;
	case IF_TYPE_ATAPI:
		puts ("ATAPI");
3480f014:	e59f0058 	ldr	r0, [pc, #88]	; 3480f074 <print_part+0xc8>
3480f018:	ea000006 	b	3480f038 <print_part+0x8c>
		break;
	case IF_TYPE_USB:
		puts ("USB");
3480f01c:	e59f0054 	ldr	r0, [pc, #84]	; 3480f078 <print_part+0xcc>
3480f020:	ea000004 	b	3480f038 <print_part+0x8c>
		break;
	case IF_TYPE_DOC:
		puts ("DOC");
3480f024:	e59f0050 	ldr	r0, [pc, #80]	; 3480f07c <print_part+0xd0>
3480f028:	ea000002 	b	3480f038 <print_part+0x8c>
		break;
	case IF_TYPE_MMC:
		puts ("MMC");
3480f02c:	e59f004c 	ldr	r0, [pc, #76]	; 3480f080 <print_part+0xd4>
3480f030:	ea000000 	b	3480f038 <print_part+0x8c>
		break;
	default:
		puts ("UNKNOWN");
3480f034:	e59f0048 	ldr	r0, [pc, #72]	; 3480f084 <print_part+0xd8>
3480f038:	ebffe7b9 	bl	34808f24 <puts>
		break;
	}
	printf (" device %d  --   Partition Type: %s\n\n",
3480f03c:	e5941004 	ldr	r1, [r4, #4]
3480f040:	e59f2040 	ldr	r2, [pc, #64]	; 3480f088 <print_part+0xdc>
3480f044:	e59f0040 	ldr	r0, [pc, #64]	; 3480f08c <print_part+0xe0>
3480f048:	ebffe7bf 	bl	34808f4c <printf>
#endif
#ifdef CONFIG_DOS_PARTITION
	case PART_TYPE_DOS:
		PRINTF ("## Testing for valid DOS partition ##\n");
		print_part_header ("DOS", dev_desc);
		print_part_dos (dev_desc);
3480f04c:	e1a00004 	mov	r0, r4
		print_part_efi (dev_desc);
		return;
#endif
	}
	puts ("## Unknown partition table\n");
}
3480f050:	e8bd4010 	pop	{r4, lr}
#endif
#ifdef CONFIG_DOS_PARTITION
	case PART_TYPE_DOS:
		PRINTF ("## Testing for valid DOS partition ##\n");
		print_part_header ("DOS", dev_desc);
		print_part_dos (dev_desc);
3480f054:	ea000241 	b	3480f960 <print_part_dos>
		print_part_header ("EFI", dev_desc);
		print_part_efi (dev_desc);
		return;
#endif
	}
	puts ("## Unknown partition table\n");
3480f058:	e59f0030 	ldr	r0, [pc, #48]	; 3480f090 <print_part+0xe4>
}
3480f05c:	e8bd4010 	pop	{r4, lr}
		print_part_header ("EFI", dev_desc);
		print_part_efi (dev_desc);
		return;
#endif
	}
	puts ("## Unknown partition table\n");
3480f060:	eaffe7af 	b	34808f24 <puts>
3480f064:	34826a74 	.word	0x34826a74
3480f068:	34826a88 	.word	0x34826a88
3480f06c:	34826a8c 	.word	0x34826a8c
3480f070:	34826a91 	.word	0x34826a91
3480f074:	34826a96 	.word	0x34826a96
3480f078:	34826a9c 	.word	0x34826a9c
3480f07c:	34826aa0 	.word	0x34826aa0
3480f080:	3482451f 	.word	0x3482451f
3480f084:	34826aa4 	.word	0x34826aa4
3480f088:	34826ad2 	.word	0x34826ad2
3480f08c:	34826aac 	.word	0x34826aac
3480f090:	34826ad6 	.word	0x34826ad6

3480f094 <get_partition_info>:

#endif

int get_partition_info(block_dev_desc_t *dev_desc, int part
					, disk_partition_t *info)
{
3480f094:	e92d4008 	push	{r3, lr}
#ifdef CONFIG_PARTITION_UUIDS
	/* The common case is no UUID support */
	info->uuid[0] = 0;
#endif

	switch (dev_desc->part_type) {
3480f098:	e5d03008 	ldrb	r3, [r0, #8]
3480f09c:	e3530002 	cmp	r3, #2
3480f0a0:	1a000003 	bne	3480f0b4 <get_partition_info+0x20>
		break;
#endif

#ifdef CONFIG_DOS_PARTITION
	case PART_TYPE_DOS:
		if (get_partition_info_dos(dev_desc, part, info) == 0) {
3480f0a4:	eb000238 	bl	3480f98c <get_partition_info_dos>
3480f0a8:	e3500000 	cmp	r0, #0
	default:
		break;
	}
#endif

	return -1;
3480f0ac:	13e00000 	mvnne	r0, #0
3480f0b0:	e8bd8008 	pop	{r3, pc}
3480f0b4:	e3e00000 	mvn	r0, #0
}
3480f0b8:	e8bd8008 	pop	{r3, pc}

3480f0bc <get_device>:

int get_device(const char *ifname, const char *dev_str,
	       block_dev_desc_t **dev_desc)
{
3480f0bc:	e92d40f7 	push	{r0, r1, r2, r4, r5, r6, r7, lr}
3480f0c0:	e1a05000 	mov	r5, r0
3480f0c4:	e1a04001 	mov	r4, r1
	char *ep;
	int dev;

	dev = simple_strtoul(dev_str, &ep, 16);
3480f0c8:	e1a00001 	mov	r0, r1
	return -1;
}

int get_device(const char *ifname, const char *dev_str,
	       block_dev_desc_t **dev_desc)
{
3480f0cc:	e1a06002 	mov	r6, r2
	char *ep;
	int dev;

	dev = simple_strtoul(dev_str, &ep, 16);
3480f0d0:	e28d1004 	add	r1, sp, #4
3480f0d4:	e3a02010 	mov	r2, #16
3480f0d8:	eb002ac6 	bl	34819bf8 <simple_strtoul>
	if (*ep) {
3480f0dc:	e59d3004 	ldr	r3, [sp, #4]
3480f0e0:	e5d33000 	ldrb	r3, [r3]
3480f0e4:	e3530000 	cmp	r3, #0
		printf("** Bad device specification %s %s **\n",
3480f0e8:	159f0044 	ldrne	r0, [pc, #68]	; 3480f134 <get_device+0x78>
{
	char *ep;
	int dev;

	dev = simple_strtoul(dev_str, &ep, 16);
	if (*ep) {
3480f0ec:	1a00000a 	bne	3480f11c <get_device+0x60>
	       block_dev_desc_t **dev_desc)
{
	char *ep;
	int dev;

	dev = simple_strtoul(dev_str, &ep, 16);
3480f0f0:	e1a07000 	mov	r7, r0
		printf("** Bad device specification %s %s **\n",
		       ifname, dev_str);
		return -1;
	}

	*dev_desc = get_dev(ifname, dev);
3480f0f4:	e1a01007 	mov	r1, r7
3480f0f8:	e1a00005 	mov	r0, r5
3480f0fc:	ebffff03 	bl	3480ed10 <get_dev>
	if (!(*dev_desc) || ((*dev_desc)->type == DEV_TYPE_UNKNOWN)) {
3480f100:	e3500000 	cmp	r0, #0
		printf("** Bad device specification %s %s **\n",
		       ifname, dev_str);
		return -1;
	}

	*dev_desc = get_dev(ifname, dev);
3480f104:	e5860000 	str	r0, [r6]
	if (!(*dev_desc) || ((*dev_desc)->type == DEV_TYPE_UNKNOWN)) {
3480f108:	0a000002 	beq	3480f118 <get_device+0x5c>
3480f10c:	e5d0300b 	ldrb	r3, [r0, #11]
3480f110:	e35300ff 	cmp	r3, #255	; 0xff
3480f114:	1a000004 	bne	3480f12c <get_device+0x70>
		printf("** Bad device %s %s **\n", ifname, dev_str);
3480f118:	e59f0018 	ldr	r0, [pc, #24]	; 3480f138 <get_device+0x7c>
3480f11c:	e1a01005 	mov	r1, r5
3480f120:	e1a02004 	mov	r2, r4
3480f124:	ebffe788 	bl	34808f4c <printf>
		return -1;
3480f128:	e3e07000 	mvn	r7, #0
	}

	return dev;
}
3480f12c:	e1a00007 	mov	r0, r7
3480f130:	e8bd80fe 	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
3480f134:	34826af2 	.word	0x34826af2
3480f138:	34826b18 	.word	0x34826b18

3480f13c <get_device_and_partition>:
#define PART_AUTO -1
#define MAX_SEARCH_PARTITIONS 16
int get_device_and_partition(const char *ifname, const char *dev_part_str,
			     block_dev_desc_t **dev_desc,
			     disk_partition_t *info, int allow_whole_dev)
{
3480f13c:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	int p;
	int part;
	disk_partition_t tmpinfo;

	/* If no dev_part_str, use bootdevice environment variable */
	if (!dev_part_str || !strlen(dev_part_str) ||
3480f140:	e2516000 	subs	r6, r1, #0
#define PART_AUTO -1
#define MAX_SEARCH_PARTITIONS 16
int get_device_and_partition(const char *ifname, const char *dev_part_str,
			     block_dev_desc_t **dev_desc,
			     disk_partition_t *info, int allow_whole_dev)
{
3480f144:	e24dd058 	sub	sp, sp, #88	; 0x58
3480f148:	e1a09000 	mov	r9, r0
3480f14c:	e1a0b002 	mov	fp, r2
3480f150:	e1a05003 	mov	r5, r3
	int p;
	int part;
	disk_partition_t tmpinfo;

	/* If no dev_part_str, use bootdevice environment variable */
	if (!dev_part_str || !strlen(dev_part_str) ||
3480f154:	0a000008 	beq	3480f17c <get_device_and_partition+0x40>
3480f158:	e1a00006 	mov	r0, r6
3480f15c:	eb002687 	bl	34818b80 <strlen>
3480f160:	e3500000 	cmp	r0, #0
3480f164:	0a000004 	beq	3480f17c <get_device_and_partition+0x40>
	    !strcmp(dev_part_str, "-"))
3480f168:	e1a00006 	mov	r0, r6
3480f16c:	e59f1280 	ldr	r1, [pc, #640]	; 3480f3f4 <get_device_and_partition+0x2b8>
3480f170:	eb00264e 	bl	34818ab0 <strcmp>
	int p;
	int part;
	disk_partition_t tmpinfo;

	/* If no dev_part_str, use bootdevice environment variable */
	if (!dev_part_str || !strlen(dev_part_str) ||
3480f174:	e3500000 	cmp	r0, #0
3480f178:	1a000007 	bne	3480f19c <get_device_and_partition+0x60>
	    !strcmp(dev_part_str, "-"))
		dev_part_str = getenv("bootdevice");
3480f17c:	e59f0274 	ldr	r0, [pc, #628]	; 3480f3f8 <get_device_and_partition+0x2bc>
3480f180:	ebffe42d 	bl	3480823c <getenv>

	/* If still no dev_part_str, it's an error */
	if (!dev_part_str) {
3480f184:	e2506000 	subs	r6, r0, #0
3480f188:	1a000003 	bne	3480f19c <get_device_and_partition+0x60>
		printf("** No device specified **\n");
3480f18c:	e59f0268 	ldr	r0, [pc, #616]	; 3480f3fc <get_device_and_partition+0x2c0>
3480f190:	ebffe76d 	bl	34808f4c <printf>
			     block_dev_desc_t **dev_desc,
			     disk_partition_t *info, int allow_whole_dev)
{
	int ret = -1;
	const char *part_str;
	char *dup_str = NULL;
3480f194:	e1a07006 	mov	r7, r6
3480f198:	ea00008f 	b	3480f3dc <get_device_and_partition+0x2a0>
		printf("** No device specified **\n");
		goto cleanup;
	}

	/* Separate device and partition ID specification */
	part_str = strchr(dev_part_str, ':');
3480f19c:	e1a00006 	mov	r0, r6
3480f1a0:	e3a0103a 	mov	r1, #58	; 0x3a
3480f1a4:	eb00265f 	bl	34818b28 <strchr>
	if (part_str) {
3480f1a8:	e2504000 	subs	r4, r0, #0
3480f1ac:	01a0a006 	moveq	sl, r6
			     block_dev_desc_t **dev_desc,
			     disk_partition_t *info, int allow_whole_dev)
{
	int ret = -1;
	const char *part_str;
	char *dup_str = NULL;
3480f1b0:	01a07004 	moveq	r7, r4
		goto cleanup;
	}

	/* Separate device and partition ID specification */
	part_str = strchr(dev_part_str, ':');
	if (part_str) {
3480f1b4:	0a000007 	beq	3480f1d8 <get_device_and_partition+0x9c>
		dup_str = strdup(dev_part_str);
3480f1b8:	e1a00006 	mov	r0, r6
3480f1bc:	eb0026a4 	bl	34818c54 <strdup>
		dup_str[part_str - dev_part_str] = 0;
3480f1c0:	e0663004 	rsb	r3, r6, r4
3480f1c4:	e3a02000 	mov	r2, #0
	}

	/* Separate device and partition ID specification */
	part_str = strchr(dev_part_str, ':');
	if (part_str) {
		dup_str = strdup(dev_part_str);
3480f1c8:	e1a07000 	mov	r7, r0
		dup_str[part_str - dev_part_str] = 0;
3480f1cc:	e7c02003 	strb	r2, [r0, r3]
		dev_str = dup_str;
		part_str++;
3480f1d0:	e2844001 	add	r4, r4, #1
	/* Separate device and partition ID specification */
	part_str = strchr(dev_part_str, ':');
	if (part_str) {
		dup_str = strdup(dev_part_str);
		dup_str[part_str - dev_part_str] = 0;
		dev_str = dup_str;
3480f1d4:	e1a0a000 	mov	sl, r0
	} else {
		dev_str = dev_part_str;
	}

	/* Look up the device */
	dev = get_device(ifname, dev_str, dev_desc);
3480f1d8:	e1a00009 	mov	r0, r9
3480f1dc:	e1a0100a 	mov	r1, sl
3480f1e0:	e1a0200b 	mov	r2, fp
3480f1e4:	ebffffb4 	bl	3480f0bc <get_device>
	if (dev < 0)
3480f1e8:	e3500000 	cmp	r0, #0
3480f1ec:	ba00007a 	blt	3480f3dc <get_device_and_partition+0x2a0>
		goto cleanup;

	/* Convert partition ID string to number */
	if (!part_str || !*part_str) {
3480f1f0:	e3540000 	cmp	r4, #0
3480f1f4:	0a000018 	beq	3480f25c <get_device_and_partition+0x120>
3480f1f8:	e5d43000 	ldrb	r3, [r4]
3480f1fc:	e3530000 	cmp	r3, #0
3480f200:	0a000015 	beq	3480f25c <get_device_and_partition+0x120>
		part = PART_UNSPECIFIED;
	} else if (!strcmp(part_str, "auto")) {
3480f204:	e1a00004 	mov	r0, r4
3480f208:	e59f11f0 	ldr	r1, [pc, #496]	; 3480f400 <get_device_and_partition+0x2c4>
3480f20c:	eb002627 	bl	34818ab0 <strcmp>
3480f210:	e3500000 	cmp	r0, #0
		part = PART_AUTO;
3480f214:	03e04000 	mvneq	r4, #0
		goto cleanup;

	/* Convert partition ID string to number */
	if (!part_str || !*part_str) {
		part = PART_UNSPECIFIED;
	} else if (!strcmp(part_str, "auto")) {
3480f218:	0a000010 	beq	3480f260 <get_device_and_partition+0x124>
		part = PART_AUTO;
	} else {
		/* Something specified -> use exactly that */
		part = (int)simple_strtoul(part_str, &ep, 16);
3480f21c:	e1a00004 	mov	r0, r4
3480f220:	e28d1054 	add	r1, sp, #84	; 0x54
3480f224:	e3a02010 	mov	r2, #16
3480f228:	eb002a72 	bl	34819bf8 <simple_strtoul>
		/*
		 * Less than whole string converted,
		 * or request for whole device, but caller requires partition.
		 */
		if (*ep || (part == 0 && !allow_whole_dev)) {
3480f22c:	e59d3054 	ldr	r3, [sp, #84]	; 0x54
3480f230:	e5d33000 	ldrb	r3, [r3]
3480f234:	e3530000 	cmp	r3, #0
3480f238:	1a000003 	bne	3480f24c <get_device_and_partition+0x110>
3480f23c:	e59d2078 	ldr	r2, [sp, #120]	; 0x78
		part = PART_UNSPECIFIED;
	} else if (!strcmp(part_str, "auto")) {
		part = PART_AUTO;
	} else {
		/* Something specified -> use exactly that */
		part = (int)simple_strtoul(part_str, &ep, 16);
3480f240:	e1a04000 	mov	r4, r0
		/*
		 * Less than whole string converted,
		 * or request for whole device, but caller requires partition.
		 */
		if (*ep || (part == 0 && !allow_whole_dev)) {
3480f244:	e1902002 	orrs	r2, r0, r2
3480f248:	1a000004 	bne	3480f260 <get_device_and_partition+0x124>
			printf("** Bad partition specification %s %s **\n",
3480f24c:	e59f01b0 	ldr	r0, [pc, #432]	; 3480f404 <get_device_and_partition+0x2c8>
3480f250:	e1a01009 	mov	r1, r9
3480f254:	e1a02006 	mov	r2, r6
3480f258:	ea00000d 	b	3480f294 <get_device_and_partition+0x158>
	if (dev < 0)
		goto cleanup;

	/* Convert partition ID string to number */
	if (!part_str || !*part_str) {
		part = PART_UNSPECIFIED;
3480f25c:	e3e04001 	mvn	r4, #1

	/*
	 * No partition table on device,
	 * or user requested partition 0 (entire device).
	 */
	if (((*dev_desc)->part_type == PART_TYPE_UNKNOWN) ||
3480f260:	e59b0000 	ldr	r0, [fp]
3480f264:	e5d03008 	ldrb	r3, [r0, #8]
3480f268:	e3530000 	cmp	r3, #0
3480f26c:	13540000 	cmpne	r4, #0
3480f270:	13a03000 	movne	r3, #0
3480f274:	03a03001 	moveq	r3, #1
3480f278:	1a000015 	bne	3480f2d4 <get_device_and_partition+0x198>
	    (part == 0)) {
		if (!(*dev_desc)->lba) {
3480f27c:	e5903010 	ldr	r3, [r0, #16]
3480f280:	e3530000 	cmp	r3, #0
3480f284:	1a000004 	bne	3480f29c <get_device_and_partition+0x160>
			printf("** Bad device size - %s %s **\n", ifname,
3480f288:	e59f0178 	ldr	r0, [pc, #376]	; 3480f408 <get_device_and_partition+0x2cc>
3480f28c:	e1a01009 	mov	r1, r9
3480f290:	e1a0200a 	mov	r2, sl
3480f294:	ebffe72c 	bl	34808f4c <printf>
3480f298:	ea00004f 	b	3480f3dc <get_device_and_partition+0x2a0>
		/*
		 * If user specified a partition ID other than 0,
		 * or the calling command only accepts partitions,
		 * it's an error.
		 */
		if ((part > 0) || (!allow_whole_dev)) {
3480f29c:	e59d2078 	ldr	r2, [sp, #120]	; 0x78
3480f2a0:	e2726001 	rsbs	r6, r2, #1
3480f2a4:	33a06000 	movcc	r6, #0
3480f2a8:	e3540000 	cmp	r4, #0
3480f2ac:	c3866001 	orrgt	r6, r6, #1
3480f2b0:	e3560000 	cmp	r6, #0
			printf("** No partition table - %s %s **\n", ifname,
3480f2b4:	159f0150 	ldrne	r0, [pc, #336]	; 3480f40c <get_device_and_partition+0x2d0>
		/*
		 * If user specified a partition ID other than 0,
		 * or the calling command only accepts partitions,
		 * it's an error.
		 */
		if ((part > 0) || (!allow_whole_dev)) {
3480f2b8:	1afffff3 	bne	3480f28c <get_device_and_partition+0x150>
			       dev_str);
			goto cleanup;
		}

		info->start = 0;
		info->size = (*dev_desc)->lba;
3480f2bc:	e5853004 	str	r3, [r5, #4]
		info->blksz = (*dev_desc)->blksz;
3480f2c0:	e5903014 	ldr	r3, [r0, #20]
			printf("** No partition table - %s %s **\n", ifname,
			       dev_str);
			goto cleanup;
		}

		info->start = 0;
3480f2c4:	e5856000 	str	r6, [r5]
		info->size = (*dev_desc)->lba;
		info->blksz = (*dev_desc)->blksz;
3480f2c8:	e5853008 	str	r3, [r5, #8]
		info->bootable = 0;
3480f2cc:	e585604c 	str	r6, [r5, #76]	; 0x4c
#ifdef CONFIG_PARTITION_UUIDS
		info->uuid[0] = 0;
#endif

		ret = 0;
		goto cleanup;
3480f2d0:	ea000042 	b	3480f3e0 <get_device_and_partition+0x2a4>

	/*
	 * Now there's known to be a partition table,
	 * not specifying a partition means to pick partition 1.
	 */
	if (part == PART_UNSPECIFIED)
3480f2d4:	e3740002 	cmn	r4, #2
3480f2d8:	0a000005 	beq	3480f2f4 <get_device_and_partition+0x1b8>

	/*
	 * If user didn't specify a partition number, or did specify something
	 * other than "auto", use that partition number directly.
	 */
	if (part != PART_AUTO) {
3480f2dc:	e3740001 	cmn	r4, #1
3480f2e0:	01a04003 	moveq	r4, r3
3480f2e4:	03a0a001 	moveq	sl, #1
			 * We now need to search further for best possible.
			 * If we what we just queried was the best so far,
			 * save the info since we over-write it next loop.
			 */
			if (part == p)
				tmpinfo = *info;
3480f2e8:	028d9004 	addeq	r9, sp, #4

	/*
	 * If user didn't specify a partition number, or did specify something
	 * other than "auto", use that partition number directly.
	 */
	if (part != PART_AUTO) {
3480f2ec:	0a00000a 	beq	3480f31c <get_device_and_partition+0x1e0>
3480f2f0:	ea000000 	b	3480f2f8 <get_device_and_partition+0x1bc>
	/*
	 * Now there's known to be a partition table,
	 * not specifying a partition means to pick partition 1.
	 */
	if (part == PART_UNSPECIFIED)
		part = 1;
3480f2f4:	e3a04001 	mov	r4, #1
	/*
	 * If user didn't specify a partition number, or did specify something
	 * other than "auto", use that partition number directly.
	 */
	if (part != PART_AUTO) {
		ret = get_partition_info(*dev_desc, part, info);
3480f2f8:	e1a01004 	mov	r1, r4
3480f2fc:	e1a02005 	mov	r2, r5
3480f300:	ebffff63 	bl	3480f094 <get_partition_info>
		if (ret) {
3480f304:	e2506000 	subs	r6, r0, #0
3480f308:	0a000028 	beq	3480f3b0 <get_device_and_partition+0x274>
			printf("** Invalid partition %d **\n", part);
3480f30c:	e1a01004 	mov	r1, r4
3480f310:	e59f00f8 	ldr	r0, [pc, #248]	; 3480f410 <get_device_and_partition+0x2d4>
3480f314:	ebffe70c 	bl	34808f4c <printf>
			goto cleanup;
3480f318:	ea000030 	b	3480f3e0 <get_device_and_partition+0x2a4>
		 * Find the first bootable partition.
		 * If none are bootable, fall back to the first valid partition.
		 */
		part = 0;
		for (p = 1; p <= MAX_SEARCH_PARTITIONS; p++) {
			ret = get_partition_info(*dev_desc, p, info);
3480f31c:	e59b0000 	ldr	r0, [fp]
3480f320:	e1a0100a 	mov	r1, sl
3480f324:	e1a02005 	mov	r2, r5
3480f328:	ebffff59 	bl	3480f094 <get_partition_info>
			if (ret)
3480f32c:	e2506000 	subs	r6, r0, #0
3480f330:	1a000011 	bne	3480f37c <get_device_and_partition+0x240>

			/*
			 * First valid partition, or new better partition?
			 * If so, save partition ID.
			 */
			if (!part || info->bootable)
3480f334:	e3540000 	cmp	r4, #0
3480f338:	01a0400a 	moveq	r4, sl
3480f33c:	0a000002 	beq	3480f34c <get_device_and_partition+0x210>
3480f340:	e595304c 	ldr	r3, [r5, #76]	; 0x4c
3480f344:	e3530000 	cmp	r3, #0
3480f348:	11a0400a 	movne	r4, sl
				part = p;

			/* Best possible partition? Stop searching. */
			if (info->bootable)
3480f34c:	e595304c 	ldr	r3, [r5, #76]	; 0x4c
3480f350:	e3530000 	cmp	r3, #0
3480f354:	0a000002 	beq	3480f364 <get_device_and_partition+0x228>
		if (part) {
			/*
			 * If we searched all possible partition IDs,
			 * return the first valid partition we found.
			 */
			if (p == MAX_SEARCH_PARTITIONS + 1)
3480f358:	e35a0011 	cmp	sl, #17
3480f35c:	1a000013 	bne	3480f3b0 <get_device_and_partition+0x274>
3480f360:	ea00000a 	b	3480f390 <get_device_and_partition+0x254>
			/*
			 * We now need to search further for best possible.
			 * If we what we just queried was the best so far,
			 * save the info since we over-write it next loop.
			 */
			if (part == p)
3480f364:	e154000a 	cmp	r4, sl
3480f368:	1a000003 	bne	3480f37c <get_device_and_partition+0x240>
				tmpinfo = *info;
3480f36c:	e1a00009 	mov	r0, r9
3480f370:	e1a01005 	mov	r1, r5
3480f374:	e3a02050 	mov	r2, #80	; 0x50
3480f378:	eb0026c4 	bl	34818e90 <memcpy>
		/*
		 * Find the first bootable partition.
		 * If none are bootable, fall back to the first valid partition.
		 */
		part = 0;
		for (p = 1; p <= MAX_SEARCH_PARTITIONS; p++) {
3480f37c:	e28aa001 	add	sl, sl, #1
3480f380:	e35a0011 	cmp	sl, #17
3480f384:	1affffe4 	bne	3480f31c <get_device_and_partition+0x1e0>
			 */
			if (part == p)
				tmpinfo = *info;
		}
		/* If we found any acceptable partition */
		if (part) {
3480f388:	e3540000 	cmp	r4, #0
3480f38c:	0a000004 	beq	3480f3a4 <get_device_and_partition+0x268>
			/*
			 * If we searched all possible partition IDs,
			 * return the first valid partition we found.
			 */
			if (p == MAX_SEARCH_PARTITIONS + 1)
				*info = tmpinfo;
3480f390:	e1a00005 	mov	r0, r5
3480f394:	e28d1004 	add	r1, sp, #4
3480f398:	e3a02050 	mov	r2, #80	; 0x50
3480f39c:	eb0026bb 	bl	34818e90 <memcpy>
3480f3a0:	ea000002 	b	3480f3b0 <get_device_and_partition+0x274>
			ret = 0;
		} else {
			printf("** No valid partitions found **\n");
3480f3a4:	e59f0068 	ldr	r0, [pc, #104]	; 3480f414 <get_device_and_partition+0x2d8>
3480f3a8:	ebffe6e7 	bl	34808f4c <printf>
			goto cleanup;
3480f3ac:	ea00000b 	b	3480f3e0 <get_device_and_partition+0x2a4>
		}
	}
	if (strncmp((char *)info->type, BOOT_PART_TYPE, sizeof(info->type)) != 0) {
3480f3b0:	e285502c 	add	r5, r5, #44	; 0x2c
3480f3b4:	e1a00005 	mov	r0, r5
3480f3b8:	e59f1058 	ldr	r1, [pc, #88]	; 3480f418 <get_device_and_partition+0x2dc>
3480f3bc:	e3a02020 	mov	r2, #32
3480f3c0:	eb0025c6 	bl	34818ae0 <strncmp>
3480f3c4:	e3500000 	cmp	r0, #0
			info->type);
		ret  = -1;
		goto cleanup;
	}

	ret = part;
3480f3c8:	01a06004 	moveq	r6, r4
		} else {
			printf("** No valid partitions found **\n");
			goto cleanup;
		}
	}
	if (strncmp((char *)info->type, BOOT_PART_TYPE, sizeof(info->type)) != 0) {
3480f3cc:	0a000003 	beq	3480f3e0 <get_device_and_partition+0x2a4>
		printf("** Invalid partition type \"%.32s\""
3480f3d0:	e59f0044 	ldr	r0, [pc, #68]	; 3480f41c <get_device_and_partition+0x2e0>
3480f3d4:	e1a01005 	mov	r1, r5
3480f3d8:	ebffe6db 	bl	34808f4c <printf>
#define MAX_SEARCH_PARTITIONS 16
int get_device_and_partition(const char *ifname, const char *dev_part_str,
			     block_dev_desc_t **dev_desc,
			     disk_partition_t *info, int allow_whole_dev)
{
	int ret = -1;
3480f3dc:	e3e06000 	mvn	r6, #0

	ret = part;
	goto cleanup;

cleanup:
	free(dup_str);
3480f3e0:	e1a00007 	mov	r0, r7
3480f3e4:	ebffe816 	bl	34809444 <free>
	return ret;
}
3480f3e8:	e1a00006 	mov	r0, r6
3480f3ec:	e28dd058 	add	sp, sp, #88	; 0x58
3480f3f0:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
3480f3f4:	3482636f 	.word	0x3482636f
3480f3f8:	34826b30 	.word	0x34826b30
3480f3fc:	34826b3b 	.word	0x34826b3b
3480f400:	34826b56 	.word	0x34826b56
3480f404:	34826b5b 	.word	0x34826b5b
3480f408:	34826b84 	.word	0x34826b84
3480f40c:	34826ba3 	.word	0x34826ba3
3480f410:	34826bc5 	.word	0x34826bc5
3480f414:	34826be1 	.word	0x34826be1
3480f418:	348267c7 	.word	0x348267c7
3480f41c:	34826c02 	.word	0x34826c02

3480f420 <le32_to_int>:
/* Convert char[4] in little endian format to the host format integer
 */
static inline int le32_to_int(unsigned char *le32)
{
    return ((le32[3] << 24) +
	    (le32[2] << 16) +
3480f420:	e5d03002 	ldrb	r3, [r0, #2]

/* Convert char[4] in little endian format to the host format integer
 */
static inline int le32_to_int(unsigned char *le32)
{
    return ((le32[3] << 24) +
3480f424:	e5d02003 	ldrb	r2, [r0, #3]
	    (le32[2] << 16) +
3480f428:	e1a03803 	lsl	r3, r3, #16

/* Convert char[4] in little endian format to the host format integer
 */
static inline int le32_to_int(unsigned char *le32)
{
    return ((le32[3] << 24) +
3480f42c:	e0833c02 	add	r3, r3, r2, lsl #24
	    (le32[2] << 16) +
	    (le32[1] << 8) +
3480f430:	e5d02000 	ldrb	r2, [r0]
3480f434:	e5d00001 	ldrb	r0, [r0, #1]
/* Convert char[4] in little endian format to the host format integer
 */
static inline int le32_to_int(unsigned char *le32)
{
    return ((le32[3] << 24) +
	    (le32[2] << 16) +
3480f438:	e0833002 	add	r3, r3, r2
	    (le32[1] << 8) +
	     le32[0]
	   );
}
3480f43c:	e0830400 	add	r0, r3, r0, lsl #8
3480f440:	e12fff1e 	bx	lr

3480f444 <is_extended>:

static inline int is_extended(int part_type)
{
    return (part_type == 0x5 ||
3480f444:	e3500005 	cmp	r0, #5
3480f448:	1350000f 	cmpne	r0, #15
3480f44c:	0a000003 	beq	3480f460 <is_extended+0x1c>
3480f450:	e3500085 	cmp	r0, #133	; 0x85
3480f454:	13a00000 	movne	r0, #0
3480f458:	03a00001 	moveq	r0, #1
3480f45c:	e12fff1e 	bx	lr
3480f460:	e3a00001 	mov	r0, #1
	    part_type == 0xf ||
	    part_type == 0x85);
}
3480f464:	e12fff1e 	bx	lr

3480f468 <test_block_type>:
		(is_extended(p->sys_ind) ? " Extd" : ""),
		(is_bootable(p) ? " Boot" : ""));
}

static int test_block_type(unsigned char *buffer)
{
3480f468:	e92d4010 	push	{r4, lr}
	if((buffer[DOS_PART_MAGIC_OFFSET + 0] != 0x55) ||
3480f46c:	e5d031fe 	ldrb	r3, [r0, #510]	; 0x1fe
		(is_extended(p->sys_ind) ? " Extd" : ""),
		(is_bootable(p) ? " Boot" : ""));
}

static int test_block_type(unsigned char *buffer)
{
3480f470:	e1a04000 	mov	r4, r0
	if((buffer[DOS_PART_MAGIC_OFFSET + 0] != 0x55) ||
3480f474:	e3530055 	cmp	r3, #85	; 0x55
3480f478:	1a00000f 	bne	3480f4bc <test_block_type+0x54>
3480f47c:	e5d031ff 	ldrb	r3, [r0, #511]	; 0x1ff
3480f480:	e35300aa 	cmp	r3, #170	; 0xaa
3480f484:	1a00000c 	bne	3480f4bc <test_block_type+0x54>
	    (buffer[DOS_PART_MAGIC_OFFSET + 1] != 0xaa) ) {
		return (-1);
	} /* no DOS Signature at all */
	if (strncmp((char *)&buffer[DOS_PBR_FSTYPE_OFFSET],"FAT",3)==0 ||
3480f488:	e2800036 	add	r0, r0, #54	; 0x36
3480f48c:	e59f1038 	ldr	r1, [pc, #56]	; 3480f4cc <test_block_type+0x64>
3480f490:	e3a02003 	mov	r2, #3
3480f494:	eb002591 	bl	34818ae0 <strncmp>
3480f498:	e3500000 	cmp	r0, #0
3480f49c:	0a000008 	beq	3480f4c4 <test_block_type+0x5c>
	    strncmp((char *)&buffer[DOS_PBR32_FSTYPE_OFFSET],"FAT32",5)==0) {
3480f4a0:	e2840052 	add	r0, r4, #82	; 0x52
3480f4a4:	e59f1024 	ldr	r1, [pc, #36]	; 3480f4d0 <test_block_type+0x68>
3480f4a8:	e3a02005 	mov	r2, #5
3480f4ac:	eb00258b 	bl	34818ae0 <strncmp>

static int test_block_type(unsigned char *buffer)
{
	if((buffer[DOS_PART_MAGIC_OFFSET + 0] != 0x55) ||
	    (buffer[DOS_PART_MAGIC_OFFSET + 1] != 0xaa) ) {
		return (-1);
3480f4b0:	e2700001 	rsbs	r0, r0, #1
3480f4b4:	33a00000 	movcc	r0, #0
3480f4b8:	e8bd8010 	pop	{r4, pc}
3480f4bc:	e3e00000 	mvn	r0, #0
3480f4c0:	e8bd8010 	pop	{r4, pc}
	} /* no DOS Signature at all */
	if (strncmp((char *)&buffer[DOS_PBR_FSTYPE_OFFSET],"FAT",3)==0 ||
	    strncmp((char *)&buffer[DOS_PBR32_FSTYPE_OFFSET],"FAT32",5)==0) {
		return DOS_PBR; /* is PBR */
3480f4c4:	e3a00001 	mov	r0, #1
	}
	return DOS_MBR;	    /* Is MBR */
}
3480f4c8:	e8bd8010 	pop	{r4, pc}
3480f4cc:	34826c37 	.word	0x34826c37
3480f4d0:	34826c3b 	.word	0x34826c3b

3480f4d4 <print_partition_extended>:

/*  Print a partition that is relative to its Extended partition table
 */
static void print_partition_extended (block_dev_desc_t *dev_desc, int ext_part_sector, int relative,
							   int part_num)
{
3480f4d4:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
3480f4d8:	e28db01c 	add	fp, sp, #28
3480f4dc:	e24dd020 	sub	sp, sp, #32
3480f4e0:	e1a0a003 	mov	sl, r3
	ALLOC_CACHE_ALIGN_BUFFER(unsigned char, buffer, dev_desc->blksz);
3480f4e4:	e5903014 	ldr	r3, [r0, #20]

/*  Print a partition that is relative to its Extended partition table
 */
static void print_partition_extended (block_dev_desc_t *dev_desc, int ext_part_sector, int relative,
							   int part_num)
{
3480f4e8:	e50b2024 	str	r2, [fp, #-36]	; 0x24
	ALLOC_CACHE_ALIGN_BUFFER(unsigned char, buffer, dev_desc->blksz);
3480f4ec:	e283303f 	add	r3, r3, #63	; 0x3f
3480f4f0:	e3c3303f 	bic	r3, r3, #63	; 0x3f
3480f4f4:	e2833048 	add	r3, r3, #72	; 0x48
3480f4f8:	e04dd003 	sub	sp, sp, r3
3480f4fc:	e28d504f 	add	r5, sp, #79	; 0x4f
3480f500:	e3c5503f 	bic	r5, r5, #63	; 0x3f
	dos_partition_t *pt;
	int i;

	if (dev_desc->block_read(dev_desc->dev, ext_part_sector, 1, (ulong *) buffer) != 1) {
3480f504:	e590c060 	ldr	ip, [r0, #96]	; 0x60

/*  Print a partition that is relative to its Extended partition table
 */
static void print_partition_extended (block_dev_desc_t *dev_desc, int ext_part_sector, int relative,
							   int part_num)
{
3480f508:	e1a04000 	mov	r4, r0
	ALLOC_CACHE_ALIGN_BUFFER(unsigned char, buffer, dev_desc->blksz);
	dos_partition_t *pt;
	int i;

	if (dev_desc->block_read(dev_desc->dev, ext_part_sector, 1, (ulong *) buffer) != 1) {
3480f50c:	e3a02001 	mov	r2, #1
3480f510:	e5900004 	ldr	r0, [r0, #4]
3480f514:	e1a03005 	mov	r3, r5

/*  Print a partition that is relative to its Extended partition table
 */
static void print_partition_extended (block_dev_desc_t *dev_desc, int ext_part_sector, int relative,
							   int part_num)
{
3480f518:	e1a07001 	mov	r7, r1
	ALLOC_CACHE_ALIGN_BUFFER(unsigned char, buffer, dev_desc->blksz);
	dos_partition_t *pt;
	int i;

	if (dev_desc->block_read(dev_desc->dev, ext_part_sector, 1, (ulong *) buffer) != 1) {
3480f51c:	e12fff3c 	blx	ip
3480f520:	e3500001 	cmp	r0, #1
		printf ("** Can't read partition table on %d:%d **\n",
3480f524:	159f0158 	ldrne	r0, [pc, #344]	; 3480f684 <print_partition_extended+0x1b0>
3480f528:	15941004 	ldrne	r1, [r4, #4]
3480f52c:	11a02007 	movne	r2, r7
3480f530:	1a000006 	bne	3480f550 <print_partition_extended+0x7c>
			dev_desc->dev, ext_part_sector);
		return;
	}
	i=test_block_type(buffer);
3480f534:	e1a00005 	mov	r0, r5
3480f538:	ebffffca 	bl	3480f468 <test_block_type>
	if (i != DOS_MBR) {
3480f53c:	e3500000 	cmp	r0, #0
3480f540:	0a000004 	beq	3480f558 <print_partition_extended+0x84>
		printf ("bad MBR sector signature 0x%02x%02x\n",
3480f544:	e59f013c 	ldr	r0, [pc, #316]	; 3480f688 <print_partition_extended+0x1b4>
3480f548:	e5d511fe 	ldrb	r1, [r5, #510]	; 0x1fe
3480f54c:	e5d521ff 	ldrb	r2, [r5, #511]	; 0x1ff
3480f550:	ebffe67d 	bl	34808f4c <printf>
3480f554:	ea000048 	b	3480f67c <print_partition_extended+0x1a8>
			buffer[DOS_PART_MAGIC_OFFSET + 1]);
		return;
	}

	/* Print all primary/logical partitions */
	pt = (dos_partition_t *) (buffer + DOS_PART_TBL_OFFSET);
3480f558:	e2856f6f 	add	r6, r5, #444	; 0x1bc
3480f55c:	e2866002 	add	r6, r6, #2
	return 0;
}

/*  Print a partition that is relative to its Extended partition table
 */
static void print_partition_extended (block_dev_desc_t *dev_desc, int ext_part_sector, int relative,
3480f560:	e2855f7b 	add	r5, r5, #492	; 0x1ec
3480f564:	e2859002 	add	r9, r5, #2
			buffer[DOS_PART_MAGIC_OFFSET + 1]);
		return;
	}

	/* Print all primary/logical partitions */
	pt = (dos_partition_t *) (buffer + DOS_PART_TBL_OFFSET);
3480f568:	e1a05006 	mov	r5, r6
		/*
		 * fdisk does not show the extended partitions that
		 * are not in the MBR
		 */

		if ((pt->sys_ind != 0) &&
3480f56c:	e5d51004 	ldrb	r1, [r5, #4]
3480f570:	e3510000 	cmp	r1, #0
3480f574:	e50b1020 	str	r1, [fp, #-32]
3480f578:	0a000022 	beq	3480f608 <print_partition_extended+0x134>
3480f57c:	e3570000 	cmp	r7, #0
3480f580:	0a000003 	beq	3480f594 <print_partition_extended+0xc0>
		    (ext_part_sector == 0 || !is_extended (pt->sys_ind)) ) {
3480f584:	e1a00001 	mov	r0, r1
3480f588:	ebffffad 	bl	3480f444 <is_extended>
3480f58c:	e3500000 	cmp	r0, #0
3480f590:	1a00001e 	bne	3480f610 <print_partition_extended+0x13c>
	return p->boot_ind == 0x80;
}

static void print_one_part (dos_partition_t *p, int ext_part_sector, int part_num)
{
	int lba_start = ext_part_sector + le32_to_int (p->start4);
3480f594:	e2850008 	add	r0, r5, #8
3480f598:	ebffffa0 	bl	3480f420 <le32_to_int>
3480f59c:	e0802007 	add	r2, r0, r7
	int lba_size  = le32_to_int (p->size4);
3480f5a0:	e285000c 	add	r0, r5, #12
3480f5a4:	e50b202c 	str	r2, [fp, #-44]	; 0x2c
3480f5a8:	ebffff9c 	bl	3480f420 <le32_to_int>
3480f5ac:	e1a03000 	mov	r3, r0

	printf("%5d\t\t%10d\t%10d\t%2x%s%s\n",
		part_num, lba_start, lba_size, p->sys_ind,
		(is_extended(p->sys_ind) ? " Extd" : ""),
3480f5b0:	e51b0020 	ldr	r0, [fp, #-32]
3480f5b4:	e50b3028 	str	r3, [fp, #-40]	; 0x28
3480f5b8:	ebffffa1 	bl	3480f444 <is_extended>
static void print_one_part (dos_partition_t *p, int ext_part_sector, int part_num)
{
	int lba_start = ext_part_sector + le32_to_int (p->start4);
	int lba_size  = le32_to_int (p->size4);

	printf("%5d\t\t%10d\t%10d\t%2x%s%s\n",
3480f5bc:	e59fe0c8 	ldr	lr, [pc, #200]	; 3480f68c <print_partition_extended+0x1b8>
3480f5c0:	e5d51000 	ldrb	r1, [r5]
3480f5c4:	e59fc0c4 	ldr	ip, [pc, #196]	; 3480f690 <print_partition_extended+0x1bc>
3480f5c8:	e3500000 	cmp	r0, #0
3480f5cc:	11a0c00e 	movne	ip, lr
3480f5d0:	e59fe0bc 	ldr	lr, [pc, #188]	; 3480f694 <print_partition_extended+0x1c0>
3480f5d4:	e1a0000c 	mov	r0, ip
3480f5d8:	e3510080 	cmp	r1, #128	; 0x80
3480f5dc:	e59fc0ac 	ldr	ip, [pc, #172]	; 3480f690 <print_partition_extended+0x1bc>
3480f5e0:	01a0c00e 	moveq	ip, lr
3480f5e4:	e1a0100c 	mov	r1, ip
3480f5e8:	e51bc020 	ldr	ip, [fp, #-32]
3480f5ec:	e98d0003 	stmib	sp, {r0, r1}
3480f5f0:	e59f00a0 	ldr	r0, [pc, #160]	; 3480f698 <print_partition_extended+0x1c4>
3480f5f4:	e1a0100a 	mov	r1, sl
3480f5f8:	e51b202c 	ldr	r2, [fp, #-44]	; 0x2c
3480f5fc:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
3480f600:	e58dc000 	str	ip, [sp]
3480f604:	ebffe650 	bl	34808f4c <printf>
		    (ext_part_sector == 0 || !is_extended (pt->sys_ind)) ) {
			print_one_part (pt, ext_part_sector, part_num);
		}

		/* Reverse engr the fdisk part# assignment rule! */
		if ((ext_part_sector == 0) ||
3480f608:	e3570000 	cmp	r7, #0
3480f60c:	0a000005 	beq	3480f628 <print_partition_extended+0x154>
		    (pt->sys_ind != 0 && !is_extended (pt->sys_ind)) ) {
3480f610:	e5d50004 	ldrb	r0, [r5, #4]
		    (ext_part_sector == 0 || !is_extended (pt->sys_ind)) ) {
			print_one_part (pt, ext_part_sector, part_num);
		}

		/* Reverse engr the fdisk part# assignment rule! */
		if ((ext_part_sector == 0) ||
3480f614:	e3500000 	cmp	r0, #0
3480f618:	0a000003 	beq	3480f62c <print_partition_extended+0x158>
		    (pt->sys_ind != 0 && !is_extended (pt->sys_ind)) ) {
3480f61c:	ebffff88 	bl	3480f444 <is_extended>
3480f620:	e3500000 	cmp	r0, #0
3480f624:	1a000000 	bne	3480f62c <print_partition_extended+0x158>
			part_num++;
3480f628:	e28aa001 	add	sl, sl, #1
		return;
	}

	/* Print all primary/logical partitions */
	pt = (dos_partition_t *) (buffer + DOS_PART_TBL_OFFSET);
	for (i = 0; i < 4; i++, pt++) {
3480f62c:	e1550009 	cmp	r5, r9
3480f630:	12855010 	addne	r5, r5, #16
3480f634:	1affffcc 	bne	3480f56c <print_partition_extended+0x98>
3480f638:	e51b5024 	ldr	r5, [fp, #-36]	; 0x24
	}

	/* Follows the extended partitions */
	pt = (dos_partition_t *) (buffer + DOS_PART_TBL_OFFSET);
	for (i = 0; i < 4; i++, pt++) {
		if (is_extended (pt->sys_ind)) {
3480f63c:	e5d60004 	ldrb	r0, [r6, #4]
3480f640:	ebffff7f 	bl	3480f444 <is_extended>
3480f644:	e3500000 	cmp	r0, #0
3480f648:	0a000008 	beq	3480f670 <print_partition_extended+0x19c>
			int lba_start = le32_to_int (pt->start4) + relative;
3480f64c:	e2860008 	add	r0, r6, #8
3480f650:	ebffff72 	bl	3480f420 <le32_to_int>

			print_partition_extended (dev_desc, lba_start,
3480f654:	e3570000 	cmp	r7, #0

	/* Follows the extended partitions */
	pt = (dos_partition_t *) (buffer + DOS_PART_TBL_OFFSET);
	for (i = 0; i < 4; i++, pt++) {
		if (is_extended (pt->sys_ind)) {
			int lba_start = le32_to_int (pt->start4) + relative;
3480f658:	e0801005 	add	r1, r0, r5

			print_partition_extended (dev_desc, lba_start,
3480f65c:	11a02005 	movne	r2, r5
3480f660:	e1a00004 	mov	r0, r4
3480f664:	01a02001 	moveq	r2, r1
3480f668:	e1a0300a 	mov	r3, sl
3480f66c:	ebffff98 	bl	3480f4d4 <print_partition_extended>
		}
	}

	/* Follows the extended partitions */
	pt = (dos_partition_t *) (buffer + DOS_PART_TBL_OFFSET);
	for (i = 0; i < 4; i++, pt++) {
3480f670:	e1560009 	cmp	r6, r9
3480f674:	12866010 	addne	r6, r6, #16
3480f678:	1affffef 	bne	3480f63c <print_partition_extended+0x168>
						  part_num);
		}
	}

	return;
}
3480f67c:	e24bd01c 	sub	sp, fp, #28
3480f680:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
3480f684:	34826c4d 	.word	0x34826c4d
3480f688:	34826c78 	.word	0x34826c78
3480f68c:	34826c41 	.word	0x34826c41
3480f690:	34824054 	.word	0x34824054
3480f694:	34826c47 	.word	0x34826c47
3480f698:	34826c9d 	.word	0x34826c9d

3480f69c <get_partition_info_extended.clone.1>:


/*  Print a partition that is relative to its Extended partition table
 */
static int get_partition_info_extended (block_dev_desc_t *dev_desc, int ext_part_sector,
3480f69c:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
3480f6a0:	e28db01c 	add	fp, sp, #28
3480f6a4:	e24dd010 	sub	sp, sp, #16
3480f6a8:	e1a06003 	mov	r6, r3
				 int relative, int part_num,
				 int which_part, disk_partition_t *info,
				 unsigned int disksig)
{
	ALLOC_CACHE_ALIGN_BUFFER(unsigned char, buffer, dev_desc->blksz);
3480f6ac:	e5903014 	ldr	r3, [r0, #20]
	dos_partition_t *pt;
	int i;

	if (dev_desc->block_read (dev_desc->dev, ext_part_sector, 1, (ulong *) buffer) != 1) {
3480f6b0:	e590c060 	ldr	ip, [r0, #96]	; 0x60
static int get_partition_info_extended (block_dev_desc_t *dev_desc, int ext_part_sector,
				 int relative, int part_num,
				 int which_part, disk_partition_t *info,
				 unsigned int disksig)
{
	ALLOC_CACHE_ALIGN_BUFFER(unsigned char, buffer, dev_desc->blksz);
3480f6b4:	e283303f 	add	r3, r3, #63	; 0x3f
3480f6b8:	e3c3303f 	bic	r3, r3, #63	; 0x3f
3480f6bc:	e2833048 	add	r3, r3, #72	; 0x48
3480f6c0:	e04dd003 	sub	sp, sp, r3
3480f6c4:	e28d4047 	add	r4, sp, #71	; 0x47
3480f6c8:	e3c4403f 	bic	r4, r4, #63	; 0x3f
}


/*  Print a partition that is relative to its Extended partition table
 */
static int get_partition_info_extended (block_dev_desc_t *dev_desc, int ext_part_sector,
3480f6cc:	e1a05000 	mov	r5, r0
3480f6d0:	e1a09002 	mov	r9, r2
{
	ALLOC_CACHE_ALIGN_BUFFER(unsigned char, buffer, dev_desc->blksz);
	dos_partition_t *pt;
	int i;

	if (dev_desc->block_read (dev_desc->dev, ext_part_sector, 1, (ulong *) buffer) != 1) {
3480f6d4:	e5900004 	ldr	r0, [r0, #4]
3480f6d8:	e3a02001 	mov	r2, #1
3480f6dc:	e1a03004 	mov	r3, r4
}


/*  Print a partition that is relative to its Extended partition table
 */
static int get_partition_info_extended (block_dev_desc_t *dev_desc, int ext_part_sector,
3480f6e0:	e1a0a001 	mov	sl, r1
3480f6e4:	e59b7008 	ldr	r7, [fp, #8]
{
	ALLOC_CACHE_ALIGN_BUFFER(unsigned char, buffer, dev_desc->blksz);
	dos_partition_t *pt;
	int i;

	if (dev_desc->block_read (dev_desc->dev, ext_part_sector, 1, (ulong *) buffer) != 1) {
3480f6e8:	e12fff3c 	blx	ip
3480f6ec:	e3500001 	cmp	r0, #1
		printf ("** Can't read partition table on %d:%d **\n",
3480f6f0:	159f01e8 	ldrne	r0, [pc, #488]	; 3480f8e0 <get_partition_info_extended.clone.1+0x244>
3480f6f4:	15951004 	ldrne	r1, [r5, #4]
3480f6f8:	11a0200a 	movne	r2, sl
3480f6fc:	1a000007 	bne	3480f720 <get_partition_info_extended.clone.1+0x84>
			dev_desc->dev, ext_part_sector);
		return -1;
	}
	if (buffer[DOS_PART_MAGIC_OFFSET] != 0x55 ||
3480f700:	e5d411fe 	ldrb	r1, [r4, #510]	; 0x1fe
3480f704:	e3510055 	cmp	r1, #85	; 0x55
3480f708:	1a000002 	bne	3480f718 <get_partition_info_extended.clone.1+0x7c>
3480f70c:	e5d431ff 	ldrb	r3, [r4, #511]	; 0x1ff
3480f710:	e35300aa 	cmp	r3, #170	; 0xaa
3480f714:	0a000003 	beq	3480f728 <get_partition_info_extended.clone.1+0x8c>
		buffer[DOS_PART_MAGIC_OFFSET + 1] != 0xaa) {
		printf ("bad MBR sector signature 0x%02x%02x\n",
3480f718:	e59f01c4 	ldr	r0, [pc, #452]	; 3480f8e4 <get_partition_info_extended.clone.1+0x248>
3480f71c:	e5d421ff 	ldrb	r2, [r4, #511]	; 0x1ff
3480f720:	ebffe609 	bl	34808f4c <printf>
3480f724:	ea00006a 	b	3480f8d4 <get_partition_info_extended.clone.1+0x238>
	if (!ext_part_sector)
		disksig = le32_to_int(&buffer[DOS_PART_DISKSIG_OFFSET]);
#endif

	/* Print all primary/logical partitions */
	pt = (dos_partition_t *) (buffer + DOS_PART_TBL_OFFSET);
3480f728:	e2843f6f 	add	r3, r4, #444	; 0x1bc
}


/*  Print a partition that is relative to its Extended partition table
 */
static int get_partition_info_extended (block_dev_desc_t *dev_desc, int ext_part_sector,
3480f72c:	e2844f7b 	add	r4, r4, #492	; 0x1ec
3480f730:	e2844002 	add	r4, r4, #2
	if (!ext_part_sector)
		disksig = le32_to_int(&buffer[DOS_PART_DISKSIG_OFFSET]);
#endif

	/* Print all primary/logical partitions */
	pt = (dos_partition_t *) (buffer + DOS_PART_TBL_OFFSET);
3480f734:	e2833002 	add	r3, r3, #2
}


/*  Print a partition that is relative to its Extended partition table
 */
static int get_partition_info_extended (block_dev_desc_t *dev_desc, int ext_part_sector,
3480f738:	e50b4020 	str	r4, [fp, #-32]
	if (!ext_part_sector)
		disksig = le32_to_int(&buffer[DOS_PART_DISKSIG_OFFSET]);
#endif

	/* Print all primary/logical partitions */
	pt = (dos_partition_t *) (buffer + DOS_PART_TBL_OFFSET);
3480f73c:	e1a04003 	mov	r4, r3
	for (i = 0; i < 4; i++, pt++) {
		/*
		 * fdisk does not show the extended partitions that
		 * are not in the MBR
		 */
		if (((pt->boot_ind & ~0x80) == 0) &&
3480f740:	e5d42000 	ldrb	r2, [r4]
3480f744:	e312007f 	tst	r2, #127	; 0x7f
3480f748:	1a00003b 	bne	3480f83c <get_partition_info_extended.clone.1+0x1a0>
		    (pt->sys_ind != 0) &&
3480f74c:	e5d40004 	ldrb	r0, [r4, #4]
3480f750:	e59b1004 	ldr	r1, [fp, #4]
3480f754:	e1560001 	cmp	r6, r1
3480f758:	13a02000 	movne	r2, #0
3480f75c:	03a02001 	moveq	r2, #1
3480f760:	e3500000 	cmp	r0, #0
3480f764:	03a02000 	moveq	r2, #0
3480f768:	e3520000 	cmp	r2, #0
3480f76c:	0a000032 	beq	3480f83c <get_partition_info_extended.clone.1+0x1a0>
		    (part_num == which_part) &&
		    (is_extended(pt->sys_ind) == 0)) {
3480f770:	e50b3024 	str	r3, [fp, #-36]	; 0x24
3480f774:	ebffff32 	bl	3480f444 <is_extended>
		 * fdisk does not show the extended partitions that
		 * are not in the MBR
		 */
		if (((pt->boot_ind & ~0x80) == 0) &&
		    (pt->sys_ind != 0) &&
		    (part_num == which_part) &&
3480f778:	e3500000 	cmp	r0, #0
3480f77c:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
3480f780:	1a00002d 	bne	3480f83c <get_partition_info_extended.clone.1+0x1a0>
		    (is_extended(pt->sys_ind) == 0)) {
			info->blksz = 512;
3480f784:	e3a03c02 	mov	r3, #512	; 0x200
3480f788:	e5873008 	str	r3, [r7, #8]
			info->start = ext_part_sector + le32_to_int (pt->start4);
3480f78c:	e2840008 	add	r0, r4, #8
3480f790:	ebffff22 	bl	3480f420 <le32_to_int>
3480f794:	e080000a 	add	r0, r0, sl
3480f798:	e5870000 	str	r0, [r7]
			info->size  = le32_to_int (pt->size4);
3480f79c:	e284000c 	add	r0, r4, #12
3480f7a0:	ebffff1e 	bl	3480f420 <le32_to_int>
			switch(dev_desc->if_type) {
3480f7a4:	e5953000 	ldr	r3, [r5]
		    (pt->sys_ind != 0) &&
		    (part_num == which_part) &&
		    (is_extended(pt->sys_ind) == 0)) {
			info->blksz = 512;
			info->start = ext_part_sector + le32_to_int (pt->start4);
			info->size  = le32_to_int (pt->size4);
3480f7a8:	e5870004 	str	r0, [r7, #4]
			switch(dev_desc->if_type) {
3480f7ac:	e2433001 	sub	r3, r3, #1
3480f7b0:	e287000c 	add	r0, r7, #12
3480f7b4:	e5952004 	ldr	r2, [r5, #4]
3480f7b8:	e3530007 	cmp	r3, #7
3480f7bc:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
3480f7c0:	ea00000f 	b	3480f804 <get_partition_info_extended.clone.1+0x168>
3480f7c4:	3480f7e4 	.word	0x3480f7e4
3480f7c8:	3480f7ec 	.word	0x3480f7ec
3480f7cc:	3480f7e4 	.word	0x3480f7e4
3480f7d0:	3480f7f4 	.word	0x3480f7f4
3480f7d4:	3480f7fc 	.word	0x3480f7fc
3480f7d8:	3480f804 	.word	0x3480f804
3480f7dc:	3480f804 	.word	0x3480f804
3480f7e0:	3480f7e4 	.word	0x3480f7e4
				case IF_TYPE_IDE:
				case IF_TYPE_SATA:
				case IF_TYPE_ATAPI:
					sprintf ((char *)info->name, "hd%c%d",
3480f7e4:	e59f10fc 	ldr	r1, [pc, #252]	; 3480f8e8 <get_partition_info_extended.clone.1+0x24c>
3480f7e8:	ea000006 	b	3480f808 <get_partition_info_extended.clone.1+0x16c>
						'a' + dev_desc->dev, part_num);
					break;
				case IF_TYPE_SCSI:
					sprintf ((char *)info->name, "sd%c%d",
3480f7ec:	e59f10f8 	ldr	r1, [pc, #248]	; 3480f8ec <get_partition_info_extended.clone.1+0x250>
3480f7f0:	ea000004 	b	3480f808 <get_partition_info_extended.clone.1+0x16c>
						'a' + dev_desc->dev, part_num);
					break;
				case IF_TYPE_USB:
					sprintf ((char *)info->name, "usbd%c%d",
3480f7f4:	e59f10f4 	ldr	r1, [pc, #244]	; 3480f8f0 <get_partition_info_extended.clone.1+0x254>
3480f7f8:	ea000002 	b	3480f808 <get_partition_info_extended.clone.1+0x16c>
						'a' + dev_desc->dev, part_num);
					break;
				case IF_TYPE_DOC:
					sprintf ((char *)info->name, "docd%c%d",
3480f7fc:	e59f10f0 	ldr	r1, [pc, #240]	; 3480f8f4 <get_partition_info_extended.clone.1+0x258>
3480f800:	ea000000 	b	3480f808 <get_partition_info_extended.clone.1+0x16c>
						'a' + dev_desc->dev, part_num);
					break;
				default:
					sprintf ((char *)info->name, "xx%c%d",
3480f804:	e59f10ec 	ldr	r1, [pc, #236]	; 3480f8f8 <get_partition_info_extended.clone.1+0x25c>
3480f808:	e1a03006 	mov	r3, r6
3480f80c:	e2822061 	add	r2, r2, #97	; 0x61
3480f810:	eb00299e 	bl	34819e90 <sprintf>
						'a' + dev_desc->dev, part_num);
					break;
			}
			/* sprintf(info->type, "%d, pt->sys_ind); */
			sprintf ((char *)info->type, "U-Boot");
3480f814:	e287002c 	add	r0, r7, #44	; 0x2c
3480f818:	e59f10dc 	ldr	r1, [pc, #220]	; 3480f8fc <get_partition_info_extended.clone.1+0x260>
3480f81c:	eb00299b 	bl	34819e90 <sprintf>
	    part_type == 0x85);
}

static inline int is_bootable(dos_partition_t *p)
{
	return p->boot_ind == 0x80;
3480f820:	e5d43000 	ldrb	r3, [r4]
			sprintf ((char *)info->type, "U-Boot");
			info->bootable = is_bootable(pt);
#ifdef CONFIG_PARTITION_UUIDS
			sprintf(info->uuid, "%08x-%02x", disksig, part_num);
#endif
			return 0;
3480f824:	e3a00000 	mov	r0, #0
	    part_type == 0x85);
}

static inline int is_bootable(dos_partition_t *p)
{
	return p->boot_ind == 0x80;
3480f828:	e3530080 	cmp	r3, #128	; 0x80
3480f82c:	13a03000 	movne	r3, #0
3480f830:	03a03001 	moveq	r3, #1
						'a' + dev_desc->dev, part_num);
					break;
			}
			/* sprintf(info->type, "%d, pt->sys_ind); */
			sprintf ((char *)info->type, "U-Boot");
			info->bootable = is_bootable(pt);
3480f834:	e587304c 	str	r3, [r7, #76]	; 0x4c
3480f838:	ea000026 	b	3480f8d8 <get_partition_info_extended.clone.1+0x23c>
#endif
			return 0;
		}

		/* Reverse engr the fdisk part# assignment rule! */
		if ((ext_part_sector == 0) ||
3480f83c:	e35a0000 	cmp	sl, #0
3480f840:	0a000007 	beq	3480f864 <get_partition_info_extended.clone.1+0x1c8>
		    (pt->sys_ind != 0 && !is_extended (pt->sys_ind)) ) {
3480f844:	e5d40004 	ldrb	r0, [r4, #4]
#endif
			return 0;
		}

		/* Reverse engr the fdisk part# assignment rule! */
		if ((ext_part_sector == 0) ||
3480f848:	e3500000 	cmp	r0, #0
3480f84c:	0a000005 	beq	3480f868 <get_partition_info_extended.clone.1+0x1cc>
		    (pt->sys_ind != 0 && !is_extended (pt->sys_ind)) ) {
3480f850:	e50b3024 	str	r3, [fp, #-36]	; 0x24
3480f854:	ebfffefa 	bl	3480f444 <is_extended>
3480f858:	e3500000 	cmp	r0, #0
3480f85c:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
3480f860:	1a000000 	bne	3480f868 <get_partition_info_extended.clone.1+0x1cc>
			part_num++;
3480f864:	e2866001 	add	r6, r6, #1
		disksig = le32_to_int(&buffer[DOS_PART_DISKSIG_OFFSET]);
#endif

	/* Print all primary/logical partitions */
	pt = (dos_partition_t *) (buffer + DOS_PART_TBL_OFFSET);
	for (i = 0; i < 4; i++, pt++) {
3480f868:	e51b2020 	ldr	r2, [fp, #-32]
3480f86c:	e1540002 	cmp	r4, r2
3480f870:	12844010 	addne	r4, r4, #16
3480f874:	1affffb1 	bne	3480f740 <get_partition_info_extended.clone.1+0xa4>
	}

	/* Follows the extended partitions */
	pt = (dos_partition_t *) (buffer + DOS_PART_TBL_OFFSET);
	for (i = 0; i < 4; i++, pt++) {
		if (is_extended (pt->sys_ind)) {
3480f878:	e5d30004 	ldrb	r0, [r3, #4]
3480f87c:	e50b3024 	str	r3, [fp, #-36]	; 0x24
3480f880:	ebfffeef 	bl	3480f444 <is_extended>
3480f884:	e3500000 	cmp	r0, #0
3480f888:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
3480f88c:	0a00000c 	beq	3480f8c4 <get_partition_info_extended.clone.1+0x228>
			int lba_start = le32_to_int (pt->start4) + relative;
3480f890:	e2830008 	add	r0, r3, #8
3480f894:	ebfffee1 	bl	3480f420 <le32_to_int>

			return get_partition_info_extended (dev_desc, lba_start,
3480f898:	e59b3004 	ldr	r3, [fp, #4]

	/* Follows the extended partitions */
	pt = (dos_partition_t *) (buffer + DOS_PART_TBL_OFFSET);
	for (i = 0; i < 4; i++, pt++) {
		if (is_extended (pt->sys_ind)) {
			int lba_start = le32_to_int (pt->start4) + relative;
3480f89c:	e0801009 	add	r1, r0, r9

			return get_partition_info_extended (dev_desc, lba_start,
3480f8a0:	e35a0000 	cmp	sl, #0
3480f8a4:	e58d3000 	str	r3, [sp]
3480f8a8:	e1a00005 	mov	r0, r5
3480f8ac:	11a02009 	movne	r2, r9
3480f8b0:	01a02001 	moveq	r2, r1
3480f8b4:	e1a03006 	mov	r3, r6
3480f8b8:	e58d7004 	str	r7, [sp, #4]
3480f8bc:	ebffff76 	bl	3480f69c <get_partition_info_extended.clone.1>
3480f8c0:	ea000004 	b	3480f8d8 <get_partition_info_extended.clone.1+0x23c>
		}
	}

	/* Follows the extended partitions */
	pt = (dos_partition_t *) (buffer + DOS_PART_TBL_OFFSET);
	for (i = 0; i < 4; i++, pt++) {
3480f8c4:	e51b1020 	ldr	r1, [fp, #-32]
3480f8c8:	e1530001 	cmp	r3, r1
3480f8cc:	12833010 	addne	r3, r3, #16
3480f8d0:	1affffe8 	bne	3480f878 <get_partition_info_extended.clone.1+0x1dc>
			return get_partition_info_extended (dev_desc, lba_start,
				 ext_part_sector == 0 ? lba_start : relative,
				 part_num, which_part, info, disksig);
		}
	}
	return -1;
3480f8d4:	e3e00000 	mvn	r0, #0
}
3480f8d8:	e24bd01c 	sub	sp, fp, #28
3480f8dc:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
3480f8e0:	34826c4d 	.word	0x34826c4d
3480f8e4:	34826c78 	.word	0x34826c78
3480f8e8:	34826cb5 	.word	0x34826cb5
3480f8ec:	34826cbc 	.word	0x34826cbc
3480f8f0:	34826cc3 	.word	0x34826cc3
3480f8f4:	34826ccc 	.word	0x34826ccc
3480f8f8:	34826cd5 	.word	0x34826cd5
3480f8fc:	348267c7 	.word	0x348267c7

3480f900 <test_part_dos>:
	return DOS_MBR;	    /* Is MBR */
}


int test_part_dos (block_dev_desc_t *dev_desc)
{
3480f900:	e92d4818 	push	{r3, r4, fp, lr}
	ALLOC_CACHE_ALIGN_BUFFER(unsigned char, buffer, dev_desc->blksz);
3480f904:	e5903014 	ldr	r3, [r0, #20]
	return DOS_MBR;	    /* Is MBR */
}


int test_part_dos (block_dev_desc_t *dev_desc)
{
3480f908:	e28db00c 	add	fp, sp, #12
	ALLOC_CACHE_ALIGN_BUFFER(unsigned char, buffer, dev_desc->blksz);
3480f90c:	e283303f 	add	r3, r3, #63	; 0x3f
3480f910:	e3c3303f 	bic	r3, r3, #63	; 0x3f
3480f914:	e2833048 	add	r3, r3, #72	; 0x48
3480f918:	e04dd003 	sub	sp, sp, r3
3480f91c:	e28d403f 	add	r4, sp, #63	; 0x3f
3480f920:	e3c4403f 	bic	r4, r4, #63	; 0x3f

	if (dev_desc->block_read(dev_desc->dev, 0, 1, (ulong *) buffer) != 1)
3480f924:	e590c060 	ldr	ip, [r0, #96]	; 0x60
3480f928:	e3a01000 	mov	r1, #0
3480f92c:	e5900004 	ldr	r0, [r0, #4]
3480f930:	e3a02001 	mov	r2, #1
3480f934:	e1a03004 	mov	r3, r4
3480f938:	e12fff3c 	blx	ip
3480f93c:	e3500001 	cmp	r0, #1
		return -1;
3480f940:	13e00000 	mvnne	r0, #0

int test_part_dos (block_dev_desc_t *dev_desc)
{
	ALLOC_CACHE_ALIGN_BUFFER(unsigned char, buffer, dev_desc->blksz);

	if (dev_desc->block_read(dev_desc->dev, 0, 1, (ulong *) buffer) != 1)
3480f944:	1a000003 	bne	3480f958 <test_part_dos+0x58>
		return -1;

	if (test_block_type(buffer) != DOS_MBR)
3480f948:	e1a00004 	mov	r0, r4
3480f94c:	ebfffec5 	bl	3480f468 <test_block_type>
3480f950:	e3500000 	cmp	r0, #0
		return -1;
3480f954:	13e00000 	mvnne	r0, #0

	return 0;
}
3480f958:	e24bd00c 	sub	sp, fp, #12
3480f95c:	e8bd8818 	pop	{r3, r4, fp, pc}

3480f960 <print_part_dos>:
	}
	return -1;
}

void print_part_dos (block_dev_desc_t *dev_desc)
{
3480f960:	e92d4010 	push	{r4, lr}
3480f964:	e1a04000 	mov	r4, r0
	printf ("Partition     Start Sector     Num Sectors     Type\n");
3480f968:	e59f0018 	ldr	r0, [pc, #24]	; 3480f988 <print_part_dos+0x28>
3480f96c:	ebffe576 	bl	34808f4c <printf>
	print_partition_extended (dev_desc, 0, 0, 1);
3480f970:	e3a01000 	mov	r1, #0
3480f974:	e1a00004 	mov	r0, r4
3480f978:	e1a02001 	mov	r2, r1
3480f97c:	e3a03001 	mov	r3, #1
}
3480f980:	e8bd4010 	pop	{r4, lr}
}

void print_part_dos (block_dev_desc_t *dev_desc)
{
	printf ("Partition     Start Sector     Num Sectors     Type\n");
	print_partition_extended (dev_desc, 0, 0, 1);
3480f984:	eafffed2 	b	3480f4d4 <print_partition_extended>
3480f988:	34826cdc 	.word	0x34826cdc

3480f98c <get_partition_info_dos>:
}

int get_partition_info_dos (block_dev_desc_t *dev_desc, int part, disk_partition_t * info)
{
3480f98c:	e92d4007 	push	{r0, r1, r2, lr}
	return get_partition_info_extended(dev_desc, 0, 0, 1, part, info, 0);
3480f990:	e58d1000 	str	r1, [sp]
3480f994:	e3a01000 	mov	r1, #0
3480f998:	e58d2004 	str	r2, [sp, #4]
3480f99c:	e3a03001 	mov	r3, #1
3480f9a0:	e1a02001 	mov	r2, r1
3480f9a4:	ebffff3c 	bl	3480f69c <get_partition_info_extended.clone.1>
}
3480f9a8:	e8bd800e 	pop	{r1, r2, r3, pc}

3480f9ac <s5p_gpio_cfg_pin>:

void s5p_gpio_cfg_pin(struct s5p_gpio_bank *bank, int gpio, int cfg)
{
	unsigned int value;

	value = readl(&bank->con);
3480f9ac:	e5903000 	ldr	r3, [r0]
	value &= ~CON_MASK(gpio);
3480f9b0:	e3a0c00f 	mov	ip, #15
3480f9b4:	e1a01101 	lsl	r1, r1, #2
3480f9b8:	e1c3311c 	bic	r3, r3, ip, lsl r1
	value |= CON_SFR(gpio, cfg);
3480f9bc:	e1831112 	orr	r1, r3, r2, lsl r1
	writel(value, &bank->con);
3480f9c0:	e5801000 	str	r1, [r0]
}
3480f9c4:	e12fff1e 	bx	lr

3480f9c8 <s5p_gpio_direction_output>:

void s5p_gpio_direction_output(struct s5p_gpio_bank *bank, int gpio, int en)
{
3480f9c8:	e92d4070 	push	{r4, r5, r6, lr}
3480f9cc:	e1a04000 	mov	r4, r0
3480f9d0:	e1a05002 	mov	r5, r2
	unsigned int value;

	s5p_gpio_cfg_pin(bank, gpio, GPIO_OUTPUT);
3480f9d4:	e3a02001 	mov	r2, #1
	value |= CON_SFR(gpio, cfg);
	writel(value, &bank->con);
}

void s5p_gpio_direction_output(struct s5p_gpio_bank *bank, int gpio, int en)
{
3480f9d8:	e1a06001 	mov	r6, r1
	unsigned int value;

	s5p_gpio_cfg_pin(bank, gpio, GPIO_OUTPUT);
3480f9dc:	ebfffff2 	bl	3480f9ac <s5p_gpio_cfg_pin>

	value = readl(&bank->dat);
3480f9e0:	e5943004 	ldr	r3, [r4, #4]
	value &= ~DAT_MASK(gpio);
3480f9e4:	e3a02001 	mov	r2, #1
3480f9e8:	e1a06612 	lsl	r6, r2, r6
	if (en)
3480f9ec:	e3550000 	cmp	r5, #0
	unsigned int value;

	s5p_gpio_cfg_pin(bank, gpio, GPIO_OUTPUT);

	value = readl(&bank->dat);
	value &= ~DAT_MASK(gpio);
3480f9f0:	e1c33006 	bic	r3, r3, r6
	if (en)
		value |= DAT_SET(gpio);
3480f9f4:	11833006 	orrne	r3, r3, r6
	writel(value, &bank->dat);
3480f9f8:	e5843004 	str	r3, [r4, #4]
}
3480f9fc:	e8bd8070 	pop	{r4, r5, r6, pc}

3480fa00 <s5p_gpio_direction_input>:

void s5p_gpio_direction_input(struct s5p_gpio_bank *bank, int gpio)
{
	s5p_gpio_cfg_pin(bank, gpio, GPIO_INPUT);
3480fa00:	e3a02000 	mov	r2, #0
3480fa04:	eaffffe8 	b	3480f9ac <s5p_gpio_cfg_pin>

3480fa08 <s5p_gpio_set_value>:

void s5p_gpio_set_value(struct s5p_gpio_bank *bank, int gpio, int en)
{
	unsigned int value;

	value = readl(&bank->dat);
3480fa08:	e5903004 	ldr	r3, [r0, #4]
	value &= ~DAT_MASK(gpio);
3480fa0c:	e3a0c001 	mov	ip, #1
3480fa10:	e1a0111c 	lsl	r1, ip, r1
	if (en)
3480fa14:	e3520000 	cmp	r2, #0
void s5p_gpio_set_value(struct s5p_gpio_bank *bank, int gpio, int en)
{
	unsigned int value;

	value = readl(&bank->dat);
	value &= ~DAT_MASK(gpio);
3480fa18:	e1c33001 	bic	r3, r3, r1
	if (en)
		value |= DAT_SET(gpio);
3480fa1c:	11833001 	orrne	r3, r3, r1
	writel(value, &bank->dat);
3480fa20:	e5803004 	str	r3, [r0, #4]
}
3480fa24:	e12fff1e 	bx	lr

3480fa28 <s5p_gpio_get_value>:

unsigned int s5p_gpio_get_value(struct s5p_gpio_bank *bank, int gpio)
{
	unsigned int value;

	value = readl(&bank->dat);
3480fa28:	e5903004 	ldr	r3, [r0, #4]
	return !!(value & DAT_MASK(gpio));
3480fa2c:	e3a02001 	mov	r2, #1
3480fa30:	e0132112 	ands	r2, r3, r2, lsl r1
}
3480fa34:	03a00000 	moveq	r0, #0
3480fa38:	13a00001 	movne	r0, #1
3480fa3c:	e12fff1e 	bx	lr

3480fa40 <s5p_gpio_set_pull>:

void s5p_gpio_set_pull(struct s5p_gpio_bank *bank, int gpio, int mode)
{
	unsigned int value;

	value = readl(&bank->pull);
3480fa40:	e5903008 	ldr	r3, [r0, #8]
	value &= ~PULL_MASK(gpio);
3480fa44:	e3a0c003 	mov	ip, #3
3480fa48:	e1a01081 	lsl	r1, r1, #1
3480fa4c:	e1c3311c 	bic	r3, r3, ip, lsl r1

	switch (mode) {
3480fa50:	e242c001 	sub	ip, r2, #1
3480fa54:	e35c0001 	cmp	ip, #1
	case GPIO_PULL_DOWN:
	case GPIO_PULL_UP:
		value |= PULL_MODE(gpio, mode);
3480fa58:	91833112 	orrls	r3, r3, r2, lsl r1
		break;
	default:
		break;
	}

	writel(value, &bank->pull);
3480fa5c:	e5803008 	str	r3, [r0, #8]
}
3480fa60:	e12fff1e 	bx	lr

3480fa64 <s5p_gpio_set_drv>:

void s5p_gpio_set_drv(struct s5p_gpio_bank *bank, int gpio, int mode)
{
	unsigned int value;

	value = readl(&bank->drv);
3480fa64:	e590300c 	ldr	r3, [r0, #12]
	value &= ~DRV_MASK(gpio);

	switch (mode) {
3480fa68:	e3520003 	cmp	r2, #3
3480fa6c:	812fff1e 	bxhi	lr
void s5p_gpio_set_drv(struct s5p_gpio_bank *bank, int gpio, int mode)
{
	unsigned int value;

	value = readl(&bank->drv);
	value &= ~DRV_MASK(gpio);
3480fa70:	e1a01081 	lsl	r1, r1, #1
3480fa74:	e3a0c003 	mov	ip, #3
3480fa78:	e1c3311c 	bic	r3, r3, ip, lsl r1
	switch (mode) {
	case GPIO_DRV_1X:
	case GPIO_DRV_2X:
	case GPIO_DRV_3X:
	case GPIO_DRV_4X:
		value |= DRV_SET(gpio, mode);
3480fa7c:	e1831112 	orr	r1, r3, r2, lsl r1
		break;
	default:
		return;
	}

	writel(value, &bank->drv);
3480fa80:	e580100c 	str	r1, [r0, #12]
3480fa84:	e12fff1e 	bx	lr

3480fa88 <s5p_gpio_set_rate>:

void s5p_gpio_set_rate(struct s5p_gpio_bank *bank, int gpio, int mode)
{
	unsigned int value;

	value = readl(&bank->drv);
3480fa88:	e590300c 	ldr	r3, [r0, #12]
	value &= ~RATE_MASK(gpio);

	switch (mode) {
3480fa8c:	e3520001 	cmp	r2, #1
3480fa90:	812fff1e 	bxhi	lr
void s5p_gpio_set_rate(struct s5p_gpio_bank *bank, int gpio, int mode)
{
	unsigned int value;

	value = readl(&bank->drv);
	value &= ~RATE_MASK(gpio);
3480fa94:	e3a02001 	mov	r2, #1
3480fa98:	e2811010 	add	r1, r1, #16
3480fa9c:	e1a01112 	lsl	r1, r2, r1
3480faa0:	e1c33001 	bic	r3, r3, r1

	switch (mode) {
	case GPIO_DRV_FAST:
	case GPIO_DRV_SLOW:
		value |= RATE_SET(gpio);
3480faa4:	e1831001 	orr	r1, r3, r1
		break;
	default:
		return;
	}

	writel(value, &bank->drv);
3480faa8:	e580100c 	str	r1, [r0, #12]
3480faac:	e12fff1e 	bx	lr

3480fab0 <s5p_gpio_get_bank>:
}

struct s5p_gpio_bank *s5p_gpio_get_bank(unsigned gpio)
{
	int bank = gpio / GPIO_PER_BANK;
3480fab0:	e1a001a0 	lsr	r0, r0, #3
	bank *= sizeof(struct s5p_gpio_bank);
3480fab4:	e1a00280 	lsl	r0, r0, #5

	return (struct s5p_gpio_bank *) (s5p_gpio_base(gpio) + bank);
3480fab8:	e280020e 	add	r0, r0, #-536870912	; 0xe0000000
}
3480fabc:	e2800602 	add	r0, r0, #2097152	; 0x200000
3480fac0:	e12fff1e 	bx	lr

3480fac4 <s5p_gpio_get_pin>:

int s5p_gpio_get_pin(unsigned gpio)
{
	return gpio % GPIO_PER_BANK;
}
3480fac4:	e2000007 	and	r0, r0, #7
3480fac8:	e12fff1e 	bx	lr

3480facc <gpio_request>:
/* Common GPIO API */

int gpio_request(unsigned gpio, const char *label)
{
	return 0;
}
3480facc:	e3a00000 	mov	r0, #0
3480fad0:	e12fff1e 	bx	lr

3480fad4 <gpio_free>:

int gpio_free(unsigned gpio)
{
	return 0;
}
3480fad4:	e3a00000 	mov	r0, #0
3480fad8:	e12fff1e 	bx	lr

3480fadc <gpio_direction_input>:

int gpio_direction_input(unsigned gpio)
{
3480fadc:	e1a01000 	mov	r1, r0
	writel(value, &bank->drv);
}

struct s5p_gpio_bank *s5p_gpio_get_bank(unsigned gpio)
{
	int bank = gpio / GPIO_PER_BANK;
3480fae0:	e1a001a0 	lsr	r0, r0, #3
	bank *= sizeof(struct s5p_gpio_bank);
3480fae4:	e1a00280 	lsl	r0, r0, #5

	return (struct s5p_gpio_bank *) (s5p_gpio_base(gpio) + bank);
3480fae8:	e280020e 	add	r0, r0, #-536870912	; 0xe0000000
{
	return 0;
}

int gpio_direction_input(unsigned gpio)
{
3480faec:	e92d4008 	push	{r3, lr}
	s5p_gpio_direction_input(s5p_gpio_get_bank(gpio),
3480faf0:	e2800602 	add	r0, r0, #2097152	; 0x200000
3480faf4:	e2011007 	and	r1, r1, #7
3480faf8:	ebffffc0 	bl	3480fa00 <s5p_gpio_direction_input>
				s5p_gpio_get_pin(gpio));
	return 0;
}
3480fafc:	e3a00000 	mov	r0, #0
3480fb00:	e8bd8008 	pop	{r3, pc}

3480fb04 <gpio_direction_output>:

int gpio_direction_output(unsigned gpio, int value)
{
3480fb04:	e92d4008 	push	{r3, lr}
3480fb08:	e1a03000 	mov	r3, r0
	writel(value, &bank->drv);
}

struct s5p_gpio_bank *s5p_gpio_get_bank(unsigned gpio)
{
	int bank = gpio / GPIO_PER_BANK;
3480fb0c:	e1a001a0 	lsr	r0, r0, #3
	bank *= sizeof(struct s5p_gpio_bank);
3480fb10:	e1a00280 	lsl	r0, r0, #5

	return (struct s5p_gpio_bank *) (s5p_gpio_base(gpio) + bank);
3480fb14:	e280020e 	add	r0, r0, #-536870912	; 0xe0000000
				s5p_gpio_get_pin(gpio));
	return 0;
}

int gpio_direction_output(unsigned gpio, int value)
{
3480fb18:	e1a02001 	mov	r2, r1
	s5p_gpio_direction_output(s5p_gpio_get_bank(gpio),
3480fb1c:	e2800602 	add	r0, r0, #2097152	; 0x200000
3480fb20:	e2031007 	and	r1, r3, #7
3480fb24:	ebffffa7 	bl	3480f9c8 <s5p_gpio_direction_output>
				 s5p_gpio_get_pin(gpio), value);
	return 0;
}
3480fb28:	e3a00000 	mov	r0, #0
3480fb2c:	e8bd8008 	pop	{r3, pc}

3480fb30 <gpio_get_value>:
	writel(value, &bank->drv);
}

struct s5p_gpio_bank *s5p_gpio_get_bank(unsigned gpio)
{
	int bank = gpio / GPIO_PER_BANK;
3480fb30:	e1a031a0 	lsr	r3, r0, #3

unsigned int s5p_gpio_get_value(struct s5p_gpio_bank *bank, int gpio)
{
	unsigned int value;

	value = readl(&bank->dat);
3480fb34:	e1a03283 	lsl	r3, r3, #5
3480fb38:	e283320e 	add	r3, r3, #-536870912	; 0xe0000000
3480fb3c:	e2833602 	add	r3, r3, #2097152	; 0x200000
3480fb40:	e5933004 	ldr	r3, [r3, #4]
	return 0;
}

int gpio_get_value(unsigned gpio)
{
	return (int) s5p_gpio_get_value(s5p_gpio_get_bank(gpio),
3480fb44:	e3a02001 	mov	r2, #1
	return (struct s5p_gpio_bank *) (s5p_gpio_base(gpio) + bank);
}

int s5p_gpio_get_pin(unsigned gpio)
{
	return gpio % GPIO_PER_BANK;
3480fb48:	e2000007 	and	r0, r0, #7
	return 0;
}

int gpio_get_value(unsigned gpio)
{
	return (int) s5p_gpio_get_value(s5p_gpio_get_bank(gpio),
3480fb4c:	e0132012 	ands	r2, r3, r2, lsl r0
				       s5p_gpio_get_pin(gpio));
}
3480fb50:	03a00000 	moveq	r0, #0
3480fb54:	13a00001 	movne	r0, #1
3480fb58:	e12fff1e 	bx	lr

3480fb5c <gpio_set_value>:

int gpio_set_value(unsigned gpio, int value)
{
3480fb5c:	e92d4008 	push	{r3, lr}
3480fb60:	e1a03000 	mov	r3, r0
	writel(value, &bank->drv);
}

struct s5p_gpio_bank *s5p_gpio_get_bank(unsigned gpio)
{
	int bank = gpio / GPIO_PER_BANK;
3480fb64:	e1a001a0 	lsr	r0, r0, #3
	bank *= sizeof(struct s5p_gpio_bank);
3480fb68:	e1a00280 	lsl	r0, r0, #5

	return (struct s5p_gpio_bank *) (s5p_gpio_base(gpio) + bank);
3480fb6c:	e280020e 	add	r0, r0, #-536870912	; 0xe0000000
	return (int) s5p_gpio_get_value(s5p_gpio_get_bank(gpio),
				       s5p_gpio_get_pin(gpio));
}

int gpio_set_value(unsigned gpio, int value)
{
3480fb70:	e1a02001 	mov	r2, r1
	s5p_gpio_set_value(s5p_gpio_get_bank(gpio),
3480fb74:	e2800602 	add	r0, r0, #2097152	; 0x200000
3480fb78:	e2031007 	and	r1, r3, #7
3480fb7c:	ebffffa1 	bl	3480fa08 <s5p_gpio_set_value>
			  s5p_gpio_get_pin(gpio), value);

	return 0;
}
3480fb80:	e3a00000 	mov	r0, #0
3480fb84:	e8bd8008 	pop	{r3, pc}

3480fb88 <send_start>:

/*-----------------------------------------------------------------------
 * START: High -> Low on SDA while SCL is High
 */
static void send_start(void)
{
3480fb88:	e92d4010 	push	{r4, lr}
	I2C_SOFT_DECLARATIONS	/* intentional without ';' */

	I2C_DELAY;
3480fb8c:	e3a00005 	mov	r0, #5
3480fb90:	eb002549 	bl	348190bc <udelay>
	I2C_SDA(1);
3480fb94:	e3a000b0 	mov	r0, #176	; 0xb0
3480fb98:	ebffffcf 	bl	3480fadc <gpio_direction_input>
	I2C_ACTIVE;
	I2C_DELAY;
3480fb9c:	e3a00005 	mov	r0, #5
3480fba0:	eb002545 	bl	348190bc <udelay>
	I2C_SCL(1);
3480fba4:	e3a01001 	mov	r1, #1
3480fba8:	e3a000b3 	mov	r0, #179	; 0xb3
3480fbac:	ebffffd4 	bl	3480fb04 <gpio_direction_output>
	I2C_DELAY;
3480fbb0:	e3a00005 	mov	r0, #5
3480fbb4:	eb002540 	bl	348190bc <udelay>
	I2C_SDA(0);
3480fbb8:	e3a01000 	mov	r1, #0
3480fbbc:	e3a000b0 	mov	r0, #176	; 0xb0
3480fbc0:	ebffffcf 	bl	3480fb04 <gpio_direction_output>
	I2C_DELAY;
3480fbc4:	e3a00005 	mov	r0, #5
}
3480fbc8:	e8bd4010 	pop	{r4, lr}
	I2C_ACTIVE;
	I2C_DELAY;
	I2C_SCL(1);
	I2C_DELAY;
	I2C_SDA(0);
	I2C_DELAY;
3480fbcc:	ea00253a 	b	348190bc <udelay>

3480fbd0 <send_stop>:

/*-----------------------------------------------------------------------
 * STOP: Low -> High on SDA while SCL is High
 */
static void send_stop(void)
{
3480fbd0:	e92d4010 	push	{r4, lr}
	I2C_SOFT_DECLARATIONS	/* intentional without ';' */

	I2C_SCL(0);
3480fbd4:	e3a01000 	mov	r1, #0
3480fbd8:	e3a000b3 	mov	r0, #179	; 0xb3
3480fbdc:	ebffffc8 	bl	3480fb04 <gpio_direction_output>
	I2C_DELAY;
3480fbe0:	e3a00005 	mov	r0, #5
3480fbe4:	eb002534 	bl	348190bc <udelay>
	I2C_SDA(0);
3480fbe8:	e3a01000 	mov	r1, #0
3480fbec:	e3a000b0 	mov	r0, #176	; 0xb0
3480fbf0:	ebffffc3 	bl	3480fb04 <gpio_direction_output>
	I2C_ACTIVE;
	I2C_DELAY;
3480fbf4:	e3a00005 	mov	r0, #5
3480fbf8:	eb00252f 	bl	348190bc <udelay>
	I2C_SCL(1);
3480fbfc:	e3a01001 	mov	r1, #1
3480fc00:	e3a000b3 	mov	r0, #179	; 0xb3
3480fc04:	ebffffbe 	bl	3480fb04 <gpio_direction_output>
	I2C_DELAY;
3480fc08:	e3a00005 	mov	r0, #5
3480fc0c:	eb00252a 	bl	348190bc <udelay>
	I2C_SDA(1);
3480fc10:	e3a000b0 	mov	r0, #176	; 0xb0
3480fc14:	ebffffb0 	bl	3480fadc <gpio_direction_input>
	I2C_DELAY;
3480fc18:	e3a00005 	mov	r0, #5
	I2C_TRISTATE;
}
3480fc1c:	e8bd4010 	pop	{r4, lr}
	I2C_ACTIVE;
	I2C_DELAY;
	I2C_SCL(1);
	I2C_DELAY;
	I2C_SDA(1);
	I2C_DELAY;
3480fc20:	ea002525 	b	348190bc <udelay>

3480fc24 <write_byte>:

/*-----------------------------------------------------------------------
 * Send 8 bits and look for an acknowledgement.
 */
static int write_byte(uchar data)
{
3480fc24:	e92d4038 	push	{r3, r4, r5, lr}
3480fc28:	e1a05000 	mov	r5, r0
3480fc2c:	e3a04008 	mov	r4, #8
	int j;
	int nack;

	I2C_ACTIVE;
	for(j = 0; j < 8; j++) {
		I2C_SCL(0);
3480fc30:	e3a01000 	mov	r1, #0
3480fc34:	e3a000b3 	mov	r0, #179	; 0xb3
3480fc38:	ebffffb1 	bl	3480fb04 <gpio_direction_output>
		I2C_DELAY;
3480fc3c:	e3a00005 	mov	r0, #5
3480fc40:	eb00251d 	bl	348190bc <udelay>
		I2C_SDA(data & 0x80);
3480fc44:	e3150080 	tst	r5, #128	; 0x80
3480fc48:	0a000002 	beq	3480fc58 <write_byte+0x34>
3480fc4c:	e3a000b0 	mov	r0, #176	; 0xb0
3480fc50:	ebffffa1 	bl	3480fadc <gpio_direction_input>
3480fc54:	ea000002 	b	3480fc64 <write_byte+0x40>
3480fc58:	e3a000b0 	mov	r0, #176	; 0xb0
3480fc5c:	e3a01000 	mov	r1, #0
3480fc60:	ebffffa7 	bl	3480fb04 <gpio_direction_output>
		I2C_DELAY;
3480fc64:	e3a00005 	mov	r0, #5
3480fc68:	eb002513 	bl	348190bc <udelay>
		I2C_SCL(1);
3480fc6c:	e3a01001 	mov	r1, #1
3480fc70:	e3a000b3 	mov	r0, #179	; 0xb3
3480fc74:	ebffffa2 	bl	3480fb04 <gpio_direction_output>
		I2C_DELAY;
3480fc78:	e3a00005 	mov	r0, #5
3480fc7c:	eb00250e 	bl	348190bc <udelay>
		I2C_DELAY;
3480fc80:	e3a00005 	mov	r0, #5
3480fc84:	eb00250c 	bl	348190bc <udelay>
	I2C_SOFT_DECLARATIONS	/* intentional without ';' */
	int j;
	int nack;

	I2C_ACTIVE;
	for(j = 0; j < 8; j++) {
3480fc88:	e2544001 	subs	r4, r4, #1
		I2C_DELAY;
		I2C_SCL(1);
		I2C_DELAY;
		I2C_DELAY;

		data <<= 1;
3480fc8c:	11a05085 	lslne	r5, r5, #1
3480fc90:	16ef5075 	uxtbne	r5, r5
3480fc94:	1affffe5 	bne	3480fc30 <write_byte+0xc>
	}

	/*
	 * Look for an <ACK>(negative logic) and return it.
	 */
	I2C_SCL(0);
3480fc98:	e1a01004 	mov	r1, r4
3480fc9c:	e3a000b3 	mov	r0, #179	; 0xb3
3480fca0:	ebffff97 	bl	3480fb04 <gpio_direction_output>
	I2C_DELAY;
3480fca4:	e3a00005 	mov	r0, #5
3480fca8:	eb002503 	bl	348190bc <udelay>
	I2C_SDA(1);
3480fcac:	e3a000b0 	mov	r0, #176	; 0xb0
3480fcb0:	ebffff89 	bl	3480fadc <gpio_direction_input>
	I2C_TRISTATE;
	I2C_DELAY;
3480fcb4:	e3a00005 	mov	r0, #5
3480fcb8:	eb0024ff 	bl	348190bc <udelay>
	I2C_SCL(1);
3480fcbc:	e3a01001 	mov	r1, #1
3480fcc0:	e3a000b3 	mov	r0, #179	; 0xb3
3480fcc4:	ebffff8e 	bl	3480fb04 <gpio_direction_output>
	I2C_DELAY;
3480fcc8:	e3a00005 	mov	r0, #5
3480fccc:	eb0024fa 	bl	348190bc <udelay>
	I2C_DELAY;
3480fcd0:	e3a00005 	mov	r0, #5
3480fcd4:	eb0024f8 	bl	348190bc <udelay>
	nack = I2C_READ;
3480fcd8:	e3a000b0 	mov	r0, #176	; 0xb0
3480fcdc:	ebffff93 	bl	3480fb30 <gpio_get_value>
	I2C_SCL(0);
3480fce0:	e1a01004 	mov	r1, r4
	I2C_TRISTATE;
	I2C_DELAY;
	I2C_SCL(1);
	I2C_DELAY;
	I2C_DELAY;
	nack = I2C_READ;
3480fce4:	e1a05000 	mov	r5, r0
	I2C_SCL(0);
3480fce8:	e3a000b3 	mov	r0, #179	; 0xb3
3480fcec:	ebffff84 	bl	3480fb04 <gpio_direction_output>
	I2C_DELAY;
3480fcf0:	e3a00005 	mov	r0, #5
3480fcf4:	eb0024f0 	bl	348190bc <udelay>
	I2C_ACTIVE;

	return(nack);	/* not a nack is an ack */
}
3480fcf8:	e1a00005 	mov	r0, r5
3480fcfc:	e8bd8038 	pop	{r3, r4, r5, pc}

3480fd00 <i2c_get_bus_num>:
 * Functions for multiple I2C bus handling
 */
unsigned int i2c_get_bus_num(void)
{
	return i2c_bus_num;
}
3480fd00:	e59f3004 	ldr	r3, [pc, #4]	; 3480fd0c <i2c_get_bus_num+0xc>
3480fd04:	e5930000 	ldr	r0, [r3]
3480fd08:	e12fff1e 	bx	lr
3480fd0c:	34828880 	.word	0x34828880

3480fd10 <i2c_set_bus_num>:
			i2c_bus_num = bus;
		else
			return ret;
	}
#else
	if (bus >= CONFIG_SYS_MAX_I2C_BUS)
3480fd10:	e3500006 	cmp	r0, #6
		return -1;
	i2c_bus_num = bus;
3480fd14:	959f300c 	ldrls	r3, [pc, #12]	; 3480fd28 <i2c_set_bus_num+0x18>
		else
			return ret;
	}
#else
	if (bus >= CONFIG_SYS_MAX_I2C_BUS)
		return -1;
3480fd18:	83e00000 	mvnhi	r0, #0
	i2c_bus_num = bus;
3480fd1c:	95830000 	strls	r0, [r3]
#endif
	return 0;
3480fd20:	93a00000 	movls	r0, #0
}
3480fd24:	e12fff1e 	bx	lr
3480fd28:	34828880 	.word	0x34828880

3480fd2c <i2c_init>:

/*-----------------------------------------------------------------------
 * Initialization
 */
void i2c_init (int speed, int slaveaddr)
{
3480fd2c:	e92d4010 	push	{r4, lr}
static void send_reset(void)
{
	I2C_SOFT_DECLARATIONS	/* intentional without ';' */
	int j;

	I2C_SCL(1);
3480fd30:	e3a01001 	mov	r1, #1
3480fd34:	e3a000b3 	mov	r0, #179	; 0xb3
3480fd38:	ebffff71 	bl	3480fb04 <gpio_direction_output>
	I2C_SDA(1);
3480fd3c:	e3a000b0 	mov	r0, #176	; 0xb0
3480fd40:	ebffff65 	bl	3480fadc <gpio_direction_input>
#ifdef	I2C_INIT
	I2C_INIT;
3480fd44:	e59f105c 	ldr	r1, [pc, #92]	; 3480fda8 <i2c_init+0x7c>
3480fd48:	e3a000b3 	mov	r0, #179	; 0xb3
3480fd4c:	ebffff5e 	bl	3480facc <gpio_request>
3480fd50:	e3a000b0 	mov	r0, #176	; 0xb0
3480fd54:	e59f104c 	ldr	r1, [pc, #76]	; 3480fda8 <i2c_init+0x7c>
3480fd58:	ebffff5b 	bl	3480facc <gpio_request>
3480fd5c:	e3a04009 	mov	r4, #9
#endif
	I2C_TRISTATE;
	for(j = 0; j < 9; j++) {
		I2C_SCL(0);
3480fd60:	e3a01000 	mov	r1, #0
3480fd64:	e3a000b3 	mov	r0, #179	; 0xb3
3480fd68:	ebffff65 	bl	3480fb04 <gpio_direction_output>
		I2C_DELAY;
3480fd6c:	e3a00005 	mov	r0, #5
3480fd70:	eb0024d1 	bl	348190bc <udelay>
		I2C_DELAY;
3480fd74:	e3a00005 	mov	r0, #5
3480fd78:	eb0024cf 	bl	348190bc <udelay>
		I2C_SCL(1);
3480fd7c:	e3a01001 	mov	r1, #1
3480fd80:	e3a000b3 	mov	r0, #179	; 0xb3
3480fd84:	ebffff5e 	bl	3480fb04 <gpio_direction_output>
		I2C_DELAY;
3480fd88:	e3a00005 	mov	r0, #5
3480fd8c:	eb0024ca 	bl	348190bc <udelay>
		I2C_DELAY;
3480fd90:	e3a00005 	mov	r0, #5
3480fd94:	eb0024c8 	bl	348190bc <udelay>
	I2C_SDA(1);
#ifdef	I2C_INIT
	I2C_INIT;
#endif
	I2C_TRISTATE;
	for(j = 0; j < 9; j++) {
3480fd98:	e2544001 	subs	r4, r4, #1
3480fd9c:	1affffef 	bne	3480fd60 <i2c_init+0x34>
	 * the DIMM SPD, for instance), RAM won't be usable and your
	 * system will crash.
	 */
	send_reset ();
#endif
}
3480fda0:	e8bd4010 	pop	{r4, lr}
		I2C_DELAY;
		I2C_SCL(1);
		I2C_DELAY;
		I2C_DELAY;
	}
	send_stop();
3480fda4:	eaffff89 	b	3480fbd0 <send_stop>
3480fda8:	34826d11 	.word	0x34826d11

3480fdac <i2c_probe>:
 * Probe to see if a chip is present.  Also good for checking for the
 * completion of EEPROM writes since the chip stops responding until
 * the write completes (typically 10mSec).
 */
int i2c_probe(uchar addr)
{
3480fdac:	e92d4010 	push	{r4, lr}
3480fdb0:	e1a04000 	mov	r4, r0

	/*
	 * perform 1 byte write transaction with just address byte
	 * (fake write)
	 */
	send_start();
3480fdb4:	ebffff73 	bl	3480fb88 <send_start>
	rc = write_byte ((addr << 1) | 0);
3480fdb8:	e1a00084 	lsl	r0, r4, #1
3480fdbc:	e20000fe 	and	r0, r0, #254	; 0xfe
3480fdc0:	ebffff97 	bl	3480fc24 <write_byte>
3480fdc4:	e1a04000 	mov	r4, r0
	send_stop();
3480fdc8:	ebffff80 	bl	3480fbd0 <send_stop>

	return (rc ? 1 : 0);
}
3480fdcc:	e2540000 	subs	r0, r4, #0
3480fdd0:	13a00001 	movne	r0, #1
3480fdd4:	e8bd8010 	pop	{r4, pc}

3480fdd8 <i2c_read>:

/*-----------------------------------------------------------------------
 * Read bytes
 */
int  i2c_read(uchar chip, uint addr, int alen, uchar *buffer, int len)
{
3480fdd8:	e92d46f8 	push	{r3, r4, r5, r6, r7, r9, sl, lr}
3480fddc:	e1a07002 	mov	r7, r2
3480fde0:	e1a04000 	mov	r4, r0
3480fde4:	e1a05001 	mov	r5, r1
3480fde8:	e1a0a003 	mov	sl, r3
3480fdec:	e59d6020 	ldr	r6, [sp, #32]
	 * Do the addressing portion of a write cycle to set the
	 * chip's address pointer.  If the address length is zero,
	 * don't do the normal write cycle to set the address pointer,
	 * there is no address pointer in this chip.
	 */
	send_start();
3480fdf0:	ebffff64 	bl	3480fb88 <send_start>
	if(alen > 0) {
3480fdf4:	e3570000 	cmp	r7, #0
3480fdf8:	da000014 	ble	3480fe50 <i2c_read+0x78>
		if(write_byte(chip << 1)) {	/* write cycle */
3480fdfc:	e1a00084 	lsl	r0, r4, #1
3480fe00:	e20000fe 	and	r0, r0, #254	; 0xfe
3480fe04:	ebffff86 	bl	3480fc24 <write_byte>
3480fe08:	e3500000 	cmp	r0, #0
			send_stop();
			PRINTD("i2c_read, no chip responded %02X\n", chip);
			return(1);
		}
		shift = (alen-1) * 8;
3480fe0c:	02479001 	subeq	r9, r7, #1
3480fe10:	01a09189 	lsleq	r9, r9, #3
	 * don't do the normal write cycle to set the address pointer,
	 * there is no address pointer in this chip.
	 */
	send_start();
	if(alen > 0) {
		if(write_byte(chip << 1)) {	/* write cycle */
3480fe14:	0a000009 	beq	3480fe40 <i2c_read+0x68>
			send_stop();
3480fe18:	ebffff6c 	bl	3480fbd0 <send_stop>
			PRINTD("i2c_read, no chip responded %02X\n", chip);
			return(1);
3480fe1c:	e3a00001 	mov	r0, #1
3480fe20:	e8bd86f8 	pop	{r3, r4, r5, r6, r7, r9, sl, pc}
		}
		shift = (alen-1) * 8;
		while(alen-- > 0) {
			if(write_byte(addr >> shift)) {
3480fe24:	e1a00935 	lsr	r0, r5, r9
3480fe28:	e6ef0070 	uxtb	r0, r0
3480fe2c:	ebffff7c 	bl	3480fc24 <write_byte>
3480fe30:	e3500000 	cmp	r0, #0
3480fe34:	e2477001 	sub	r7, r7, #1
3480fe38:	1a000041 	bne	3480ff44 <i2c_read+0x16c>
				PRINTD("i2c_read, address not <ACK>ed\n");
				return(1);
			}
			shift -= 8;
3480fe3c:	e2499008 	sub	r9, r9, #8
			send_stop();
			PRINTD("i2c_read, no chip responded %02X\n", chip);
			return(1);
		}
		shift = (alen-1) * 8;
		while(alen-- > 0) {
3480fe40:	e3570000 	cmp	r7, #0
3480fe44:	cafffff6 	bgt	3480fe24 <i2c_read+0x4c>
		 * stop/start sequence.
		 */
#ifdef CONFIG_SOFT_I2C_READ_REPEATED_START
		send_start();
#else
		send_stop();
3480fe48:	ebffff60 	bl	3480fbd0 <send_stop>
		send_start();
3480fe4c:	ebffff4d 	bl	3480fb88 <send_start>
	/*
	 * Send the chip address again, this time for a read cycle.
	 * Then read the data.  On the last byte, we do a NACK instead
	 * of an ACK(len == 0) to terminate the read.
	 */
	write_byte((chip << 1) | 1);	/* read cycle */
3480fe50:	e1a04084 	lsl	r4, r4, #1
3480fe54:	e3840001 	orr	r0, r4, #1
3480fe58:	e6ef0070 	uxtb	r0, r0
3480fe5c:	ebffff70 	bl	3480fc24 <write_byte>
	while(len-- > 0) {
3480fe60:	ea000032 	b	3480ff30 <i2c_read+0x158>

	/*
	 * Read 8 bits, MSB first.
	 */
	I2C_TRISTATE;
	I2C_SDA(1);
3480fe64:	e3a000b0 	mov	r0, #176	; 0xb0
3480fe68:	ebffff1b 	bl	3480fadc <gpio_direction_input>
3480fe6c:	e3a04008 	mov	r4, #8
	data = 0;
3480fe70:	e3a05000 	mov	r5, #0
	for(j = 0; j < 8; j++) {
		I2C_SCL(0);
3480fe74:	e3a01000 	mov	r1, #0
3480fe78:	e3a000b3 	mov	r0, #179	; 0xb3
3480fe7c:	ebffff20 	bl	3480fb04 <gpio_direction_output>
		I2C_DELAY;
3480fe80:	e3a00005 	mov	r0, #5
3480fe84:	eb00248c 	bl	348190bc <udelay>
		I2C_SCL(1);
3480fe88:	e3a01001 	mov	r1, #1
3480fe8c:	e3a000b3 	mov	r0, #179	; 0xb3
3480fe90:	ebffff1b 	bl	3480fb04 <gpio_direction_output>
		I2C_DELAY;
3480fe94:	e3a00005 	mov	r0, #5
3480fe98:	eb002487 	bl	348190bc <udelay>
		data <<= 1;
		data |= I2C_READ;
3480fe9c:	e3a000b0 	mov	r0, #176	; 0xb0
3480fea0:	ebffff22 	bl	3480fb30 <gpio_get_value>
	for(j = 0; j < 8; j++) {
		I2C_SCL(0);
		I2C_DELAY;
		I2C_SCL(1);
		I2C_DELAY;
		data <<= 1;
3480fea4:	e1a05085 	lsl	r5, r5, #1
		data |= I2C_READ;
3480fea8:	e1855000 	orr	r5, r5, r0
		I2C_DELAY;
3480feac:	e3a00005 	mov	r0, #5
3480feb0:	eb002481 	bl	348190bc <udelay>
	 * Read 8 bits, MSB first.
	 */
	I2C_TRISTATE;
	I2C_SDA(1);
	data = 0;
	for(j = 0; j < 8; j++) {
3480feb4:	e2544001 	subs	r4, r4, #1
3480feb8:	1affffed 	bne	3480fe74 <i2c_read+0x9c>
 */
static void send_ack(int ack)
{
	I2C_SOFT_DECLARATIONS	/* intentional without ';' */

	I2C_SCL(0);
3480febc:	e1a01004 	mov	r1, r4
3480fec0:	e3a000b3 	mov	r0, #179	; 0xb3
3480fec4:	ebffff0e 	bl	3480fb04 <gpio_direction_output>
	 * Send the chip address again, this time for a read cycle.
	 * Then read the data.  On the last byte, we do a NACK instead
	 * of an ACK(len == 0) to terminate the read.
	 */
	write_byte((chip << 1) | 1);	/* read cycle */
	while(len-- > 0) {
3480fec8:	e2466001 	sub	r6, r6, #1
static void send_ack(int ack)
{
	I2C_SOFT_DECLARATIONS	/* intentional without ';' */

	I2C_SCL(0);
	I2C_DELAY;
3480fecc:	e3a00005 	mov	r0, #5
3480fed0:	eb002479 	bl	348190bc <udelay>
	I2C_ACTIVE;
	I2C_SDA(ack);
3480fed4:	e3560000 	cmp	r6, #0
3480fed8:	1a000002 	bne	3480fee8 <i2c_read+0x110>
3480fedc:	e3a000b0 	mov	r0, #176	; 0xb0
3480fee0:	ebfffefd 	bl	3480fadc <gpio_direction_input>
3480fee4:	ea000002 	b	3480fef4 <i2c_read+0x11c>
3480fee8:	e3a000b0 	mov	r0, #176	; 0xb0
3480feec:	e1a01004 	mov	r1, r4
3480fef0:	ebffff03 	bl	3480fb04 <gpio_direction_output>
	I2C_DELAY;
3480fef4:	e3a00005 	mov	r0, #5
3480fef8:	eb00246f 	bl	348190bc <udelay>
	I2C_SCL(1);
3480fefc:	e3a01001 	mov	r1, #1
3480ff00:	e3a000b3 	mov	r0, #179	; 0xb3
3480ff04:	ebfffefe 	bl	3480fb04 <gpio_direction_output>
	I2C_DELAY;
3480ff08:	e3a00005 	mov	r0, #5
3480ff0c:	eb00246a 	bl	348190bc <udelay>
	I2C_DELAY;
3480ff10:	e3a00005 	mov	r0, #5
3480ff14:	eb002468 	bl	348190bc <udelay>
	I2C_SCL(0);
3480ff18:	e3a01000 	mov	r1, #0
3480ff1c:	e3a000b3 	mov	r0, #179	; 0xb3
3480ff20:	ebfffef7 	bl	3480fb04 <gpio_direction_output>
	I2C_DELAY;
3480ff24:	e3a00005 	mov	r0, #5
3480ff28:	eb002463 	bl	348190bc <udelay>
		data |= I2C_READ;
		I2C_DELAY;
	}
	send_ack(ack);

	return(data);
3480ff2c:	e4ca5001 	strb	r5, [sl], #1
	 * Send the chip address again, this time for a read cycle.
	 * Then read the data.  On the last byte, we do a NACK instead
	 * of an ACK(len == 0) to terminate the read.
	 */
	write_byte((chip << 1) | 1);	/* read cycle */
	while(len-- > 0) {
3480ff30:	e3560000 	cmp	r6, #0
3480ff34:	caffffca 	bgt	3480fe64 <i2c_read+0x8c>
		*buffer++ = read_byte(len == 0);
	}
	send_stop();
3480ff38:	ebffff24 	bl	3480fbd0 <send_stop>
	return(0);
3480ff3c:	e3a00000 	mov	r0, #0
3480ff40:	e8bd86f8 	pop	{r3, r4, r5, r6, r7, r9, sl, pc}
		}
		shift = (alen-1) * 8;
		while(alen-- > 0) {
			if(write_byte(addr >> shift)) {
				PRINTD("i2c_read, address not <ACK>ed\n");
				return(1);
3480ff44:	e3a00001 	mov	r0, #1
	while(len-- > 0) {
		*buffer++ = read_byte(len == 0);
	}
	send_stop();
	return(0);
}
3480ff48:	e8bd86f8 	pop	{r3, r4, r5, r6, r7, r9, sl, pc}

3480ff4c <i2c_write>:

/*-----------------------------------------------------------------------
 * Write bytes
 */
int  i2c_write(uchar chip, uint addr, int alen, uchar *buffer, int len)
{
3480ff4c:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
3480ff50:	e1a05000 	mov	r5, r0
3480ff54:	e1a06002 	mov	r6, r2
3480ff58:	e1a04001 	mov	r4, r1
3480ff5c:	e1a07003 	mov	r7, r3
	int shift, failures = 0;

	PRINTD("i2c_write: chip %02X addr %02X alen %d buffer %p len %d\n",
		chip, addr, alen, buffer, len);

	send_start();
3480ff60:	ebffff08 	bl	3480fb88 <send_start>
	if(write_byte(chip << 1)) {	/* write cycle */
3480ff64:	e1a00085 	lsl	r0, r5, #1
3480ff68:	e20000fe 	and	r0, r0, #254	; 0xfe
3480ff6c:	ebffff2c 	bl	3480fc24 <write_byte>
3480ff70:	e3500000 	cmp	r0, #0
		send_stop();
		PRINTD("i2c_write, no chip responded %02X\n", chip);
		return(1);
	}
	shift = (alen-1) * 8;
3480ff74:	02465001 	subeq	r5, r6, #1
3480ff78:	01a05185 	lsleq	r5, r5, #3

	PRINTD("i2c_write: chip %02X addr %02X alen %d buffer %p len %d\n",
		chip, addr, alen, buffer, len);

	send_start();
	if(write_byte(chip << 1)) {	/* write cycle */
3480ff7c:	0a000008 	beq	3480ffa4 <i2c_write+0x58>
		send_stop();
3480ff80:	ebffff12 	bl	3480fbd0 <send_stop>
3480ff84:	ea000014 	b	3480ffdc <i2c_write+0x90>
		PRINTD("i2c_write, no chip responded %02X\n", chip);
		return(1);
	}
	shift = (alen-1) * 8;
	while(alen-- > 0) {
		if(write_byte(addr >> shift)) {
3480ff88:	e1a00534 	lsr	r0, r4, r5
3480ff8c:	e6ef0070 	uxtb	r0, r0
3480ff90:	ebffff23 	bl	3480fc24 <write_byte>
3480ff94:	e3500000 	cmp	r0, #0
3480ff98:	e2466001 	sub	r6, r6, #1
3480ff9c:	1a00000e 	bne	3480ffdc <i2c_write+0x90>
			PRINTD("i2c_write, address not <ACK>ed\n");
			return(1);
		}
		shift -= 8;
3480ffa0:	e2455008 	sub	r5, r5, #8
		send_stop();
		PRINTD("i2c_write, no chip responded %02X\n", chip);
		return(1);
	}
	shift = (alen-1) * 8;
	while(alen-- > 0) {
3480ffa4:	e3560000 	cmp	r6, #0
3480ffa8:	cafffff6 	bgt	3480ff88 <i2c_write+0x3c>
3480ffac:	e59d5018 	ldr	r5, [sp, #24]
3480ffb0:	e3a04000 	mov	r4, #0
3480ffb4:	ea000004 	b	3480ffcc <i2c_write+0x80>
		}
		shift -= 8;
	}

	while(len-- > 0) {
		if(write_byte(*buffer++)) {
3480ffb8:	e4d70001 	ldrb	r0, [r7], #1
3480ffbc:	ebffff18 	bl	3480fc24 <write_byte>
3480ffc0:	e3500000 	cmp	r0, #0
			failures++;
3480ffc4:	12844001 	addne	r4, r4, #1
3480ffc8:	e2455001 	sub	r5, r5, #1
			return(1);
		}
		shift -= 8;
	}

	while(len-- > 0) {
3480ffcc:	e3550000 	cmp	r5, #0
3480ffd0:	cafffff8 	bgt	3480ffb8 <i2c_write+0x6c>
		if(write_byte(*buffer++)) {
			failures++;
		}
	}
	send_stop();
3480ffd4:	ebfffefd 	bl	3480fbd0 <send_stop>
	return(failures);
3480ffd8:	ea000000 	b	3480ffe0 <i2c_write+0x94>
	}
	shift = (alen-1) * 8;
	while(alen-- > 0) {
		if(write_byte(addr >> shift)) {
			PRINTD("i2c_write, address not <ACK>ed\n");
			return(1);
3480ffdc:	e3a04001 	mov	r4, #1
			failures++;
		}
	}
	send_stop();
	return(failures);
}
3480ffe0:	e1a00004 	mov	r0, r4
3480ffe4:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}

3480ffe8 <sort_array_by_ordering>:
 * @return number of elements in dest that are in order (these will be at the
 *	start of dest).
 */
static int sort_array_by_ordering(int *dest, int count, int *order,
				   int ocount)
{
3480ffe8:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
3480ffec:	e28db01c 	add	fp, sp, #28
3480fff0:	e24dd008 	sub	sp, sp, #8
3480fff4:	e50b2020 	str	r2, [fp, #-32]
	int temp[count];
3480fff8:	e1a02101 	lsl	r2, r1, #2
 * @return number of elements in dest that are in order (these will be at the
 *	start of dest).
 */
static int sort_array_by_ordering(int *dest, int count, int *order,
				   int ocount)
{
3480fffc:	e1a09003 	mov	r9, r3
	int temp[count];
34810000:	e282300e 	add	r3, r2, #14
34810004:	e3c33007 	bic	r3, r3, #7
34810008:	e04dd003 	sub	sp, sp, r3
 * @return number of elements in dest that are in order (these will be at the
 *	start of dest).
 */
static int sort_array_by_ordering(int *dest, int count, int *order,
				   int ocount)
{
3481000c:	e1a04000 	mov	r4, r0
34810010:	e1a05001 	mov	r5, r1
	int dest_count;
	int same;	/* number of elements which are the same */
	int i;

	/* setup output items, copy items to be sorted into our temp area */
	memcpy(temp, dest, count * sizeof(*dest));
34810014:	e1a0000d 	mov	r0, sp
34810018:	e1a01004 	mov	r1, r4
3481001c:	eb00239b 	bl	34818e90 <memcpy>
	dest_count = 0;

	/* work through the ordering, move over the elements we agree on */
	for (i = 0; i < ocount; i++) {
34810020:	e3a02000 	mov	r2, #0
 *	start of dest).
 */
static int sort_array_by_ordering(int *dest, int count, int *order,
				   int ocount)
{
	int temp[count];
34810024:	e1a0600d 	mov	r6, sp
	/* setup output items, copy items to be sorted into our temp area */
	memcpy(temp, dest, count * sizeof(*dest));
	dest_count = 0;

	/* work through the ordering, move over the elements we agree on */
	for (i = 0; i < ocount; i++) {
34810028:	e51b0020 	ldr	r0, [fp, #-32]
	int same;	/* number of elements which are the same */
	int i;

	/* setup output items, copy items to be sorted into our temp area */
	memcpy(temp, dest, count * sizeof(*dest));
	dest_count = 0;
3481002c:	e1a03002 	mov	r3, r2

	/* work through the ordering, move over the elements we agree on */
	for (i = 0; i < ocount; i++) {
34810030:	ea00000d 	b	3481006c <sort_array_by_ordering+0x84>
		if (array_search(temp, count, order[i]) != -1)
34810034:	e490c004 	ldr	ip, [r0], #4
34810038:	e1a07006 	mov	r7, r6
 */
static int array_search(int *array, int count, int key)
{
	int i;

	for (i = 0; i < count; i++) {
3481003c:	e3a01000 	mov	r1, #0
34810040:	ea000003 	b	34810054 <sort_array_by_ordering+0x6c>
		if (array[i] == key)
34810044:	e497a004 	ldr	sl, [r7], #4
34810048:	e15a000c 	cmp	sl, ip
3481004c:	0a000003 	beq	34810060 <sort_array_by_ordering+0x78>
 */
static int array_search(int *array, int count, int key)
{
	int i;

	for (i = 0; i < count; i++) {
34810050:	e2811001 	add	r1, r1, #1
34810054:	e1510005 	cmp	r1, r5
34810058:	bafffff9 	blt	34810044 <sort_array_by_ordering+0x5c>
3481005c:	ea000001 	b	34810068 <sort_array_by_ordering+0x80>
	dest_count = 0;

	/* work through the ordering, move over the elements we agree on */
	for (i = 0; i < ocount; i++) {
		if (array_search(temp, count, order[i]) != -1)
			dest[dest_count++] = order[i];
34810060:	e784c103 	str	ip, [r4, r3, lsl #2]
34810064:	e2833001 	add	r3, r3, #1
	/* setup output items, copy items to be sorted into our temp area */
	memcpy(temp, dest, count * sizeof(*dest));
	dest_count = 0;

	/* work through the ordering, move over the elements we agree on */
	for (i = 0; i < ocount; i++) {
34810068:	e2822001 	add	r2, r2, #1
3481006c:	e1520009 	cmp	r2, r9
34810070:	baffffef 	blt	34810034 <sort_array_by_ordering+0x4c>
34810074:	e1a00003 	mov	r0, r3
34810078:	e3a02000 	mov	r2, #0
3481007c:	ea00000b 	b	348100b0 <sort_array_by_ordering+0xc8>
	}
	same = dest_count;

	/* now move over the elements that are not in the ordering */
	for (i = 0; i < count; i++) {
		if (array_search(order, ocount, temp[i]) == -1)
34810080:	e496c004 	ldr	ip, [r6], #4
34810084:	e51b7020 	ldr	r7, [fp, #-32]
 */
static int array_search(int *array, int count, int key)
{
	int i;

	for (i = 0; i < count; i++) {
34810088:	e3a01000 	mov	r1, #0
3481008c:	ea000003 	b	348100a0 <sort_array_by_ordering+0xb8>
		if (array[i] == key)
34810090:	e497a004 	ldr	sl, [r7], #4
34810094:	e15a000c 	cmp	sl, ip
34810098:	0a000003 	beq	348100ac <sort_array_by_ordering+0xc4>
 */
static int array_search(int *array, int count, int key)
{
	int i;

	for (i = 0; i < count; i++) {
3481009c:	e2811001 	add	r1, r1, #1
348100a0:	e1510009 	cmp	r1, r9
348100a4:	bafffff9 	blt	34810090 <sort_array_by_ordering+0xa8>
348100a8:	ea000004 	b	348100c0 <sort_array_by_ordering+0xd8>
			dest[dest_count++] = order[i];
	}
	same = dest_count;

	/* now move over the elements that are not in the ordering */
	for (i = 0; i < count; i++) {
348100ac:	e2822001 	add	r2, r2, #1
348100b0:	e1520005 	cmp	r2, r5
348100b4:	bafffff1 	blt	34810080 <sort_array_by_ordering+0x98>
		if (array_search(order, ocount, temp[i]) == -1)
			dest[dest_count++] = temp[i];
	}
	assert(dest_count == count);
	return same;
}
348100b8:	e24bd01c 	sub	sp, fp, #28
348100bc:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
	same = dest_count;

	/* now move over the elements that are not in the ordering */
	for (i = 0; i < count; i++) {
		if (array_search(order, ocount, temp[i]) == -1)
			dest[dest_count++] = temp[i];
348100c0:	e784c103 	str	ip, [r4, r3, lsl #2]
348100c4:	e2833001 	add	r3, r3, #1
348100c8:	eafffff7 	b	348100ac <sort_array_by_ordering+0xc4>

348100cc <input_queue_ascii>:
};


int input_queue_ascii(struct input_config *config, int ch)
{
	if (config->fifo_in + 1 == INPUT_BUFFER_LEN) {
348100cc:	e5903010 	ldr	r3, [r0, #16]
348100d0:	e5902014 	ldr	r2, [r0, #20]
348100d4:	e353000f 	cmp	r3, #15
348100d8:	1a000003 	bne	348100ec <input_queue_ascii+0x20>
		if (!config->fifo_out)
348100dc:	e3520000 	cmp	r2, #0
			return -1; /* buffer full */
		else
			config->fifo_in = 0;
348100e0:	13a03000 	movne	r3, #0


int input_queue_ascii(struct input_config *config, int ch)
{
	if (config->fifo_in + 1 == INPUT_BUFFER_LEN) {
		if (!config->fifo_out)
348100e4:	1a000003 	bne	348100f8 <input_queue_ascii+0x2c>
348100e8:	ea000007 	b	3481010c <input_queue_ascii+0x40>
			return -1; /* buffer full */
		else
			config->fifo_in = 0;
	} else {
		if (config->fifo_in + 1 == config->fifo_out)
348100ec:	e2833001 	add	r3, r3, #1
348100f0:	e1530002 	cmp	r3, r2
348100f4:	0a000006 	beq	34810114 <input_queue_ascii+0x48>
			return -1; /* buffer full */
		config->fifo_in++;
348100f8:	e5803010 	str	r3, [r0, #16]
	}
	config->fifo[config->fifo_in] = (uchar)ch;
348100fc:	e5903010 	ldr	r3, [r0, #16]
34810100:	e7c01003 	strb	r1, [r0, r3]

	return 0;
34810104:	e3a00000 	mov	r0, #0
34810108:	e12fff1e 	bx	lr

int input_queue_ascii(struct input_config *config, int ch)
{
	if (config->fifo_in + 1 == INPUT_BUFFER_LEN) {
		if (!config->fifo_out)
			return -1; /* buffer full */
3481010c:	e3e00000 	mvn	r0, #0
34810110:	e12fff1e 	bx	lr
		else
			config->fifo_in = 0;
	} else {
		if (config->fifo_in + 1 == config->fifo_out)
			return -1; /* buffer full */
34810114:	e3e00000 	mvn	r0, #0
		config->fifo_in++;
	}
	config->fifo[config->fifo_in] = (uchar)ch;

	return 0;
}
34810118:	e12fff1e 	bx	lr

3481011c <input_tstc>:

int input_tstc(struct input_config *config)
{
	if (config->fifo_in == config->fifo_out && config->read_keys) {
3481011c:	e5902010 	ldr	r2, [r0, #16]
34810120:	e5903014 	ldr	r3, [r0, #20]

	return 0;
}

int input_tstc(struct input_config *config)
{
34810124:	e92d4010 	push	{r4, lr}
	if (config->fifo_in == config->fifo_out && config->read_keys) {
34810128:	e1520003 	cmp	r2, r3

	return 0;
}

int input_tstc(struct input_config *config)
{
3481012c:	e1a04000 	mov	r4, r0
	if (config->fifo_in == config->fifo_out && config->read_keys) {
34810130:	1a000005 	bne	3481014c <input_tstc+0x30>
34810134:	e59030a0 	ldr	r3, [r0, #160]	; 0xa0
34810138:	e3530000 	cmp	r3, #0
3481013c:	0a000002 	beq	3481014c <input_tstc+0x30>
		if (!(*config->read_keys)(config))
34810140:	e12fff33 	blx	r3
34810144:	e3500000 	cmp	r0, #0
34810148:	08bd8010 	popeq	{r4, pc}
			return 0;
	}
	return config->fifo_in != config->fifo_out;
3481014c:	e5940010 	ldr	r0, [r4, #16]
34810150:	e5943014 	ldr	r3, [r4, #20]
34810154:	e0500003 	subs	r0, r0, r3
34810158:	13a00001 	movne	r0, #1
}
3481015c:	e8bd8010 	pop	{r4, pc}

34810160 <input_getc>:

int input_getc(struct input_config *config)
{
34810160:	e92d4010 	push	{r4, lr}
34810164:	e1a04000 	mov	r4, r0
	int err = 0;

	while (config->fifo_in == config->fifo_out) {
34810168:	ea000006 	b	34810188 <input_getc+0x28>
		if (config->read_keys)
3481016c:	e59430a0 	ldr	r3, [r4, #160]	; 0xa0
34810170:	e3530000 	cmp	r3, #0
34810174:	0a000003 	beq	34810188 <input_getc+0x28>
			err = (*config->read_keys)(config);
34810178:	e1a00004 	mov	r0, r4
3481017c:	e12fff33 	blx	r3
		if (err)
34810180:	e3500000 	cmp	r0, #0
34810184:	1a00000b 	bne	348101b8 <input_getc+0x58>

int input_getc(struct input_config *config)
{
	int err = 0;

	while (config->fifo_in == config->fifo_out) {
34810188:	e5943014 	ldr	r3, [r4, #20]
3481018c:	e5942010 	ldr	r2, [r4, #16]
34810190:	e1520003 	cmp	r2, r3
34810194:	0afffff4 	beq	3481016c <input_getc+0xc>
			err = (*config->read_keys)(config);
		if (err)
			return -1;
	}

	if (++config->fifo_out == INPUT_BUFFER_LEN)
34810198:	e2833001 	add	r3, r3, #1
3481019c:	e3530010 	cmp	r3, #16
348101a0:	e5843014 	str	r3, [r4, #20]
		config->fifo_out = 0;
348101a4:	03a03000 	moveq	r3, #0
348101a8:	05843014 	streq	r3, [r4, #20]

	return config->fifo[config->fifo_out];
348101ac:	e5943014 	ldr	r3, [r4, #20]
348101b0:	e7d40003 	ldrb	r0, [r4, r3]
348101b4:	e8bd8010 	pop	{r4, pc}

	while (config->fifo_in == config->fifo_out) {
		if (config->read_keys)
			err = (*config->read_keys)(config);
		if (err)
			return -1;
348101b8:	e3e00000 	mvn	r0, #0

	if (++config->fifo_out == INPUT_BUFFER_LEN)
		config->fifo_out = 0;

	return config->fifo[config->fifo_out];
}
348101bc:	e8bd8010 	pop	{r4, pc}

348101c0 <input_send_keycodes>:
	return ch_count;
}

int input_send_keycodes(struct input_config *config,
			int keycode[], int num_keycodes)
{
348101c0:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
348101c4:	e28db01c 	add	fp, sp, #28
348101c8:	e24dd010 	sub	sp, sp, #16
 */
static int input_check_keycodes(struct input_config *config,
			   int keycode[], int num_keycodes, int *same)
{
	/* Select the 'plain' xlate table to start with */
	if (!config->num_tables) {
348101cc:	e5d0701b 	ldrb	r7, [r0, #27]
}

int input_send_keycodes(struct input_config *config,
			int keycode[], int num_keycodes)
{
	char ch[num_keycodes];
348101d0:	e282300e 	add	r3, r2, #14
	int count, i, same = 0;
	int is_repeat = 0;
	unsigned delay_ms;

	config->modifiers = 0;
348101d4:	e3a09000 	mov	r9, #0
}

int input_send_keycodes(struct input_config *config,
			int keycode[], int num_keycodes)
{
	char ch[num_keycodes];
348101d8:	e3c33007 	bic	r3, r3, #7
348101dc:	e04dd003 	sub	sp, sp, r3
 */
static int input_check_keycodes(struct input_config *config,
			   int keycode[], int num_keycodes, int *same)
{
	/* Select the 'plain' xlate table to start with */
	if (!config->num_tables) {
348101e0:	e1570009 	cmp	r7, r9
	char ch[num_keycodes];
	int count, i, same = 0;
	int is_repeat = 0;
	unsigned delay_ms;

	config->modifiers = 0;
348101e4:	e5c09018 	strb	r9, [r0, #24]
	return ch_count;
}

int input_send_keycodes(struct input_config *config,
			int keycode[], int num_keycodes)
{
348101e8:	e1a04000 	mov	r4, r0
348101ec:	e1a06001 	mov	r6, r1
348101f0:	e1a05002 	mov	r5, r2
	char ch[num_keycodes];
348101f4:	e50bd020 	str	sp, [fp, #-32]
	int count, i, same = 0;
	int is_repeat = 0;
348101f8:	01a09007 	moveq	r9, r7
 */
static int input_check_keycodes(struct input_config *config,
			   int keycode[], int num_keycodes, int *same)
{
	/* Select the 'plain' xlate table to start with */
	if (!config->num_tables) {
348101fc:	0a000012 	beq	3481024c <input_send_keycodes+0x8c>
		debug("%s: No xlate tables: cannot decode keys\n", __func__);
		return -1;
	}

	/* sort the keycodes into the same order as the previous ones */
	*same = sort_array_by_ordering(keycode, num_keycodes,
34810200:	e280a01c 	add	sl, r0, #28
34810204:	e594305c 	ldr	r3, [r4, #92]	; 0x5c
34810208:	e1a00001 	mov	r0, r1
3481020c:	e1a01002 	mov	r1, r2
34810210:	e1a0200a 	mov	r2, sl
34810214:	ebffff73 	bl	3480ffe8 <sort_array_by_ordering>
			config->prev_keycodes, config->num_prev_keycodes);

	memcpy(config->prev_keycodes, keycode, num_keycodes * sizeof(int));
34810218:	e1a01006 	mov	r1, r6
		debug("%s: No xlate tables: cannot decode keys\n", __func__);
		return -1;
	}

	/* sort the keycodes into the same order as the previous ones */
	*same = sort_array_by_ordering(keycode, num_keycodes,
3481021c:	e1a07000 	mov	r7, r0
			config->prev_keycodes, config->num_prev_keycodes);

	memcpy(config->prev_keycodes, keycode, num_keycodes * sizeof(int));
34810220:	e1a02105 	lsl	r2, r5, #2
34810224:	e1a0000a 	mov	r0, sl
34810228:	eb002318 	bl	34818e90 <memcpy>
	int count, i, same = 0;
	int is_repeat = 0;
	unsigned delay_ms;

	config->modifiers = 0;
	if (!input_check_keycodes(config, keycode, num_keycodes, &same)) {
3481022c:	e1570005 	cmp	r7, r5
	/* sort the keycodes into the same order as the previous ones */
	*same = sort_array_by_ordering(keycode, num_keycodes,
			config->prev_keycodes, config->num_prev_keycodes);

	memcpy(config->prev_keycodes, keycode, num_keycodes * sizeof(int));
	config->num_prev_keycodes = num_keycodes;
34810230:	e584505c 	str	r5, [r4, #92]	; 0x5c
	int count, i, same = 0;
	int is_repeat = 0;
	unsigned delay_ms;

	config->modifiers = 0;
	if (!input_check_keycodes(config, keycode, num_keycodes, &same)) {
34810234:	1a000004 	bne	3481024c <input_send_keycodes+0x8c>
		 * the caller may not call in again for a while, our
		 * auto-repeat speed is not quite correct. We should
		 * insert another character if we later realise that we
		 * have missed a repeat slot.
		 */
		is_repeat = (int)get_timer(config->next_repeat_ms) >= 0;
34810238:	e59400a4 	ldr	r0, [r4, #164]	; 0xa4
3481023c:	ebffc404 	bl	34801254 <get_timer>
		if (!is_repeat)
34810240:	e1500009 	cmp	r0, r9
34810244:	a2899001 	addge	r9, r9, #1
34810248:	ba000061 	blt	348103d4 <input_send_keycodes+0x214>
{
	struct input_key_xlate *table;
	int ch_count;
	int i;

	table = &config->table[0];
3481024c:	e2840060 	add	r0, r4, #96	; 0x60
		is_repeat = (int)get_timer(config->next_repeat_ms) >= 0;
		if (!is_repeat)
			return 0;
	}

	count = input_keycodes_to_ascii(config, keycode, num_keycodes,
34810250:	e3590000 	cmp	r9, #0
34810254:	13a07000 	movne	r7, #0
{
	struct input_key_xlate *table;
	int ch_count;
	int i;

	table = &config->table[0];
34810258:	e50b0024 	str	r0, [fp, #-36]	; 0x24
3481025c:	e1a0e006 	mov	lr, r6
34810260:	e1a03000 	mov	r3, r0

	/* deal with modifiers first */
	for (i = 0; i < num_keycodes; i++) {
34810264:	e3a0c000 	mov	ip, #0
34810268:	ea000032 	b	34810338 <input_send_keycodes+0x178>
		int key = keycode[i] & KEY_MASK;
3481026c:	e49e1004 	ldr	r1, [lr], #4

		if (key >= table->num_entries || table->xlate[key] == 0xff) {
34810270:	e593a00c 	ldr	sl, [r3, #12]

	table = &config->table[0];

	/* deal with modifiers first */
	for (i = 0; i < num_keycodes; i++) {
		int key = keycode[i] & KEY_MASK;
34810274:	e1a00a01 	lsl	r0, r1, #20
34810278:	e1a02a20 	lsr	r2, r0, #20

		if (key >= table->num_entries || table->xlate[key] == 0xff) {
3481027c:	e152000a 	cmp	r2, sl
34810280:	aa000003 	bge	34810294 <input_send_keycodes+0xd4>
34810284:	e593a008 	ldr	sl, [r3, #8]
34810288:	e7da0a20 	ldrb	r0, [sl, r0, lsr #20]
3481028c:	e35000ff 	cmp	r0, #255	; 0xff
34810290:	1a000027 	bne	34810334 <input_send_keycodes+0x174>
			table = process_modifier(config, key,
34810294:	e2011902 	and	r1, r1, #32768	; 0x8000
34810298:	e50b1028 	str	r1, [fp, #-40]	; 0x28
	int i;

	/* Start with the main table, and see what modifiers change it */
	assert(config->num_tables > 0);
	table = &config->table[0];
	for (i = 1; i < config->num_tables; i++) {
3481029c:	e5d4101b 	ldrb	r1, [r4, #27]
348102a0:	e1a00004 	mov	r0, r4
348102a4:	e50b102c 	str	r1, [fp, #-44]	; 0x2c
	int flip = -1;
	int i;

	/* Start with the main table, and see what modifiers change it */
	assert(config->num_tables > 0);
	table = &config->table[0];
348102a8:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
	for (i = 1; i < config->num_tables; i++) {
348102ac:	e3a01001 	mov	r1, #1
348102b0:	ea000009 	b	348102dc <input_send_keycodes+0x11c>
		struct input_key_xlate *tab = &config->table[i];

		if (key == tab->left_keycode || key == tab->right_keycode)
348102b4:	e590a070 	ldr	sl, [r0, #112]	; 0x70
348102b8:	e152000a 	cmp	r2, sl
348102bc:	0a000002 	beq	348102cc <input_send_keycodes+0x10c>
348102c0:	e590a074 	ldr	sl, [r0, #116]	; 0x74
348102c4:	e152000a 	cmp	r2, sl
348102c8:	1a000001 	bne	348102d4 <input_send_keycodes+0x114>

	/* Start with the main table, and see what modifiers change it */
	assert(config->num_tables > 0);
	table = &config->table[0];
	for (i = 1; i < config->num_tables; i++) {
		struct input_key_xlate *tab = &config->table[i];
348102cc:	e2813006 	add	r3, r1, #6
348102d0:	e0843203 	add	r3, r4, r3, lsl #4
	int i;

	/* Start with the main table, and see what modifiers change it */
	assert(config->num_tables > 0);
	table = &config->table[0];
	for (i = 1; i < config->num_tables; i++) {
348102d4:	e2811001 	add	r1, r1, #1
348102d8:	e2800010 	add	r0, r0, #16
348102dc:	e51ba02c 	ldr	sl, [fp, #-44]	; 0x2c
348102e0:	e151000a 	cmp	r1, sl
348102e4:	bafffff2 	blt	348102b4 <input_send_keycodes+0xf4>
		if (key == tab->left_keycode || key == tab->right_keycode)
			table = tab;
	}

	/* Handle the lighted keys */
	if (!release) {
348102e8:	e51b0028 	ldr	r0, [fp, #-40]	; 0x28
348102ec:	e3500000 	cmp	r0, #0
348102f0:	1a00000f 	bne	34810334 <input_send_keycodes+0x174>
348102f4:	e242203a 	sub	r2, r2, #58	; 0x3a
348102f8:	e352000c 	cmp	r2, #12
348102fc:	8a00000c 	bhi	34810334 <input_send_keycodes+0x174>
			flip = FLAG_CAPS_LOCK;
			break;
		}
	}

	if (flip != -1) {
34810300:	e59f10d8 	ldr	r1, [pc, #216]	; 348103e0 <input_send_keycodes+0x220>
34810304:	e7912102 	ldr	r2, [r1, r2, lsl #2]
34810308:	e3720001 	cmn	r2, #1
3481030c:	0a000008 	beq	34810334 <input_send_keycodes+0x174>
		int leds = 0;

		config->leds ^= flip;
		if (config->flags & FLAG_NUM_LOCK)
34810310:	e5d41019 	ldrb	r1, [r4, #25]
			leds |= INPUT_LED_NUM;
34810314:	e3110001 	tst	r1, #1
34810318:	03a02000 	moveq	r2, #0
3481031c:	13a02004 	movne	r2, #4
		if (config->flags & FLAG_CAPS_LOCK)
34810320:	e3110002 	tst	r1, #2
			leds |= INPUT_LED_CAPS;
34810324:	13822002 	orrne	r2, r2, #2
		if (config->flags & FLAG_SCROLL_LOCK)
34810328:	e3110004 	tst	r1, #4
			leds |= INPUT_LED_SCROLL;
3481032c:	13822001 	orrne	r2, r2, #1
		config->leds = leds;
34810330:	e5c4201a 	strb	r2, [r4, #26]
	int i;

	table = &config->table[0];

	/* deal with modifiers first */
	for (i = 0; i < num_keycodes; i++) {
34810334:	e28cc001 	add	ip, ip, #1
34810338:	e15c0005 	cmp	ip, r5
3481033c:	baffffca 	blt	3481026c <input_send_keycodes+0xac>
34810340:	e3a02000 	mov	r2, #0
34810344:	e1a0a002 	mov	sl, r2
34810348:	ea00000f 	b	3481038c <input_send_keycodes+0x1cc>
		}
	}

	/* now find normal keys */
	for (i = ch_count = 0; i < num_keycodes; i++) {
		int key = keycode[i];
3481034c:	e4961004 	ldr	r1, [r6], #4

		if (key < table->num_entries && i >= same) {
34810350:	e593c00c 	ldr	ip, [r3, #12]
34810354:	e1520007 	cmp	r2, r7
34810358:	b3a00000 	movlt	r0, #0
3481035c:	a3a00001 	movge	r0, #1
34810360:	e151000c 	cmp	r1, ip
34810364:	a3a00000 	movge	r0, #0
34810368:	e3500000 	cmp	r0, #0
3481036c:	0a000005 	beq	34810388 <input_send_keycodes+0x1c8>
			int ch = table->xlate[key];
34810370:	e5930008 	ldr	r0, [r3, #8]
34810374:	e7d01001 	ldrb	r1, [r0, r1]

			/* If a normal key with an ASCII value, add it! */
			if (ch != 0xff)
34810378:	e35100ff 	cmp	r1, #255	; 0xff
				output_ch[ch_count++] = (uchar)ch;
3481037c:	151b0020 	ldrne	r0, [fp, #-32]
34810380:	17c0100a 	strbne	r1, [r0, sl]
34810384:	128aa001 	addne	sl, sl, #1
					keycode[i] & KEY_RELEASE);
		}
	}

	/* now find normal keys */
	for (i = ch_count = 0; i < num_keycodes; i++) {
34810388:	e2822001 	add	r2, r2, #1
3481038c:	e1520005 	cmp	r2, r5
34810390:	baffffed 	blt	3481034c <input_send_keycodes+0x18c>
			return 0;
	}

	count = input_keycodes_to_ascii(config, keycode, num_keycodes,
					ch, is_repeat ? 0 : same);
	for (i = 0; i < count; i++)
34810394:	e3a05000 	mov	r5, #0
34810398:	ea000004 	b	348103b0 <input_send_keycodes+0x1f0>
		input_queue_ascii(config, ch[i]);
3481039c:	e51b3020 	ldr	r3, [fp, #-32]
348103a0:	e1a00004 	mov	r0, r4
348103a4:	e7d31005 	ldrb	r1, [r3, r5]
348103a8:	ebffff47 	bl	348100cc <input_queue_ascii>
			return 0;
	}

	count = input_keycodes_to_ascii(config, keycode, num_keycodes,
					ch, is_repeat ? 0 : same);
	for (i = 0; i < count; i++)
348103ac:	e2855001 	add	r5, r5, #1
348103b0:	e155000a 	cmp	r5, sl
348103b4:	bafffff8 	blt	3481039c <input_send_keycodes+0x1dc>
		input_queue_ascii(config, ch[i]);
	delay_ms = is_repeat ?
			config->repeat_rate_ms :
348103b8:	e3590000 	cmp	r9, #0
			config->repeat_delay_ms;

	config->next_repeat_ms = get_timer(0) + delay_ms;
348103bc:	e3a00000 	mov	r0, #0
	count = input_keycodes_to_ascii(config, keycode, num_keycodes,
					ch, is_repeat ? 0 : same);
	for (i = 0; i < count; i++)
		input_queue_ascii(config, ch[i]);
	delay_ms = is_repeat ?
			config->repeat_rate_ms :
348103c0:	159450ac 	ldrne	r5, [r4, #172]	; 0xac
348103c4:	059450a8 	ldreq	r5, [r4, #168]	; 0xa8
			config->repeat_delay_ms;

	config->next_repeat_ms = get_timer(0) + delay_ms;
348103c8:	ebffc3a1 	bl	34801254 <get_timer>
348103cc:	e0800005 	add	r0, r0, r5
348103d0:	e58400a4 	str	r0, [r4, #164]	; 0xa4
	return 0;
}
348103d4:	e3a00000 	mov	r0, #0
348103d8:	e24bd01c 	sub	sp, fp, #28
348103dc:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
348103e0:	348216f4 	.word	0x348216f4

348103e4 <input_add_table>:

int input_add_table(struct input_config *config, int left_keycode,
		    int right_keycode, const uchar *xlate, int num_entries)
{
348103e4:	e92d4010 	push	{r4, lr}
	struct input_key_xlate *table;

	if (config->num_tables == INPUT_MAX_MODIFIERS) {
348103e8:	e5d0c01b 	ldrb	ip, [r0, #27]
348103ec:	e35c0004 	cmp	ip, #4
348103f0:	0a00000b 	beq	34810424 <input_add_table+0x40>
		debug("%s: Too many modifier tables\n", __func__);
		return -1;
	}

	table = &config->table[config->num_tables++];
348103f4:	e28c4001 	add	r4, ip, #1
348103f8:	e5c0401b 	strb	r4, [r0, #27]
	table->left_keycode = left_keycode;
348103fc:	e28c4006 	add	r4, ip, #6
34810400:	e7801204 	str	r1, [r0, r4, lsl #4]
	table->right_keycode = right_keycode;
34810404:	e0804204 	add	r4, r0, r4, lsl #4
	table->xlate = xlate;
34810408:	e080020c 	add	r0, r0, ip, lsl #4
3481040c:	e5803068 	str	r3, [r0, #104]	; 0x68
	table->num_entries = num_entries;
34810410:	e59d3008 	ldr	r3, [sp, #8]
		return -1;
	}

	table = &config->table[config->num_tables++];
	table->left_keycode = left_keycode;
	table->right_keycode = right_keycode;
34810414:	e5842004 	str	r2, [r4, #4]
	table->xlate = xlate;
	table->num_entries = num_entries;
34810418:	e580306c 	str	r3, [r0, #108]	; 0x6c

	return 0;
3481041c:	e3a00000 	mov	r0, #0
34810420:	e8bd8010 	pop	{r4, pc}
{
	struct input_key_xlate *table;

	if (config->num_tables == INPUT_MAX_MODIFIERS) {
		debug("%s: Too many modifier tables\n", __func__);
		return -1;
34810424:	e3e00000 	mvn	r0, #0
	table->right_keycode = right_keycode;
	table->xlate = xlate;
	table->num_entries = num_entries;

	return 0;
}
34810428:	e8bd8010 	pop	{r4, pc}

3481042c <input_init>:

int input_init(struct input_config *config, int leds, int repeat_delay_ms,
	       int repeat_rate_ms)
{
3481042c:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
34810430:	e1a04000 	mov	r4, r0
34810434:	e1a06001 	mov	r6, r1
34810438:	e1a05002 	mov	r5, r2
	memset(config, '\0', sizeof(*config));
3481043c:	e3a01000 	mov	r1, #0
34810440:	e3a020b0 	mov	r2, #176	; 0xb0
	return 0;
}

int input_init(struct input_config *config, int leds, int repeat_delay_ms,
	       int repeat_rate_ms)
{
34810444:	e1a07003 	mov	r7, r3
	memset(config, '\0', sizeof(*config));
34810448:	eb00226c 	bl	34818e00 <memset>
int input_add_table(struct input_config *config, int left_keycode,
		    int right_keycode, const uchar *xlate, int num_entries)
{
	struct input_key_xlate *table;

	if (config->num_tables == INPUT_MAX_MODIFIERS) {
3481044c:	e5d4301b 	ldrb	r3, [r4, #27]

int input_init(struct input_config *config, int leds, int repeat_delay_ms,
	       int repeat_rate_ms)
{
	memset(config, '\0', sizeof(*config));
	config->leds = leds;
34810450:	e5c4601a 	strb	r6, [r4, #26]
int input_add_table(struct input_config *config, int left_keycode,
		    int right_keycode, const uchar *xlate, int num_entries)
{
	struct input_key_xlate *table;

	if (config->num_tables == INPUT_MAX_MODIFIERS) {
34810454:	e3530004 	cmp	r3, #4
int input_init(struct input_config *config, int leds, int repeat_delay_ms,
	       int repeat_rate_ms)
{
	memset(config, '\0', sizeof(*config));
	config->leds = leds;
	config->repeat_delay_ms = repeat_delay_ms;
34810458:	e58450a8 	str	r5, [r4, #168]	; 0xa8
	config->repeat_rate_ms = repeat_rate_ms;
3481045c:	e58470ac 	str	r7, [r4, #172]	; 0xac
int input_add_table(struct input_config *config, int left_keycode,
		    int right_keycode, const uchar *xlate, int num_entries)
{
	struct input_key_xlate *table;

	if (config->num_tables == INPUT_MAX_MODIFIERS) {
34810460:	0a00002b 	beq	34810514 <input_init+0xe8>
		debug("%s: Too many modifier tables\n", __func__);
		return -1;
	}

	table = &config->table[config->num_tables++];
	table->left_keycode = left_keycode;
34810464:	e2831006 	add	r1, r3, #6
34810468:	e3e00000 	mvn	r0, #0
3481046c:	e7840201 	str	r0, [r4, r1, lsl #4]
	table->right_keycode = right_keycode;
34810470:	e0841201 	add	r1, r4, r1, lsl #4
	if (config->num_tables == INPUT_MAX_MODIFIERS) {
		debug("%s: Too many modifier tables\n", __func__);
		return -1;
	}

	table = &config->table[config->num_tables++];
34810474:	e2832001 	add	r2, r3, #1
	table->left_keycode = left_keycode;
	table->right_keycode = right_keycode;
34810478:	e5810004 	str	r0, [r1, #4]
	table->xlate = xlate;
3481047c:	e59f1098 	ldr	r1, [pc, #152]	; 3481051c <input_init+0xf0>
	if (config->num_tables == INPUT_MAX_MODIFIERS) {
		debug("%s: Too many modifier tables\n", __func__);
		return -1;
	}

	table = &config->table[config->num_tables++];
34810480:	e6ef2072 	uxtb	r2, r2
	table->left_keycode = left_keycode;
	table->right_keycode = right_keycode;
	table->xlate = xlate;
34810484:	e0843203 	add	r3, r4, r3, lsl #4
34810488:	e5831068 	str	r1, [r3, #104]	; 0x68
int input_add_table(struct input_config *config, int left_keycode,
		    int right_keycode, const uchar *xlate, int num_entries)
{
	struct input_key_xlate *table;

	if (config->num_tables == INPUT_MAX_MODIFIERS) {
3481048c:	e3520004 	cmp	r2, #4

	table = &config->table[config->num_tables++];
	table->left_keycode = left_keycode;
	table->right_keycode = right_keycode;
	table->xlate = xlate;
	table->num_entries = num_entries;
34810490:	e3a01063 	mov	r1, #99	; 0x63
	if (config->num_tables == INPUT_MAX_MODIFIERS) {
		debug("%s: Too many modifier tables\n", __func__);
		return -1;
	}

	table = &config->table[config->num_tables++];
34810494:	e5c4201b 	strb	r2, [r4, #27]
	table->left_keycode = left_keycode;
	table->right_keycode = right_keycode;
	table->xlate = xlate;
	table->num_entries = num_entries;
34810498:	e583106c 	str	r1, [r3, #108]	; 0x6c
int input_add_table(struct input_config *config, int left_keycode,
		    int right_keycode, const uchar *xlate, int num_entries)
{
	struct input_key_xlate *table;

	if (config->num_tables == INPUT_MAX_MODIFIERS) {
3481049c:	08bd80f8 	popeq	{r3, r4, r5, r6, r7, pc}
		debug("%s: Too many modifier tables\n", __func__);
		return -1;
	}

	table = &config->table[config->num_tables++];
	table->left_keycode = left_keycode;
348104a0:	e282c006 	add	ip, r2, #6
348104a4:	e3a0502a 	mov	r5, #42	; 0x2a
	if (config->num_tables == INPUT_MAX_MODIFIERS) {
		debug("%s: Too many modifier tables\n", __func__);
		return -1;
	}

	table = &config->table[config->num_tables++];
348104a8:	e2823001 	add	r3, r2, #1
	table->left_keycode = left_keycode;
348104ac:	e784520c 	str	r5, [r4, ip, lsl #4]
	table->right_keycode = right_keycode;
348104b0:	e084c20c 	add	ip, r4, ip, lsl #4
348104b4:	e285500c 	add	r5, r5, #12
	if (config->num_tables == INPUT_MAX_MODIFIERS) {
		debug("%s: Too many modifier tables\n", __func__);
		return -1;
	}

	table = &config->table[config->num_tables++];
348104b8:	e6ef3073 	uxtb	r3, r3
	table->left_keycode = left_keycode;
	table->right_keycode = right_keycode;
348104bc:	e58c5004 	str	r5, [ip, #4]
	table->xlate = xlate;
348104c0:	e59fc058 	ldr	ip, [pc, #88]	; 34810520 <input_init+0xf4>
348104c4:	e0842202 	add	r2, r4, r2, lsl #4
int input_add_table(struct input_config *config, int left_keycode,
		    int right_keycode, const uchar *xlate, int num_entries)
{
	struct input_key_xlate *table;

	if (config->num_tables == INPUT_MAX_MODIFIERS) {
348104c8:	e3530004 	cmp	r3, #4
		debug("%s: Too many modifier tables\n", __func__);
		return -1;
	}

	table = &config->table[config->num_tables++];
348104cc:	e5c4301b 	strb	r3, [r4, #27]
	table->left_keycode = left_keycode;
	table->right_keycode = right_keycode;
	table->xlate = xlate;
348104d0:	e582c068 	str	ip, [r2, #104]	; 0x68
	table->num_entries = num_entries;
348104d4:	e582106c 	str	r1, [r2, #108]	; 0x6c
int input_add_table(struct input_config *config, int left_keycode,
		    int right_keycode, const uchar *xlate, int num_entries)
{
	struct input_key_xlate *table;

	if (config->num_tables == INPUT_MAX_MODIFIERS) {
348104d8:	08bd80f8 	popeq	{r3, r4, r5, r6, r7, pc}
		debug("%s: Too many modifier tables\n", __func__);
		return -1;
	}

	table = &config->table[config->num_tables++];
348104dc:	e2832001 	add	r2, r3, #1
348104e0:	e5c4201b 	strb	r2, [r4, #27]
	table->left_keycode = left_keycode;
348104e4:	e280001e 	add	r0, r0, #30
348104e8:	e2832006 	add	r2, r3, #6
348104ec:	e7840202 	str	r0, [r4, r2, lsl #4]
	table->right_keycode = right_keycode;
	table->xlate = xlate;
348104f0:	e28cc064 	add	ip, ip, #100	; 0x64
		return -1;
	}

	table = &config->table[config->num_tables++];
	table->left_keycode = left_keycode;
	table->right_keycode = right_keycode;
348104f4:	e0842202 	add	r2, r4, r2, lsl #4
348104f8:	e2800044 	add	r0, r0, #68	; 0x44
	table->xlate = xlate;
348104fc:	e0844203 	add	r4, r4, r3, lsl #4
		return -1;
	}

	table = &config->table[config->num_tables++];
	table->left_keycode = left_keycode;
	table->right_keycode = right_keycode;
34810500:	e5820004 	str	r0, [r2, #4]
	table->xlate = xlate;
34810504:	e584c068 	str	ip, [r4, #104]	; 0x68
	table->num_entries = num_entries;
34810508:	e584106c 	str	r1, [r4, #108]	; 0x6c
			kbd_ctrl_xlate, ARRAY_SIZE(kbd_ctrl_xlate))) {
		debug("%s: Could not add modifier tables\n", __func__);
		return -1;
	}

	return 0;
3481050c:	e3a00000 	mov	r0, #0
34810510:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
		input_add_table(config, KEY_LEFTSHIFT, KEY_RIGHTSHIFT,
			kbd_shift_xlate, ARRAY_SIZE(kbd_shift_xlate)) ||
		input_add_table(config, KEY_LEFTCTRL, KEY_RIGHTCTRL,
			kbd_ctrl_xlate, ARRAY_SIZE(kbd_ctrl_xlate))) {
		debug("%s: Could not add modifier tables\n", __func__);
		return -1;
34810514:	e3e00000 	mvn	r0, #0
	}

	return 0;
}
34810518:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
3481051c:	34821728 	.word	0x34821728
34810520:	34828884 	.word	0x34828884

34810524 <input_stdio_register>:

int input_stdio_register(struct stdio_dev *dev)
{
34810524:	e92d4038 	push	{r3, r4, r5, lr}
34810528:	e1a04000 	mov	r4, r0
	int error;

	error = stdio_register(dev);
3481052c:	ebfff78e 	bl	3480e36c <stdio_register>

	/* check if this is the standard input device */
	if (!error && strcmp(getenv("stdin"), dev->name) == 0) {
34810530:	e2505000 	subs	r5, r0, #0
		if (OVERWRITE_CONSOLE ||
				console_assign(stdin, dev->name))
			return -1;
	}

	return 0;
34810534:	13a00000 	movne	r0, #0
	int error;

	error = stdio_register(dev);

	/* check if this is the standard input device */
	if (!error && strcmp(getenv("stdin"), dev->name) == 0) {
34810538:	18bd8038 	popne	{r3, r4, r5, pc}
3481053c:	e59f0030 	ldr	r0, [pc, #48]	; 34810574 <input_stdio_register+0x50>
34810540:	e2844008 	add	r4, r4, #8
34810544:	ebffdf3c 	bl	3480823c <getenv>
34810548:	e1a01004 	mov	r1, r4
3481054c:	eb002157 	bl	34818ab0 <strcmp>
34810550:	e3500000 	cmp	r0, #0
34810554:	1a000004 	bne	3481056c <input_stdio_register+0x48>
		/* reassign the console */
		if (OVERWRITE_CONSOLE ||
				console_assign(stdin, dev->name))
34810558:	e1a01004 	mov	r1, r4
3481055c:	ebffe2ce 	bl	3480909c <console_assign>
	error = stdio_register(dev);

	/* check if this is the standard input device */
	if (!error && strcmp(getenv("stdin"), dev->name) == 0) {
		/* reassign the console */
		if (OVERWRITE_CONSOLE ||
34810560:	e3500000 	cmp	r0, #0
				console_assign(stdin, dev->name))
			return -1;
	}

	return 0;
34810564:	13e00000 	mvnne	r0, #0
34810568:	e8bd8038 	pop	{r3, r4, r5, pc}
3481056c:	e1a00005 	mov	r0, r5
}
34810570:	e8bd8038 	pop	{r3, r4, r5, pc}
34810574:	348256e0 	.word	0x348256e0

34810578 <do_pmic>:
	char *cmd;

	struct pmic *p = &pmic;

	/* at least two arguments please */
	if (argc < 2)
34810578:	e3520001 	cmp	r2, #1
{
	return &pmic;
}

int do_pmic(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
3481057c:	e92d44f3 	push	{r0, r1, r4, r5, r6, r7, sl, lr}
34810580:	e1a04000 	mov	r4, r0
34810584:	e1a07002 	mov	r7, r2
34810588:	e1a05003 	mov	r5, r3
	char *cmd;

	struct pmic *p = &pmic;

	/* at least two arguments please */
	if (argc < 2)
3481058c:	da000045 	ble	348106a8 <do_pmic+0x130>
		return cmd_usage(cmdtp);

	cmd = argv[1];
34810590:	e5936004 	ldr	r6, [r3, #4]
	if (strcmp(cmd, "dump") == 0) {
34810594:	e59f1154 	ldr	r1, [pc, #340]	; 348106f0 <do_pmic+0x178>
34810598:	e1a00006 	mov	r0, r6
3481059c:	eb002143 	bl	34818ab0 <strcmp>
348105a0:	e250a000 	subs	sl, r0, #0
348105a4:	1a00001d 	bne	34810620 <do_pmic+0xa8>

	/* No subcommand found */
	return 1;
}

U_BOOT_CMD(
348105a8:	e59f6144 	ldr	r6, [pc, #324]	; 348106f4 <do_pmic+0x17c>
	return 0;
}

static void pmic_show_info(struct pmic *p)
{
	printf("PMIC: %s\n", p->name);
348105ac:	e59f0144 	ldr	r0, [pc, #324]	; 348106f8 <do_pmic+0x180>
348105b0:	e5961000 	ldr	r1, [r6]
348105b4:	ebffe264 	bl	34808f4c <printf>
{
	int i, ret;
	u32 val;

	pmic_show_info(p);
	for (i = 0; i < p->number_of_regs; i++) {
348105b8:	e1a0400a 	mov	r4, sl
		ret = pmic_reg_read(p, i, &val);
348105bc:	e1a0500d 	mov	r5, sp
348105c0:	ea000010 	b	34810608 <do_pmic+0x90>
348105c4:	e59f0128 	ldr	r0, [pc, #296]	; 348106f4 <do_pmic+0x17c>
348105c8:	e1a01004 	mov	r1, r4
348105cc:	e1a0200d 	mov	r2, sp
348105d0:	eb0000a2 	bl	34810860 <pmic_reg_read>
		if (ret)
348105d4:	e3500000 	cmp	r0, #0
348105d8:	0a000001 	beq	348105e4 <do_pmic+0x6c>
			puts("PMIC: Registers dump failed\n");
348105dc:	e59f0118 	ldr	r0, [pc, #280]	; 348106fc <do_pmic+0x184>
348105e0:	ebffe24f 	bl	34808f24 <puts>

		if (!(i % 8))
348105e4:	e3140007 	tst	r4, #7
348105e8:	1a000002 	bne	348105f8 <do_pmic+0x80>
			printf("\n0x%02x: ", i);
348105ec:	e59f010c 	ldr	r0, [pc, #268]	; 34810700 <do_pmic+0x188>
348105f0:	e1a01004 	mov	r1, r4
348105f4:	ebffe254 	bl	34808f4c <printf>

		printf("%08x ", val);
348105f8:	e59f0104 	ldr	r0, [pc, #260]	; 34810704 <do_pmic+0x18c>
348105fc:	e59d1000 	ldr	r1, [sp]
34810600:	ebffe251 	bl	34808f4c <printf>
{
	int i, ret;
	u32 val;

	pmic_show_info(p);
	for (i = 0; i < p->number_of_regs; i++) {
34810604:	e2844001 	add	r4, r4, #1
34810608:	e5d63006 	ldrb	r3, [r6, #6]
3481060c:	e1540003 	cmp	r4, r3
34810610:	baffffeb 	blt	348105c4 <do_pmic+0x4c>
		if (!(i % 8))
			printf("\n0x%02x: ", i);

		printf("%08x ", val);
	}
	puts("\n");
34810614:	e59f00ec 	ldr	r0, [pc, #236]	; 34810708 <do_pmic+0x190>
34810618:	ebffe241 	bl	34808f24 <puts>
3481061c:	ea000016 	b	3481067c <do_pmic+0x104>
	if (strcmp(cmd, "dump") == 0) {
		pmic_dump(p);
		return 0;
	}

	if (strcmp(cmd, "read") == 0) {
34810620:	e59f10e4 	ldr	r1, [pc, #228]	; 3481070c <do_pmic+0x194>
34810624:	e1a00006 	mov	r0, r6
34810628:	eb002120 	bl	34818ab0 <strcmp>
3481062c:	e2501000 	subs	r1, r0, #0
34810630:	1a000013 	bne	34810684 <do_pmic+0x10c>
		if (argc < 3)
34810634:	e3570002 	cmp	r7, #2
34810638:	0a000019 	beq	348106a4 <do_pmic+0x12c>
			return cmd_usage(cmdtp);

		reg = simple_strtoul(argv[2], NULL, 16);
3481063c:	e3a02010 	mov	r2, #16
34810640:	e5950008 	ldr	r0, [r5, #8]
34810644:	eb00256b 	bl	34819bf8 <simple_strtoul>
34810648:	e1a04000 	mov	r4, r0

		ret = pmic_reg_read(p, reg, &val);
3481064c:	e1a01004 	mov	r1, r4
34810650:	e59f009c 	ldr	r0, [pc, #156]	; 348106f4 <do_pmic+0x17c>
34810654:	e28d2004 	add	r2, sp, #4
34810658:	eb000080 	bl	34810860 <pmic_reg_read>

		if (ret)
3481065c:	e3500000 	cmp	r0, #0
34810660:	0a000001 	beq	3481066c <do_pmic+0xf4>
			puts("PMIC: Register read failed\n");
34810664:	e59f00a4 	ldr	r0, [pc, #164]	; 34810710 <do_pmic+0x198>
34810668:	ebffe22d 	bl	34808f24 <puts>

		printf("\n0x%02x: 0x%08x\n", reg, val);
3481066c:	e59f00a0 	ldr	r0, [pc, #160]	; 34810714 <do_pmic+0x19c>
34810670:	e1a01004 	mov	r1, r4
34810674:	e59d2004 	ldr	r2, [sp, #4]
34810678:	ebffe233 	bl	34808f4c <printf>

		return 0;
3481067c:	e3a00000 	mov	r0, #0
34810680:	ea000019 	b	348106ec <do_pmic+0x174>
	}

	if (strcmp(cmd, "write") == 0) {
34810684:	e1a00006 	mov	r0, r6
34810688:	e59f1088 	ldr	r1, [pc, #136]	; 34810718 <do_pmic+0x1a0>
3481068c:	eb002107 	bl	34818ab0 <strcmp>
34810690:	e2506000 	subs	r6, r0, #0

		return 0;
	}

	/* No subcommand found */
	return 1;
34810694:	13a00001 	movne	r0, #1
		printf("\n0x%02x: 0x%08x\n", reg, val);

		return 0;
	}

	if (strcmp(cmd, "write") == 0) {
34810698:	1a000013 	bne	348106ec <do_pmic+0x174>
		if (argc < 4)
3481069c:	e3570003 	cmp	r7, #3
348106a0:	ca000002 	bgt	348106b0 <do_pmic+0x138>
			return cmd_usage(cmdtp);
348106a4:	e1a00004 	mov	r0, r4
348106a8:	ebffe0d0 	bl	348089f0 <cmd_usage>
348106ac:	ea00000e 	b	348106ec <do_pmic+0x174>

		reg = simple_strtoul(argv[2], NULL, 16);
348106b0:	e1a01006 	mov	r1, r6
348106b4:	e3a02010 	mov	r2, #16
348106b8:	e5950008 	ldr	r0, [r5, #8]
348106bc:	eb00254d 	bl	34819bf8 <simple_strtoul>
		val = simple_strtoul(argv[3], NULL, 16);
348106c0:	e1a01006 	mov	r1, r6

	if (strcmp(cmd, "write") == 0) {
		if (argc < 4)
			return cmd_usage(cmdtp);

		reg = simple_strtoul(argv[2], NULL, 16);
348106c4:	e1a04000 	mov	r4, r0
		val = simple_strtoul(argv[3], NULL, 16);
348106c8:	e3a02010 	mov	r2, #16
348106cc:	e595000c 	ldr	r0, [r5, #12]
348106d0:	eb002548 	bl	34819bf8 <simple_strtoul>

		pmic_reg_write(p, reg, val);
348106d4:	e1a01004 	mov	r1, r4
	if (strcmp(cmd, "write") == 0) {
		if (argc < 4)
			return cmd_usage(cmdtp);

		reg = simple_strtoul(argv[2], NULL, 16);
		val = simple_strtoul(argv[3], NULL, 16);
348106d8:	e1a02000 	mov	r2, r0
348106dc:	e58d0004 	str	r0, [sp, #4]

		pmic_reg_write(p, reg, val);
348106e0:	e59f000c 	ldr	r0, [pc, #12]	; 348106f4 <do_pmic+0x17c>
348106e4:	eb000033 	bl	348107b8 <pmic_reg_write>

		return 0;
348106e8:	e1a00006 	mov	r0, r6
	}

	/* No subcommand found */
	return 1;
}
348106ec:	e8bd84fc 	pop	{r2, r3, r4, r5, r6, r7, sl, pc}
348106f0:	34826d1a 	.word	0x34826d1a
348106f4:	3482b16c 	.word	0x3482b16c
348106f8:	34826d1f 	.word	0x34826d1f
348106fc:	34826d29 	.word	0x34826d29
34810700:	34826d46 	.word	0x34826d46
34810704:	34826d50 	.word	0x34826d50
34810708:	348260f7 	.word	0x348260f7
3481070c:	348244cf 	.word	0x348244cf
34810710:	34826d56 	.word	0x34826d56
34810714:	34826d72 	.word	0x34826d72
34810718:	348244d4 	.word	0x348244d4

3481071c <check_reg>:
#include <pmic.h>

static struct pmic pmic;

int check_reg(u32 reg)
{
3481071c:	e92d4008 	push	{r3, lr}
	if (reg >= pmic.number_of_regs) {
34810720:	e59f3024 	ldr	r3, [pc, #36]	; 3481074c <check_reg+0x30>
#include <pmic.h>

static struct pmic pmic;

int check_reg(u32 reg)
{
34810724:	e1a01000 	mov	r1, r0
	if (reg >= pmic.number_of_regs) {
34810728:	e5d32006 	ldrb	r2, [r3, #6]
3481072c:	e1500002 	cmp	r0, r2
34810730:	3a000003 	bcc	34810744 <check_reg+0x28>
		printf("<reg num> = %d is invalid. Should be less than %d\n",
34810734:	e59f0014 	ldr	r0, [pc, #20]	; 34810750 <check_reg+0x34>
34810738:	ebffe203 	bl	34808f4c <printf>
		       reg, pmic.number_of_regs);
		return -1;
3481073c:	e3e00000 	mvn	r0, #0
34810740:	e8bd8008 	pop	{r3, pc}
	}
	return 0;
34810744:	e3a00000 	mov	r0, #0
}
34810748:	e8bd8008 	pop	{r3, pc}
3481074c:	3482b16c 	.word	0x3482b16c
34810750:	34826d83 	.word	0x34826d83

34810754 <pmic_set_output>:

int pmic_set_output(struct pmic *p, u32 reg, int out, int on)
{
34810754:	e92d40f7 	push	{r0, r1, r2, r4, r5, r6, r7, lr}
34810758:	e1a04002 	mov	r4, r2
	u32 val;

	if (pmic_reg_read(p, reg, &val))
3481075c:	e28d2004 	add	r2, sp, #4
	}
	return 0;
}

int pmic_set_output(struct pmic *p, u32 reg, int out, int on)
{
34810760:	e1a06000 	mov	r6, r0
34810764:	e1a05001 	mov	r5, r1
34810768:	e1a07003 	mov	r7, r3
	u32 val;

	if (pmic_reg_read(p, reg, &val))
3481076c:	eb00003b 	bl	34810860 <pmic_reg_read>
34810770:	e3500000 	cmp	r0, #0
		return -1;
34810774:	13e00000 	mvnne	r0, #0

int pmic_set_output(struct pmic *p, u32 reg, int out, int on)
{
	u32 val;

	if (pmic_reg_read(p, reg, &val))
34810778:	1a00000a 	bne	348107a8 <pmic_set_output+0x54>
3481077c:	e59d3004 	ldr	r3, [sp, #4]
		return -1;

	if (on)
34810780:	e3570000 	cmp	r7, #0
		val |= out;
34810784:	11834004 	orrne	r4, r3, r4
	else
		val &= ~out;
34810788:	01c34004 	biceq	r4, r3, r4
3481078c:	e58d4004 	str	r4, [sp, #4]

	if (pmic_reg_write(p, reg, val))
34810790:	e1a00006 	mov	r0, r6
34810794:	e1a01005 	mov	r1, r5
34810798:	e59d2004 	ldr	r2, [sp, #4]
3481079c:	eb000005 	bl	348107b8 <pmic_reg_write>
348107a0:	e3500000 	cmp	r0, #0
		return -1;
348107a4:	13e00000 	mvnne	r0, #0

	return 0;
}
348107a8:	e8bd80fe 	pop	{r1, r2, r3, r4, r5, r6, r7, pc}

348107ac <get_pmic>:
}

struct pmic *get_pmic(void)
{
	return &pmic;
}
348107ac:	e59f0000 	ldr	r0, [pc, #0]	; 348107b4 <get_pmic+0x8>
348107b0:	e12fff1e 	bx	lr
348107b4:	3482b16c 	.word	0x3482b16c

348107b8 <pmic_reg_write>:
#include <linux/types.h>
#include <pmic.h>
#include <i2c.h>

int pmic_reg_write(struct pmic *p, u32 reg, u32 val)
{
348107b8:	e92d407f 	push	{r0, r1, r2, r3, r4, r5, r6, lr}
	unsigned char buf[4] = { 0 };
348107bc:	e3a03000 	mov	r3, #0
#include <linux/types.h>
#include <pmic.h>
#include <i2c.h>

int pmic_reg_write(struct pmic *p, u32 reg, u32 val)
{
348107c0:	e1a04000 	mov	r4, r0
	unsigned char buf[4] = { 0 };

	if (check_reg(reg))
348107c4:	e1a00001 	mov	r0, r1
#include <linux/types.h>
#include <pmic.h>
#include <i2c.h>

int pmic_reg_write(struct pmic *p, u32 reg, u32 val)
{
348107c8:	e1a05001 	mov	r5, r1
348107cc:	e1a06002 	mov	r6, r2
	unsigned char buf[4] = { 0 };
348107d0:	e58d300c 	str	r3, [sp, #12]

	if (check_reg(reg))
348107d4:	ebffffd0 	bl	3481071c <check_reg>
348107d8:	e3500000 	cmp	r0, #0
348107dc:	1a00001a 	bne	3481084c <pmic_reg_write+0x94>
		return -1;

	switch (pmic_i2c_tx_num) {
348107e0:	e5d43010 	ldrb	r3, [r4, #16]
348107e4:	e3530001 	cmp	r3, #1
348107e8:	0a000007 	beq	3481080c <pmic_reg_write+0x54>
348107ec:	e3530003 	cmp	r3, #3
348107f0:	1a000007 	bne	34810814 <pmic_reg_write+0x5c>
	case 3:
		buf[0] = (val >> 16) & 0xff;
348107f4:	e1a02826 	lsr	r2, r6, #16
348107f8:	e5cd200c 	strb	r2, [sp, #12]
		buf[1] = (val >> 8) & 0xff;
348107fc:	e1a02426 	lsr	r2, r6, #8
34810800:	e5cd200d 	strb	r2, [sp, #13]
		buf[2] = val & 0xff;
34810804:	e5cd600e 	strb	r6, [sp, #14]
		break;
34810808:	ea000006 	b	34810828 <pmic_reg_write+0x70>
	case 1:
		buf[0] = val & 0xff;
3481080c:	e5cd600c 	strb	r6, [sp, #12]
		break;
34810810:	ea000004 	b	34810828 <pmic_reg_write+0x70>
	default:
		printf("%s: invalid tx_num: %d", __func__, pmic_i2c_tx_num);
34810814:	e59f103c 	ldr	r1, [pc, #60]	; 34810858 <pmic_reg_write+0xa0>
34810818:	e1a02003 	mov	r2, r3
3481081c:	e59f0038 	ldr	r0, [pc, #56]	; 3481085c <pmic_reg_write+0xa4>
34810820:	ebffe1c9 	bl	34808f4c <printf>
34810824:	ea000008 	b	3481084c <pmic_reg_write+0x94>
		return -1;
	}

	if (i2c_write(pmic_i2c_addr, reg, 1, buf, pmic_i2c_tx_num))
34810828:	e58d3000 	str	r3, [sp]
3481082c:	e5d40008 	ldrb	r0, [r4, #8]
34810830:	e1a01005 	mov	r1, r5
34810834:	e3a02001 	mov	r2, #1
34810838:	e28d300c 	add	r3, sp, #12
3481083c:	ebfffdc2 	bl	3480ff4c <i2c_write>
34810840:	e3500000 	cmp	r0, #0
		return -1;
34810844:	13e00000 	mvnne	r0, #0
34810848:	ea000000 	b	34810850 <pmic_reg_write+0x98>
int pmic_reg_write(struct pmic *p, u32 reg, u32 val)
{
	unsigned char buf[4] = { 0 };

	if (check_reg(reg))
		return -1;
3481084c:	e3e00000 	mvn	r0, #0

	if (i2c_write(pmic_i2c_addr, reg, 1, buf, pmic_i2c_tx_num))
		return -1;

	return 0;
}
34810850:	e28dd010 	add	sp, sp, #16
34810854:	e8bd8070 	pop	{r4, r5, r6, pc}
34810858:	3482178c 	.word	0x3482178c
3481085c:	34826e25 	.word	0x34826e25

34810860 <pmic_reg_read>:

int pmic_reg_read(struct pmic *p, u32 reg, u32 *val)
{
34810860:	e92d407f 	push	{r0, r1, r2, r3, r4, r5, r6, lr}
	unsigned char buf[4] = { 0 };
34810864:	e3a03000 	mov	r3, #0

	return 0;
}

int pmic_reg_read(struct pmic *p, u32 reg, u32 *val)
{
34810868:	e1a04000 	mov	r4, r0
	unsigned char buf[4] = { 0 };
	u32 ret_val = 0;

	if (check_reg(reg))
3481086c:	e1a00001 	mov	r0, r1

	return 0;
}

int pmic_reg_read(struct pmic *p, u32 reg, u32 *val)
{
34810870:	e1a06001 	mov	r6, r1
34810874:	e1a05002 	mov	r5, r2
	unsigned char buf[4] = { 0 };
34810878:	e58d300c 	str	r3, [sp, #12]
	u32 ret_val = 0;
3481087c:	e58d3008 	str	r3, [sp, #8]

	if (check_reg(reg))
34810880:	ebffffa5 	bl	3481071c <check_reg>
34810884:	e3500000 	cmp	r0, #0
34810888:	1a00001f 	bne	3481090c <pmic_reg_read+0xac>
		return -1;

	if (i2c_read(pmic_i2c_addr, reg, 1, buf, pmic_i2c_tx_num))
3481088c:	e5d43010 	ldrb	r3, [r4, #16]
34810890:	e5d40008 	ldrb	r0, [r4, #8]
34810894:	e58d3000 	str	r3, [sp]
34810898:	e1a01006 	mov	r1, r6
3481089c:	e3a02001 	mov	r2, #1
348108a0:	e28d300c 	add	r3, sp, #12
348108a4:	ebfffd4b 	bl	3480fdd8 <i2c_read>
348108a8:	e3500000 	cmp	r0, #0
348108ac:	1a000016 	bne	3481090c <pmic_reg_read+0xac>
		return -1;

	switch (pmic_i2c_tx_num) {
348108b0:	e5d42010 	ldrb	r2, [r4, #16]
348108b4:	e3520001 	cmp	r2, #1
348108b8:	0a000008 	beq	348108e0 <pmic_reg_read+0x80>
348108bc:	e3520003 	cmp	r2, #3
348108c0:	1a00000e 	bne	34810900 <pmic_reg_read+0xa0>
	case 3:
		ret_val = buf[0] << 16 | buf[1] << 8 | buf[2];
348108c4:	e5dd300d 	ldrb	r3, [sp, #13]
348108c8:	e5dd200c 	ldrb	r2, [sp, #12]
348108cc:	e1a03403 	lsl	r3, r3, #8
348108d0:	e1833802 	orr	r3, r3, r2, lsl #16
348108d4:	e5dd200e 	ldrb	r2, [sp, #14]
348108d8:	e1833002 	orr	r3, r3, r2
348108dc:	ea000000 	b	348108e4 <pmic_reg_read+0x84>
		break;
	case 1:
		ret_val = buf[0];
348108e0:	e5dd300c 	ldrb	r3, [sp, #12]
		break;
	default:
		printf("%s: invalid tx_num: %d", __func__, pmic_i2c_tx_num);
		return -1;
	}
	memcpy(val, &ret_val, sizeof(ret_val));
348108e4:	e1a00005 	mov	r0, r5
348108e8:	e28d1008 	add	r1, sp, #8
348108ec:	e3a02004 	mov	r2, #4
	switch (pmic_i2c_tx_num) {
	case 3:
		ret_val = buf[0] << 16 | buf[1] << 8 | buf[2];
		break;
	case 1:
		ret_val = buf[0];
348108f0:	e58d3008 	str	r3, [sp, #8]
		break;
	default:
		printf("%s: invalid tx_num: %d", __func__, pmic_i2c_tx_num);
		return -1;
	}
	memcpy(val, &ret_val, sizeof(ret_val));
348108f4:	eb002165 	bl	34818e90 <memcpy>

	return 0;
348108f8:	e3a00000 	mov	r0, #0
348108fc:	ea000003 	b	34810910 <pmic_reg_read+0xb0>
		break;
	case 1:
		ret_val = buf[0];
		break;
	default:
		printf("%s: invalid tx_num: %d", __func__, pmic_i2c_tx_num);
34810900:	e59f0010 	ldr	r0, [pc, #16]	; 34810918 <pmic_reg_read+0xb8>
34810904:	e59f1010 	ldr	r1, [pc, #16]	; 3481091c <pmic_reg_read+0xbc>
34810908:	ebffe18f 	bl	34808f4c <printf>

	if (check_reg(reg))
		return -1;

	if (i2c_read(pmic_i2c_addr, reg, 1, buf, pmic_i2c_tx_num))
		return -1;
3481090c:	e3e00000 	mvn	r0, #0
		return -1;
	}
	memcpy(val, &ret_val, sizeof(ret_val));

	return 0;
}
34810910:	e28dd010 	add	sp, sp, #16
34810914:	e8bd8070 	pop	{r4, r5, r6, pc}
34810918:	34826e25 	.word	0x34826e25
3481091c:	3482179c 	.word	0x3482179c

34810920 <pmic_probe>:

int pmic_probe(struct pmic *p)
{
34810920:	e92d4010 	push	{r4, lr}
34810924:	e1a04000 	mov	r4, r0

static inline void I2C_SET_BUS(unsigned int bus) __attribute__((always_inline));
static inline void I2C_SET_BUS(unsigned int bus)
{
	if (I2C_MULTI_BUS)
		i2c_set_bus_num(bus);
34810928:	e5d00004 	ldrb	r0, [r0, #4]
3481092c:	ebfffcf7 	bl	3480fd10 <i2c_set_bus_num>
	I2C_SET_BUS(p->bus);
	debug("PMIC:%s probed!\n", p->name);
	if (i2c_probe(pmic_i2c_addr)) {
34810930:	e5d40008 	ldrb	r0, [r4, #8]
34810934:	ebfffd1c 	bl	3480fdac <i2c_probe>
34810938:	e3500000 	cmp	r0, #0
3481093c:	08bd8010 	popeq	{r4, pc}
		printf("Can't find PMIC:%s\n", p->name);
34810940:	e5941000 	ldr	r1, [r4]
34810944:	e59f0008 	ldr	r0, [pc, #8]	; 34810954 <pmic_probe+0x34>
34810948:	ebffe17f 	bl	34808f4c <printf>
		return -1;
3481094c:	e3e00000 	mvn	r0, #0
	}

	return 0;
}
34810950:	e8bd8010 	pop	{r4, pc}
34810954:	34826e3c 	.word	0x34826e3c

34810958 <pmic_init>:
#include <common.h>
#include <pmic.h>
#include <max8998_pmic.h>

int pmic_init(void)
{
34810958:	e92d4010 	push	{r4, lr}
	struct pmic *p = get_pmic();
3481095c:	ebffff92 	bl	348107ac <get_pmic>
34810960:	e1a04000 	mov	r4, r0
	static const char name[] = "MAX8998_PMIC";

	puts("Board PMIC init\n");
34810964:	e59f0030 	ldr	r0, [pc, #48]	; 3481099c <pmic_init+0x44>
34810968:	ebffe16d 	bl	34808f24 <puts>

	p->name = name;
3481096c:	e59f302c 	ldr	r3, [pc, #44]	; 348109a0 <pmic_init+0x48>
	p->interface = PMIC_I2C;
34810970:	e3a00000 	mov	r0, #0
	struct pmic *p = get_pmic();
	static const char name[] = "MAX8998_PMIC";

	puts("Board PMIC init\n");

	p->name = name;
34810974:	e5843000 	str	r3, [r4]
	p->interface = PMIC_I2C;
	p->number_of_regs = PMIC_NUM_OF_REGS;
34810978:	e3a0302d 	mov	r3, #45	; 0x2d
3481097c:	e5c43006 	strb	r3, [r4, #6]
	p->hw.i2c.addr = MAX8998_I2C_ADDR;
34810980:	e2833039 	add	r3, r3, #57	; 0x39
34810984:	e5c43008 	strb	r3, [r4, #8]
	p->hw.i2c.tx_num = 1;
34810988:	e3a03001 	mov	r3, #1
	static const char name[] = "MAX8998_PMIC";

	puts("Board PMIC init\n");

	p->name = name;
	p->interface = PMIC_I2C;
3481098c:	e5c40005 	strb	r0, [r4, #5]
	p->number_of_regs = PMIC_NUM_OF_REGS;
	p->hw.i2c.addr = MAX8998_I2C_ADDR;
	p->hw.i2c.tx_num = 1;
34810990:	e5c43010 	strb	r3, [r4, #16]
	p->bus = I2C_PMIC;
34810994:	e5c40004 	strb	r0, [r4, #4]

	return 0;
}
34810998:	e8bd8010 	pop	{r4, pc}
3481099c:	34826e50 	.word	0x34826e50
348109a0:	348217ac 	.word	0x348217ac

348109a4 <__fswab32>:
348109a4:	e6bf0f30 	rev	r0, r0
348109a8:	e12fff1e 	bx	lr

348109ac <__board_mmc_getcd>:
static struct list_head mmc_devices;
static int cur_dev_num = -1;

int __board_mmc_getcd(struct mmc *mmc) {
	return -1;
}
348109ac:	e3e00000 	mvn	r0, #0
348109b0:	e12fff1e 	bx	lr

348109b4 <mmc_send_cmd>:
static inline void mmc_bounce_buffer_stop(struct mmc_data *backup,
					struct mmc_data *orig) { }
#endif

int mmc_send_cmd(struct mmc *mmc, struct mmc_cmd *cmd, struct mmc_data *data)
{
348109b4:	e92d407f 	push	{r0, r1, r2, r3, r4, r5, r6, lr}
348109b8:	e1a04000 	mov	r4, r0
348109bc:	e1a06001 	mov	r6, r1
348109c0:	e1a05002 	mov	r5, r2
	struct mmc_data backup;
	int ret;

	memset(&backup, 0, sizeof(backup));
348109c4:	e1a0000d 	mov	r0, sp
348109c8:	e3a01000 	mov	r1, #0
348109cc:	e3a02010 	mov	r2, #16
348109d0:	eb00210a 	bl	34818e00 <memset>
		default:
			printf("\t\tERROR MMC rsp not supported\n");
			break;
	}
#else
	ret = mmc->send_cmd(mmc, cmd, data);
348109d4:	e5943110 	ldr	r3, [r4, #272]	; 0x110
348109d8:	e1a00004 	mov	r0, r4
348109dc:	e1a01006 	mov	r1, r6
348109e0:	e1a02005 	mov	r2, r5
348109e4:	e12fff33 	blx	r3
#endif
	mmc_bounce_buffer_stop(&backup, data);
	return ret;
}
348109e8:	e28dd010 	add	sp, sp, #16
348109ec:	e8bd8070 	pop	{r4, r5, r6, pc}

348109f0 <mmc_send_status>:

int mmc_send_status(struct mmc *mmc, int timeout)
{
348109f0:	e92d40f0 	push	{r4, r5, r6, r7, lr}
	int err, retries = 5;
#ifdef CONFIG_MMC_TRACE
	int status;
#endif

	cmd.cmdidx = MMC_CMD_SEND_STATUS;
348109f4:	e3a0300d 	mov	r3, #13
	mmc_bounce_buffer_stop(&backup, data);
	return ret;
}

int mmc_send_status(struct mmc *mmc, int timeout)
{
348109f8:	e24dd024 	sub	sp, sp, #36	; 0x24
	int err, retries = 5;
#ifdef CONFIG_MMC_TRACE
	int status;
#endif

	cmd.cmdidx = MMC_CMD_SEND_STATUS;
348109fc:	e1cd30b4 	strh	r3, [sp, #4]
	cmd.resp_type = MMC_RSP_R1;
34810a00:	e3a03015 	mov	r3, #21
34810a04:	e58d3008 	str	r3, [sp, #8]
	if (!mmc_host_is_spi(mmc))
34810a08:	e5903050 	ldr	r3, [r0, #80]	; 0x50
	mmc_bounce_buffer_stop(&backup, data);
	return ret;
}

int mmc_send_status(struct mmc *mmc, int timeout)
{
34810a0c:	e1a06000 	mov	r6, r0
	int status;
#endif

	cmd.cmdidx = MMC_CMD_SEND_STATUS;
	cmd.resp_type = MMC_RSP_R1;
	if (!mmc_host_is_spi(mmc))
34810a10:	e3130b01 	tst	r3, #1024	; 0x400
		cmd.cmdarg = mmc->rca << 16;
34810a14:	01d038b0 	ldrheq	r3, [r0, #128]	; 0x80
	mmc_bounce_buffer_stop(&backup, data);
	return ret;
}

int mmc_send_status(struct mmc *mmc, int timeout)
{
34810a18:	e1a04001 	mov	r4, r1
#endif

	cmd.cmdidx = MMC_CMD_SEND_STATUS;
	cmd.resp_type = MMC_RSP_R1;
	if (!mmc_host_is_spi(mmc))
		cmd.cmdarg = mmc->rca << 16;
34810a1c:	01a03803 	lsleq	r3, r3, #16
34810a20:	058d300c 	streq	r3, [sp, #12]
	mmc_bounce_buffer_stop(&backup, data);
	return ret;
}

int mmc_send_status(struct mmc *mmc, int timeout)
{
34810a24:	e3a05005 	mov	r5, #5
	cmd.resp_type = MMC_RSP_R1;
	if (!mmc_host_is_spi(mmc))
		cmd.cmdarg = mmc->rca << 16;

	do {
		err = mmc_send_cmd(mmc, &cmd, NULL);
34810a28:	e28d7004 	add	r7, sp, #4
34810a2c:	e1a00006 	mov	r0, r6
34810a30:	e1a01007 	mov	r1, r7
34810a34:	e3a02000 	mov	r2, #0
34810a38:	ebffffdd 	bl	348109b4 <mmc_send_cmd>
		if (!err) {
34810a3c:	e3500000 	cmp	r0, #0
34810a40:	1a00000d 	bne	34810a7c <mmc_send_status+0x8c>
			if ((cmd.response[0] & MMC_STATUS_RDY_FOR_DATA) &&
34810a44:	e59d1010 	ldr	r1, [sp, #16]
34810a48:	e3110c01 	tst	r1, #256	; 0x100
34810a4c:	0a000002 	beq	34810a5c <mmc_send_status+0x6c>
			    (cmd.response[0] & MMC_STATUS_CURR_STATE) !=
34810a50:	e2013c1e 	and	r3, r1, #7680	; 0x1e00
		cmd.cmdarg = mmc->rca << 16;

	do {
		err = mmc_send_cmd(mmc, &cmd, NULL);
		if (!err) {
			if ((cmd.response[0] & MMC_STATUS_RDY_FOR_DATA) &&
34810a54:	e3530c0e 	cmp	r3, #3584	; 0xe00
34810a58:	1a00000d 	bne	34810a94 <mmc_send_status+0xa4>
			    (cmd.response[0] & MMC_STATUS_CURR_STATE) !=
			     MMC_STATE_PRG)
				break;
			else if (cmd.response[0] & MMC_STATUS_MASK) {
34810a5c:	e59f3050 	ldr	r3, [pc, #80]	; 34810ab4 <mmc_send_status+0xc4>
34810a60:	e0013003 	and	r3, r1, r3
34810a64:	e3530000 	cmp	r3, #0
34810a68:	0a000005 	beq	34810a84 <mmc_send_status+0x94>
				printf("Status Error: 0x%08X\n",
34810a6c:	e59f0044 	ldr	r0, [pc, #68]	; 34810ab8 <mmc_send_status+0xc8>
34810a70:	ebffe135 	bl	34808f4c <printf>
					cmd.response[0]);
				return COMM_ERR;
34810a74:	e3e00011 	mvn	r0, #17
34810a78:	ea00000b 	b	34810aac <mmc_send_status+0xbc>
			}
		} else if (--retries < 0)
34810a7c:	e2555001 	subs	r5, r5, #1
34810a80:	4a000009 	bmi	34810aac <mmc_send_status+0xbc>
			return err;

		udelay(1000);
34810a84:	e3a00ffa 	mov	r0, #1000	; 0x3e8
34810a88:	eb00218b 	bl	348190bc <udelay>

	} while (timeout--);
34810a8c:	e2544001 	subs	r4, r4, #1
34810a90:	2affffe5 	bcs	34810a2c <mmc_send_status+0x3c>

#ifdef CONFIG_MMC_TRACE
	status = (cmd.response[0] & MMC_STATUS_CURR_STATE) >> 9;
	printf("CURR STATE:%d\n", status);
#endif
	if (timeout <= 0) {
34810a94:	e3540000 	cmp	r4, #0
		printf("Timeout waiting card ready\n");
		return TIMEOUT;
	}

	return 0;
34810a98:	c3a00000 	movgt	r0, #0

#ifdef CONFIG_MMC_TRACE
	status = (cmd.response[0] & MMC_STATUS_CURR_STATE) >> 9;
	printf("CURR STATE:%d\n", status);
#endif
	if (timeout <= 0) {
34810a9c:	ca000002 	bgt	34810aac <mmc_send_status+0xbc>
		printf("Timeout waiting card ready\n");
34810aa0:	e59f0014 	ldr	r0, [pc, #20]	; 34810abc <mmc_send_status+0xcc>
34810aa4:	ebffe128 	bl	34808f4c <printf>
		return TIMEOUT;
34810aa8:	e3e00012 	mvn	r0, #18
	}

	return 0;
}
34810aac:	e28dd024 	add	sp, sp, #36	; 0x24
34810ab0:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
34810ab4:	fdf94080 	.word	0xfdf94080
34810ab8:	34826e61 	.word	0x34826e61
34810abc:	34826e77 	.word	0x34826e77

34810ac0 <mmc_set_blocklen>:

int mmc_set_blocklen(struct mmc *mmc, int len)
{
34810ac0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
	struct mmc_cmd cmd;

	cmd.cmdidx = MMC_CMD_SET_BLOCKLEN;
34810ac4:	e3a03010 	mov	r3, #16

	return 0;
}

int mmc_set_blocklen(struct mmc *mmc, int len)
{
34810ac8:	e24dd024 	sub	sp, sp, #36	; 0x24
	struct mmc_cmd cmd;

	cmd.cmdidx = MMC_CMD_SET_BLOCKLEN;
34810acc:	e1cd30b4 	strh	r3, [sp, #4]
	cmd.resp_type = MMC_RSP_R1;
	cmd.cmdarg = len;
34810ad0:	e58d100c 	str	r1, [sp, #12]
int mmc_set_blocklen(struct mmc *mmc, int len)
{
	struct mmc_cmd cmd;

	cmd.cmdidx = MMC_CMD_SET_BLOCKLEN;
	cmd.resp_type = MMC_RSP_R1;
34810ad4:	e3a03015 	mov	r3, #21
	cmd.cmdarg = len;

	return mmc_send_cmd(mmc, &cmd, NULL);
34810ad8:	e28d1004 	add	r1, sp, #4
34810adc:	e3a02000 	mov	r2, #0
int mmc_set_blocklen(struct mmc *mmc, int len)
{
	struct mmc_cmd cmd;

	cmd.cmdidx = MMC_CMD_SET_BLOCKLEN;
	cmd.resp_type = MMC_RSP_R1;
34810ae0:	e58d3008 	str	r3, [sp, #8]
	cmd.cmdarg = len;

	return mmc_send_cmd(mmc, &cmd, NULL);
34810ae4:	ebffffb2 	bl	348109b4 <mmc_send_cmd>
}
34810ae8:	e28dd024 	add	sp, sp, #36	; 0x24
34810aec:	e8bd8000 	pop	{pc}

34810af0 <find_mmc_device>:
struct mmc *find_mmc_device(int dev_num)
{
	struct mmc *m;
	struct list_head *entry;

	list_for_each(entry, &mmc_devices) {
34810af0:	e59f2038 	ldr	r2, [pc, #56]	; 34810b30 <find_mmc_device+0x40>

	return mmc_send_cmd(mmc, &cmd, NULL);
}

struct mmc *find_mmc_device(int dev_num)
{
34810af4:	e92d4008 	push	{r3, lr}
34810af8:	e1a01000 	mov	r1, r0
	struct mmc *m;
	struct list_head *entry;

	list_for_each(entry, &mmc_devices) {
34810afc:	e5923000 	ldr	r3, [r2]
34810b00:	ea000004 	b	34810b18 <find_mmc_device+0x28>
		m = list_entry(entry, struct mmc, link);

		if (m->block_dev.dev == dev_num)
34810b04:	e593c0a4 	ldr	ip, [r3, #164]	; 0xa4
{
	struct mmc *m;
	struct list_head *entry;

	list_for_each(entry, &mmc_devices) {
		m = list_entry(entry, struct mmc, link);
34810b08:	e1a00003 	mov	r0, r3

		if (m->block_dev.dev == dev_num)
34810b0c:	e15c0001 	cmp	ip, r1
34810b10:	08bd8008 	popeq	{r3, pc}
struct mmc *find_mmc_device(int dev_num)
{
	struct mmc *m;
	struct list_head *entry;

	list_for_each(entry, &mmc_devices) {
34810b14:	e5933000 	ldr	r3, [r3]
34810b18:	e1530002 	cmp	r3, r2
34810b1c:	1afffff8 	bne	34810b04 <find_mmc_device+0x14>

		if (m->block_dev.dev == dev_num)
			return m;
	}

	printf("MMC Device %d not found\n", dev_num);
34810b20:	e59f000c 	ldr	r0, [pc, #12]	; 34810b34 <find_mmc_device+0x44>
34810b24:	ebffe108 	bl	34808f4c <printf>

	return NULL;
34810b28:	e3a00000 	mov	r0, #0
}
34810b2c:	e8bd8008 	pop	{r3, pc}
34810b30:	3482b18c 	.word	0x3482b18c
34810b34:	34826e93 	.word	0x34826e93

34810b38 <mmc_berase>:
	return err;
}

static unsigned long
mmc_berase(int dev_num, unsigned long start, lbaint_t blkcnt)
{
34810b38:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
34810b3c:	e24dd028 	sub	sp, sp, #40	; 0x28
34810b40:	e1a05001 	mov	r5, r1
34810b44:	e1a06002 	mov	r6, r2
	int err = 0;
	struct mmc *mmc = find_mmc_device(dev_num);
34810b48:	ebffffe8 	bl	34810af0 <find_mmc_device>
	lbaint_t blk = 0, blk_r = 0;
	int timeout = 1000;

	if (!mmc)
34810b4c:	e2504000 	subs	r4, r0, #0
		return -1;
34810b50:	03e07000 	mvneq	r7, #0
	int err = 0;
	struct mmc *mmc = find_mmc_device(dev_num);
	lbaint_t blk = 0, blk_r = 0;
	int timeout = 1000;

	if (!mmc)
34810b54:	0a000056 	beq	34810cb4 <mmc_berase+0x17c>
		return -1;

	if ((start % mmc->erase_grp_size) || (blkcnt % mmc->erase_grp_size))
34810b58:	e5947090 	ldr	r7, [r4, #144]	; 0x90
34810b5c:	e1a00005 	mov	r0, r5
34810b60:	e1a01007 	mov	r1, r7
34810b64:	eb003d49 	bl	34820090 <__aeabi_uidivmod>
34810b68:	e3510000 	cmp	r1, #0
34810b6c:	1a000004 	bne	34810b84 <mmc_berase+0x4c>
34810b70:	e1a00006 	mov	r0, r6
34810b74:	e1a01007 	mov	r1, r7
34810b78:	eb003d44 	bl	34820090 <__aeabi_uidivmod>
34810b7c:	e3510000 	cmp	r1, #0
34810b80:	0a000045 	beq	34810c9c <mmc_berase+0x164>
		printf("\n\nCaution! Your devices Erase group is 0x%x\n"
			"The erase range would be change to 0x%lx~0x%lx\n\n",
		       mmc->erase_grp_size, start & ~(mmc->erase_grp_size - 1),
		       ((start + blkcnt + mmc->erase_grp_size)
34810b84:	e0853007 	add	r3, r5, r7
		return -1;

	if ((start % mmc->erase_grp_size) || (blkcnt % mmc->erase_grp_size))
		printf("\n\nCaution! Your devices Erase group is 0x%x\n"
			"The erase range would be change to 0x%lx~0x%lx\n\n",
		       mmc->erase_grp_size, start & ~(mmc->erase_grp_size - 1),
34810b88:	e2672000 	rsb	r2, r7, #0
		       ((start + blkcnt + mmc->erase_grp_size)
34810b8c:	e0833006 	add	r3, r3, r6
		       & ~(mmc->erase_grp_size - 1)) - 1);
34810b90:	e0033002 	and	r3, r3, r2

	if (!mmc)
		return -1;

	if ((start % mmc->erase_grp_size) || (blkcnt % mmc->erase_grp_size))
		printf("\n\nCaution! Your devices Erase group is 0x%x\n"
34810b94:	e1a01007 	mov	r1, r7
34810b98:	e0052002 	and	r2, r5, r2
34810b9c:	e2433001 	sub	r3, r3, #1
34810ba0:	e59f0118 	ldr	r0, [pc, #280]	; 34810cc0 <mmc_berase+0x188>
34810ba4:	ebffe0e8 	bl	34808f4c <printf>
34810ba8:	ea00003b 	b	34810c9c <mmc_berase+0x164>
		       mmc->erase_grp_size, start & ~(mmc->erase_grp_size - 1),
		       ((start + blkcnt + mmc->erase_grp_size)
		       & ~(mmc->erase_grp_size - 1)) - 1);

	while (blk < blkcnt) {
		blk_r = ((blkcnt - blk) > mmc->erase_grp_size) ?
34810bac:	e5943090 	ldr	r3, [r4, #144]	; 0x90
			mmc->erase_grp_size : (blkcnt - blk);
34810bb0:	e067a006 	rsb	sl, r7, r6
		       mmc->erase_grp_size, start & ~(mmc->erase_grp_size - 1),
		       ((start + blkcnt + mmc->erase_grp_size)
		       & ~(mmc->erase_grp_size - 1)) - 1);

	while (blk < blkcnt) {
		blk_r = ((blkcnt - blk) > mmc->erase_grp_size) ?
34810bb4:	e15a0003 	cmp	sl, r3
34810bb8:	21a0a003 	movcs	sl, r3
{
	struct mmc_cmd cmd;
	ulong end;
	int err, start_cmd, end_cmd;

	if (mmc->high_capacity)
34810bbc:	e5943040 	ldr	r3, [r4, #64]	; 0x40
		       & ~(mmc->erase_grp_size - 1)) - 1);

	while (blk < blkcnt) {
		blk_r = ((blkcnt - blk) > mmc->erase_grp_size) ?
			mmc->erase_grp_size : (blkcnt - blk);
		err = mmc_erase_t(mmc, start + blk, blk_r);
34810bc0:	e0872005 	add	r2, r7, r5
{
	struct mmc_cmd cmd;
	ulong end;
	int err, start_cmd, end_cmd;

	if (mmc->high_capacity)
34810bc4:	e3530000 	cmp	r3, #0
		end = start + blkcnt - 1;
	else {
		end = (start + blkcnt - 1) * mmc->write_bl_len;
34810bc8:	0594308c 	ldreq	r3, [r4, #140]	; 0x8c
34810bcc:	e242b001 	sub	fp, r2, #1
34810bd0:	008bb00a 	addeq	fp, fp, sl
		start *= mmc->write_bl_len;
34810bd4:	00020293 	muleq	r2, r3, r2
	int err, start_cmd, end_cmd;

	if (mmc->high_capacity)
		end = start + blkcnt - 1;
	else {
		end = (start + blkcnt - 1) * mmc->write_bl_len;
34810bd8:	000b0b93 	muleq	fp, r3, fp
		start *= mmc->write_bl_len;
	}

	if (IS_SD(mmc)) {
34810bdc:	e5943030 	ldr	r3, [r4, #48]	; 0x30
	struct mmc_cmd cmd;
	ulong end;
	int err, start_cmd, end_cmd;

	if (mmc->high_capacity)
		end = start + blkcnt - 1;
34810be0:	108bb00a 	addne	fp, fp, sl
	else {
		end = (start + blkcnt - 1) * mmc->write_bl_len;
		start *= mmc->write_bl_len;
	}

	if (IS_SD(mmc)) {
34810be4:	e2033802 	and	r3, r3, #131072	; 0x20000
		start_cmd = SD_CMD_ERASE_WR_BLK_START;
		end_cmd = SD_CMD_ERASE_WR_BLK_END;
34810be8:	e3530000 	cmp	r3, #0
34810bec:	03a01023 	moveq	r1, #35	; 0x23
34810bf0:	13a01020 	movne	r1, #32
		start_cmd = MMC_CMD_ERASE_GROUP_START;
		end_cmd = MMC_CMD_ERASE_GROUP_END;
	}

	cmd.cmdidx = start_cmd;
	cmd.cmdarg = start;
34810bf4:	e58d2014 	str	r2, [sp, #20]
	cmd.resp_type = MMC_RSP_R1;
34810bf8:	e3a02015 	mov	r2, #21
		start *= mmc->write_bl_len;
	}

	if (IS_SD(mmc)) {
		start_cmd = SD_CMD_ERASE_WR_BLK_START;
		end_cmd = SD_CMD_ERASE_WR_BLK_END;
34810bfc:	03a03024 	moveq	r3, #36	; 0x24
34810c00:	13a03021 	movne	r3, #33	; 0x21
	} else {
		start_cmd = MMC_CMD_ERASE_GROUP_START;
		end_cmd = MMC_CMD_ERASE_GROUP_END;
	}

	cmd.cmdidx = start_cmd;
34810c04:	e1cd10bc 	strh	r1, [sp, #12]
	cmd.cmdarg = start;
	cmd.resp_type = MMC_RSP_R1;
34810c08:	e58d2010 	str	r2, [sp, #16]

	err = mmc_send_cmd(mmc, &cmd, NULL);
34810c0c:	e1a00004 	mov	r0, r4
34810c10:	e3a02000 	mov	r2, #0
34810c14:	e1a01009 	mov	r1, r9
34810c18:	e58d3004 	str	r3, [sp, #4]
34810c1c:	ebffff64 	bl	348109b4 <mmc_send_cmd>
	if (err)
34810c20:	e2502000 	subs	r2, r0, #0
34810c24:	e59d3004 	ldr	r3, [sp, #4]
34810c28:	1a000011 	bne	34810c74 <mmc_berase+0x13c>
		goto err_out;

	cmd.cmdidx = end_cmd;
	cmd.cmdarg = end;

	err = mmc_send_cmd(mmc, &cmd, NULL);
34810c2c:	e1a00004 	mov	r0, r4
34810c30:	e1a01009 	mov	r1, r9

	err = mmc_send_cmd(mmc, &cmd, NULL);
	if (err)
		goto err_out;

	cmd.cmdidx = end_cmd;
34810c34:	e1cd30bc 	strh	r3, [sp, #12]
	cmd.cmdarg = end;
34810c38:	e58db014 	str	fp, [sp, #20]

	err = mmc_send_cmd(mmc, &cmd, NULL);
34810c3c:	ebffff5c 	bl	348109b4 <mmc_send_cmd>
	if (err)
34810c40:	e2502000 	subs	r2, r0, #0
34810c44:	1a00000a 	bne	34810c74 <mmc_berase+0x13c>
		goto err_out;

	cmd.cmdidx = MMC_CMD_ERASE;
34810c48:	e3a03026 	mov	r3, #38	; 0x26
34810c4c:	e1cd30bc 	strh	r3, [sp, #12]
	cmd.cmdarg = SECURE_ERASE;
34810c50:	e3a03102 	mov	r3, #-2147483648	; 0x80000000
34810c54:	e58d3014 	str	r3, [sp, #20]
	cmd.resp_type = MMC_RSP_R1b;

	err = mmc_send_cmd(mmc, &cmd, NULL);
34810c58:	e1a00004 	mov	r0, r4
	if (err)
		goto err_out;

	cmd.cmdidx = MMC_CMD_ERASE;
	cmd.cmdarg = SECURE_ERASE;
	cmd.resp_type = MMC_RSP_R1b;
34810c5c:	e2833176 	add	r3, r3, #-2147483619	; 0x8000001d

	err = mmc_send_cmd(mmc, &cmd, NULL);
34810c60:	e1a01009 	mov	r1, r9
	if (err)
		goto err_out;

	cmd.cmdidx = MMC_CMD_ERASE;
	cmd.cmdarg = SECURE_ERASE;
	cmd.resp_type = MMC_RSP_R1b;
34810c64:	e58d3010 	str	r3, [sp, #16]

	err = mmc_send_cmd(mmc, &cmd, NULL);
34810c68:	ebffff51 	bl	348109b4 <mmc_send_cmd>
	if (err)
34810c6c:	e250b000 	subs	fp, r0, #0
34810c70:	0a000002 	beq	34810c80 <mmc_berase+0x148>
		goto err_out;

	return 0;

err_out:
	puts("mmc erase failed\n");
34810c74:	e59f0048 	ldr	r0, [pc, #72]	; 34810cc4 <mmc_berase+0x18c>
34810c78:	ebffe0a9 	bl	34808f24 <puts>
34810c7c:	ea00000c 	b	34810cb4 <mmc_berase+0x17c>
			break;

		blk += blk_r;

		/* Waiting for the ready status */
		if (mmc_send_status(mmc, timeout))
34810c80:	e1a00004 	mov	r0, r4
34810c84:	e3a01ffa 	mov	r1, #1000	; 0x3e8
34810c88:	ebffff58 	bl	348109f0 <mmc_send_status>
34810c8c:	e3500000 	cmp	r0, #0
34810c90:	1a000006 	bne	34810cb0 <mmc_berase+0x178>
			mmc->erase_grp_size : (blkcnt - blk);
		err = mmc_erase_t(mmc, start + blk, blk_r);
		if (err)
			break;

		blk += blk_r;
34810c94:	e087700a 	add	r7, r7, sl
34810c98:	ea000001 	b	34810ca4 <mmc_berase+0x16c>

	if (IS_SD(mmc)) {
		start_cmd = SD_CMD_ERASE_WR_BLK_START;
		end_cmd = SD_CMD_ERASE_WR_BLK_END;
	} else {
		start_cmd = MMC_CMD_ERASE_GROUP_START;
34810c9c:	e3a07000 	mov	r7, #0

	cmd.cmdidx = start_cmd;
	cmd.cmdarg = start;
	cmd.resp_type = MMC_RSP_R1;

	err = mmc_send_cmd(mmc, &cmd, NULL);
34810ca0:	e28d900c 	add	r9, sp, #12
			"The erase range would be change to 0x%lx~0x%lx\n\n",
		       mmc->erase_grp_size, start & ~(mmc->erase_grp_size - 1),
		       ((start + blkcnt + mmc->erase_grp_size)
		       & ~(mmc->erase_grp_size - 1)) - 1);

	while (blk < blkcnt) {
34810ca4:	e1570006 	cmp	r7, r6
34810ca8:	3affffbf 	bcc	34810bac <mmc_berase+0x74>
34810cac:	ea000000 	b	34810cb4 <mmc_berase+0x17c>

		blk += blk_r;

		/* Waiting for the ready status */
		if (mmc_send_status(mmc, timeout))
			return 0;
34810cb0:	e1a0700b 	mov	r7, fp
	}

	return blk;
}
34810cb4:	e1a00007 	mov	r0, r7
34810cb8:	e28dd028 	add	sp, sp, #40	; 0x28
34810cbc:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
34810cc0:	34826eac 	.word	0x34826eac
34810cc4:	34826f09 	.word	0x34826f09

34810cc8 <mmc_bwrite>:
	return blkcnt;
}

static ulong
mmc_bwrite(int dev_num, ulong start, lbaint_t blkcnt, const void*src)
{
34810cc8:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
34810ccc:	e24dd030 	sub	sp, sp, #48	; 0x30
34810cd0:	e1a04002 	mov	r4, r2
34810cd4:	e1a05001 	mov	r5, r1
34810cd8:	e1a09003 	mov	r9, r3
	lbaint_t cur, blocks_todo = blkcnt;

	struct mmc *mmc = find_mmc_device(dev_num);
34810cdc:	ebffff83 	bl	34810af0 <find_mmc_device>
	if (!mmc)
34810ce0:	e2506000 	subs	r6, r0, #0
		return 0;
34810ce4:	01a04006 	moveq	r4, r6
mmc_bwrite(int dev_num, ulong start, lbaint_t blkcnt, const void*src)
{
	lbaint_t cur, blocks_todo = blkcnt;

	struct mmc *mmc = find_mmc_device(dev_num);
	if (!mmc)
34810ce8:	0a000052 	beq	34810e38 <mmc_bwrite+0x170>
		return 0;

	if (mmc_set_blocklen(mmc, mmc->write_bl_len))
34810cec:	e596108c 	ldr	r1, [r6, #140]	; 0x8c
34810cf0:	ebffff72 	bl	34810ac0 <mmc_set_blocklen>
34810cf4:	e3500000 	cmp	r0, #0
34810cf8:	1a00004b 	bne	34810e2c <mmc_bwrite+0x164>
34810cfc:	e1a0b004 	mov	fp, r4
	 * token, not a STOP_TRANSMISSION request.
	 */
	if (!mmc_host_is_spi(mmc) && blkcnt > 1) {
		cmd.cmdidx = MMC_CMD_STOP_TRANSMISSION;
		cmd.cmdarg = 0;
		cmd.resp_type = MMC_RSP_R1b;
34810d00:	e1a0a004 	mov	sl, r4

	if (mmc_set_blocklen(mmc, mmc->write_bl_len))
		return 0;

	do {
		cur = (blocks_todo > mmc->b_max) ?  mmc->b_max : blocks_todo;
34810d04:	e5964120 	ldr	r4, [r6, #288]	; 0x120
{
	struct mmc_cmd cmd;
	struct mmc_data data;
	int timeout = 1000;

	if ((start + blkcnt) > mmc->block_dev.lba) {
34810d08:	e59620b0 	ldr	r2, [r6, #176]	; 0xb0

	if (mmc_set_blocklen(mmc, mmc->write_bl_len))
		return 0;

	do {
		cur = (blocks_todo > mmc->b_max) ?  mmc->b_max : blocks_todo;
34810d0c:	e15b0004 	cmp	fp, r4
34810d10:	31a0400b 	movcc	r4, fp
{
	struct mmc_cmd cmd;
	struct mmc_data data;
	int timeout = 1000;

	if ((start + blkcnt) > mmc->block_dev.lba) {
34810d14:	e0847005 	add	r7, r4, r5
34810d18:	e1570002 	cmp	r7, r2
34810d1c:	9a000003 	bls	34810d30 <mmc_bwrite+0x68>
		printf("MMC: block number 0x%lx exceeds max(0x%lx)\n",
34810d20:	e1a01007 	mov	r1, r7
34810d24:	e59f0118 	ldr	r0, [pc, #280]	; 34810e44 <mmc_bwrite+0x17c>
34810d28:	ebffe087 	bl	34808f4c <printf>
34810d2c:	ea000036 	b	34810e0c <mmc_bwrite+0x144>
			start + blkcnt, mmc->block_dev.lba);
		return 0;
	}

	if (blkcnt > 1)
34810d30:	e3540001 	cmp	r4, #1
		cmd.cmdidx = MMC_CMD_WRITE_MULTIPLE_BLOCK;
34810d34:	83a03019 	movhi	r3, #25
	else
		cmd.cmdidx = MMC_CMD_WRITE_SINGLE_BLOCK;
34810d38:	93a03018 	movls	r3, #24
34810d3c:	e1cd30b4 	strh	r3, [sp, #4]

	if (mmc->high_capacity)
34810d40:	e5963040 	ldr	r3, [r6, #64]	; 0x40
	data.src = src;
	data.blocks = blkcnt;
	data.blocksize = mmc->write_bl_len;
	data.flags = MMC_DATA_WRITE;

	if (mmc_send_cmd(mmc, &cmd, &data)) {
34810d44:	e1a00006 	mov	r0, r6
	if (blkcnt > 1)
		cmd.cmdidx = MMC_CMD_WRITE_MULTIPLE_BLOCK;
	else
		cmd.cmdidx = MMC_CMD_WRITE_SINGLE_BLOCK;

	if (mmc->high_capacity)
34810d48:	e3530000 	cmp	r3, #0
		cmd.cmdarg = start;
	else
		cmd.cmdarg = start * mmc->write_bl_len;
34810d4c:	0596308c 	ldreq	r3, [r6, #140]	; 0x8c
	data.src = src;
	data.blocks = blkcnt;
	data.blocksize = mmc->write_bl_len;
	data.flags = MMC_DATA_WRITE;

	if (mmc_send_cmd(mmc, &cmd, &data)) {
34810d50:	e28d1004 	add	r1, sp, #4
		cmd.cmdidx = MMC_CMD_WRITE_SINGLE_BLOCK;

	if (mmc->high_capacity)
		cmd.cmdarg = start;
	else
		cmd.cmdarg = start * mmc->write_bl_len;
34810d54:	00050593 	muleq	r5, r3, r5

	cmd.resp_type = MMC_RSP_R1;
34810d58:	e3a03015 	mov	r3, #21
34810d5c:	e58d3008 	str	r3, [sp, #8]

	data.src = src;
	data.blocks = blkcnt;
	data.blocksize = mmc->write_bl_len;
34810d60:	e596308c 	ldr	r3, [r6, #140]	; 0x8c
	data.flags = MMC_DATA_WRITE;

	if (mmc_send_cmd(mmc, &cmd, &data)) {
34810d64:	e28d2020 	add	r2, sp, #32

	cmd.resp_type = MMC_RSP_R1;

	data.src = src;
	data.blocks = blkcnt;
	data.blocksize = mmc->write_bl_len;
34810d68:	e58d302c 	str	r3, [sp, #44]	; 0x2c
	data.flags = MMC_DATA_WRITE;
34810d6c:	e3a03002 	mov	r3, #2
		cmd.cmdidx = MMC_CMD_WRITE_SINGLE_BLOCK;

	if (mmc->high_capacity)
		cmd.cmdarg = start;
	else
		cmd.cmdarg = start * mmc->write_bl_len;
34810d70:	e58d500c 	str	r5, [sp, #12]

	cmd.resp_type = MMC_RSP_R1;

	data.src = src;
34810d74:	e58d9020 	str	r9, [sp, #32]
	data.blocks = blkcnt;
34810d78:	e58d4028 	str	r4, [sp, #40]	; 0x28
	data.blocksize = mmc->write_bl_len;
	data.flags = MMC_DATA_WRITE;
34810d7c:	e58d3024 	str	r3, [sp, #36]	; 0x24

	if (mmc_send_cmd(mmc, &cmd, &data)) {
34810d80:	ebffff0b 	bl	348109b4 <mmc_send_cmd>
34810d84:	e2505000 	subs	r5, r0, #0
34810d88:	0a000002 	beq	34810d98 <mmc_bwrite+0xd0>
		printf("mmc write failed\n");
34810d8c:	e59f00b4 	ldr	r0, [pc, #180]	; 34810e48 <mmc_bwrite+0x180>
34810d90:	ebffe06d 	bl	34808f4c <printf>
34810d94:	ea00001c 	b	34810e0c <mmc_bwrite+0x144>
	}

	/* SPI multiblock writes terminate using a special
	 * token, not a STOP_TRANSMISSION request.
	 */
	if (!mmc_host_is_spi(mmc) && blkcnt > 1) {
34810d98:	e5963050 	ldr	r3, [r6, #80]	; 0x50
34810d9c:	e3130b01 	tst	r3, #1024	; 0x400
34810da0:	13a03000 	movne	r3, #0
34810da4:	03a03001 	moveq	r3, #1
34810da8:	e3540001 	cmp	r4, #1
34810dac:	93a03000 	movls	r3, #0
34810db0:	82033001 	andhi	r3, r3, #1
34810db4:	e3530000 	cmp	r3, #0
34810db8:	0a00000e 	beq	34810df8 <mmc_bwrite+0x130>
		cmd.cmdidx = MMC_CMD_STOP_TRANSMISSION;
34810dbc:	e3a0300c 	mov	r3, #12
34810dc0:	e1cd30b4 	strh	r3, [sp, #4]
		cmd.cmdarg = 0;
		cmd.resp_type = MMC_RSP_R1b;
		if (mmc_send_cmd(mmc, &cmd, NULL)) {
34810dc4:	e1a00006 	mov	r0, r6
	 * token, not a STOP_TRANSMISSION request.
	 */
	if (!mmc_host_is_spi(mmc) && blkcnt > 1) {
		cmd.cmdidx = MMC_CMD_STOP_TRANSMISSION;
		cmd.cmdarg = 0;
		cmd.resp_type = MMC_RSP_R1b;
34810dc8:	e3a0301d 	mov	r3, #29
		if (mmc_send_cmd(mmc, &cmd, NULL)) {
34810dcc:	e28d1004 	add	r1, sp, #4
34810dd0:	e1a02005 	mov	r2, r5
	/* SPI multiblock writes terminate using a special
	 * token, not a STOP_TRANSMISSION request.
	 */
	if (!mmc_host_is_spi(mmc) && blkcnt > 1) {
		cmd.cmdidx = MMC_CMD_STOP_TRANSMISSION;
		cmd.cmdarg = 0;
34810dd4:	e58d500c 	str	r5, [sp, #12]
		cmd.resp_type = MMC_RSP_R1b;
34810dd8:	e58d3008 	str	r3, [sp, #8]
		if (mmc_send_cmd(mmc, &cmd, NULL)) {
34810ddc:	ebfffef4 	bl	348109b4 <mmc_send_cmd>
34810de0:	e3500000 	cmp	r0, #0
34810de4:	0a000003 	beq	34810df8 <mmc_bwrite+0x130>
			printf("mmc fail to send stop cmd\n");
34810de8:	e59f005c 	ldr	r0, [pc, #92]	; 34810e4c <mmc_bwrite+0x184>
34810dec:	ebffe056 	bl	34808f4c <printf>
		return 0;

	do {
		cur = (blocks_todo > mmc->b_max) ?  mmc->b_max : blocks_todo;
		if(mmc_write_blocks(mmc, start, cur, src) != cur)
			return 0;
34810df0:	e1a04005 	mov	r4, r5
34810df4:	ea00000f 	b	34810e38 <mmc_bwrite+0x170>
			return 0;
		}
	}

	/* Waiting for the ready status */
	if (mmc_send_status(mmc, timeout))
34810df8:	e1a00006 	mov	r0, r6
34810dfc:	e3a01ffa 	mov	r1, #1000	; 0x3e8
34810e00:	ebfffefa 	bl	348109f0 <mmc_send_status>
34810e04:	e3500000 	cmp	r0, #0
34810e08:	0a000001 	beq	34810e14 <mmc_bwrite+0x14c>
	if (mmc_set_blocklen(mmc, mmc->write_bl_len))
		return 0;

	do {
		cur = (blocks_todo > mmc->b_max) ?  mmc->b_max : blocks_todo;
		if(mmc_write_blocks(mmc, start, cur, src) != cur)
34810e0c:	e3540000 	cmp	r4, #0
34810e10:	1a000005 	bne	34810e2c <mmc_bwrite+0x164>
			return 0;
		blocks_todo -= cur;
		start += cur;
		src += cur * mmc->write_bl_len;
	} while (blocks_todo > 0);
34810e14:	e05bb004 	subs	fp, fp, r4
		cur = (blocks_todo > mmc->b_max) ?  mmc->b_max : blocks_todo;
		if(mmc_write_blocks(mmc, start, cur, src) != cur)
			return 0;
		blocks_todo -= cur;
		start += cur;
		src += cur * mmc->write_bl_len;
34810e18:	e596308c 	ldr	r3, [r6, #140]	; 0x8c
	} while (blocks_todo > 0);
34810e1c:	0a000004 	beq	34810e34 <mmc_bwrite+0x16c>
		cur = (blocks_todo > mmc->b_max) ?  mmc->b_max : blocks_todo;
		if(mmc_write_blocks(mmc, start, cur, src) != cur)
			return 0;
		blocks_todo -= cur;
		start += cur;
		src += cur * mmc->write_bl_len;
34810e20:	e0299493 	mla	r9, r3, r4, r9
{
	struct mmc_cmd cmd;
	struct mmc_data data;
	int timeout = 1000;

	if ((start + blkcnt) > mmc->block_dev.lba) {
34810e24:	e1a05007 	mov	r5, r7
34810e28:	eaffffb5 	b	34810d04 <mmc_bwrite+0x3c>
		return 0;

	do {
		cur = (blocks_todo > mmc->b_max) ?  mmc->b_max : blocks_todo;
		if(mmc_write_blocks(mmc, start, cur, src) != cur)
			return 0;
34810e2c:	e3a04000 	mov	r4, #0
34810e30:	ea000000 	b	34810e38 <mmc_bwrite+0x170>
34810e34:	e1a0400a 	mov	r4, sl
		start += cur;
		src += cur * mmc->write_bl_len;
	} while (blocks_todo > 0);

	return blkcnt;
}
34810e38:	e1a00004 	mov	r0, r4
34810e3c:	e28dd030 	add	sp, sp, #48	; 0x30
34810e40:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
34810e44:	34826f1b 	.word	0x34826f1b
34810e48:	34826f47 	.word	0x34826f47
34810e4c:	34826f59 	.word	0x34826f59

34810e50 <mmc_read_blocks>:

int mmc_read_blocks(struct mmc *mmc, void *dst, ulong start, lbaint_t blkcnt)
{
34810e50:	e92d40f0 	push	{r4, r5, r6, r7, lr}
	struct mmc_cmd cmd;
	struct mmc_data data;

	if (blkcnt > 1)
34810e54:	e3530001 	cmp	r3, #1

	return blkcnt;
}

int mmc_read_blocks(struct mmc *mmc, void *dst, ulong start, lbaint_t blkcnt)
{
34810e58:	e24dd034 	sub	sp, sp, #52	; 0x34
34810e5c:	e1a05003 	mov	r5, r3
	struct mmc_cmd cmd;
	struct mmc_data data;

	if (blkcnt > 1)
		cmd.cmdidx = MMC_CMD_READ_MULTIPLE_BLOCK;
34810e60:	83a03012 	movhi	r3, #18
	else
		cmd.cmdidx = MMC_CMD_READ_SINGLE_BLOCK;
34810e64:	93a03011 	movls	r3, #17
34810e68:	e1cd30b4 	strh	r3, [sp, #4]

	if (mmc->high_capacity)
34810e6c:	e5903040 	ldr	r3, [r0, #64]	; 0x40
	data.dest = dst;
	data.blocks = blkcnt;
	data.blocksize = mmc->read_bl_len;
	data.flags = MMC_DATA_READ;

	if (mmc_send_cmd(mmc, &cmd, &data))
34810e70:	e28d7004 	add	r7, sp, #4
	if (blkcnt > 1)
		cmd.cmdidx = MMC_CMD_READ_MULTIPLE_BLOCK;
	else
		cmd.cmdidx = MMC_CMD_READ_SINGLE_BLOCK;

	if (mmc->high_capacity)
34810e74:	e3530000 	cmp	r3, #0
		cmd.cmdarg = start;
	else
		cmd.cmdarg = start * mmc->read_bl_len;
34810e78:	05903088 	ldreq	r3, [r0, #136]	; 0x88

	cmd.resp_type = MMC_RSP_R1;

	data.dest = dst;
34810e7c:	e58d1020 	str	r1, [sp, #32]
		cmd.cmdidx = MMC_CMD_READ_SINGLE_BLOCK;

	if (mmc->high_capacity)
		cmd.cmdarg = start;
	else
		cmd.cmdarg = start * mmc->read_bl_len;
34810e80:	00020293 	muleq	r2, r3, r2

	cmd.resp_type = MMC_RSP_R1;
34810e84:	e3a03015 	mov	r3, #21
34810e88:	e58d3008 	str	r3, [sp, #8]

	data.dest = dst;
	data.blocks = blkcnt;
	data.blocksize = mmc->read_bl_len;
34810e8c:	e5903088 	ldr	r3, [r0, #136]	; 0x88
		cmd.cmdidx = MMC_CMD_READ_SINGLE_BLOCK;

	if (mmc->high_capacity)
		cmd.cmdarg = start;
	else
		cmd.cmdarg = start * mmc->read_bl_len;
34810e90:	e58d200c 	str	r2, [sp, #12]

	cmd.resp_type = MMC_RSP_R1;

	data.dest = dst;
	data.blocks = blkcnt;
	data.blocksize = mmc->read_bl_len;
34810e94:	e58d302c 	str	r3, [sp, #44]	; 0x2c
	data.flags = MMC_DATA_READ;

	if (mmc_send_cmd(mmc, &cmd, &data))
34810e98:	e1a01007 	mov	r1, r7
	cmd.resp_type = MMC_RSP_R1;

	data.dest = dst;
	data.blocks = blkcnt;
	data.blocksize = mmc->read_bl_len;
	data.flags = MMC_DATA_READ;
34810e9c:	e3a03001 	mov	r3, #1

	if (mmc_send_cmd(mmc, &cmd, &data))
34810ea0:	e28d2020 	add	r2, sp, #32

	return blkcnt;
}

int mmc_read_blocks(struct mmc *mmc, void *dst, ulong start, lbaint_t blkcnt)
{
34810ea4:	e1a04000 	mov	r4, r0
		cmd.cmdarg = start * mmc->read_bl_len;

	cmd.resp_type = MMC_RSP_R1;

	data.dest = dst;
	data.blocks = blkcnt;
34810ea8:	e58d5028 	str	r5, [sp, #40]	; 0x28
	data.blocksize = mmc->read_bl_len;
	data.flags = MMC_DATA_READ;
34810eac:	e58d3024 	str	r3, [sp, #36]	; 0x24

	if (mmc_send_cmd(mmc, &cmd, &data))
34810eb0:	ebfffebf 	bl	348109b4 <mmc_send_cmd>
34810eb4:	e2506000 	subs	r6, r0, #0
		return 0;
34810eb8:	13a00000 	movne	r0, #0
	data.dest = dst;
	data.blocks = blkcnt;
	data.blocksize = mmc->read_bl_len;
	data.flags = MMC_DATA_READ;

	if (mmc_send_cmd(mmc, &cmd, &data))
34810ebc:	1a000011 	bne	34810f08 <mmc_read_blocks+0xb8>
		return 0;

	if (blkcnt > 1) {
34810ec0:	e3550001 	cmp	r5, #1
34810ec4:	9a00000e 	bls	34810f04 <mmc_read_blocks+0xb4>
		cmd.cmdidx = MMC_CMD_STOP_TRANSMISSION;
34810ec8:	e3a0300c 	mov	r3, #12
34810ecc:	e1cd30b4 	strh	r3, [sp, #4]
		cmd.cmdarg = 0;
		cmd.resp_type = MMC_RSP_R1b;
		if (mmc_send_cmd(mmc, &cmd, NULL)) {
34810ed0:	e1a00004 	mov	r0, r4
		return 0;

	if (blkcnt > 1) {
		cmd.cmdidx = MMC_CMD_STOP_TRANSMISSION;
		cmd.cmdarg = 0;
		cmd.resp_type = MMC_RSP_R1b;
34810ed4:	e3a0301d 	mov	r3, #29
		if (mmc_send_cmd(mmc, &cmd, NULL)) {
34810ed8:	e1a01007 	mov	r1, r7
34810edc:	e1a02006 	mov	r2, r6
	if (mmc_send_cmd(mmc, &cmd, &data))
		return 0;

	if (blkcnt > 1) {
		cmd.cmdidx = MMC_CMD_STOP_TRANSMISSION;
		cmd.cmdarg = 0;
34810ee0:	e58d600c 	str	r6, [sp, #12]
		cmd.resp_type = MMC_RSP_R1b;
34810ee4:	e58d3008 	str	r3, [sp, #8]
		if (mmc_send_cmd(mmc, &cmd, NULL)) {
34810ee8:	ebfffeb1 	bl	348109b4 <mmc_send_cmd>
34810eec:	e3500000 	cmp	r0, #0
34810ef0:	0a000003 	beq	34810f04 <mmc_read_blocks+0xb4>
			printf("mmc fail to send stop cmd\n");
34810ef4:	e59f0014 	ldr	r0, [pc, #20]	; 34810f10 <mmc_read_blocks+0xc0>
34810ef8:	ebffe013 	bl	34808f4c <printf>
			return 0;
34810efc:	e1a00006 	mov	r0, r6
34810f00:	ea000000 	b	34810f08 <mmc_read_blocks+0xb8>
		}
	}

	return blkcnt;
34810f04:	e1a00005 	mov	r0, r5
}
34810f08:	e28dd034 	add	sp, sp, #52	; 0x34
34810f0c:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
34810f10:	34826f59 	.word	0x34826f59

34810f14 <mmc_bread>:

static ulong mmc_bread(int dev_num, ulong start, lbaint_t blkcnt, void *dst)
{
34810f14:	e92d46f8 	push	{r3, r4, r5, r6, r7, r9, sl, lr}
	lbaint_t cur, blocks_todo = blkcnt;

	if (blkcnt == 0)
34810f18:	e2524000 	subs	r4, r2, #0

	return blkcnt;
}

static ulong mmc_bread(int dev_num, ulong start, lbaint_t blkcnt, void *dst)
{
34810f1c:	e1a06001 	mov	r6, r1
34810f20:	e1a07003 	mov	r7, r3
	lbaint_t cur, blocks_todo = blkcnt;

	if (blkcnt == 0)
34810f24:	0a000020 	beq	34810fac <mmc_bread+0x98>
		return 0;

	struct mmc *mmc = find_mmc_device(dev_num);
34810f28:	ebfffef0 	bl	34810af0 <find_mmc_device>
	if (!mmc)
34810f2c:	e2505000 	subs	r5, r0, #0
		return 0;
34810f30:	01a04005 	moveq	r4, r5

	if (blkcnt == 0)
		return 0;

	struct mmc *mmc = find_mmc_device(dev_num);
	if (!mmc)
34810f34:	0a00001c 	beq	34810fac <mmc_bread+0x98>
		return 0;

	if ((start + blkcnt) > mmc->block_dev.lba) {
34810f38:	e59520b0 	ldr	r2, [r5, #176]	; 0xb0
34810f3c:	e0841006 	add	r1, r4, r6
34810f40:	e1510002 	cmp	r1, r2
34810f44:	9a000002 	bls	34810f54 <mmc_bread+0x40>
		printf("MMC: block number 0x%lx exceeds max(0x%lx)\n",
34810f48:	e59f0064 	ldr	r0, [pc, #100]	; 34810fb4 <mmc_bread+0xa0>
34810f4c:	ebffdffe 	bl	34808f4c <printf>
34810f50:	ea000014 	b	34810fa8 <mmc_bread+0x94>
			start + blkcnt, mmc->block_dev.lba);
		return 0;
	}

	if (mmc_set_blocklen(mmc, mmc->read_bl_len))
34810f54:	e5951088 	ldr	r1, [r5, #136]	; 0x88
34810f58:	ebfffed8 	bl	34810ac0 <mmc_set_blocklen>
34810f5c:	e3500000 	cmp	r0, #0
34810f60:	1a000010 	bne	34810fa8 <mmc_bread+0x94>
34810f64:	e1a0a004 	mov	sl, r4
		return 0;

	do {
		cur = (blocks_todo > mmc->b_max) ?  mmc->b_max : blocks_todo;
34810f68:	e5959120 	ldr	r9, [r5, #288]	; 0x120
		if(mmc_read_blocks(mmc, dst, start, cur) != cur)
34810f6c:	e1a00005 	mov	r0, r5

	if (mmc_set_blocklen(mmc, mmc->read_bl_len))
		return 0;

	do {
		cur = (blocks_todo > mmc->b_max) ?  mmc->b_max : blocks_todo;
34810f70:	e15a0009 	cmp	sl, r9
34810f74:	31a0900a 	movcc	r9, sl
		if(mmc_read_blocks(mmc, dst, start, cur) != cur)
34810f78:	e1a01007 	mov	r1, r7
34810f7c:	e1a02006 	mov	r2, r6
34810f80:	e1a03009 	mov	r3, r9
34810f84:	ebffffb1 	bl	34810e50 <mmc_read_blocks>
34810f88:	e1500009 	cmp	r0, r9
34810f8c:	1a000005 	bne	34810fa8 <mmc_bread+0x94>
			return 0;
		blocks_todo -= cur;
		start += cur;
		dst += cur * mmc->read_bl_len;
	} while (blocks_todo > 0);
34810f90:	e05aa000 	subs	sl, sl, r0
		cur = (blocks_todo > mmc->b_max) ?  mmc->b_max : blocks_todo;
		if(mmc_read_blocks(mmc, dst, start, cur) != cur)
			return 0;
		blocks_todo -= cur;
		start += cur;
		dst += cur * mmc->read_bl_len;
34810f94:	e5953088 	ldr	r3, [r5, #136]	; 0x88
	} while (blocks_todo > 0);
34810f98:	0a000003 	beq	34810fac <mmc_bread+0x98>
	do {
		cur = (blocks_todo > mmc->b_max) ?  mmc->b_max : blocks_todo;
		if(mmc_read_blocks(mmc, dst, start, cur) != cur)
			return 0;
		blocks_todo -= cur;
		start += cur;
34810f9c:	e0866000 	add	r6, r6, r0
		dst += cur * mmc->read_bl_len;
34810fa0:	e0277093 	mla	r7, r3, r0, r7
34810fa4:	eaffffef 	b	34810f68 <mmc_bread+0x54>
		return 0;

	do {
		cur = (blocks_todo > mmc->b_max) ?  mmc->b_max : blocks_todo;
		if(mmc_read_blocks(mmc, dst, start, cur) != cur)
			return 0;
34810fa8:	e3a04000 	mov	r4, #0
		start += cur;
		dst += cur * mmc->read_bl_len;
	} while (blocks_todo > 0);

	return blkcnt;
}
34810fac:	e1a00004 	mov	r0, r4
34810fb0:	e8bd86f8 	pop	{r3, r4, r5, r6, r7, r9, sl, pc}
34810fb4:	34826f1b 	.word	0x34826f1b

34810fb8 <mmc_go_idle>:

int mmc_go_idle(struct mmc* mmc)
{
34810fb8:	e92d4010 	push	{r4, lr}
34810fbc:	e1a04000 	mov	r4, r0
34810fc0:	e24dd020 	sub	sp, sp, #32
	struct mmc_cmd cmd;
	int err;

	udelay(1000);
34810fc4:	e3a00ffa 	mov	r0, #1000	; 0x3e8
34810fc8:	eb00203b 	bl	348190bc <udelay>

	cmd.cmdidx = MMC_CMD_GO_IDLE_STATE;
34810fcc:	e3a02000 	mov	r2, #0
	cmd.cmdarg = 0;
	cmd.resp_type = MMC_RSP_NONE;

	err = mmc_send_cmd(mmc, &cmd, NULL);
34810fd0:	e1a00004 	mov	r0, r4
34810fd4:	e28d1004 	add	r1, sp, #4
	struct mmc_cmd cmd;
	int err;

	udelay(1000);

	cmd.cmdidx = MMC_CMD_GO_IDLE_STATE;
34810fd8:	e1cd20b4 	strh	r2, [sp, #4]
	cmd.cmdarg = 0;
34810fdc:	e58d200c 	str	r2, [sp, #12]
	cmd.resp_type = MMC_RSP_NONE;
34810fe0:	e58d2008 	str	r2, [sp, #8]

	err = mmc_send_cmd(mmc, &cmd, NULL);
34810fe4:	ebfffe72 	bl	348109b4 <mmc_send_cmd>

	if (err)
34810fe8:	e2504000 	subs	r4, r0, #0
34810fec:	1a000001 	bne	34810ff8 <mmc_go_idle+0x40>
		return err;

	udelay(2000);
34810ff0:	e2800e7d 	add	r0, r0, #2000	; 0x7d0
34810ff4:	eb002030 	bl	348190bc <udelay>

	return 0;
}
34810ff8:	e1a00004 	mov	r0, r4
34810ffc:	e28dd020 	add	sp, sp, #32
34811000:	e8bd8010 	pop	{r4, pc}

34811004 <sd_send_op_cond>:

int
sd_send_op_cond(struct mmc *mmc)
{
34811004:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
34811008:	e24dd020 	sub	sp, sp, #32
3481100c:	e1a04000 	mov	r4, r0
	int timeout = 1000;
34811010:	e3a06ffa 	mov	r6, #1000	; 0x3e8
	int err;
	struct mmc_cmd cmd;

	do {
		cmd.cmdidx = MMC_CMD_APP_CMD;
		cmd.resp_type = MMC_RSP_R1;
34811014:	e3a09015 	mov	r9, #21
		cmd.cmdarg = 0;
34811018:	e3a07000 	mov	r7, #0

		err = mmc_send_cmd(mmc, &cmd, NULL);
3481101c:	e28da004 	add	sl, sp, #4

		if (err)
			return err;

		cmd.cmdidx = SD_CMD_APP_SEND_OP_COND;
		cmd.resp_type = MMC_RSP_R3;
34811020:	e3a0b001 	mov	fp, #1
	int timeout = 1000;
	int err;
	struct mmc_cmd cmd;

	do {
		cmd.cmdidx = MMC_CMD_APP_CMD;
34811024:	e3a01037 	mov	r1, #55	; 0x37
34811028:	e1cd10b4 	strh	r1, [sp, #4]
		cmd.resp_type = MMC_RSP_R1;
		cmd.cmdarg = 0;

		err = mmc_send_cmd(mmc, &cmd, NULL);
3481102c:	e1a00004 	mov	r0, r4
34811030:	e1a0100a 	mov	r1, sl
34811034:	e1a02007 	mov	r2, r7
	int err;
	struct mmc_cmd cmd;

	do {
		cmd.cmdidx = MMC_CMD_APP_CMD;
		cmd.resp_type = MMC_RSP_R1;
34811038:	e58d9008 	str	r9, [sp, #8]
		cmd.cmdarg = 0;
3481103c:	e58d700c 	str	r7, [sp, #12]

		err = mmc_send_cmd(mmc, &cmd, NULL);
34811040:	ebfffe5b 	bl	348109b4 <mmc_send_cmd>

		if (err)
34811044:	e2505000 	subs	r5, r0, #0
34811048:	1a00003a 	bne	34811138 <sd_send_op_cond+0x134>
			return err;

		cmd.cmdidx = SD_CMD_APP_SEND_OP_COND;
3481104c:	e3a03029 	mov	r3, #41	; 0x29
34811050:	e1cd30b4 	strh	r3, [sp, #4]
		 * in the ocr are set. However, Some controller
		 * can set bit 7 (reserved for low voltages), but
		 * how to manage low voltages SD card is not yet
		 * specified.
		 */
		cmd.cmdarg = mmc_host_is_spi(mmc) ? 0 :
34811054:	e5943050 	ldr	r3, [r4, #80]	; 0x50
			(mmc->voltages & 0xff8000);

		if (mmc->version == SD_VERSION_2)
34811058:	e59f10e4 	ldr	r1, [pc, #228]	; 34811144 <sd_send_op_cond+0x140>
		 * in the ocr are set. However, Some controller
		 * can set bit 7 (reserved for low voltages), but
		 * how to manage low voltages SD card is not yet
		 * specified.
		 */
		cmd.cmdarg = mmc_host_is_spi(mmc) ? 0 :
3481105c:	e3130b01 	tst	r3, #1024	; 0x400
34811060:	059f30e0 	ldreq	r3, [pc, #224]	; 34811148 <sd_send_op_cond+0x144>
34811064:	0594202c 	ldreq	r2, [r4, #44]	; 0x2c
34811068:	11a03007 	movne	r3, r7
3481106c:	00023003 	andeq	r3, r2, r3
			(mmc->voltages & 0xff8000);

		if (mmc->version == SD_VERSION_2)
34811070:	e5942030 	ldr	r2, [r4, #48]	; 0x30
		 * in the ocr are set. However, Some controller
		 * can set bit 7 (reserved for low voltages), but
		 * how to manage low voltages SD card is not yet
		 * specified.
		 */
		cmd.cmdarg = mmc_host_is_spi(mmc) ? 0 :
34811074:	e58d300c 	str	r3, [sp, #12]
			(mmc->voltages & 0xff8000);

		if (mmc->version == SD_VERSION_2)
34811078:	e1520001 	cmp	r2, r1
			cmd.cmdarg |= OCR_HCS;
3481107c:	03833101 	orreq	r3, r3, #1073741824	; 0x40000000

		err = mmc_send_cmd(mmc, &cmd, NULL);
34811080:	e1a00004 	mov	r0, r4
34811084:	e1a0100a 	mov	r1, sl
34811088:	e3a02000 	mov	r2, #0
		 */
		cmd.cmdarg = mmc_host_is_spi(mmc) ? 0 :
			(mmc->voltages & 0xff8000);

		if (mmc->version == SD_VERSION_2)
			cmd.cmdarg |= OCR_HCS;
3481108c:	058d300c 	streq	r3, [sp, #12]

		if (err)
			return err;

		cmd.cmdidx = SD_CMD_APP_SEND_OP_COND;
		cmd.resp_type = MMC_RSP_R3;
34811090:	e58db008 	str	fp, [sp, #8]
			(mmc->voltages & 0xff8000);

		if (mmc->version == SD_VERSION_2)
			cmd.cmdarg |= OCR_HCS;

		err = mmc_send_cmd(mmc, &cmd, NULL);
34811094:	ebfffe46 	bl	348109b4 <mmc_send_cmd>

		if (err)
34811098:	e2505000 	subs	r5, r0, #0
3481109c:	1a000025 	bne	34811138 <sd_send_op_cond+0x134>
			return err;

		udelay(1000);
348110a0:	e2800ffa 	add	r0, r0, #1000	; 0x3e8
348110a4:	eb002004 	bl	348190bc <udelay>
	} while ((!(cmd.response[0] & OCR_BUSY)) && timeout--);
348110a8:	e59d3010 	ldr	r3, [sp, #16]
348110ac:	e3530000 	cmp	r3, #0
348110b0:	ba000002 	blt	348110c0 <sd_send_op_cond+0xbc>
348110b4:	e2566001 	subs	r6, r6, #1
348110b8:	2affffd9 	bcs	34811024 <sd_send_op_cond+0x20>
348110bc:	ea00001c 	b	34811134 <sd_send_op_cond+0x130>

	if (timeout <= 0)
348110c0:	e3560000 	cmp	r6, #0
348110c4:	da00001a 	ble	34811134 <sd_send_op_cond+0x130>
		return UNUSABLE_ERR;

	if (mmc->version != SD_VERSION_2)
348110c8:	e59f3074 	ldr	r3, [pc, #116]	; 34811144 <sd_send_op_cond+0x140>
348110cc:	e5942030 	ldr	r2, [r4, #48]	; 0x30
348110d0:	e1520003 	cmp	r2, r3
		mmc->version = SD_VERSION_1_0;
348110d4:	12433010 	subne	r3, r3, #16
348110d8:	15843030 	strne	r3, [r4, #48]	; 0x30

	if (mmc_host_is_spi(mmc)) { /* read OCR for spi */
348110dc:	e5943050 	ldr	r3, [r4, #80]	; 0x50
348110e0:	e3130b01 	tst	r3, #1024	; 0x400
348110e4:	0a00000b 	beq	34811118 <sd_send_op_cond+0x114>
		cmd.cmdidx = MMC_CMD_SPI_READ_OCR;
348110e8:	e3a0303a 	mov	r3, #58	; 0x3a
348110ec:	e1cd30b4 	strh	r3, [sp, #4]
		cmd.resp_type = MMC_RSP_R3;
		cmd.cmdarg = 0;
348110f0:	e3a02000 	mov	r2, #0
	if (mmc->version != SD_VERSION_2)
		mmc->version = SD_VERSION_1_0;

	if (mmc_host_is_spi(mmc)) { /* read OCR for spi */
		cmd.cmdidx = MMC_CMD_SPI_READ_OCR;
		cmd.resp_type = MMC_RSP_R3;
348110f4:	e3a03001 	mov	r3, #1
		cmd.cmdarg = 0;

		err = mmc_send_cmd(mmc, &cmd, NULL);
348110f8:	e1a00004 	mov	r0, r4
348110fc:	e28d1004 	add	r1, sp, #4
	if (mmc->version != SD_VERSION_2)
		mmc->version = SD_VERSION_1_0;

	if (mmc_host_is_spi(mmc)) { /* read OCR for spi */
		cmd.cmdidx = MMC_CMD_SPI_READ_OCR;
		cmd.resp_type = MMC_RSP_R3;
34811100:	e58d3008 	str	r3, [sp, #8]
		cmd.cmdarg = 0;
34811104:	e58d200c 	str	r2, [sp, #12]

		err = mmc_send_cmd(mmc, &cmd, NULL);
34811108:	ebfffe29 	bl	348109b4 <mmc_send_cmd>

		if (err)
3481110c:	e3500000 	cmp	r0, #0
34811110:	11a05000 	movne	r5, r0
34811114:	1a000007 	bne	34811138 <sd_send_op_cond+0x134>
			return err;
	}

	mmc->ocr = cmd.response[0];
34811118:	e59d3010 	ldr	r3, [sp, #16]

	mmc->high_capacity = ((mmc->ocr & OCR_HCS) == OCR_HCS);
	mmc->rca = 0;
3481111c:	e3a01000 	mov	r1, #0

		if (err)
			return err;
	}

	mmc->ocr = cmd.response[0];
34811120:	e5843054 	str	r3, [r4, #84]	; 0x54

	mmc->high_capacity = ((mmc->ocr & OCR_HCS) == OCR_HCS);
34811124:	e7e03f53 	ubfx	r3, r3, #30, #1
34811128:	e5843040 	str	r3, [r4, #64]	; 0x40
	mmc->rca = 0;
3481112c:	e1c418b0 	strh	r1, [r4, #128]	; 0x80

	return 0;
34811130:	ea000000 	b	34811138 <sd_send_op_cond+0x134>

		udelay(1000);
	} while ((!(cmd.response[0] & OCR_BUSY)) && timeout--);

	if (timeout <= 0)
		return UNUSABLE_ERR;
34811134:	e3e05010 	mvn	r5, #16

	mmc->high_capacity = ((mmc->ocr & OCR_HCS) == OCR_HCS);
	mmc->rca = 0;

	return 0;
}
34811138:	e1a00005 	mov	r0, r5
3481113c:	e28dd020 	add	sp, sp, #32
34811140:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
34811144:	00020020 	.word	0x00020020
34811148:	00ff8000 	.word	0x00ff8000

3481114c <mmc_send_op_cond>:

int mmc_send_op_cond(struct mmc *mmc)
{
3481114c:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
34811150:	e24dd020 	sub	sp, sp, #32
34811154:	e1a04000 	mov	r4, r0
 	/* Asking to the card its capabilities */
 	cmd.cmdidx = MMC_CMD_SEND_OP_COND;
 	cmd.resp_type = MMC_RSP_R3;
 	cmd.cmdarg = 0;

 	err = mmc_send_cmd(mmc, &cmd, NULL);
34811158:	e28da004 	add	sl, sp, #4
	int timeout = 10000;
	struct mmc_cmd cmd;
	int err;

	/* Some cards seem to need this */
	mmc_go_idle(mmc);
3481115c:	ebffff95 	bl	34810fb8 <mmc_go_idle>

 	/* Asking to the card its capabilities */
 	cmd.cmdidx = MMC_CMD_SEND_OP_COND;
34811160:	e3a07001 	mov	r7, #1
 	cmd.resp_type = MMC_RSP_R3;
 	cmd.cmdarg = 0;
34811164:	e3a02000 	mov	r2, #0

 	err = mmc_send_cmd(mmc, &cmd, NULL);
34811168:	e1a00004 	mov	r0, r4
3481116c:	e1a0100a 	mov	r1, sl

	/* Some cards seem to need this */
	mmc_go_idle(mmc);

 	/* Asking to the card its capabilities */
 	cmd.cmdidx = MMC_CMD_SEND_OP_COND;
34811170:	e1cd70b4 	strh	r7, [sp, #4]
 	cmd.resp_type = MMC_RSP_R3;
34811174:	e58d7008 	str	r7, [sp, #8]
 	cmd.cmdarg = 0;
34811178:	e58d200c 	str	r2, [sp, #12]

 	err = mmc_send_cmd(mmc, &cmd, NULL);
3481117c:	ebfffe0c 	bl	348109b4 <mmc_send_cmd>

 	if (err)
34811180:	e2505000 	subs	r5, r0, #0
34811184:	1a00003d 	bne	34811280 <mmc_send_op_cond+0x134>
 		return err;

 	udelay(1000);
34811188:	e2800ffa 	add	r0, r0, #1000	; 0x3e8
3481118c:	eb001fca 	bl	348190bc <udelay>
	return 0;
}

int mmc_send_op_cond(struct mmc *mmc)
{
	int timeout = 10000;
34811190:	e3026710 	movw	r6, #10000	; 0x2710
 	udelay(1000);

	do {
		cmd.cmdidx = MMC_CMD_SEND_OP_COND;
		cmd.resp_type = MMC_RSP_R3;
		cmd.cmdarg = (mmc_host_is_spi(mmc) ? 0 :
34811194:	e5941050 	ldr	r1, [r4, #80]	; 0x50
 		return err;

 	udelay(1000);

	do {
		cmd.cmdidx = MMC_CMD_SEND_OP_COND;
34811198:	e3a03001 	mov	r3, #1
		cmd.resp_type = MMC_RSP_R3;
		cmd.cmdarg = (mmc_host_is_spi(mmc) ? 0 :
3481119c:	e3110b01 	tst	r1, #1024	; 0x400
 		return err;

 	udelay(1000);

	do {
		cmd.cmdidx = MMC_CMD_SEND_OP_COND;
348111a0:	e1cd30b4 	strh	r3, [sp, #4]
		cmd.resp_type = MMC_RSP_R3;
		cmd.cmdarg = (mmc_host_is_spi(mmc) ? 0 :
				(mmc->voltages &
348111a4:	0594002c 	ldreq	r0, [r4, #44]	; 0x2c
				(cmd.response[0] & OCR_VOLTAGE_MASK)) |
348111a8:	059d3010 	ldreq	r3, [sp, #16]

	do {
		cmd.cmdidx = MMC_CMD_SEND_OP_COND;
		cmd.resp_type = MMC_RSP_R3;
		cmd.cmdarg = (mmc_host_is_spi(mmc) ? 0 :
				(mmc->voltages &
348111ac:	059f20d8 	ldreq	r2, [pc, #216]	; 3481128c <mmc_send_op_cond+0x140>
348111b0:	00030000 	andeq	r0, r3, r0
348111b4:	00002002 	andeq	r2, r0, r2
				(cmd.response[0] & OCR_VOLTAGE_MASK)) |
				(cmd.response[0] & OCR_ACCESS_MODE));
348111b8:	02033206 	andeq	r3, r3, #1610612736	; 0x60000000
 	udelay(1000);

	do {
		cmd.cmdidx = MMC_CMD_SEND_OP_COND;
		cmd.resp_type = MMC_RSP_R3;
		cmd.cmdarg = (mmc_host_is_spi(mmc) ? 0 :
348111bc:	01823003 	orreq	r3, r2, r3
348111c0:	13a03000 	movne	r3, #0
				(mmc->voltages &
				(cmd.response[0] & OCR_VOLTAGE_MASK)) |
				(cmd.response[0] & OCR_ACCESS_MODE));

		if (mmc->host_caps & MMC_MODE_HC)
348111c4:	e3110b02 	tst	r1, #2048	; 0x800
 	udelay(1000);

	do {
		cmd.cmdidx = MMC_CMD_SEND_OP_COND;
		cmd.resp_type = MMC_RSP_R3;
		cmd.cmdarg = (mmc_host_is_spi(mmc) ? 0 :
348111c8:	e58d300c 	str	r3, [sp, #12]
				(cmd.response[0] & OCR_ACCESS_MODE));

		if (mmc->host_caps & MMC_MODE_HC)
			cmd.cmdarg |= OCR_HCS;

		err = mmc_send_cmd(mmc, &cmd, NULL);
348111cc:	e1a00004 	mov	r0, r4
				(mmc->voltages &
				(cmd.response[0] & OCR_VOLTAGE_MASK)) |
				(cmd.response[0] & OCR_ACCESS_MODE));

		if (mmc->host_caps & MMC_MODE_HC)
			cmd.cmdarg |= OCR_HCS;
348111d0:	13833101 	orrne	r3, r3, #1073741824	; 0x40000000

		err = mmc_send_cmd(mmc, &cmd, NULL);
348111d4:	e1a0100a 	mov	r1, sl
348111d8:	e3a02000 	mov	r2, #0
				(mmc->voltages &
				(cmd.response[0] & OCR_VOLTAGE_MASK)) |
				(cmd.response[0] & OCR_ACCESS_MODE));

		if (mmc->host_caps & MMC_MODE_HC)
			cmd.cmdarg |= OCR_HCS;
348111dc:	158d300c 	strne	r3, [sp, #12]

 	udelay(1000);

	do {
		cmd.cmdidx = MMC_CMD_SEND_OP_COND;
		cmd.resp_type = MMC_RSP_R3;
348111e0:	e58d7008 	str	r7, [sp, #8]
				(cmd.response[0] & OCR_ACCESS_MODE));

		if (mmc->host_caps & MMC_MODE_HC)
			cmd.cmdarg |= OCR_HCS;

		err = mmc_send_cmd(mmc, &cmd, NULL);
348111e4:	ebfffdf2 	bl	348109b4 <mmc_send_cmd>

		if (err)
348111e8:	e2505000 	subs	r5, r0, #0
348111ec:	1a000023 	bne	34811280 <mmc_send_op_cond+0x134>
			return err;

		udelay(1000);
348111f0:	e2800ffa 	add	r0, r0, #1000	; 0x3e8
348111f4:	eb001fb0 	bl	348190bc <udelay>
	} while (!(cmd.response[0] & OCR_BUSY) && timeout--);
348111f8:	e59d3010 	ldr	r3, [sp, #16]
348111fc:	e3530000 	cmp	r3, #0
34811200:	aa000002 	bge	34811210 <mmc_send_op_cond+0xc4>

	if (timeout <= 0)
34811204:	e3560000 	cmp	r6, #0
34811208:	ca000003 	bgt	3481121c <mmc_send_op_cond+0xd0>
3481120c:	ea00001a 	b	3481127c <mmc_send_op_cond+0x130>

		if (err)
			return err;

		udelay(1000);
	} while (!(cmd.response[0] & OCR_BUSY) && timeout--);
34811210:	e2566001 	subs	r6, r6, #1
34811214:	2affffde 	bcs	34811194 <mmc_send_op_cond+0x48>
34811218:	ea000017 	b	3481127c <mmc_send_op_cond+0x130>

	if (timeout <= 0)
		return UNUSABLE_ERR;

	if (mmc_host_is_spi(mmc)) { /* read OCR for spi */
3481121c:	e5943050 	ldr	r3, [r4, #80]	; 0x50
34811220:	e3130b01 	tst	r3, #1024	; 0x400
34811224:	0a00000b 	beq	34811258 <mmc_send_op_cond+0x10c>
		cmd.cmdidx = MMC_CMD_SPI_READ_OCR;
34811228:	e3a0303a 	mov	r3, #58	; 0x3a
3481122c:	e1cd30b4 	strh	r3, [sp, #4]
		cmd.resp_type = MMC_RSP_R3;
		cmd.cmdarg = 0;

		err = mmc_send_cmd(mmc, &cmd, NULL);
34811230:	e1a02005 	mov	r2, r5
	if (timeout <= 0)
		return UNUSABLE_ERR;

	if (mmc_host_is_spi(mmc)) { /* read OCR for spi */
		cmd.cmdidx = MMC_CMD_SPI_READ_OCR;
		cmd.resp_type = MMC_RSP_R3;
34811234:	e3a03001 	mov	r3, #1
		cmd.cmdarg = 0;

		err = mmc_send_cmd(mmc, &cmd, NULL);
34811238:	e1a00004 	mov	r0, r4
3481123c:	e1a0100a 	mov	r1, sl
		return UNUSABLE_ERR;

	if (mmc_host_is_spi(mmc)) { /* read OCR for spi */
		cmd.cmdidx = MMC_CMD_SPI_READ_OCR;
		cmd.resp_type = MMC_RSP_R3;
		cmd.cmdarg = 0;
34811240:	e58d500c 	str	r5, [sp, #12]
	if (timeout <= 0)
		return UNUSABLE_ERR;

	if (mmc_host_is_spi(mmc)) { /* read OCR for spi */
		cmd.cmdidx = MMC_CMD_SPI_READ_OCR;
		cmd.resp_type = MMC_RSP_R3;
34811244:	e58d3008 	str	r3, [sp, #8]
		cmd.cmdarg = 0;

		err = mmc_send_cmd(mmc, &cmd, NULL);
34811248:	ebfffdd9 	bl	348109b4 <mmc_send_cmd>

		if (err)
3481124c:	e3500000 	cmp	r0, #0
34811250:	11a05000 	movne	r5, r0
34811254:	1a000009 	bne	34811280 <mmc_send_op_cond+0x134>
			return err;
	}

	mmc->version = MMC_VERSION_UNKNOWN;
34811258:	e3a03801 	mov	r3, #65536	; 0x10000
3481125c:	e5843030 	str	r3, [r4, #48]	; 0x30
	mmc->ocr = cmd.response[0];
34811260:	e59d3010 	ldr	r3, [sp, #16]
34811264:	e5843054 	str	r3, [r4, #84]	; 0x54

	mmc->high_capacity = ((mmc->ocr & OCR_HCS) == OCR_HCS);
34811268:	e7e03f53 	ubfx	r3, r3, #30, #1
3481126c:	e5843040 	str	r3, [r4, #64]	; 0x40
	mmc->rca = 0;
34811270:	e3a03000 	mov	r3, #0
34811274:	e1c438b0 	strh	r3, [r4, #128]	; 0x80

	return 0;
34811278:	ea000000 	b	34811280 <mmc_send_op_cond+0x134>

		udelay(1000);
	} while (!(cmd.response[0] & OCR_BUSY) && timeout--);

	if (timeout <= 0)
		return UNUSABLE_ERR;
3481127c:	e3e05010 	mvn	r5, #16

	mmc->high_capacity = ((mmc->ocr & OCR_HCS) == OCR_HCS);
	mmc->rca = 0;

	return 0;
}
34811280:	e1a00005 	mov	r0, r5
34811284:	e28dd020 	add	sp, sp, #32
34811288:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
3481128c:	007fff80 	.word	0x007fff80

34811290 <mmc_send_ext_csd>:


int mmc_send_ext_csd(struct mmc *mmc, u8 *ext_csd)
{
34811290:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
	struct mmc_cmd cmd;
	struct mmc_data data;
	int err;

	/* Get the Card Status Register */
	cmd.cmdidx = MMC_CMD_SEND_EXT_CSD;
34811294:	e3a03008 	mov	r3, #8
	return 0;
}


int mmc_send_ext_csd(struct mmc *mmc, u8 *ext_csd)
{
34811298:	e24dd034 	sub	sp, sp, #52	; 0x34
	struct mmc_cmd cmd;
	struct mmc_data data;
	int err;

	/* Get the Card Status Register */
	cmd.cmdidx = MMC_CMD_SEND_EXT_CSD;
3481129c:	e1cd30b4 	strh	r3, [sp, #4]
	cmd.resp_type = MMC_RSP_R1;
348112a0:	e3a03015 	mov	r3, #21
348112a4:	e58d3008 	str	r3, [sp, #8]
	cmd.cmdarg = 0;

	data.dest = (char *)ext_csd;
	data.blocks = 1;
	data.blocksize = 512;
348112a8:	e3a02c02 	mov	r2, #512	; 0x200
	int err;

	/* Get the Card Status Register */
	cmd.cmdidx = MMC_CMD_SEND_EXT_CSD;
	cmd.resp_type = MMC_RSP_R1;
	cmd.cmdarg = 0;
348112ac:	e3a03000 	mov	r3, #0
348112b0:	e58d300c 	str	r3, [sp, #12]

	data.dest = (char *)ext_csd;
348112b4:	e58d1020 	str	r1, [sp, #32]
	data.blocks = 1;
348112b8:	e2833001 	add	r3, r3, #1
	data.blocksize = 512;
348112bc:	e58d202c 	str	r2, [sp, #44]	; 0x2c
	data.flags = MMC_DATA_READ;

	err = mmc_send_cmd(mmc, &cmd, &data);
348112c0:	e28d1004 	add	r1, sp, #4
348112c4:	e28d2020 	add	r2, sp, #32
	cmd.cmdidx = MMC_CMD_SEND_EXT_CSD;
	cmd.resp_type = MMC_RSP_R1;
	cmd.cmdarg = 0;

	data.dest = (char *)ext_csd;
	data.blocks = 1;
348112c8:	e58d3028 	str	r3, [sp, #40]	; 0x28
	data.blocksize = 512;
	data.flags = MMC_DATA_READ;
348112cc:	e58d3024 	str	r3, [sp, #36]	; 0x24

	err = mmc_send_cmd(mmc, &cmd, &data);
348112d0:	ebfffdb7 	bl	348109b4 <mmc_send_cmd>

	return err;
}
348112d4:	e28dd034 	add	sp, sp, #52	; 0x34
348112d8:	e8bd8000 	pop	{pc}

348112dc <mmc_switch>:


int mmc_switch(struct mmc *mmc, u8 set, u8 index, u8 value)
{
348112dc:	e92d4010 	push	{r4, lr}
	struct mmc_cmd cmd;
	int timeout = 1000;
	int ret;

	cmd.cmdidx = MMC_CMD_SWITCH;
348112e0:	e3a01006 	mov	r1, #6
	return err;
}


int mmc_switch(struct mmc *mmc, u8 set, u8 index, u8 value)
{
348112e4:	e24dd020 	sub	sp, sp, #32
	int ret;

	cmd.cmdidx = MMC_CMD_SWITCH;
	cmd.resp_type = MMC_RSP_R1b;
	cmd.cmdarg = (MMC_SWITCH_MODE_WRITE_BYTE << 24) |
				 (index << 16) |
348112e8:	e1a02802 	lsl	r2, r2, #16
{
	struct mmc_cmd cmd;
	int timeout = 1000;
	int ret;

	cmd.cmdidx = MMC_CMD_SWITCH;
348112ec:	e1cd10b4 	strh	r1, [sp, #4]
	cmd.resp_type = MMC_RSP_R1b;
	cmd.cmdarg = (MMC_SWITCH_MODE_WRITE_BYTE << 24) |
348112f0:	e3822403 	orr	r2, r2, #50331648	; 0x3000000
	struct mmc_cmd cmd;
	int timeout = 1000;
	int ret;

	cmd.cmdidx = MMC_CMD_SWITCH;
	cmd.resp_type = MMC_RSP_R1b;
348112f4:	e3a0101d 	mov	r1, #29
	cmd.cmdarg = (MMC_SWITCH_MODE_WRITE_BYTE << 24) |
				 (index << 16) |
348112f8:	e1823403 	orr	r3, r2, r3, lsl #8
	struct mmc_cmd cmd;
	int timeout = 1000;
	int ret;

	cmd.cmdidx = MMC_CMD_SWITCH;
	cmd.resp_type = MMC_RSP_R1b;
348112fc:	e58d1008 	str	r1, [sp, #8]
	cmd.cmdarg = (MMC_SWITCH_MODE_WRITE_BYTE << 24) |
				 (index << 16) |
				 (value << 8);

	ret = mmc_send_cmd(mmc, &cmd, NULL);
34811300:	e3a02000 	mov	r2, #0
34811304:	e28d1004 	add	r1, sp, #4
	return err;
}


int mmc_switch(struct mmc *mmc, u8 set, u8 index, u8 value)
{
34811308:	e1a04000 	mov	r4, r0
	int timeout = 1000;
	int ret;

	cmd.cmdidx = MMC_CMD_SWITCH;
	cmd.resp_type = MMC_RSP_R1b;
	cmd.cmdarg = (MMC_SWITCH_MODE_WRITE_BYTE << 24) |
3481130c:	e58d300c 	str	r3, [sp, #12]
				 (index << 16) |
				 (value << 8);

	ret = mmc_send_cmd(mmc, &cmd, NULL);
34811310:	ebfffda7 	bl	348109b4 <mmc_send_cmd>

	/* Waiting for the ready status */
	if (!ret)
34811314:	e3500000 	cmp	r0, #0
34811318:	1a000002 	bne	34811328 <mmc_switch+0x4c>
		ret = mmc_send_status(mmc, timeout);
3481131c:	e1a00004 	mov	r0, r4
34811320:	e3a01ffa 	mov	r1, #1000	; 0x3e8
34811324:	ebfffdb1 	bl	348109f0 <mmc_send_status>

	return ret;

}
34811328:	e28dd020 	add	sp, sp, #32
3481132c:	e8bd8010 	pop	{r4, pc}

34811330 <mmc_change_freq>:

int mmc_change_freq(struct mmc *mmc)
{
34811330:	e92d4070 	push	{r4, r5, r6, lr}
	char cardtype;
	int err;

	mmc->card_caps = 0;

	if (mmc_host_is_spi(mmc))
34811334:	e5902050 	ldr	r2, [r0, #80]	; 0x50
{
	ALLOC_CACHE_ALIGN_BUFFER(u8, ext_csd, 512);
	char cardtype;
	int err;

	mmc->card_caps = 0;
34811338:	e3a03000 	mov	r3, #0

	if (mmc_host_is_spi(mmc))
3481133c:	e2122b01 	ands	r2, r2, #1024	; 0x400
	return ret;

}

int mmc_change_freq(struct mmc *mmc)
{
34811340:	e1a04000 	mov	r4, r0
	ALLOC_CACHE_ALIGN_BUFFER(u8, ext_csd, 512);
	char cardtype;
	int err;

	mmc->card_caps = 0;
34811344:	e580304c 	str	r3, [r0, #76]	; 0x4c
	return ret;

}

int mmc_change_freq(struct mmc *mmc)
{
34811348:	e24ddd09 	sub	sp, sp, #576	; 0x240
	int err;

	mmc->card_caps = 0;

	if (mmc_host_is_spi(mmc))
		return 0;
3481134c:	11a00003 	movne	r0, r3
	char cardtype;
	int err;

	mmc->card_caps = 0;

	if (mmc_host_is_spi(mmc))
34811350:	1a00001f 	bne	348113d4 <mmc_change_freq+0xa4>
		return 0;

	/* Only version 4 supports high-speed */
	if (mmc->version < MMC_VERSION_4)
34811354:	e5941030 	ldr	r1, [r4, #48]	; 0x30
34811358:	e59f307c 	ldr	r3, [pc, #124]	; 348113dc <mmc_change_freq+0xac>
3481135c:	e1510003 	cmp	r1, r3
		return 0;
34811360:	91a00002 	movls	r0, r2

	if (mmc_host_is_spi(mmc))
		return 0;

	/* Only version 4 supports high-speed */
	if (mmc->version < MMC_VERSION_4)
34811364:	9a00001a 	bls	348113d4 <mmc_change_freq+0xa4>

}

int mmc_change_freq(struct mmc *mmc)
{
	ALLOC_CACHE_ALIGN_BUFFER(u8, ext_csd, 512);
34811368:	e28d503f 	add	r5, sp, #63	; 0x3f
3481136c:	e3c5503f 	bic	r5, r5, #63	; 0x3f

	/* Only version 4 supports high-speed */
	if (mmc->version < MMC_VERSION_4)
		return 0;

	err = mmc_send_ext_csd(mmc, ext_csd);
34811370:	e1a01005 	mov	r1, r5
34811374:	ebffffc5 	bl	34811290 <mmc_send_ext_csd>

	if (err)
34811378:	e3500000 	cmp	r0, #0
3481137c:	1a000014 	bne	348113d4 <mmc_change_freq+0xa4>
		return err;

	cardtype = ext_csd[EXT_CSD_CARD_TYPE] & 0xf;

	err = mmc_switch(mmc, EXT_CSD_CMD_SET_NORMAL, EXT_CSD_HS_TIMING, 1);
34811380:	e3a01001 	mov	r1, #1
34811384:	e1a00004 	mov	r0, r4
34811388:	e3a020b9 	mov	r2, #185	; 0xb9
3481138c:	e1a03001 	mov	r3, r1
	err = mmc_send_ext_csd(mmc, ext_csd);

	if (err)
		return err;

	cardtype = ext_csd[EXT_CSD_CARD_TYPE] & 0xf;
34811390:	e5d560c4 	ldrb	r6, [r5, #196]	; 0xc4

	err = mmc_switch(mmc, EXT_CSD_CMD_SET_NORMAL, EXT_CSD_HS_TIMING, 1);
34811394:	ebffffd0 	bl	348112dc <mmc_switch>

	if (err)
34811398:	e3500000 	cmp	r0, #0
3481139c:	1a00000c 	bne	348113d4 <mmc_change_freq+0xa4>
		return err;

	/* Now check to see that it worked */
	err = mmc_send_ext_csd(mmc, ext_csd);
348113a0:	e1a00004 	mov	r0, r4
348113a4:	e1a01005 	mov	r1, r5
348113a8:	ebffffb8 	bl	34811290 <mmc_send_ext_csd>

	if (err)
348113ac:	e3500000 	cmp	r0, #0
348113b0:	1a000007 	bne	348113d4 <mmc_change_freq+0xa4>
		return err;

	/* No high-speed support */
	if (!ext_csd[EXT_CSD_HS_TIMING])
348113b4:	e5d530b9 	ldrb	r3, [r5, #185]	; 0xb9
348113b8:	e3530000 	cmp	r3, #0
348113bc:	0a000004 	beq	348113d4 <mmc_change_freq+0xa4>
348113c0:	e594304c 	ldr	r3, [r4, #76]	; 0x4c
		return 0;

	/* High Speed is set, there are two types: 52MHz and 26MHz */
	if (cardtype & MMC_HS_52MHZ)
348113c4:	e3160002 	tst	r6, #2
		mmc->card_caps |= MMC_MODE_HS_52MHz | MMC_MODE_HS;
348113c8:	13833011 	orrne	r3, r3, #17
	else
		mmc->card_caps |= MMC_MODE_HS;
348113cc:	03833001 	orreq	r3, r3, #1
348113d0:	e584304c 	str	r3, [r4, #76]	; 0x4c

	return 0;
}
348113d4:	e28ddd09 	add	sp, sp, #576	; 0x240
348113d8:	e8bd8070 	pop	{r4, r5, r6, pc}
348113dc:	0001003f 	.word	0x0001003f

348113e0 <mmc_switch_part>:

int mmc_switch_part(int dev_num, unsigned int part_num)
{
348113e0:	e92d4010 	push	{r4, lr}
348113e4:	e1a04001 	mov	r4, r1
	struct mmc *mmc = find_mmc_device(dev_num);
348113e8:	ebfffdc0 	bl	34810af0 <find_mmc_device>

	if (!mmc)
348113ec:	e2503000 	subs	r3, r0, #0
348113f0:	0a000007 	beq	34811414 <mmc_switch_part+0x34>
		return -1;

	return mmc_switch(mmc, EXT_CSD_CMD_SET_NORMAL, EXT_CSD_PART_CONF,
348113f4:	e5d33082 	ldrb	r3, [r3, #130]	; 0x82
348113f8:	e204c007 	and	ip, r4, #7
348113fc:	e3c33007 	bic	r3, r3, #7
34811400:	e3a01001 	mov	r1, #1
34811404:	e3a020b3 	mov	r2, #179	; 0xb3
34811408:	e18c3003 	orr	r3, ip, r3
			  (mmc->part_config & ~PART_ACCESS_MASK)
			  | (part_num & PART_ACCESS_MASK));
}
3481140c:	e8bd4010 	pop	{r4, lr}
	struct mmc *mmc = find_mmc_device(dev_num);

	if (!mmc)
		return -1;

	return mmc_switch(mmc, EXT_CSD_CMD_SET_NORMAL, EXT_CSD_PART_CONF,
34811410:	eaffffb1 	b	348112dc <mmc_switch>
			  (mmc->part_config & ~PART_ACCESS_MASK)
			  | (part_num & PART_ACCESS_MASK));
}
34811414:	e3e00000 	mvn	r0, #0
34811418:	e8bd8010 	pop	{r4, pc}

3481141c <mmc_getcd>:

int mmc_getcd(struct mmc *mmc)
{
3481141c:	e92d4010 	push	{r4, lr}
34811420:	e1a04000 	mov	r4, r0
	int cd;

	cd = board_mmc_getcd(mmc);
34811424:	ebfffd60 	bl	348109ac <__board_mmc_getcd>

	if ((cd < 0) && mmc->getcd)
34811428:	e3500000 	cmp	r0, #0
3481142c:	a8bd8010 	popge	{r4, pc}
34811430:	e594311c 	ldr	r3, [r4, #284]	; 0x11c
34811434:	e3530000 	cmp	r3, #0
34811438:	08bd8010 	popeq	{r4, pc}
		cd = mmc->getcd(mmc);
3481143c:	e1a00004 	mov	r0, r4
34811440:	e12fff33 	blx	r3

	return cd;
}
34811444:	e8bd8010 	pop	{r4, pc}

34811448 <sd_switch>:

int sd_switch(struct mmc *mmc, int mode, int group, u8 value, u8 *resp)
{
34811448:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
	struct mmc_cmd cmd;
	struct mmc_data data;

	/* Switch the frequency */
	cmd.cmdidx = SD_CMD_SWITCH_FUNC;
3481144c:	e3a0c006 	mov	ip, #6

	return cd;
}

int sd_switch(struct mmc *mmc, int mode, int group, u8 value, u8 *resp)
{
34811450:	e24dd034 	sub	sp, sp, #52	; 0x34
	struct mmc_cmd cmd;
	struct mmc_data data;

	/* Switch the frequency */
	cmd.cmdidx = SD_CMD_SWITCH_FUNC;
34811454:	e1cdc0b4 	strh	ip, [sp, #4]
	cmd.resp_type = MMC_RSP_R1;
34811458:	e3a0c015 	mov	ip, #21
3481145c:	e58dc008 	str	ip, [sp, #8]
	cmd.cmdarg = (mode << 31) | 0xffffff;
34811460:	e3e0c4ff 	mvn	ip, #-16777216	; 0xff000000
34811464:	e18c1f81 	orr	r1, ip, r1, lsl #31
	cmd.cmdarg &= ~(0xf << (group * 4));
34811468:	e1a02102 	lsl	r2, r2, #2
3481146c:	e3a0c00f 	mov	ip, #15
34811470:	e1c1c21c 	bic	ip, r1, ip, lsl r2
	cmd.cmdarg |= value << (group * 4);
34811474:	e18c2213 	orr	r2, ip, r3, lsl r2

	data.dest = (char *)resp;
34811478:	e59d3038 	ldr	r3, [sp, #56]	; 0x38
	/* Switch the frequency */
	cmd.cmdidx = SD_CMD_SWITCH_FUNC;
	cmd.resp_type = MMC_RSP_R1;
	cmd.cmdarg = (mode << 31) | 0xffffff;
	cmd.cmdarg &= ~(0xf << (group * 4));
	cmd.cmdarg |= value << (group * 4);
3481147c:	e58d200c 	str	r2, [sp, #12]

	data.dest = (char *)resp;
34811480:	e58d3020 	str	r3, [sp, #32]
	data.blocksize = 64;
34811484:	e3a03040 	mov	r3, #64	; 0x40
34811488:	e58d302c 	str	r3, [sp, #44]	; 0x2c
	data.blocks = 1;
	data.flags = MMC_DATA_READ;

	return mmc_send_cmd(mmc, &cmd, &data);
3481148c:	e28d1004 	add	r1, sp, #4
	cmd.cmdarg &= ~(0xf << (group * 4));
	cmd.cmdarg |= value << (group * 4);

	data.dest = (char *)resp;
	data.blocksize = 64;
	data.blocks = 1;
34811490:	e3a03001 	mov	r3, #1
	data.flags = MMC_DATA_READ;

	return mmc_send_cmd(mmc, &cmd, &data);
34811494:	e28d2020 	add	r2, sp, #32
	cmd.cmdarg &= ~(0xf << (group * 4));
	cmd.cmdarg |= value << (group * 4);

	data.dest = (char *)resp;
	data.blocksize = 64;
	data.blocks = 1;
34811498:	e58d3028 	str	r3, [sp, #40]	; 0x28
	data.flags = MMC_DATA_READ;
3481149c:	e58d3024 	str	r3, [sp, #36]	; 0x24

	return mmc_send_cmd(mmc, &cmd, &data);
348114a0:	ebfffd43 	bl	348109b4 <mmc_send_cmd>
}
348114a4:	e28dd034 	add	sp, sp, #52	; 0x34
348114a8:	e8bd8000 	pop	{pc}

348114ac <sd_change_freq>:


int sd_change_freq(struct mmc *mmc)
{
348114ac:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	struct mmc_data data;
	int timeout;

	mmc->card_caps = 0;

	if (mmc_host_is_spi(mmc))
348114b0:	e5902050 	ldr	r2, [r0, #80]	; 0x50
	return mmc_send_cmd(mmc, &cmd, &data);
}


int sd_change_freq(struct mmc *mmc)
{
348114b4:	e24ddd05 	sub	sp, sp, #320	; 0x140
	int err;
	struct mmc_cmd cmd;
	ALLOC_CACHE_ALIGN_BUFFER(uint, scr, 2);
348114b8:	e28d70d3 	add	r7, sp, #211	; 0xd3
	ALLOC_CACHE_ALIGN_BUFFER(uint, switch_status, 16);
348114bc:	e28d6053 	add	r6, sp, #83	; 0x53
	struct mmc_data data;
	int timeout;

	mmc->card_caps = 0;
348114c0:	e3a05000 	mov	r5, #0

	if (mmc_host_is_spi(mmc))
348114c4:	e2122b01 	ands	r2, r2, #1024	; 0x400
	return mmc_send_cmd(mmc, &cmd, &data);
}


int sd_change_freq(struct mmc *mmc)
{
348114c8:	e1a04000 	mov	r4, r0
	int err;
	struct mmc_cmd cmd;
	ALLOC_CACHE_ALIGN_BUFFER(uint, scr, 2);
348114cc:	e3c7703f 	bic	r7, r7, #63	; 0x3f
	ALLOC_CACHE_ALIGN_BUFFER(uint, switch_status, 16);
348114d0:	e3c6603f 	bic	r6, r6, #63	; 0x3f
	struct mmc_data data;
	int timeout;

	mmc->card_caps = 0;
348114d4:	e580504c 	str	r5, [r0, #76]	; 0x4c

	if (mmc_host_is_spi(mmc))
348114d8:	1a000069 	bne	34811684 <sd_change_freq+0x1d8>
		return 0;

	/* Read the SCR to find out if this card supports higher speeds */
	cmd.cmdidx = MMC_CMD_APP_CMD;
348114dc:	e3a01037 	mov	r1, #55	; 0x37
348114e0:	e28d3c01 	add	r3, sp, #256	; 0x100
348114e4:	e1c311b4 	strh	r1, [r3, #20]
	cmd.resp_type = MMC_RSP_R1;
	cmd.cmdarg = mmc->rca << 16;
348114e8:	e1d038b0 	ldrh	r3, [r0, #128]	; 0x80

	err = mmc_send_cmd(mmc, &cmd, NULL);
348114ec:	e28dbf45 	add	fp, sp, #276	; 0x114
		return 0;

	/* Read the SCR to find out if this card supports higher speeds */
	cmd.cmdidx = MMC_CMD_APP_CMD;
	cmd.resp_type = MMC_RSP_R1;
	cmd.cmdarg = mmc->rca << 16;
348114f0:	e1a03803 	lsl	r3, r3, #16
	if (mmc_host_is_spi(mmc))
		return 0;

	/* Read the SCR to find out if this card supports higher speeds */
	cmd.cmdidx = MMC_CMD_APP_CMD;
	cmd.resp_type = MMC_RSP_R1;
348114f4:	e3a0a015 	mov	sl, #21
	cmd.cmdarg = mmc->rca << 16;

	err = mmc_send_cmd(mmc, &cmd, NULL);
348114f8:	e1a0100b 	mov	r1, fp
	if (mmc_host_is_spi(mmc))
		return 0;

	/* Read the SCR to find out if this card supports higher speeds */
	cmd.cmdidx = MMC_CMD_APP_CMD;
	cmd.resp_type = MMC_RSP_R1;
348114fc:	e58da118 	str	sl, [sp, #280]	; 0x118
	cmd.cmdarg = mmc->rca << 16;
34811500:	e58d311c 	str	r3, [sp, #284]	; 0x11c

	err = mmc_send_cmd(mmc, &cmd, NULL);
34811504:	ebfffd2a 	bl	348109b4 <mmc_send_cmd>

	if (err)
34811508:	e2505000 	subs	r5, r0, #0
3481150c:	1a00005c 	bne	34811684 <sd_change_freq+0x1d8>
		return err;

	cmd.cmdidx = SD_CMD_APP_SEND_SCR;
34811510:	e3a01033 	mov	r1, #51	; 0x33
34811514:	e28d2c01 	add	r2, sp, #256	; 0x100
	cmd.resp_type = MMC_RSP_R1;
34811518:	e58da118 	str	sl, [sp, #280]	; 0x118
	err = mmc_send_cmd(mmc, &cmd, NULL);

	if (err)
		return err;

	cmd.cmdidx = SD_CMD_APP_SEND_SCR;
3481151c:	e1c211b4 	strh	r1, [r2, #20]
	cmd.resp_type = MMC_RSP_R1;
	cmd.cmdarg = 0;
34811520:	e58d511c 	str	r5, [sp, #284]	; 0x11c

	timeout = 3;
34811524:	e3a0a003 	mov	sl, #3

retry_scr:
	data.dest = (char *)scr;
	data.blocksize = 8;
34811528:	e3a0c008 	mov	ip, #8
	data.blocks = 1;
3481152c:	e3a09001 	mov	r9, #1
	data.flags = MMC_DATA_READ;

	err = mmc_send_cmd(mmc, &cmd, &data);
34811530:	e28d3e13 	add	r3, sp, #304	; 0x130
34811534:	e1a02003 	mov	r2, r3
34811538:	e1a00004 	mov	r0, r4
3481153c:	e1a0100b 	mov	r1, fp

	timeout = 3;

retry_scr:
	data.dest = (char *)scr;
	data.blocksize = 8;
34811540:	e58dc13c 	str	ip, [sp, #316]	; 0x13c
	data.blocks = 1;
	data.flags = MMC_DATA_READ;

	err = mmc_send_cmd(mmc, &cmd, &data);
34811544:	e58d3008 	str	r3, [sp, #8]
34811548:	e58dc00c 	str	ip, [sp, #12]
	cmd.cmdarg = 0;

	timeout = 3;

retry_scr:
	data.dest = (char *)scr;
3481154c:	e58d7130 	str	r7, [sp, #304]	; 0x130
	data.blocksize = 8;
	data.blocks = 1;
34811550:	e58d9138 	str	r9, [sp, #312]	; 0x138
	data.flags = MMC_DATA_READ;
34811554:	e58d9134 	str	r9, [sp, #308]	; 0x134

	err = mmc_send_cmd(mmc, &cmd, &data);
34811558:	ebfffd15 	bl	348109b4 <mmc_send_cmd>

	if (err) {
3481155c:	e2505000 	subs	r5, r0, #0
34811560:	e59d3008 	ldr	r3, [sp, #8]
34811564:	e59dc00c 	ldr	ip, [sp, #12]
34811568:	0a000003 	beq	3481157c <sd_change_freq+0xd0>
		if (timeout--)
3481156c:	e35a0000 	cmp	sl, #0
34811570:	0a000043 	beq	34811684 <sd_change_freq+0x1d8>
34811574:	e24aa001 	sub	sl, sl, #1
34811578:	eaffffed 	b	34811534 <sd_change_freq+0x88>
			goto retry_scr;

		return err;
	}

	mmc->scr[0] = __be32_to_cpu(scr[0]);
3481157c:	e5970000 	ldr	r0, [r7]
34811580:	ebfffd07 	bl	348109a4 <__fswab32>
34811584:	e5840058 	str	r0, [r4, #88]	; 0x58
34811588:	e1a0a000 	mov	sl, r0
	mmc->scr[1] = __be32_to_cpu(scr[1]);
3481158c:	e5970004 	ldr	r0, [r7, #4]
34811590:	ebfffd03 	bl	348109a4 <__fswab32>

	switch ((mmc->scr[0] >> 24) & 0xf) {
34811594:	e7e33c5a 	ubfx	r3, sl, #24, #4
34811598:	e3530001 	cmp	r3, #1

		return err;
	}

	mmc->scr[0] = __be32_to_cpu(scr[0]);
	mmc->scr[1] = __be32_to_cpu(scr[1]);
3481159c:	e584005c 	str	r0, [r4, #92]	; 0x5c
	switch ((mmc->scr[0] >> 24) & 0xf) {
		case 0:
			mmc->version = SD_VERSION_1_0;
			break;
		case 1:
			mmc->version = SD_VERSION_1_10;
348115a0:	059f30e8 	ldreq	r3, [pc, #232]	; 34811690 <sd_change_freq+0x1e4>
	}

	mmc->scr[0] = __be32_to_cpu(scr[0]);
	mmc->scr[1] = __be32_to_cpu(scr[1]);

	switch ((mmc->scr[0] >> 24) & 0xf) {
348115a4:	0a000004 	beq	348115bc <sd_change_freq+0x110>
348115a8:	3a000002 	bcc	348115b8 <sd_change_freq+0x10c>
348115ac:	e3530002 	cmp	r3, #2
			break;
		case 1:
			mmc->version = SD_VERSION_1_10;
			break;
		case 2:
			mmc->version = SD_VERSION_2;
348115b0:	059f30dc 	ldreq	r3, [pc, #220]	; 34811694 <sd_change_freq+0x1e8>
348115b4:	0a000000 	beq	348115bc <sd_change_freq+0x110>
			break;
		default:
			mmc->version = SD_VERSION_1_0;
348115b8:	e59f30d8 	ldr	r3, [pc, #216]	; 34811698 <sd_change_freq+0x1ec>
			break;
	}

	if (mmc->scr[0] & SD_DATA_4BIT)
348115bc:	e31a0701 	tst	sl, #262144	; 0x40000
			break;
		case 2:
			mmc->version = SD_VERSION_2;
			break;
		default:
			mmc->version = SD_VERSION_1_0;
348115c0:	e5843030 	str	r3, [r4, #48]	; 0x30
			break;
	}

	if (mmc->scr[0] & SD_DATA_4BIT)
		mmc->card_caps |= MMC_MODE_4BIT;
348115c4:	1594304c 	ldrne	r3, [r4, #76]	; 0x4c

	/* Version 1.0 doesn't support switching */
	if (mmc->version == SD_VERSION_1_0)
348115c8:	e5942030 	ldr	r2, [r4, #48]	; 0x30
			mmc->version = SD_VERSION_1_0;
			break;
	}

	if (mmc->scr[0] & SD_DATA_4BIT)
		mmc->card_caps |= MMC_MODE_4BIT;
348115cc:	13833c01 	orrne	r3, r3, #256	; 0x100
348115d0:	1584304c 	strne	r3, [r4, #76]	; 0x4c

	/* Version 1.0 doesn't support switching */
	if (mmc->version == SD_VERSION_1_0)
348115d4:	e59f30bc 	ldr	r3, [pc, #188]	; 34811698 <sd_change_freq+0x1ec>
348115d8:	e1520003 	cmp	r2, r3
348115dc:	13a07004 	movne	r7, #4
348115e0:	1a00000c 	bne	34811618 <sd_change_freq+0x16c>
348115e4:	ea000026 	b	34811684 <sd_change_freq+0x1d8>
		return 0;

	timeout = 4;
	while (timeout--) {
		err = sd_switch(mmc, SD_SWITCH_CHECK, 0, 1,
348115e8:	e3a01000 	mov	r1, #0
348115ec:	e1a00004 	mov	r0, r4
348115f0:	e1a02001 	mov	r2, r1
348115f4:	e3a03001 	mov	r3, #1
348115f8:	e58d6000 	str	r6, [sp]
348115fc:	ebffff91 	bl	34811448 <sd_switch>
				(u8 *)switch_status);

		if (err)
34811600:	e3500000 	cmp	r0, #0
34811604:	1a00001d 	bne	34811680 <sd_change_freq+0x1d4>
			return err;

		/* The high-speed function is busy.  Try again */
		if (!(__be32_to_cpu(switch_status[7]) & SD_HIGHSPEED_BUSY))
34811608:	e596001c 	ldr	r0, [r6, #28]
3481160c:	ebfffce4 	bl	348109a4 <__fswab32>
34811610:	e3100802 	tst	r0, #131072	; 0x20000
34811614:	0a000001 	beq	34811620 <sd_change_freq+0x174>
	/* Version 1.0 doesn't support switching */
	if (mmc->version == SD_VERSION_1_0)
		return 0;

	timeout = 4;
	while (timeout--) {
34811618:	e2577001 	subs	r7, r7, #1
3481161c:	2afffff1 	bcs	348115e8 <sd_change_freq+0x13c>
		if (!(__be32_to_cpu(switch_status[7]) & SD_HIGHSPEED_BUSY))
			break;
	}

	/* If high-speed isn't supported, we return */
	if (!(__be32_to_cpu(switch_status[3]) & SD_HIGHSPEED_SUPPORTED))
34811620:	e596000c 	ldr	r0, [r6, #12]
34811624:	ebfffcde 	bl	348109a4 <__fswab32>
34811628:	e3100802 	tst	r0, #131072	; 0x20000
3481162c:	0a000014 	beq	34811684 <sd_change_freq+0x1d8>
	 * If the host doesn't support SD_HIGHSPEED, do not switch card to
	 * HIGHSPEED mode even if the card support SD_HIGHSPPED.
	 * This can avoid furthur problem when the card runs in different
	 * mode between the host.
	 */
	if (!((mmc->host_caps & MMC_MODE_HS_52MHz) &&
34811630:	e5943050 	ldr	r3, [r4, #80]	; 0x50
34811634:	e2033011 	and	r3, r3, #17
34811638:	e3530011 	cmp	r3, #17
3481163c:	1a000010 	bne	34811684 <sd_change_freq+0x1d8>
		(mmc->host_caps & MMC_MODE_HS)))
		return 0;

	err = sd_switch(mmc, SD_SWITCH_SWITCH, 0, 1, (u8 *)switch_status);
34811640:	e3a01001 	mov	r1, #1
34811644:	e1a00004 	mov	r0, r4
34811648:	e3a02000 	mov	r2, #0
3481164c:	e1a03001 	mov	r3, r1
34811650:	e58d6000 	str	r6, [sp]
34811654:	ebffff7b 	bl	34811448 <sd_switch>

	if (err)
34811658:	e2505000 	subs	r5, r0, #0
3481165c:	1a000008 	bne	34811684 <sd_change_freq+0x1d8>
		return err;

	if ((__be32_to_cpu(switch_status[4]) & 0x0f000000) == 0x01000000)
34811660:	e5960010 	ldr	r0, [r6, #16]
34811664:	ebfffcce 	bl	348109a4 <__fswab32>
34811668:	e200040f 	and	r0, r0, #251658240	; 0xf000000
3481166c:	e3500401 	cmp	r0, #16777216	; 0x1000000
		mmc->card_caps |= MMC_MODE_HS;
34811670:	0594304c 	ldreq	r3, [r4, #76]	; 0x4c
34811674:	03833001 	orreq	r3, r3, #1
34811678:	0584304c 	streq	r3, [r4, #76]	; 0x4c
3481167c:	ea000000 	b	34811684 <sd_change_freq+0x1d8>
	if (mmc->version == SD_VERSION_1_0)
		return 0;

	timeout = 4;
	while (timeout--) {
		err = sd_switch(mmc, SD_SWITCH_CHECK, 0, 1,
34811680:	e1a05000 	mov	r5, r0

	if ((__be32_to_cpu(switch_status[4]) & 0x0f000000) == 0x01000000)
		mmc->card_caps |= MMC_MODE_HS;

	return 0;
}
34811684:	e1a00005 	mov	r0, r5
34811688:	e28ddd05 	add	sp, sp, #320	; 0x140
3481168c:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
34811690:	0002001a 	.word	0x0002001a
34811694:	00020020 	.word	0x00020020
34811698:	00020010 	.word	0x00020010

3481169c <mmc_set_ios>:
	70,
	80,
};

void mmc_set_ios(struct mmc *mmc)
{
3481169c:	e92d4008 	push	{r3, lr}
	mmc->set_ios(mmc);
348116a0:	e5903114 	ldr	r3, [r0, #276]	; 0x114
348116a4:	e12fff33 	blx	r3
}
348116a8:	e8bd8008 	pop	{r3, pc}

348116ac <mmc_set_clock>:

void mmc_set_clock(struct mmc *mmc, uint clock)
{
348116ac:	e590203c 	ldr	r2, [r0, #60]	; 0x3c
		clock = mmc->f_max;

	if (clock < mmc->f_min)
		clock = mmc->f_min;

	mmc->clock = clock;
348116b0:	e590c038 	ldr	ip, [r0, #56]	; 0x38
{
	mmc->set_ios(mmc);
}

void mmc_set_clock(struct mmc *mmc, uint clock)
{
348116b4:	e1510002 	cmp	r1, r2
348116b8:	31a02001 	movcc	r2, r1
348116bc:	e92d4008 	push	{r3, lr}
		clock = mmc->f_max;

	if (clock < mmc->f_min)
		clock = mmc->f_min;

	mmc->clock = clock;
348116c0:	e152000c 	cmp	r2, ip
348116c4:	25802048 	strcs	r2, [r0, #72]	; 0x48
348116c8:	3580c048 	strcc	ip, [r0, #72]	; 0x48
	80,
};

void mmc_set_ios(struct mmc *mmc)
{
	mmc->set_ios(mmc);
348116cc:	e5903114 	ldr	r3, [r0, #276]	; 0x114
348116d0:	e12fff33 	blx	r3
		clock = mmc->f_min;

	mmc->clock = clock;

	mmc_set_ios(mmc);
}
348116d4:	e8bd8008 	pop	{r3, pc}

348116d8 <mmc_set_bus_width>:

void mmc_set_bus_width(struct mmc *mmc, uint width)
{
348116d8:	e92d4008 	push	{r3, lr}
	mmc->bus_width = width;
348116dc:	e5801044 	str	r1, [r0, #68]	; 0x44
	80,
};

void mmc_set_ios(struct mmc *mmc)
{
	mmc->set_ios(mmc);
348116e0:	e5903114 	ldr	r3, [r0, #276]	; 0x114
348116e4:	e12fff33 	blx	r3
void mmc_set_bus_width(struct mmc *mmc, uint width)
{
	mmc->bus_width = width;

	mmc_set_ios(mmc);
}
348116e8:	e8bd8008 	pop	{r3, pc}

348116ec <mmc_startup>:

int mmc_startup(struct mmc *mmc)
{
348116ec:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
			return err;
	}
#endif

	/* Put the Card in Identify Mode */
	cmd.cmdidx = mmc_host_is_spi(mmc) ? MMC_CMD_SEND_CID :
348116f0:	e5903050 	ldr	r3, [r0, #80]	; 0x50

	mmc_set_ios(mmc);
}

int mmc_startup(struct mmc *mmc)
{
348116f4:	e24ddd13 	sub	sp, sp, #1216	; 0x4c0
			return err;
	}
#endif

	/* Put the Card in Identify Mode */
	cmd.cmdidx = mmc_host_is_spi(mmc) ? MMC_CMD_SEND_CID :
348116f8:	e3130b01 	tst	r3, #1024	; 0x400
		MMC_CMD_ALL_SEND_CID; /* cmd not supported in spi */
	cmd.resp_type = MMC_RSP_R2;
	cmd.cmdarg = 0;

	err = mmc_send_cmd(mmc, &cmd, NULL);
348116fc:	e28d5e49 	add	r5, sp, #1168	; 0x490
			return err;
	}
#endif

	/* Put the Card in Identify Mode */
	cmd.cmdidx = mmc_host_is_spi(mmc) ? MMC_CMD_SEND_CID :
34811700:	03a03002 	moveq	r3, #2
34811704:	13a0300a 	movne	r3, #10
34811708:	e28d1b01 	add	r1, sp, #1024	; 0x400
		MMC_CMD_ALL_SEND_CID; /* cmd not supported in spi */
	cmd.resp_type = MMC_RSP_R2;
	cmd.cmdarg = 0;

	err = mmc_send_cmd(mmc, &cmd, NULL);
3481170c:	e285500c 	add	r5, r5, #12
			return err;
	}
#endif

	/* Put the Card in Identify Mode */
	cmd.cmdidx = mmc_host_is_spi(mmc) ? MMC_CMD_SEND_CID :
34811710:	e1c139bc 	strh	r3, [r1, #156]	; 0x9c
		MMC_CMD_ALL_SEND_CID; /* cmd not supported in spi */
	cmd.resp_type = MMC_RSP_R2;
	cmd.cmdarg = 0;
34811714:	e3a02000 	mov	r2, #0
#endif

	/* Put the Card in Identify Mode */
	cmd.cmdidx = mmc_host_is_spi(mmc) ? MMC_CMD_SEND_CID :
		MMC_CMD_ALL_SEND_CID; /* cmd not supported in spi */
	cmd.resp_type = MMC_RSP_R2;
34811718:	e3a03007 	mov	r3, #7
	cmd.cmdarg = 0;

	err = mmc_send_cmd(mmc, &cmd, NULL);
3481171c:	e1a01005 	mov	r1, r5

	mmc_set_ios(mmc);
}

int mmc_startup(struct mmc *mmc)
{
34811720:	e1a04000 	mov	r4, r0
#endif

	/* Put the Card in Identify Mode */
	cmd.cmdidx = mmc_host_is_spi(mmc) ? MMC_CMD_SEND_CID :
		MMC_CMD_ALL_SEND_CID; /* cmd not supported in spi */
	cmd.resp_type = MMC_RSP_R2;
34811724:	e58d34a0 	str	r3, [sp, #1184]	; 0x4a0
	cmd.cmdarg = 0;
34811728:	e58d24a4 	str	r2, [sp, #1188]	; 0x4a4

	err = mmc_send_cmd(mmc, &cmd, NULL);
3481172c:	ebfffca0 	bl	348109b4 <mmc_send_cmd>
	int err, width;
	uint mult, freq;
	u64 cmult, csize, capacity;
	struct mmc_cmd cmd;
	ALLOC_CACHE_ALIGN_BUFFER(u8, ext_csd, 512);
	ALLOC_CACHE_ALIGN_BUFFER(u8, test_csd, 512);
34811730:	e28da020 	add	sl, sp, #32
34811734:	e28aa03b 	add	sl, sl, #59	; 0x3b
	cmd.resp_type = MMC_RSP_R2;
	cmd.cmdarg = 0;

	err = mmc_send_cmd(mmc, &cmd, NULL);

	if (err)
34811738:	e2506000 	subs	r6, r0, #0
	int err, width;
	uint mult, freq;
	u64 cmult, csize, capacity;
	struct mmc_cmd cmd;
	ALLOC_CACHE_ALIGN_BUFFER(u8, ext_csd, 512);
	ALLOC_CACHE_ALIGN_BUFFER(u8, test_csd, 512);
3481173c:	e3caa03f 	bic	sl, sl, #63	; 0x3f
	cmd.resp_type = MMC_RSP_R2;
	cmd.cmdarg = 0;

	err = mmc_send_cmd(mmc, &cmd, NULL);

	if (err)
34811740:	1a00017b 	bne	34811d34 <mmc_startup+0x648>
		return err;

	memcpy(mmc->cid, cmd.response, 16);
34811744:	e3a02010 	mov	r2, #16
34811748:	e2840070 	add	r0, r4, #112	; 0x70
3481174c:	e285100c 	add	r1, r5, #12
34811750:	eb001dce 	bl	34818e90 <memcpy>
	/*
	 * For MMC cards, set the Relative Address.
	 * For SD cards, get the Relatvie Address.
	 * This also puts the cards into Standby State
	 */
	if (!mmc_host_is_spi(mmc)) { /* cmd not supported in spi */
34811754:	e5942050 	ldr	r2, [r4, #80]	; 0x50
34811758:	e2122b01 	ands	r2, r2, #1024	; 0x400
3481175c:	1a000011 	bne	348117a8 <mmc_startup+0xbc>
		cmd.cmdidx = SD_CMD_SEND_RELATIVE_ADDR;
34811760:	e3a03003 	mov	r3, #3
34811764:	e28d0b01 	add	r0, sp, #1024	; 0x400
34811768:	e1c039bc 	strh	r3, [r0, #156]	; 0x9c
		cmd.cmdarg = mmc->rca << 16;
3481176c:	e1d438b0 	ldrh	r3, [r4, #128]	; 0x80
		cmd.resp_type = MMC_RSP_R6;

		err = mmc_send_cmd(mmc, &cmd, NULL);
34811770:	e1a00004 	mov	r0, r4
	 * For SD cards, get the Relatvie Address.
	 * This also puts the cards into Standby State
	 */
	if (!mmc_host_is_spi(mmc)) { /* cmd not supported in spi */
		cmd.cmdidx = SD_CMD_SEND_RELATIVE_ADDR;
		cmd.cmdarg = mmc->rca << 16;
34811774:	e1a03803 	lsl	r3, r3, #16
34811778:	e58d34a4 	str	r3, [sp, #1188]	; 0x4a4
		cmd.resp_type = MMC_RSP_R6;

		err = mmc_send_cmd(mmc, &cmd, NULL);
3481177c:	e1a01005 	mov	r1, r5
	 * This also puts the cards into Standby State
	 */
	if (!mmc_host_is_spi(mmc)) { /* cmd not supported in spi */
		cmd.cmdidx = SD_CMD_SEND_RELATIVE_ADDR;
		cmd.cmdarg = mmc->rca << 16;
		cmd.resp_type = MMC_RSP_R6;
34811780:	e3a03015 	mov	r3, #21
34811784:	e58d34a0 	str	r3, [sp, #1184]	; 0x4a0

		err = mmc_send_cmd(mmc, &cmd, NULL);
34811788:	ebfffc89 	bl	348109b4 <mmc_send_cmd>

		if (err)
3481178c:	e2506000 	subs	r6, r0, #0
34811790:	1a000167 	bne	34811d34 <mmc_startup+0x648>
			return err;

		if (IS_SD(mmc))
34811794:	e5943030 	ldr	r3, [r4, #48]	; 0x30
34811798:	e3130802 	tst	r3, #131072	; 0x20000
			mmc->rca = (cmd.response[0] >> 16) & 0xffff;
3481179c:	128d1b01 	addne	r1, sp, #1024	; 0x400
348117a0:	11d11aba 	ldrhne	r1, [r1, #170]	; 0xaa
348117a4:	11c418b0 	strhne	r1, [r4, #128]	; 0x80
	}

	/* Get the Card-Specific Data */
	cmd.cmdidx = MMC_CMD_SEND_CSD;
348117a8:	e3a02009 	mov	r2, #9
348117ac:	e28d3b01 	add	r3, sp, #1024	; 0x400
348117b0:	e1c329bc 	strh	r2, [r3, #156]	; 0x9c
	cmd.resp_type = MMC_RSP_R2;
348117b4:	e3a03007 	mov	r3, #7
348117b8:	e58d34a0 	str	r3, [sp, #1184]	; 0x4a0
	cmd.cmdarg = mmc->rca << 16;
348117bc:	e1d438b0 	ldrh	r3, [r4, #128]	; 0x80

	err = mmc_send_cmd(mmc, &cmd, NULL);
348117c0:	e28d1e49 	add	r1, sp, #1168	; 0x490
	}

	/* Get the Card-Specific Data */
	cmd.cmdidx = MMC_CMD_SEND_CSD;
	cmd.resp_type = MMC_RSP_R2;
	cmd.cmdarg = mmc->rca << 16;
348117c4:	e1a03803 	lsl	r3, r3, #16

	err = mmc_send_cmd(mmc, &cmd, NULL);
348117c8:	e281100c 	add	r1, r1, #12
348117cc:	e3a02000 	mov	r2, #0
348117d0:	e1a00004 	mov	r0, r4
	}

	/* Get the Card-Specific Data */
	cmd.cmdidx = MMC_CMD_SEND_CSD;
	cmd.resp_type = MMC_RSP_R2;
	cmd.cmdarg = mmc->rca << 16;
348117d4:	e58d34a4 	str	r3, [sp, #1188]	; 0x4a4

	err = mmc_send_cmd(mmc, &cmd, NULL);
348117d8:	ebfffc75 	bl	348109b4 <mmc_send_cmd>

	/* Waiting for the ready status */
	mmc_send_status(mmc, timeout);
348117dc:	e3a01ffa 	mov	r1, #1000	; 0x3e8
	/* Get the Card-Specific Data */
	cmd.cmdidx = MMC_CMD_SEND_CSD;
	cmd.resp_type = MMC_RSP_R2;
	cmd.cmdarg = mmc->rca << 16;

	err = mmc_send_cmd(mmc, &cmd, NULL);
348117e0:	e1a06000 	mov	r6, r0

	/* Waiting for the ready status */
	mmc_send_status(mmc, timeout);
348117e4:	e1a00004 	mov	r0, r4
348117e8:	ebfffc80 	bl	348109f0 <mmc_send_status>

	if (err)
348117ec:	e3560000 	cmp	r6, #0
348117f0:	1a00014f 	bne	34811d34 <mmc_startup+0x648>
		return err;

	mmc->csd[0] = cmd.response[0];
	mmc->csd[1] = cmd.response[1];
	mmc->csd[2] = cmd.response[2];
	mmc->csd[3] = cmd.response[3];
348117f4:	e59d24b4 	ldr	r2, [sp, #1204]	; 0x4b4
	mmc_send_status(mmc, timeout);

	if (err)
		return err;

	mmc->csd[0] = cmd.response[0];
348117f8:	e59d34a8 	ldr	r3, [sp, #1192]	; 0x4a8
	mmc->csd[1] = cmd.response[1];
	mmc->csd[2] = cmd.response[2];
	mmc->csd[3] = cmd.response[3];
348117fc:	e584206c 	str	r2, [r4, #108]	; 0x6c

	if (mmc->version == MMC_VERSION_UNKNOWN) {
34811800:	e5942030 	ldr	r2, [r4, #48]	; 0x30

	if (err)
		return err;

	mmc->csd[0] = cmd.response[0];
	mmc->csd[1] = cmd.response[1];
34811804:	e59d04ac 	ldr	r0, [sp, #1196]	; 0x4ac
	mmc->csd[2] = cmd.response[2];
34811808:	e59d64b0 	ldr	r6, [sp, #1200]	; 0x4b0
	mmc->csd[3] = cmd.response[3];

	if (mmc->version == MMC_VERSION_UNKNOWN) {
3481180c:	e3520801 	cmp	r2, #65536	; 0x10000
	mmc_send_status(mmc, timeout);

	if (err)
		return err;

	mmc->csd[0] = cmd.response[0];
34811810:	e5843060 	str	r3, [r4, #96]	; 0x60
	mmc->csd[1] = cmd.response[1];
34811814:	e5840064 	str	r0, [r4, #100]	; 0x64
	mmc->csd[2] = cmd.response[2];
34811818:	e5846068 	str	r6, [r4, #104]	; 0x68
	mmc->csd[3] = cmd.response[3];

	if (mmc->version == MMC_VERSION_UNKNOWN) {
3481181c:	1a000012 	bne	3481186c <mmc_startup+0x180>
		int version = (cmd.response[0] >> 26) & 0xf;
34811820:	e7e32d53 	ubfx	r2, r3, #26, #4

		switch (version) {
34811824:	e3520004 	cmp	r2, #4
34811828:	979ff102 	ldrls	pc, [pc, r2, lsl #2]
3481182c:	ea00000c 	b	34811864 <mmc_startup+0x178>
34811830:	34811864 	.word	0x34811864
34811834:	34811844 	.word	0x34811844
34811838:	3481184c 	.word	0x3481184c
3481183c:	34811854 	.word	0x34811854
34811840:	3481185c 	.word	0x3481185c
			case 0:
				mmc->version = MMC_VERSION_1_2;
				break;
			case 1:
				mmc->version = MMC_VERSION_1_4;
34811844:	e59f24f4 	ldr	r2, [pc, #1268]	; 34811d40 <mmc_startup+0x654>
34811848:	ea000006 	b	34811868 <mmc_startup+0x17c>
				break;
			case 2:
				mmc->version = MMC_VERSION_2_2;
3481184c:	e59f24f0 	ldr	r2, [pc, #1264]	; 34811d44 <mmc_startup+0x658>
34811850:	ea000004 	b	34811868 <mmc_startup+0x17c>
				break;
			case 3:
				mmc->version = MMC_VERSION_3;
34811854:	e59f24ec 	ldr	r2, [pc, #1260]	; 34811d48 <mmc_startup+0x65c>
34811858:	ea000002 	b	34811868 <mmc_startup+0x17c>
				break;
			case 4:
				mmc->version = MMC_VERSION_4;
3481185c:	e59f24e8 	ldr	r2, [pc, #1256]	; 34811d4c <mmc_startup+0x660>
34811860:	ea000000 	b	34811868 <mmc_startup+0x17c>
				break;
			default:
				mmc->version = MMC_VERSION_1_2;
34811864:	e59f24e4 	ldr	r2, [pc, #1252]	; 34811d50 <mmc_startup+0x664>
34811868:	e5842030 	str	r2, [r4, #48]	; 0x30
		}
	}

	/* divide frequency by 10, since the mults are 10x bigger */
	freq = fbase[(cmd.response[0] & 0x7)];
	mult = multipliers[((cmd.response[0] >> 3) & 0xf)];
3481186c:	e59f24e0 	ldr	r2, [pc, #1248]	; 34811d54 <mmc_startup+0x668>
34811870:	e7e311d3 	ubfx	r1, r3, #3, #4
				break;
		}
	}

	/* divide frequency by 10, since the mults are 10x bigger */
	freq = fbase[(cmd.response[0] & 0x7)];
34811874:	e2033007 	and	r3, r3, #7
34811878:	e0823103 	add	r3, r2, r3, lsl #2
	mult = multipliers[((cmd.response[0] >> 3) & 0xf)];

	mmc->tran_speed = freq * mult;
3481187c:	e5933040 	ldr	r3, [r3, #64]	; 0x40
34811880:	e7922101 	ldr	r2, [r2, r1, lsl #2]

	mmc->read_bl_len = 1 << ((cmd.response[1] >> 16) & 0xf);
34811884:	e7e35850 	ubfx	r5, r0, #16, #4

	/* divide frequency by 10, since the mults are 10x bigger */
	freq = fbase[(cmd.response[0] & 0x7)];
	mult = multipliers[((cmd.response[0] >> 3) & 0xf)];

	mmc->tran_speed = freq * mult;
34811888:	e0030293 	mul	r3, r3, r2

	mmc->read_bl_len = 1 << ((cmd.response[1] >> 16) & 0xf);

	if (IS_SD(mmc))
3481188c:	e5942030 	ldr	r2, [r4, #48]	; 0x30

	/* divide frequency by 10, since the mults are 10x bigger */
	freq = fbase[(cmd.response[0] & 0x7)];
	mult = multipliers[((cmd.response[0] >> 3) & 0xf)];

	mmc->tran_speed = freq * mult;
34811890:	e5843084 	str	r3, [r4, #132]	; 0x84

	mmc->read_bl_len = 1 << ((cmd.response[1] >> 16) & 0xf);

	if (IS_SD(mmc))
34811894:	e3120802 	tst	r2, #131072	; 0x20000
		mmc->write_bl_len = mmc->read_bl_len;
	else
		mmc->write_bl_len = 1 << ((cmd.response[3] >> 22) & 0xf);
34811898:	059d24b4 	ldreq	r2, [sp, #1204]	; 0x4b4
	freq = fbase[(cmd.response[0] & 0x7)];
	mult = multipliers[((cmd.response[0] >> 3) & 0xf)];

	mmc->tran_speed = freq * mult;

	mmc->read_bl_len = 1 << ((cmd.response[1] >> 16) & 0xf);
3481189c:	e3a03001 	mov	r3, #1

	if (IS_SD(mmc))
		mmc->write_bl_len = mmc->read_bl_len;
	else
		mmc->write_bl_len = 1 << ((cmd.response[3] >> 22) & 0xf);
348118a0:	07e32b52 	ubfxeq	r2, r2, #22, #4
	freq = fbase[(cmd.response[0] & 0x7)];
	mult = multipliers[((cmd.response[0] >> 3) & 0xf)];

	mmc->tran_speed = freq * mult;

	mmc->read_bl_len = 1 << ((cmd.response[1] >> 16) & 0xf);
348118a4:	e1a05513 	lsl	r5, r3, r5

	if (IS_SD(mmc))
		mmc->write_bl_len = mmc->read_bl_len;
	else
		mmc->write_bl_len = 1 << ((cmd.response[3] >> 22) & 0xf);
348118a8:	01a03213 	lsleq	r3, r3, r2
348118ac:	0584308c 	streq	r3, [r4, #140]	; 0x8c

	if (mmc->high_capacity) {
348118b0:	e5943040 	ldr	r3, [r4, #64]	; 0x40
	mmc->tran_speed = freq * mult;

	mmc->read_bl_len = 1 << ((cmd.response[1] >> 16) & 0xf);

	if (IS_SD(mmc))
		mmc->write_bl_len = mmc->read_bl_len;
348118b4:	1584508c 	strne	r5, [r4, #140]	; 0x8c
	else
		mmc->write_bl_len = 1 << ((cmd.response[3] >> 22) & 0xf);

	if (mmc->high_capacity) {
348118b8:	e3530000 	cmp	r3, #0
	freq = fbase[(cmd.response[0] & 0x7)];
	mult = multipliers[((cmd.response[0] >> 3) & 0xf)];

	mmc->tran_speed = freq * mult;

	mmc->read_bl_len = 1 << ((cmd.response[1] >> 16) & 0xf);
348118bc:	e5845088 	str	r5, [r4, #136]	; 0x88
	if (IS_SD(mmc))
		mmc->write_bl_len = mmc->read_bl_len;
	else
		mmc->write_bl_len = 1 << ((cmd.response[3] >> 22) & 0xf);

	if (mmc->high_capacity) {
348118c0:	0a000006 	beq	348118e0 <mmc_startup+0x1f4>
		csize = (mmc->csd[1] & 0x3f) << 16
			| (mmc->csd[2] & 0xffff0000) >> 16;
348118c4:	e1a06826 	lsr	r6, r6, #16
		mmc->write_bl_len = mmc->read_bl_len;
	else
		mmc->write_bl_len = 1 << ((cmd.response[3] >> 22) & 0xf);

	if (mmc->high_capacity) {
		csize = (mmc->csd[1] & 0x3f) << 16
348118c8:	e200003f 	and	r0, r0, #63	; 0x3f
			| (mmc->csd[2] & 0xffff0000) >> 16;
348118cc:	e1860800 	orr	r0, r6, r0, lsl #16
		mmc->write_bl_len = mmc->read_bl_len;
	else
		mmc->write_bl_len = 1 << ((cmd.response[3] >> 22) & 0xf);

	if (mmc->high_capacity) {
		csize = (mmc->csd[1] & 0x3f) << 16
348118d0:	e3a01000 	mov	r1, #0
			| (mmc->csd[2] & 0xffff0000) >> 16;
		cmult = 8;
348118d4:	e3a06008 	mov	r6, #8
348118d8:	e3a07000 	mov	r7, #0
348118dc:	ea000005 	b	348118f8 <mmc_startup+0x20c>
	} else {
		csize = (mmc->csd[1] & 0x3ff) << 2
			| (mmc->csd[2] & 0xc0000000) >> 30;
348118e0:	e1a03f26 	lsr	r3, r6, #30
	if (mmc->high_capacity) {
		csize = (mmc->csd[1] & 0x3f) << 16
			| (mmc->csd[2] & 0xffff0000) >> 16;
		cmult = 8;
	} else {
		csize = (mmc->csd[1] & 0x3ff) << 2
348118e4:	e1a00b00 	lsl	r0, r0, #22
			| (mmc->csd[2] & 0xc0000000) >> 30;
348118e8:	e1830a20 	orr	r0, r3, r0, lsr #20
		cmult = (mmc->csd[2] & 0x00038000) >> 15;
348118ec:	e7e267d6 	ubfx	r6, r6, #15, #3
	if (mmc->high_capacity) {
		csize = (mmc->csd[1] & 0x3f) << 16
			| (mmc->csd[2] & 0xffff0000) >> 16;
		cmult = 8;
	} else {
		csize = (mmc->csd[1] & 0x3ff) << 2
348118f0:	e3a01000 	mov	r1, #0
			| (mmc->csd[2] & 0xc0000000) >> 30;
		cmult = (mmc->csd[2] & 0x00038000) >> 15;
348118f4:	e3a07000 	mov	r7, #0
	}

	mmc->capacity = (csize + 1) << (cmult + 2);
348118f8:	e3a02001 	mov	r2, #1
348118fc:	e0900002 	adds	r0, r0, r2
34811900:	e3a03000 	mov	r3, #0
34811904:	e0a11003 	adc	r1, r1, r3
34811908:	e2862002 	add	r2, r6, #2
3481190c:	eb003a85 	bl	34820328 <__ashldi3>
	mmc->capacity *= mmc->read_bl_len;
34811910:	e0832590 	umull	r2, r3, r0, r5
34811914:	e0233195 	mla	r3, r5, r1, r3

	if (mmc->read_bl_len > 512)
34811918:	e3550c02 	cmp	r5, #512	; 0x200
			| (mmc->csd[2] & 0xc0000000) >> 30;
		cmult = (mmc->csd[2] & 0x00038000) >> 15;
	}

	mmc->capacity = (csize + 1) << (cmult + 2);
	mmc->capacity *= mmc->read_bl_len;
3481191c:	e1c429f8 	strd	r2, [r4, #152]	; 0x98

	if (mmc->read_bl_len > 512)
		mmc->read_bl_len = 512;
34811920:	83a03c02 	movhi	r3, #512	; 0x200
34811924:	85843088 	strhi	r3, [r4, #136]	; 0x88

	if (mmc->write_bl_len > 512)
34811928:	e594308c 	ldr	r3, [r4, #140]	; 0x8c
		mmc->write_bl_len = 512;

	/* Select the card, and put it into Transfer Mode */
	if (!mmc_host_is_spi(mmc)) { /* cmd not supported in spi */
3481192c:	e5942050 	ldr	r2, [r4, #80]	; 0x50
	mmc->capacity *= mmc->read_bl_len;

	if (mmc->read_bl_len > 512)
		mmc->read_bl_len = 512;

	if (mmc->write_bl_len > 512)
34811930:	e3530c02 	cmp	r3, #512	; 0x200
		mmc->write_bl_len = 512;
34811934:	83a03c02 	movhi	r3, #512	; 0x200
34811938:	8584308c 	strhi	r3, [r4, #140]	; 0x8c

	/* Select the card, and put it into Transfer Mode */
	if (!mmc_host_is_spi(mmc)) { /* cmd not supported in spi */
3481193c:	e2122b01 	ands	r2, r2, #1024	; 0x400
34811940:	1a00000d 	bne	3481197c <mmc_startup+0x290>
		cmd.cmdidx = MMC_CMD_SELECT_CARD;
		cmd.resp_type = MMC_RSP_R1;
34811944:	e3a03015 	mov	r3, #21
	if (mmc->write_bl_len > 512)
		mmc->write_bl_len = 512;

	/* Select the card, and put it into Transfer Mode */
	if (!mmc_host_is_spi(mmc)) { /* cmd not supported in spi */
		cmd.cmdidx = MMC_CMD_SELECT_CARD;
34811948:	e3a00007 	mov	r0, #7
3481194c:	e28d1b01 	add	r1, sp, #1024	; 0x400
		cmd.resp_type = MMC_RSP_R1;
34811950:	e58d34a0 	str	r3, [sp, #1184]	; 0x4a0
		cmd.cmdarg = mmc->rca << 16;
34811954:	e1d438b0 	ldrh	r3, [r4, #128]	; 0x80
	if (mmc->write_bl_len > 512)
		mmc->write_bl_len = 512;

	/* Select the card, and put it into Transfer Mode */
	if (!mmc_host_is_spi(mmc)) { /* cmd not supported in spi */
		cmd.cmdidx = MMC_CMD_SELECT_CARD;
34811958:	e1c109bc 	strh	r0, [r1, #156]	; 0x9c
		cmd.resp_type = MMC_RSP_R1;
		cmd.cmdarg = mmc->rca << 16;
		err = mmc_send_cmd(mmc, &cmd, NULL);
3481195c:	e28d1e49 	add	r1, sp, #1168	; 0x490

	/* Select the card, and put it into Transfer Mode */
	if (!mmc_host_is_spi(mmc)) { /* cmd not supported in spi */
		cmd.cmdidx = MMC_CMD_SELECT_CARD;
		cmd.resp_type = MMC_RSP_R1;
		cmd.cmdarg = mmc->rca << 16;
34811960:	e1a03803 	lsl	r3, r3, #16
		err = mmc_send_cmd(mmc, &cmd, NULL);
34811964:	e1a00004 	mov	r0, r4
34811968:	e281100c 	add	r1, r1, #12

	/* Select the card, and put it into Transfer Mode */
	if (!mmc_host_is_spi(mmc)) { /* cmd not supported in spi */
		cmd.cmdidx = MMC_CMD_SELECT_CARD;
		cmd.resp_type = MMC_RSP_R1;
		cmd.cmdarg = mmc->rca << 16;
3481196c:	e58d34a4 	str	r3, [sp, #1188]	; 0x4a4
		err = mmc_send_cmd(mmc, &cmd, NULL);
34811970:	ebfffc0f 	bl	348109b4 <mmc_send_cmd>

		if (err)
34811974:	e2506000 	subs	r6, r0, #0
34811978:	1a0000ed 	bne	34811d34 <mmc_startup+0x648>
	}

	/*
	 * For SD, its erase group is always one sector
	 */
	mmc->erase_grp_size = 1;
3481197c:	e3a03001 	mov	r3, #1
34811980:	e5843090 	str	r3, [r4, #144]	; 0x90
	mmc->part_config = MMCPART_NOAVAILABLE;
34811984:	e3e03000 	mvn	r3, #0
34811988:	e5c43082 	strb	r3, [r4, #130]	; 0x82
	if (!IS_SD(mmc) && (mmc->version >= MMC_VERSION_4)) {
3481198c:	e5943030 	ldr	r3, [r4, #48]	; 0x30
{
	int err, width;
	uint mult, freq;
	u64 cmult, csize, capacity;
	struct mmc_cmd cmd;
	ALLOC_CACHE_ALIGN_BUFFER(u8, ext_csd, 512);
34811990:	e28d5fa6 	add	r5, sp, #664	; 0x298
34811994:	e2855003 	add	r5, r5, #3
	/*
	 * For SD, its erase group is always one sector
	 */
	mmc->erase_grp_size = 1;
	mmc->part_config = MMCPART_NOAVAILABLE;
	if (!IS_SD(mmc) && (mmc->version >= MMC_VERSION_4)) {
34811998:	e3130802 	tst	r3, #131072	; 0x20000
{
	int err, width;
	uint mult, freq;
	u64 cmult, csize, capacity;
	struct mmc_cmd cmd;
	ALLOC_CACHE_ALIGN_BUFFER(u8, ext_csd, 512);
3481199c:	e3c5503f 	bic	r5, r5, #63	; 0x3f
	/*
	 * For SD, its erase group is always one sector
	 */
	mmc->erase_grp_size = 1;
	mmc->part_config = MMCPART_NOAVAILABLE;
	if (!IS_SD(mmc) && (mmc->version >= MMC_VERSION_4)) {
348119a0:	1a000034 	bne	34811a78 <mmc_startup+0x38c>
348119a4:	e59f23ac 	ldr	r2, [pc, #940]	; 34811d58 <mmc_startup+0x66c>
348119a8:	e1530002 	cmp	r3, r2
348119ac:	9a000031 	bls	34811a78 <mmc_startup+0x38c>
		/* check  ext_csd version and capacity */
		err = mmc_send_ext_csd(mmc, ext_csd);
348119b0:	e1a00004 	mov	r0, r4
348119b4:	e1a01005 	mov	r1, r5
348119b8:	ebfffe34 	bl	34811290 <mmc_send_ext_csd>
		if (!err & (ext_csd[EXT_CSD_REV] >= 2)) {
348119bc:	e5d530c0 	ldrb	r3, [r5, #192]	; 0xc0
348119c0:	e2700001 	rsbs	r0, r0, #1
348119c4:	33a00000 	movcc	r0, #0
348119c8:	e3530001 	cmp	r3, #1
348119cc:	93a00000 	movls	r0, #0
348119d0:	e3500000 	cmp	r0, #0
348119d4:	0a000014 	beq	34811a2c <mmc_startup+0x340>
			 * ext_csd's capacity is valid if the value is more
			 * than 2GB
			 */
			capacity = ext_csd[EXT_CSD_SEC_CNT] << 0
					| ext_csd[EXT_CSD_SEC_CNT + 1] << 8
					| ext_csd[EXT_CSD_SEC_CNT + 2] << 16
348119d8:	e5d510d6 	ldrb	r1, [r5, #214]	; 0xd6
			 * According to the JEDEC Standard, the value of
			 * ext_csd's capacity is valid if the value is more
			 * than 2GB
			 */
			capacity = ext_csd[EXT_CSD_SEC_CNT] << 0
					| ext_csd[EXT_CSD_SEC_CNT + 1] << 8
348119dc:	e5d530d5 	ldrb	r3, [r5, #213]	; 0xd5
					| ext_csd[EXT_CSD_SEC_CNT + 2] << 16
348119e0:	e1a01801 	lsl	r1, r1, #16
			 * According to the JEDEC Standard, the value of
			 * ext_csd's capacity is valid if the value is more
			 * than 2GB
			 */
			capacity = ext_csd[EXT_CSD_SEC_CNT] << 0
					| ext_csd[EXT_CSD_SEC_CNT + 1] << 8
348119e4:	e1811403 	orr	r1, r1, r3, lsl #8
			/*
			 * According to the JEDEC Standard, the value of
			 * ext_csd's capacity is valid if the value is more
			 * than 2GB
			 */
			capacity = ext_csd[EXT_CSD_SEC_CNT] << 0
348119e8:	e5d530d4 	ldrb	r3, [r5, #212]	; 0xd4
					| ext_csd[EXT_CSD_SEC_CNT + 1] << 8
					| ext_csd[EXT_CSD_SEC_CNT + 2] << 16
348119ec:	e1811003 	orr	r1, r1, r3
					| ext_csd[EXT_CSD_SEC_CNT + 3] << 24;
348119f0:	e5d530d7 	ldrb	r3, [r5, #215]	; 0xd7
348119f4:	e1811c03 	orr	r1, r1, r3, lsl #24
			/*
			 * According to the JEDEC Standard, the value of
			 * ext_csd's capacity is valid if the value is more
			 * than 2GB
			 */
			capacity = ext_csd[EXT_CSD_SEC_CNT] << 0
348119f8:	e1a02001 	mov	r2, r1
348119fc:	e1a03fc2 	asr	r3, r2, #31
					| ext_csd[EXT_CSD_SEC_CNT + 1] << 8
					| ext_csd[EXT_CSD_SEC_CNT + 2] << 16
					| ext_csd[EXT_CSD_SEC_CNT + 3] << 24;
			capacity *= 512;
34811a00:	e1a03483 	lsl	r3, r3, #9
34811a04:	e1833ba1 	orr	r3, r3, r1, lsr #23
34811a08:	e1a01481 	lsl	r1, r1, #9
			if ((capacity >> 20) > 2 * 1024)
34811a0c:	e1a02a21 	lsr	r2, r1, #20
34811a10:	e1b00a23 	lsrs	r0, r3, #20
34811a14:	e1822603 	orr	r2, r2, r3, lsl #12
34811a18:	1a000001 	bne	34811a24 <mmc_startup+0x338>
34811a1c:	e3520b02 	cmp	r2, #2048	; 0x800
34811a20:	9a000001 	bls	34811a2c <mmc_startup+0x340>
				mmc->capacity = capacity;
34811a24:	e5841098 	str	r1, [r4, #152]	; 0x98
34811a28:	e584309c 	str	r3, [r4, #156]	; 0x9c
		/*
		 * Check whether GROUP_DEF is set, if yes, read out
		 * group size from ext_csd directly, or calculate
		 * the group size from the csd value.
		 */
		if (ext_csd[EXT_CSD_ERASE_GROUP_DEF])
34811a2c:	e5d530af 	ldrb	r3, [r5, #175]	; 0xaf
34811a30:	e3530000 	cmp	r3, #0
			mmc->erase_grp_size =
			      ext_csd[EXT_CSD_HC_ERASE_GRP_SIZE] * 512 * 1024;
		else {
			int erase_gsz, erase_gmul;
			erase_gsz = (mmc->csd[2] & 0x00007c00) >> 10;
34811a34:	05943068 	ldreq	r3, [r4, #104]	; 0x68
		 * group size from ext_csd directly, or calculate
		 * the group size from the csd value.
		 */
		if (ext_csd[EXT_CSD_ERASE_GROUP_DEF])
			mmc->erase_grp_size =
			      ext_csd[EXT_CSD_HC_ERASE_GRP_SIZE] * 512 * 1024;
34811a38:	15d530e0 	ldrbne	r3, [r5, #224]	; 0xe0
		else {
			int erase_gsz, erase_gmul;
			erase_gsz = (mmc->csd[2] & 0x00007c00) >> 10;
			erase_gmul = (mmc->csd[2] & 0x000003e0) >> 5;
34811a3c:	07e422d3 	ubfxeq	r2, r3, #5, #5
		if (ext_csd[EXT_CSD_ERASE_GROUP_DEF])
			mmc->erase_grp_size =
			      ext_csd[EXT_CSD_HC_ERASE_GRP_SIZE] * 512 * 1024;
		else {
			int erase_gsz, erase_gmul;
			erase_gsz = (mmc->csd[2] & 0x00007c00) >> 10;
34811a40:	07e43553 	ubfxeq	r3, r3, #10, #5
			erase_gmul = (mmc->csd[2] & 0x000003e0) >> 5;
			mmc->erase_grp_size = (erase_gsz + 1)
34811a44:	02833001 	addeq	r3, r3, #1
				* (erase_gmul + 1);
34811a48:	02822001 	addeq	r2, r2, #1
34811a4c:	00030293 	muleq	r3, r3, r2
		 * group size from ext_csd directly, or calculate
		 * the group size from the csd value.
		 */
		if (ext_csd[EXT_CSD_ERASE_GROUP_DEF])
			mmc->erase_grp_size =
			      ext_csd[EXT_CSD_HC_ERASE_GRP_SIZE] * 512 * 1024;
34811a50:	11a03983 	lslne	r3, r3, #19
		else {
			int erase_gsz, erase_gmul;
			erase_gsz = (mmc->csd[2] & 0x00007c00) >> 10;
			erase_gmul = (mmc->csd[2] & 0x000003e0) >> 5;
			mmc->erase_grp_size = (erase_gsz + 1)
34811a54:	e5843090 	str	r3, [r4, #144]	; 0x90
				* (erase_gmul + 1);
		}

		/* store the partition info of emmc */
		if ((ext_csd[EXT_CSD_PARTITIONING_SUPPORT] & PART_SUPPORT) ||
34811a58:	e5d530a0 	ldrb	r3, [r5, #160]	; 0xa0
34811a5c:	e3130001 	tst	r3, #1
34811a60:	1a000002 	bne	34811a70 <mmc_startup+0x384>
34811a64:	e5d530e2 	ldrb	r3, [r5, #226]	; 0xe2
34811a68:	e3530000 	cmp	r3, #0
34811a6c:	0a000001 	beq	34811a78 <mmc_startup+0x38c>
		    ext_csd[EXT_CSD_BOOT_MULT])
			mmc->part_config = ext_csd[EXT_CSD_PART_CONF];
34811a70:	e5d530b3 	ldrb	r3, [r5, #179]	; 0xb3
34811a74:	e5c43082 	strb	r3, [r4, #130]	; 0x82
	}

	if (IS_SD(mmc))
34811a78:	e5943030 	ldr	r3, [r4, #48]	; 0x30
34811a7c:	e3130802 	tst	r3, #131072	; 0x20000
34811a80:	0a000002 	beq	34811a90 <mmc_startup+0x3a4>
		err = sd_change_freq(mmc);
34811a84:	e1a00004 	mov	r0, r4
34811a88:	ebfffe87 	bl	348114ac <sd_change_freq>
34811a8c:	ea000001 	b	34811a98 <mmc_startup+0x3ac>
	else
		err = mmc_change_freq(mmc);
34811a90:	e1a00004 	mov	r0, r4
34811a94:	ebfffe25 	bl	34811330 <mmc_change_freq>

	if (err)
34811a98:	e3500000 	cmp	r0, #0
	}

	if (IS_SD(mmc))
		err = sd_change_freq(mmc);
	else
		err = mmc_change_freq(mmc);
34811a9c:	e1a06000 	mov	r6, r0

	if (err)
34811aa0:	1a0000a3 	bne	34811d34 <mmc_startup+0x648>
		return err;

	/* Restrict card's capabilities by what the host can do */
	mmc->card_caps &= mmc->host_caps;
34811aa4:	e594304c 	ldr	r3, [r4, #76]	; 0x4c
34811aa8:	e5947050 	ldr	r7, [r4, #80]	; 0x50

	if (IS_SD(mmc)) {
34811aac:	e5942030 	ldr	r2, [r4, #48]	; 0x30

	if (err)
		return err;

	/* Restrict card's capabilities by what the host can do */
	mmc->card_caps &= mmc->host_caps;
34811ab0:	e0073003 	and	r3, r7, r3

	if (IS_SD(mmc)) {
34811ab4:	e3120802 	tst	r2, #131072	; 0x20000

	if (err)
		return err;

	/* Restrict card's capabilities by what the host can do */
	mmc->card_caps &= mmc->host_caps;
34811ab8:	e584304c 	str	r3, [r4, #76]	; 0x4c

	if (IS_SD(mmc)) {
34811abc:	0a000027 	beq	34811b60 <mmc_startup+0x474>
		if (mmc->card_caps & MMC_MODE_4BIT) {
34811ac0:	e3130c01 	tst	r3, #256	; 0x100
34811ac4:	0a000020 	beq	34811b4c <mmc_startup+0x460>
			cmd.cmdidx = MMC_CMD_APP_CMD;
			cmd.resp_type = MMC_RSP_R1;
			cmd.cmdarg = mmc->rca << 16;
34811ac8:	e1d438b0 	ldrh	r3, [r4, #128]	; 0x80

			err = mmc_send_cmd(mmc, &cmd, NULL);
34811acc:	e28d5e49 	add	r5, sp, #1168	; 0x490
	/* Restrict card's capabilities by what the host can do */
	mmc->card_caps &= mmc->host_caps;

	if (IS_SD(mmc)) {
		if (mmc->card_caps & MMC_MODE_4BIT) {
			cmd.cmdidx = MMC_CMD_APP_CMD;
34811ad0:	e3a01037 	mov	r1, #55	; 0x37
34811ad4:	e28d2b01 	add	r2, sp, #1024	; 0x400
			cmd.resp_type = MMC_RSP_R1;
			cmd.cmdarg = mmc->rca << 16;

			err = mmc_send_cmd(mmc, &cmd, NULL);
34811ad8:	e285500c 	add	r5, r5, #12
	/* Restrict card's capabilities by what the host can do */
	mmc->card_caps &= mmc->host_caps;

	if (IS_SD(mmc)) {
		if (mmc->card_caps & MMC_MODE_4BIT) {
			cmd.cmdidx = MMC_CMD_APP_CMD;
34811adc:	e1c219bc 	strh	r1, [r2, #156]	; 0x9c
			cmd.resp_type = MMC_RSP_R1;
			cmd.cmdarg = mmc->rca << 16;
34811ae0:	e1a03803 	lsl	r3, r3, #16
	mmc->card_caps &= mmc->host_caps;

	if (IS_SD(mmc)) {
		if (mmc->card_caps & MMC_MODE_4BIT) {
			cmd.cmdidx = MMC_CMD_APP_CMD;
			cmd.resp_type = MMC_RSP_R1;
34811ae4:	e3a07015 	mov	r7, #21
			cmd.cmdarg = mmc->rca << 16;

			err = mmc_send_cmd(mmc, &cmd, NULL);
34811ae8:	e1a00004 	mov	r0, r4
34811aec:	e1a01005 	mov	r1, r5
34811af0:	e1a02006 	mov	r2, r6
	mmc->card_caps &= mmc->host_caps;

	if (IS_SD(mmc)) {
		if (mmc->card_caps & MMC_MODE_4BIT) {
			cmd.cmdidx = MMC_CMD_APP_CMD;
			cmd.resp_type = MMC_RSP_R1;
34811af4:	e58d74a0 	str	r7, [sp, #1184]	; 0x4a0
			cmd.cmdarg = mmc->rca << 16;
34811af8:	e58d34a4 	str	r3, [sp, #1188]	; 0x4a4

			err = mmc_send_cmd(mmc, &cmd, NULL);
34811afc:	ebfffbac 	bl	348109b4 <mmc_send_cmd>
			if (err)
34811b00:	e3500000 	cmp	r0, #0
34811b04:	1a000089 	bne	34811d30 <mmc_startup+0x644>
				return err;

			cmd.cmdidx = SD_CMD_APP_SET_BUS_WIDTH;
34811b08:	e3a03006 	mov	r3, #6
34811b0c:	e28d0b01 	add	r0, sp, #1024	; 0x400
34811b10:	e1c039bc 	strh	r3, [r0, #156]	; 0x9c
			cmd.resp_type = MMC_RSP_R1;
			cmd.cmdarg = 2;
			err = mmc_send_cmd(mmc, &cmd, NULL);
34811b14:	e1a01005 	mov	r1, r5
			if (err)
				return err;

			cmd.cmdidx = SD_CMD_APP_SET_BUS_WIDTH;
			cmd.resp_type = MMC_RSP_R1;
			cmd.cmdarg = 2;
34811b18:	e3a03002 	mov	r3, #2
			err = mmc_send_cmd(mmc, &cmd, NULL);
34811b1c:	e1a00004 	mov	r0, r4
34811b20:	e1a02006 	mov	r2, r6
			err = mmc_send_cmd(mmc, &cmd, NULL);
			if (err)
				return err;

			cmd.cmdidx = SD_CMD_APP_SET_BUS_WIDTH;
			cmd.resp_type = MMC_RSP_R1;
34811b24:	e58d74a0 	str	r7, [sp, #1184]	; 0x4a0
			cmd.cmdarg = 2;
34811b28:	e58d34a4 	str	r3, [sp, #1188]	; 0x4a4
			err = mmc_send_cmd(mmc, &cmd, NULL);
34811b2c:	ebfffba0 	bl	348109b4 <mmc_send_cmd>
			if (err)
34811b30:	e3500000 	cmp	r0, #0
34811b34:	1a00007d 	bne	34811d30 <mmc_startup+0x644>
	mmc_set_ios(mmc);
}

void mmc_set_bus_width(struct mmc *mmc, uint width)
{
	mmc->bus_width = width;
34811b38:	e3a03004 	mov	r3, #4
34811b3c:	e5843044 	str	r3, [r4, #68]	; 0x44
	80,
};

void mmc_set_ios(struct mmc *mmc)
{
	mmc->set_ios(mmc);
34811b40:	e1a00004 	mov	r0, r4
34811b44:	e5943114 	ldr	r3, [r4, #276]	; 0x114
34811b48:	e12fff33 	blx	r3
				return err;

			mmc_set_bus_width(mmc, 4);
		}

		if (mmc->card_caps & MMC_MODE_HS)
34811b4c:	e594304c 	ldr	r3, [r4, #76]	; 0x4c
34811b50:	e3130001 	tst	r3, #1
			mmc->tran_speed = 50000000;
34811b54:	159f3200 	ldrne	r3, [pc, #512]	; 34811d5c <mmc_startup+0x670>
		else
			mmc->tran_speed = 25000000;
34811b58:	059f3200 	ldreq	r3, [pc, #512]	; 34811d60 <mmc_startup+0x674>
34811b5c:	ea00003e 	b	34811c5c <mmc_startup+0x570>
	} else {
		width = ((mmc->host_caps & MMC_MODE_MASK_WIDTH_BITS) >>
34811b60:	e7e17457 	ubfx	r7, r7, #8, #2
				    == test_csd[EXT_CSD_ERASE_GROUP_DEF] \
				 && ext_csd[EXT_CSD_REV] \
				    == test_csd[EXT_CSD_REV]
				 && ext_csd[EXT_CSD_HC_ERASE_GRP_SIZE] \
				    == test_csd[EXT_CSD_HC_ERASE_GRP_SIZE]
				 && memcmp(&ext_csd[EXT_CSD_SEC_CNT], \
34811b64:	e28a10d4 	add	r1, sl, #212	; 0xd4
	mmc->bus_width = width;

	mmc_set_ios(mmc);
}

int mmc_startup(struct mmc *mmc)
34811b68:	e1a09107 	lsl	r9, r7, #2
				    == test_csd[EXT_CSD_ERASE_GROUP_DEF] \
				 && ext_csd[EXT_CSD_REV] \
				    == test_csd[EXT_CSD_REV]
				 && ext_csd[EXT_CSD_HC_ERASE_GRP_SIZE] \
				    == test_csd[EXT_CSD_HC_ERASE_GRP_SIZE]
				 && memcmp(&ext_csd[EXT_CSD_SEC_CNT], \
34811b6c:	e285b0d4 	add	fp, r5, #212	; 0xd4
34811b70:	e58d1014 	str	r1, [sp, #20]
	} else {
		width = ((mmc->host_caps & MMC_MODE_MASK_WIDTH_BITS) >>
			 MMC_MODE_WIDTH_BITS_SHIFT);
		for (; width >= 0; width--) {
			/* Set the card to use 4 bit*/
			err = mmc_switch(mmc, EXT_CSD_CMD_SET_NORMAL,
34811b74:	e1a00004 	mov	r0, r4
34811b78:	e3a01001 	mov	r1, #1
34811b7c:	e3a020b7 	mov	r2, #183	; 0xb7
34811b80:	e6ef3077 	uxtb	r3, r7
34811b84:	ebfffdd4 	bl	348112dc <mmc_switch>
					EXT_CSD_BUS_WIDTH, width);

			if (err)
34811b88:	e3500000 	cmp	r0, #0
34811b8c:	1a000028 	bne	34811c34 <mmc_startup+0x548>
				continue;

			if (!width) {
34811b90:	e3570000 	cmp	r7, #0
34811b94:	e5943114 	ldr	r3, [r4, #276]	; 0x114
34811b98:	1a000004 	bne	34811bb0 <mmc_startup+0x4c4>
	mmc_set_ios(mmc);
}

void mmc_set_bus_width(struct mmc *mmc, uint width)
{
	mmc->bus_width = width;
34811b9c:	e3a02001 	mov	r2, #1
34811ba0:	e5842044 	str	r2, [r4, #68]	; 0x44
	80,
};

void mmc_set_ios(struct mmc *mmc)
{
	mmc->set_ios(mmc);
34811ba4:	e1a00004 	mov	r0, r4
34811ba8:	e12fff33 	blx	r3
			if (err)
				continue;

			if (!width) {
				mmc_set_bus_width(mmc, 1);
				break;
34811bac:	ea000024 	b	34811c44 <mmc_startup+0x558>
	80,
};

void mmc_set_ios(struct mmc *mmc)
{
	mmc->set_ios(mmc);
34811bb0:	e1a00004 	mov	r0, r4
	mmc_set_ios(mmc);
}

void mmc_set_bus_width(struct mmc *mmc, uint width)
{
	mmc->bus_width = width;
34811bb4:	e5849044 	str	r9, [r4, #68]	; 0x44
	80,
};

void mmc_set_ios(struct mmc *mmc)
{
	mmc->set_ios(mmc);
34811bb8:	e12fff33 	blx	r3
				mmc_set_bus_width(mmc, 1);
				break;
			} else
				mmc_set_bus_width(mmc, 4 * width);

			err = mmc_send_ext_csd(mmc, test_csd);
34811bbc:	e1a00004 	mov	r0, r4
34811bc0:	e1a0100a 	mov	r1, sl
34811bc4:	ebfffdb1 	bl	34811290 <mmc_send_ext_csd>
			if (!err && ext_csd[EXT_CSD_PARTITIONING_SUPPORT] \
34811bc8:	e3500000 	cmp	r0, #0
34811bcc:	1a000018 	bne	34811c34 <mmc_startup+0x548>
34811bd0:	e5d520a0 	ldrb	r2, [r5, #160]	; 0xa0
34811bd4:	e5da30a0 	ldrb	r3, [sl, #160]	; 0xa0
34811bd8:	e1520003 	cmp	r2, r3
34811bdc:	1a000014 	bne	34811c34 <mmc_startup+0x548>
				    == test_csd[EXT_CSD_PARTITIONING_SUPPORT]
				 && ext_csd[EXT_CSD_ERASE_GROUP_DEF] \
34811be0:	e5d520af 	ldrb	r2, [r5, #175]	; 0xaf
34811be4:	e5da30af 	ldrb	r3, [sl, #175]	; 0xaf
34811be8:	e1520003 	cmp	r2, r3
34811bec:	1a000010 	bne	34811c34 <mmc_startup+0x548>
				    == test_csd[EXT_CSD_ERASE_GROUP_DEF] \
				 && ext_csd[EXT_CSD_REV] \
34811bf0:	e5d520c0 	ldrb	r2, [r5, #192]	; 0xc0
34811bf4:	e5da30c0 	ldrb	r3, [sl, #192]	; 0xc0
34811bf8:	e1520003 	cmp	r2, r3
34811bfc:	1a00000c 	bne	34811c34 <mmc_startup+0x548>
				    == test_csd[EXT_CSD_REV]
				 && ext_csd[EXT_CSD_HC_ERASE_GRP_SIZE] \
34811c00:	e5d520e0 	ldrb	r2, [r5, #224]	; 0xe0
34811c04:	e5da30e0 	ldrb	r3, [sl, #224]	; 0xe0
34811c08:	e1520003 	cmp	r2, r3
34811c0c:	1a000008 	bne	34811c34 <mmc_startup+0x548>
				    == test_csd[EXT_CSD_HC_ERASE_GRP_SIZE]
				 && memcmp(&ext_csd[EXT_CSD_SEC_CNT], \
34811c10:	e1a0000b 	mov	r0, fp
34811c14:	e59d1014 	ldr	r1, [sp, #20]
34811c18:	e3a02004 	mov	r2, #4
34811c1c:	eb001cce 	bl	34818f5c <memcmp>
34811c20:	e3500000 	cmp	r0, #0
					&test_csd[EXT_CSD_SEC_CNT], 4) == 0) {

				mmc->card_caps |= width;
34811c24:	0594304c 	ldreq	r3, [r4, #76]	; 0x4c
34811c28:	01837007 	orreq	r7, r3, r7
34811c2c:	0584704c 	streq	r7, [r4, #76]	; 0x4c
				break;
34811c30:	0a000003 	beq	34811c44 <mmc_startup+0x558>
		else
			mmc->tran_speed = 25000000;
	} else {
		width = ((mmc->host_caps & MMC_MODE_MASK_WIDTH_BITS) >>
			 MMC_MODE_WIDTH_BITS_SHIFT);
		for (; width >= 0; width--) {
34811c34:	e2477001 	sub	r7, r7, #1
34811c38:	e3770001 	cmn	r7, #1
34811c3c:	e2499004 	sub	r9, r9, #4
34811c40:	1affffcb 	bne	34811b74 <mmc_startup+0x488>
				mmc->card_caps |= width;
				break;
			}
		}

		if (mmc->card_caps & MMC_MODE_HS) {
34811c44:	e594304c 	ldr	r3, [r4, #76]	; 0x4c
34811c48:	e3130001 	tst	r3, #1
34811c4c:	0a000003 	beq	34811c60 <mmc_startup+0x574>
			if (mmc->card_caps & MMC_MODE_HS_52MHz)
34811c50:	e3130010 	tst	r3, #16
				mmc->tran_speed = 52000000;
34811c54:	159f3108 	ldrne	r3, [pc, #264]	; 34811d64 <mmc_startup+0x678>
			else
				mmc->tran_speed = 26000000;
34811c58:	059f3108 	ldreq	r3, [pc, #264]	; 34811d68 <mmc_startup+0x67c>
34811c5c:	e5843084 	str	r3, [r4, #132]	; 0x84
		}
	}

	mmc_set_clock(mmc, mmc->tran_speed);
34811c60:	e1a00004 	mov	r0, r4
34811c64:	e5941084 	ldr	r1, [r4, #132]	; 0x84
34811c68:	ebfffe8f 	bl	348116ac <mmc_set_clock>

	/* fill in device description */
	mmc->block_dev.lun = 0;
	mmc->block_dev.type = 0;
	mmc->block_dev.blksz = mmc->read_bl_len;
	mmc->block_dev.lba = lldiv(mmc->capacity, mmc->read_bl_len);
34811c6c:	e594509c 	ldr	r5, [r4, #156]	; 0x9c
	}

	mmc_set_clock(mmc, mmc->tran_speed);

	/* fill in device description */
	mmc->block_dev.lun = 0;
34811c70:	e3a03000 	mov	r3, #0
	mmc->block_dev.type = 0;
	mmc->block_dev.blksz = mmc->read_bl_len;
34811c74:	e5941088 	ldr	r1, [r4, #136]	; 0x88
	mmc->block_dev.lba = lldiv(mmc->capacity, mmc->read_bl_len);
34811c78:	e5940098 	ldr	r0, [r4, #152]	; 0x98
 * the result, not reminder.
 */
static inline uint64_t lldiv(uint64_t dividend, uint32_t divisor)
{
	uint64_t __res = dividend;
	do_div(__res, divisor);
34811c7c:	e1550003 	cmp	r5, r3
	}

	mmc_set_clock(mmc, mmc->tran_speed);

	/* fill in device description */
	mmc->block_dev.lun = 0;
34811c80:	e5c430aa 	strb	r3, [r4, #170]	; 0xaa
	mmc->block_dev.type = 0;
34811c84:	e5c430ab 	strb	r3, [r4, #171]	; 0xab
	mmc->block_dev.blksz = mmc->read_bl_len;
34811c88:	e58410b4 	str	r1, [r4, #180]	; 0xb4
/* Wrapper for do_div(). Doesn't modify dividend and returns
 * the result, not reminder.
 */
static inline uint64_t lldiv(uint64_t dividend, uint32_t divisor)
{
	uint64_t __res = dividend;
34811c8c:	e58d04b8 	str	r0, [sp, #1208]	; 0x4b8
34811c90:	e58d54bc 	str	r5, [sp, #1212]	; 0x4bc
	do_div(__res, divisor);
34811c94:	1a000003 	bne	34811ca8 <mmc_startup+0x5bc>
34811c98:	eb003881 	bl	3481fea4 <__udivsi3>
34811c9c:	e58d54bc 	str	r5, [sp, #1212]	; 0x4bc
34811ca0:	e58d04b8 	str	r0, [sp, #1208]	; 0x4b8
34811ca4:	ea000002 	b	34811cb4 <mmc_startup+0x5c8>
34811ca8:	e28d0e4b 	add	r0, sp, #1200	; 0x4b0
34811cac:	e2800008 	add	r0, r0, #8
34811cb0:	eb0015b1 	bl	3481737c <__div64_32>
	mmc->block_dev.lba = lldiv(mmc->capacity, mmc->read_bl_len);
34811cb4:	e59d34b8 	ldr	r3, [sp, #1208]	; 0x4b8
	sprintf(mmc->block_dev.vendor, "Man %06x Snr %08x", mmc->cid[0] >> 8,
			(mmc->cid[2] << 8) | (mmc->cid[3] >> 24));
34811cb8:	e594c078 	ldr	ip, [r4, #120]	; 0x78

	/* fill in device description */
	mmc->block_dev.lun = 0;
	mmc->block_dev.type = 0;
	mmc->block_dev.blksz = mmc->read_bl_len;
	mmc->block_dev.lba = lldiv(mmc->capacity, mmc->read_bl_len);
34811cbc:	e58430b0 	str	r3, [r4, #176]	; 0xb0
	sprintf(mmc->block_dev.vendor, "Man %06x Snr %08x", mmc->cid[0] >> 8,
34811cc0:	e5942070 	ldr	r2, [r4, #112]	; 0x70
			(mmc->cid[2] << 8) | (mmc->cid[3] >> 24));
34811cc4:	e5d4307f 	ldrb	r3, [r4, #127]	; 0x7f
	/* fill in device description */
	mmc->block_dev.lun = 0;
	mmc->block_dev.type = 0;
	mmc->block_dev.blksz = mmc->read_bl_len;
	mmc->block_dev.lba = lldiv(mmc->capacity, mmc->read_bl_len);
	sprintf(mmc->block_dev.vendor, "Man %06x Snr %08x", mmc->cid[0] >> 8,
34811cc8:	e28400b8 	add	r0, r4, #184	; 0xb8
34811ccc:	e183340c 	orr	r3, r3, ip, lsl #8
34811cd0:	e59f1094 	ldr	r1, [pc, #148]	; 34811d6c <mmc_startup+0x680>
34811cd4:	e1a02422 	lsr	r2, r2, #8
34811cd8:	eb00206c 	bl	34819e90 <sprintf>
			(mmc->cid[2] << 8) | (mmc->cid[3] >> 24));
	sprintf(mmc->block_dev.product, "%c%c%c%c%c", mmc->cid[0] & 0xff,
			(mmc->cid[1] >> 24), (mmc->cid[1] >> 16) & 0xff,
34811cdc:	e5943074 	ldr	r3, [r4, #116]	; 0x74
	mmc->block_dev.type = 0;
	mmc->block_dev.blksz = mmc->read_bl_len;
	mmc->block_dev.lba = lldiv(mmc->capacity, mmc->read_bl_len);
	sprintf(mmc->block_dev.vendor, "Man %06x Snr %08x", mmc->cid[0] >> 8,
			(mmc->cid[2] << 8) | (mmc->cid[3] >> 24));
	sprintf(mmc->block_dev.product, "%c%c%c%c%c", mmc->cid[0] & 0xff,
34811ce0:	e5d42070 	ldrb	r2, [r4, #112]	; 0x70
34811ce4:	e7e71853 	ubfx	r1, r3, #16, #8
34811ce8:	e58d1000 	str	r1, [sp]
34811cec:	e7e71453 	ubfx	r1, r3, #8, #8
34811cf0:	e58d1004 	str	r1, [sp, #4]
34811cf4:	e20310ff 	and	r1, r3, #255	; 0xff
34811cf8:	e58d1008 	str	r1, [sp, #8]
34811cfc:	e28400e1 	add	r0, r4, #225	; 0xe1
34811d00:	e59f1068 	ldr	r1, [pc, #104]	; 34811d70 <mmc_startup+0x684>
34811d04:	e1a03c23 	lsr	r3, r3, #24
34811d08:	eb002060 	bl	34819e90 <sprintf>
			(mmc->cid[1] >> 24), (mmc->cid[1] >> 16) & 0xff,
			(mmc->cid[1] >> 8) & 0xff, mmc->cid[1] & 0xff);
	sprintf(mmc->block_dev.revision, "%d.%d", mmc->cid[2] >> 28,
34811d0c:	e5943078 	ldr	r3, [r4, #120]	; 0x78
34811d10:	e28400f6 	add	r0, r4, #246	; 0xf6
34811d14:	e1a02e23 	lsr	r2, r3, #28
34811d18:	e59f1054 	ldr	r1, [pc, #84]	; 34811d74 <mmc_startup+0x688>
34811d1c:	e7e33c53 	ubfx	r3, r3, #24, #4
34811d20:	eb00205a 	bl	34819e90 <sprintf>
			(mmc->cid[2] >> 24) & 0xf);
#if !defined(CONFIG_SPL_BUILD) || defined(CONFIG_SPL_LIBDISK_SUPPORT)
	init_part(&mmc->block_dev);
34811d24:	e28400a0 	add	r0, r4, #160	; 0xa0
34811d28:	ebfff497 	bl	3480ef8c <init_part>
#endif

	return 0;
34811d2c:	ea000000 	b	34811d34 <mmc_startup+0x648>

			cmd.cmdidx = SD_CMD_APP_SET_BUS_WIDTH;
			cmd.resp_type = MMC_RSP_R1;
			cmd.cmdarg = 2;
			err = mmc_send_cmd(mmc, &cmd, NULL);
			if (err)
34811d30:	e1a06000 	mov	r6, r0
#if !defined(CONFIG_SPL_BUILD) || defined(CONFIG_SPL_LIBDISK_SUPPORT)
	init_part(&mmc->block_dev);
#endif

	return 0;
}
34811d34:	e1a00006 	mov	r0, r6
34811d38:	e28ddd13 	add	sp, sp, #1216	; 0x4c0
34811d3c:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
34811d40:	00010014 	.word	0x00010014
34811d44:	00010022 	.word	0x00010022
34811d48:	00010030 	.word	0x00010030
34811d4c:	00010040 	.word	0x00010040
34811d50:	00010012 	.word	0x00010012
34811d54:	348217bc 	.word	0x348217bc
34811d58:	0001003f 	.word	0x0001003f
34811d5c:	02faf080 	.word	0x02faf080
34811d60:	017d7840 	.word	0x017d7840
34811d64:	03197500 	.word	0x03197500
34811d68:	018cba80 	.word	0x018cba80
34811d6c:	34826f74 	.word	0x34826f74
34811d70:	34826f86 	.word	0x34826f86
34811d74:	34827dad 	.word	0x34827dad

34811d78 <mmc_send_if_cond>:

int mmc_send_if_cond(struct mmc *mmc)
{
34811d78:	e92d4010 	push	{r4, lr}
	struct mmc_cmd cmd;
	int err;

	cmd.cmdidx = SD_CMD_SEND_IF_COND;
34811d7c:	e3a03008 	mov	r3, #8

	return 0;
}

int mmc_send_if_cond(struct mmc *mmc)
{
34811d80:	e24dd020 	sub	sp, sp, #32
	struct mmc_cmd cmd;
	int err;

	cmd.cmdidx = SD_CMD_SEND_IF_COND;
	/* We set the bit if the host supports voltages between 2.7 and 3.6 V */
	cmd.cmdarg = ((mmc->voltages & 0xff8000) != 0) << 8 | 0xaa;
34811d84:	e590202c 	ldr	r2, [r0, #44]	; 0x2c
int mmc_send_if_cond(struct mmc *mmc)
{
	struct mmc_cmd cmd;
	int err;

	cmd.cmdidx = SD_CMD_SEND_IF_COND;
34811d88:	e1cd30b4 	strh	r3, [sp, #4]
	/* We set the bit if the host supports voltages between 2.7 and 3.6 V */
	cmd.cmdarg = ((mmc->voltages & 0xff8000) != 0) << 8 | 0xaa;
34811d8c:	e59f3050 	ldr	r3, [pc, #80]	; 34811de4 <mmc_send_if_cond+0x6c>
	cmd.resp_type = MMC_RSP_R7;

	err = mmc_send_cmd(mmc, &cmd, NULL);
34811d90:	e28d1004 	add	r1, sp, #4
	struct mmc_cmd cmd;
	int err;

	cmd.cmdidx = SD_CMD_SEND_IF_COND;
	/* We set the bit if the host supports voltages between 2.7 and 3.6 V */
	cmd.cmdarg = ((mmc->voltages & 0xff8000) != 0) << 8 | 0xaa;
34811d94:	e0023003 	and	r3, r2, r3
34811d98:	e3530000 	cmp	r3, #0
34811d9c:	e30021aa 	movw	r2, #426	; 0x1aa
34811da0:	11a03002 	movne	r3, r2
34811da4:	03a030aa 	moveq	r3, #170	; 0xaa
34811da8:	e58d300c 	str	r3, [sp, #12]
	cmd.resp_type = MMC_RSP_R7;

	err = mmc_send_cmd(mmc, &cmd, NULL);
34811dac:	e3a02000 	mov	r2, #0
	int err;

	cmd.cmdidx = SD_CMD_SEND_IF_COND;
	/* We set the bit if the host supports voltages between 2.7 and 3.6 V */
	cmd.cmdarg = ((mmc->voltages & 0xff8000) != 0) << 8 | 0xaa;
	cmd.resp_type = MMC_RSP_R7;
34811db0:	e3a03015 	mov	r3, #21

	return 0;
}

int mmc_send_if_cond(struct mmc *mmc)
{
34811db4:	e1a04000 	mov	r4, r0
	int err;

	cmd.cmdidx = SD_CMD_SEND_IF_COND;
	/* We set the bit if the host supports voltages between 2.7 and 3.6 V */
	cmd.cmdarg = ((mmc->voltages & 0xff8000) != 0) << 8 | 0xaa;
	cmd.resp_type = MMC_RSP_R7;
34811db8:	e58d3008 	str	r3, [sp, #8]

	err = mmc_send_cmd(mmc, &cmd, NULL);
34811dbc:	ebfffafc 	bl	348109b4 <mmc_send_cmd>

	if (err)
34811dc0:	e3500000 	cmp	r0, #0
34811dc4:	1a000004 	bne	34811ddc <mmc_send_if_cond+0x64>
		return err;

	if ((cmd.response[0] & 0xff) != 0xaa)
34811dc8:	e5dd3010 	ldrb	r3, [sp, #16]
34811dcc:	e35300aa 	cmp	r3, #170	; 0xaa
		return UNUSABLE_ERR;
	else
		mmc->version = SD_VERSION_2;
34811dd0:	059f3010 	ldreq	r3, [pc, #16]	; 34811de8 <mmc_send_if_cond+0x70>

	if (err)
		return err;

	if ((cmd.response[0] & 0xff) != 0xaa)
		return UNUSABLE_ERR;
34811dd4:	13e00010 	mvnne	r0, #16
	else
		mmc->version = SD_VERSION_2;
34811dd8:	05843030 	streq	r3, [r4, #48]	; 0x30

	return 0;
}
34811ddc:	e28dd020 	add	sp, sp, #32
34811de0:	e8bd8010 	pop	{r4, pc}
34811de4:	00ff8000 	.word	0x00ff8000
34811de8:	00020020 	.word	0x00020020

34811dec <mmc_register>:

int mmc_register(struct mmc *mmc)
{
	/* Setup the universal parts of the block interface just once */
	mmc->block_dev.if_type = IF_TYPE_MMC;
34811dec:	e3a03006 	mov	r3, #6
34811df0:	e58030a0 	str	r3, [r0, #160]	; 0xa0
	mmc->block_dev.dev = cur_dev_num++;
34811df4:	e59f305c 	ldr	r3, [pc, #92]	; 34811e58 <mmc_register+0x6c>
34811df8:	e5932000 	ldr	r2, [r3]
34811dfc:	e58020a4 	str	r2, [r0, #164]	; 0xa4
34811e00:	e2822001 	add	r2, r2, #1
34811e04:	e5832000 	str	r2, [r3]
	mmc->block_dev.removable = 1;
34811e08:	e3a03001 	mov	r3, #1
34811e0c:	e5c030ac 	strb	r3, [r0, #172]	; 0xac
	mmc->block_dev.block_read = mmc_bread;
34811e10:	e59f3044 	ldr	r3, [pc, #68]	; 34811e5c <mmc_register+0x70>
34811e14:	e5803100 	str	r3, [r0, #256]	; 0x100
	mmc->block_dev.block_write = mmc_bwrite;
34811e18:	e59f3040 	ldr	r3, [pc, #64]	; 34811e60 <mmc_register+0x74>
34811e1c:	e5803104 	str	r3, [r0, #260]	; 0x104
	mmc->block_dev.block_erase = mmc_berase;
34811e20:	e59f303c 	ldr	r3, [pc, #60]	; 34811e64 <mmc_register+0x78>
34811e24:	e5803108 	str	r3, [r0, #264]	; 0x108
	if (!mmc->b_max)
34811e28:	e5903120 	ldr	r3, [r0, #288]	; 0x120
34811e2c:	e3530000 	cmp	r3, #0
		mmc->b_max = CONFIG_SYS_MMC_MAX_BLK_COUNT;
34811e30:	030f3fff 	movweq	r3, #65535	; 0xffff
34811e34:	05803120 	streq	r3, [r0, #288]	; 0x120
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
34811e38:	e59f3028 	ldr	r3, [pc, #40]	; 34811e68 <mmc_register+0x7c>
34811e3c:	e5932004 	ldr	r2, [r3, #4]
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
	new->next = next;
34811e40:	e5803000 	str	r3, [r0]
 */
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
34811e44:	e5830004 	str	r0, [r3, #4]
	new->next = next;
	new->prev = prev;
	prev->next = new;
34811e48:	e5820000 	str	r0, [r2]
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
	new->next = next;
	new->prev = prev;
34811e4c:	e5802004 	str	r2, [r0, #4]
	INIT_LIST_HEAD (&mmc->link);

	list_add_tail (&mmc->link, &mmc_devices);

	return 0;
}
34811e50:	e3a00000 	mov	r0, #0
34811e54:	e12fff1e 	bx	lr
34811e58:	3482894c 	.word	0x3482894c
34811e5c:	34810f14 	.word	0x34810f14
34811e60:	34810cc8 	.word	0x34810cc8
34811e64:	34810b38 	.word	0x34810b38
34811e68:	3482b18c 	.word	0x3482b18c

34811e6c <mmc_init>:
	return &mmc->block_dev;
}
#endif

int mmc_init(struct mmc *mmc)
{
34811e6c:	e92d4038 	push	{r3, r4, r5, lr}
34811e70:	e1a04000 	mov	r4, r0
	int err;

	if (mmc_getcd(mmc) == 0) {
34811e74:	ebfffd68 	bl	3481141c <mmc_getcd>
34811e78:	e3500000 	cmp	r0, #0
34811e7c:	1a000004 	bne	34811e94 <mmc_init+0x28>
		mmc->has_init = 0;
34811e80:	e5840034 	str	r0, [r4, #52]	; 0x34
		printf("MMC: no card present\n");
34811e84:	e59f00b8 	ldr	r0, [pc, #184]	; 34811f44 <mmc_init+0xd8>
34811e88:	ebffdc2f 	bl	34808f4c <printf>
		return NO_CARD_ERR;
34811e8c:	e3e0000f 	mvn	r0, #15
34811e90:	e8bd8038 	pop	{r3, r4, r5, pc}
	}

	if (mmc->has_init)
34811e94:	e5943034 	ldr	r3, [r4, #52]	; 0x34
34811e98:	e3530000 	cmp	r3, #0
34811e9c:	1a000026 	bne	34811f3c <mmc_init+0xd0>
		return 0;

	err = mmc->init(mmc);
34811ea0:	e5943118 	ldr	r3, [r4, #280]	; 0x118
34811ea4:	e1a00004 	mov	r0, r4
34811ea8:	e12fff33 	blx	r3

	if (err)
34811eac:	e3500000 	cmp	r0, #0
34811eb0:	18bd8038 	popne	{r3, r4, r5, pc}
	mmc_set_ios(mmc);
}

void mmc_set_bus_width(struct mmc *mmc, uint width)
{
	mmc->bus_width = width;
34811eb4:	e3a05001 	mov	r5, #1
	80,
};

void mmc_set_ios(struct mmc *mmc)
{
	mmc->set_ios(mmc);
34811eb8:	e5943114 	ldr	r3, [r4, #276]	; 0x114
34811ebc:	e1a00004 	mov	r0, r4
	mmc_set_ios(mmc);
}

void mmc_set_bus_width(struct mmc *mmc, uint width)
{
	mmc->bus_width = width;
34811ec0:	e5845044 	str	r5, [r4, #68]	; 0x44
	80,
};

void mmc_set_ios(struct mmc *mmc)
{
	mmc->set_ios(mmc);
34811ec4:	e12fff33 	blx	r3

	if (err)
		return err;

	mmc_set_bus_width(mmc, 1);
	mmc_set_clock(mmc, 1);
34811ec8:	e1a00004 	mov	r0, r4
34811ecc:	e1a01005 	mov	r1, r5
34811ed0:	ebfffdf5 	bl	348116ac <mmc_set_clock>

	/* Reset the Card */
	err = mmc_go_idle(mmc);
34811ed4:	e1a00004 	mov	r0, r4
34811ed8:	ebfffc36 	bl	34810fb8 <mmc_go_idle>

	if (err)
34811edc:	e3500000 	cmp	r0, #0
34811ee0:	18bd8038 	popne	{r3, r4, r5, pc}
		return err;

	/* The internal partition reset to user partition(0) at every CMD0*/
	mmc->part_num = 0;
34811ee4:	e5c40083 	strb	r0, [r4, #131]	; 0x83

	/* Test for SD version 2 */
	err = mmc_send_if_cond(mmc);
34811ee8:	e1a00004 	mov	r0, r4
34811eec:	ebffffa1 	bl	34811d78 <mmc_send_if_cond>

	/* Now try to get the SD card's operating condition */
	err = sd_send_op_cond(mmc);
34811ef0:	e1a00004 	mov	r0, r4
34811ef4:	ebfffc42 	bl	34811004 <sd_send_op_cond>

	/* If the command timed out, we check for an MMC card */
	if (err == TIMEOUT) {
34811ef8:	e3700013 	cmn	r0, #19
34811efc:	1a000007 	bne	34811f20 <mmc_init+0xb4>
		err = mmc_send_op_cond(mmc);
34811f00:	e1a00004 	mov	r0, r4
34811f04:	ebfffc90 	bl	3481114c <mmc_send_op_cond>

		if (err) {
34811f08:	e3500000 	cmp	r0, #0
34811f0c:	0a000003 	beq	34811f20 <mmc_init+0xb4>
			printf("Card did not respond to voltage select!\n");
34811f10:	e59f0030 	ldr	r0, [pc, #48]	; 34811f48 <mmc_init+0xdc>
34811f14:	ebffdc0c 	bl	34808f4c <printf>
			return UNUSABLE_ERR;
34811f18:	e3e00010 	mvn	r0, #16
34811f1c:	e8bd8038 	pop	{r3, r4, r5, pc}
		}
	}

	err = mmc_startup(mmc);
34811f20:	e1a00004 	mov	r0, r4
34811f24:	ebfffdf0 	bl	348116ec <mmc_startup>
	if (err)
34811f28:	e3500000 	cmp	r0, #0
		mmc->has_init = 0;
34811f2c:	13a03000 	movne	r3, #0
	else
		mmc->has_init = 1;
34811f30:	03a03001 	moveq	r3, #1
34811f34:	e5843034 	str	r3, [r4, #52]	; 0x34
34811f38:	e8bd8038 	pop	{r3, r4, r5, pc}
		printf("MMC: no card present\n");
		return NO_CARD_ERR;
	}

	if (mmc->has_init)
		return 0;
34811f3c:	e3a00000 	mov	r0, #0
	if (err)
		mmc->has_init = 0;
	else
		mmc->has_init = 1;
	return err;
}
34811f40:	e8bd8038 	pop	{r3, r4, r5, pc}
34811f44:	34826f91 	.word	0x34826f91
34811f48:	34826fa7 	.word	0x34826fa7

34811f4c <mmc_get_dev>:
	return 0;
}

#ifdef CONFIG_PARTITIONS
block_dev_desc_t *mmc_get_dev(int dev)
{
34811f4c:	e92d4010 	push	{r4, lr}
	struct mmc *mmc = find_mmc_device(dev);
34811f50:	ebfffae6 	bl	34810af0 <find_mmc_device>
	if (!mmc || mmc_init(mmc))
34811f54:	e2504000 	subs	r4, r0, #0
		return NULL;
34811f58:	01a00004 	moveq	r0, r4

#ifdef CONFIG_PARTITIONS
block_dev_desc_t *mmc_get_dev(int dev)
{
	struct mmc *mmc = find_mmc_device(dev);
	if (!mmc || mmc_init(mmc))
34811f5c:	08bd8010 	popeq	{r4, pc}
34811f60:	ebffffc1 	bl	34811e6c <mmc_init>
34811f64:	e3500000 	cmp	r0, #0
		return NULL;

	return &mmc->block_dev;
34811f68:	028400a0 	addeq	r0, r4, #160	; 0xa0
#ifdef CONFIG_PARTITIONS
block_dev_desc_t *mmc_get_dev(int dev)
{
	struct mmc *mmc = find_mmc_device(dev);
	if (!mmc || mmc_init(mmc))
		return NULL;
34811f6c:	13a00000 	movne	r0, #0

	return &mmc->block_dev;
}
34811f70:	e8bd8010 	pop	{r4, pc}

34811f74 <cpu_mmc_init>:
 * signals caller to move on
 */
static int __def_mmc_init(bd_t *bis)
{
	return -1;
}
34811f74:	e3e00000 	mvn	r0, #0
34811f78:	e12fff1e 	bx	lr

34811f7c <print_mmc_devices>:

int cpu_mmc_init(bd_t *bis) __attribute__((weak, alias("__def_mmc_init")));
int board_mmc_init(bd_t *bis) __attribute__((weak, alias("__def_mmc_init")));

void print_mmc_devices(char separator)
{
34811f7c:	e92d4070 	push	{r4, r5, r6, lr}
	struct mmc *m;
	struct list_head *entry;

	list_for_each(entry, &mmc_devices) {
34811f80:	e59f5048 	ldr	r5, [pc, #72]	; 34811fd0 <print_mmc_devices+0x54>

int cpu_mmc_init(bd_t *bis) __attribute__((weak, alias("__def_mmc_init")));
int board_mmc_init(bd_t *bis) __attribute__((weak, alias("__def_mmc_init")));

void print_mmc_devices(char separator)
{
34811f84:	e1a06000 	mov	r6, r0
	struct mmc *m;
	struct list_head *entry;

	list_for_each(entry, &mmc_devices) {
34811f88:	e5954000 	ldr	r4, [r5]
34811f8c:	ea00000a 	b	34811fbc <print_mmc_devices+0x40>
		m = list_entry(entry, struct mmc, link);

		printf("%s: %d", m->name, m->block_dev.dev);
34811f90:	e59f003c 	ldr	r0, [pc, #60]	; 34811fd4 <print_mmc_devices+0x58>
34811f94:	e2841008 	add	r1, r4, #8
34811f98:	e59420a4 	ldr	r2, [r4, #164]	; 0xa4
34811f9c:	ebffdbea 	bl	34808f4c <printf>

		if (entry->next != &mmc_devices)
34811fa0:	e5943000 	ldr	r3, [r4]
34811fa4:	e1530005 	cmp	r3, r5
34811fa8:	0a000002 	beq	34811fb8 <print_mmc_devices+0x3c>
			printf("%c ", separator);
34811fac:	e59f0024 	ldr	r0, [pc, #36]	; 34811fd8 <print_mmc_devices+0x5c>
34811fb0:	e1a01006 	mov	r1, r6
34811fb4:	ebffdbe4 	bl	34808f4c <printf>
void print_mmc_devices(char separator)
{
	struct mmc *m;
	struct list_head *entry;

	list_for_each(entry, &mmc_devices) {
34811fb8:	e5944000 	ldr	r4, [r4]
34811fbc:	e1540005 	cmp	r4, r5
34811fc0:	1afffff2 	bne	34811f90 <print_mmc_devices+0x14>

		if (entry->next != &mmc_devices)
			printf("%c ", separator);
	}

	printf("\n");
34811fc4:	e59f0010 	ldr	r0, [pc, #16]	; 34811fdc <print_mmc_devices+0x60>
}
34811fc8:	e8bd4070 	pop	{r4, r5, r6, lr}

		if (entry->next != &mmc_devices)
			printf("%c ", separator);
	}

	printf("\n");
34811fcc:	eaffdbde 	b	34808f4c <printf>
34811fd0:	3482b18c 	.word	0x3482b18c
34811fd4:	34826fd0 	.word	0x34826fd0
34811fd8:	34823aab 	.word	0x34823aab
34811fdc:	348260f7 	.word	0x348260f7

34811fe0 <get_mmc_num>:
}

int get_mmc_num(void)
{
	return cur_dev_num;
}
34811fe0:	e59f3004 	ldr	r3, [pc, #4]	; 34811fec <get_mmc_num+0xc>
34811fe4:	e5930000 	ldr	r0, [r3]
34811fe8:	e12fff1e 	bx	lr
34811fec:	3482894c 	.word	0x3482894c

34811ff0 <mmc_initialize>:
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
34811ff0:	e59f303c 	ldr	r3, [pc, #60]	; 34812034 <mmc_initialize+0x44>

int mmc_initialize(bd_t *bis)
{
34811ff4:	e92d4010 	push	{r4, lr}
34811ff8:	e5833000 	str	r3, [r3]
	list->prev = list;
34811ffc:	e5833004 	str	r3, [r3, #4]
	INIT_LIST_HEAD (&mmc_devices);
	cur_dev_num = 0;
34812000:	e59f3030 	ldr	r3, [pc, #48]	; 34812038 <mmc_initialize+0x48>
34812004:	e3a02000 	mov	r2, #0
34812008:	e5832000 	str	r2, [r3]
{
	return cur_dev_num;
}

int mmc_initialize(bd_t *bis)
{
3481200c:	e1a04000 	mov	r4, r0
	INIT_LIST_HEAD (&mmc_devices);
	cur_dev_num = 0;

	if (board_mmc_init(bis) < 0)
34812010:	ebffbb1a 	bl	34800c80 <board_mmc_init>
34812014:	e3500000 	cmp	r0, #0
34812018:	aa000001 	bge	34812024 <mmc_initialize+0x34>
		cpu_mmc_init(bis);
3481201c:	e1a00004 	mov	r0, r4
34812020:	ebffffd3 	bl	34811f74 <cpu_mmc_init>

	print_mmc_devices(',');
34812024:	e3a0002c 	mov	r0, #44	; 0x2c
34812028:	ebffffd3 	bl	34811f7c <print_mmc_devices>

	return 0;
}
3481202c:	e3a00000 	mov	r0, #0
34812030:	e8bd8010 	pop	{r4, pc}
34812034:	3482b18c 	.word	0x3482b18c
34812038:	3482894c 	.word	0x3482894c

3481203c <sdhci_set_ios>:

	sdhci_writeb(host, pwr, SDHCI_POWER_CONTROL);
}

void sdhci_set_ios(struct mmc *mmc)
{
3481203c:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	u32 ctrl;
	struct sdhci_host *host = (struct sdhci_host *)mmc->priv;
34812040:	e5905028 	ldr	r5, [r0, #40]	; 0x28

	sdhci_writeb(host, pwr, SDHCI_POWER_CONTROL);
}

void sdhci_set_ios(struct mmc *mmc)
{
34812044:	e1a07000 	mov	r7, r0
	u32 ctrl;
	struct sdhci_host *host = (struct sdhci_host *)mmc->priv;

	if (host->set_control_reg)
34812048:	e5953024 	ldr	r3, [r5, #36]	; 0x24
3481204c:	e3530000 	cmp	r3, #0
34812050:	0a000001 	beq	3481205c <sdhci_set_ios+0x20>
		host->set_control_reg(host);
34812054:	e1a00005 	mov	r0, r5
34812058:	e12fff33 	blx	r3

	if (mmc->clock != host->clock)
3481205c:	e597a048 	ldr	sl, [r7, #72]	; 0x48
34812060:	e5953014 	ldr	r3, [r5, #20]
34812064:	e15a0003 	cmp	sl, r3
34812068:	0a000040 	beq	34812170 <sdhci_set_ios+0x134>
		return COMM_ERR;
}

static int sdhci_set_clock(struct mmc *mmc, unsigned int clock)
{
	struct sdhci_host *host = (struct sdhci_host *)mmc->priv;
3481206c:	e5976028 	ldr	r6, [r7, #40]	; 0x28
	writel(val, host->ioaddr + reg);
}

static inline void sdhci_writew(struct sdhci_host *host, u16 val, int reg)
{
	writew(val, host->ioaddr + reg);
34812070:	e5963004 	ldr	r3, [r6, #4]
34812074:	e3a02000 	mov	r2, #0
	unsigned int div, clk, timeout;

	sdhci_writew(host, 0, SDHCI_CLOCK_CONTROL);

	if (clock == 0)
34812078:	e35a0000 	cmp	sl, #0
3481207c:	e1c322bc 	strh	r2, [r3, #44]	; 0x2c
34812080:	0a00003a 	beq	34812170 <sdhci_set_ios+0x134>
		return 0;

	if ((host->version & SDHCI_SPEC_VER_MASK) >= SDHCI_SPEC_300) {
34812084:	e5d63010 	ldrb	r3, [r6, #16]
34812088:	e597b03c 	ldr	fp, [r7, #60]	; 0x3c
3481208c:	e3530001 	cmp	r3, #1
34812090:	9a00000d 	bls	348120cc <sdhci_set_ios+0x90>
		/* Version 3.00 divisors must be a multiple of 2. */
		if (mmc->f_max <= clock)
34812094:	e15b000a 	cmp	fp, sl
			div = 1;
34812098:	93a04001 	movls	r4, #1
	if (clock == 0)
		return 0;

	if ((host->version & SDHCI_SPEC_VER_MASK) >= SDHCI_SPEC_300) {
		/* Version 3.00 divisors must be a multiple of 2. */
		if (mmc->f_max <= clock)
3481209c:	9a000014 	bls	348120f4 <sdhci_set_ios+0xb8>
348120a0:	e3a04002 	mov	r4, #2
			div = 1;
		else {
			for (div = 2; div < SDHCI_MAX_DIV_SPEC_300; div += 2) {
348120a4:	e30097fe 	movw	r9, #2046	; 0x7fe
				if ((mmc->f_max / div) <= clock)
348120a8:	e1a0000b 	mov	r0, fp
348120ac:	e1a01004 	mov	r1, r4
348120b0:	eb00377b 	bl	3481fea4 <__udivsi3>
348120b4:	e150000a 	cmp	r0, sl
348120b8:	9a00000d 	bls	348120f4 <sdhci_set_ios+0xb8>
	if ((host->version & SDHCI_SPEC_VER_MASK) >= SDHCI_SPEC_300) {
		/* Version 3.00 divisors must be a multiple of 2. */
		if (mmc->f_max <= clock)
			div = 1;
		else {
			for (div = 2; div < SDHCI_MAX_DIV_SPEC_300; div += 2) {
348120bc:	e2844002 	add	r4, r4, #2
348120c0:	e1540009 	cmp	r4, r9
348120c4:	1afffff7 	bne	348120a8 <sdhci_set_ios+0x6c>
348120c8:	ea000009 	b	348120f4 <sdhci_set_ios+0xb8>
			}
		}
	} else {
		/* Version 2.00 divisors must be a power of 2. */
		for (div = 1; div < SDHCI_MAX_DIV_SPEC_200; div *= 2) {
			if ((mmc->f_max / div) <= clock)
348120cc:	e3a09008 	mov	r9, #8
348120d0:	e3a04001 	mov	r4, #1
348120d4:	e1a0000b 	mov	r0, fp
348120d8:	e1a01004 	mov	r1, r4
348120dc:	eb003770 	bl	3481fea4 <__udivsi3>
348120e0:	e150000a 	cmp	r0, sl
348120e4:	9a000002 	bls	348120f4 <sdhci_set_ios+0xb8>
					break;
			}
		}
	} else {
		/* Version 2.00 divisors must be a power of 2. */
		for (div = 1; div < SDHCI_MAX_DIV_SPEC_200; div *= 2) {
348120e8:	e2599001 	subs	r9, r9, #1
348120ec:	e1a04084 	lsl	r4, r4, #1
348120f0:	1afffff7 	bne	348120d4 <sdhci_set_ios+0x98>
				break;
		}
	}
	div >>= 1;

	if (host->set_clock)
348120f4:	e5963028 	ldr	r3, [r6, #40]	; 0x28
		for (div = 1; div < SDHCI_MAX_DIV_SPEC_200; div *= 2) {
			if ((mmc->f_max / div) <= clock)
				break;
		}
	}
	div >>= 1;
348120f8:	e1a040a4 	lsr	r4, r4, #1

	if (host->set_clock)
348120fc:	e3530000 	cmp	r3, #0
34812100:	0a000002 	beq	34812110 <sdhci_set_ios+0xd4>
		host->set_clock(host->index, div);
34812104:	e5960020 	ldr	r0, [r6, #32]
34812108:	e1a01004 	mov	r1, r4
3481210c:	e12fff33 	blx	r3

	clk = (div & SDHCI_DIV_MASK) << SDHCI_DIVIDER_SHIFT;
34812110:	e1a03c04 	lsl	r3, r4, #24
34812114:	e1a03823 	lsr	r3, r3, #16
	clk |= ((div & SDHCI_DIV_HI_MASK) >> SDHCI_DIV_MASK_LEN)
34812118:	e3833001 	orr	r3, r3, #1
3481211c:	e7e14454 	ubfx	r4, r4, #8, #2
		<< SDHCI_DIVIDER_HI_SHIFT;
	clk |= SDHCI_CLOCK_INT_EN;
	sdhci_writew(host, clk, SDHCI_CLOCK_CONTROL);
34812120:	e1834304 	orr	r4, r3, r4, lsl #6
34812124:	e5963004 	ldr	r3, [r6, #4]
34812128:	e1c342bc 	strh	r4, [r3, #44]	; 0x2c

	/* Wait max 20 ms */
	timeout = 20;
3481212c:	e3a04014 	mov	r4, #20
34812130:	ea000007 	b	34812154 <sdhci_set_ios+0x118>
	while (!((clk = sdhci_readw(host, SDHCI_CLOCK_CONTROL))
		& SDHCI_CLOCK_INT_STABLE)) {
		if (timeout == 0) {
34812134:	e3540000 	cmp	r4, #0
34812138:	1a000002 	bne	34812148 <sdhci_set_ios+0x10c>
			printf("Internal clock never stabilised.\n");
3481213c:	e59f00a4 	ldr	r0, [pc, #164]	; 348121e8 <sdhci_set_ios+0x1ac>
34812140:	ebffdb81 	bl	34808f4c <printf>
34812144:	ea000009 	b	34812170 <sdhci_set_ios+0x134>
			return -1;
		}
		timeout--;
		udelay(1000);
34812148:	e3a00ffa 	mov	r0, #1000	; 0x3e8
		& SDHCI_CLOCK_INT_STABLE)) {
		if (timeout == 0) {
			printf("Internal clock never stabilised.\n");
			return -1;
		}
		timeout--;
3481214c:	e2444001 	sub	r4, r4, #1
		udelay(1000);
34812150:	eb001bd9 	bl	348190bc <udelay>
	return readl(host->ioaddr + reg);
}

static inline u16 sdhci_readw(struct sdhci_host *host, int reg)
{
	return readw(host->ioaddr + reg);
34812154:	e5963004 	ldr	r3, [r6, #4]
34812158:	e1d332bc 	ldrh	r3, [r3, #44]	; 0x2c
	clk |= SDHCI_CLOCK_INT_EN;
	sdhci_writew(host, clk, SDHCI_CLOCK_CONTROL);

	/* Wait max 20 ms */
	timeout = 20;
	while (!((clk = sdhci_readw(host, SDHCI_CLOCK_CONTROL))
3481215c:	e3130002 	tst	r3, #2
34812160:	0afffff3 	beq	34812134 <sdhci_set_ios+0xf8>
		timeout--;
		udelay(1000);
	}

	clk |= SDHCI_CLOCK_CARD_EN;
	sdhci_writew(host, clk, SDHCI_CLOCK_CONTROL);
34812164:	e3833004 	orr	r3, r3, #4
	writel(val, host->ioaddr + reg);
}

static inline void sdhci_writew(struct sdhci_host *host, u16 val, int reg)
{
	writew(val, host->ioaddr + reg);
34812168:	e5962004 	ldr	r2, [r6, #4]
3481216c:	e1c232bc 	strh	r3, [r2, #44]	; 0x2c
	return readw(host->ioaddr + reg);
}

static inline u8 sdhci_readb(struct sdhci_host *host, int reg)
{
	return readb(host->ioaddr + reg);
34812170:	e5953004 	ldr	r3, [r5, #4]
34812174:	e5d30028 	ldrb	r0, [r3, #40]	; 0x28
	if (mmc->clock != host->clock)
		sdhci_set_clock(mmc, mmc->clock);

	/* Set bus width */
	ctrl = sdhci_readb(host, SDHCI_HOST_CONTROL);
	if (mmc->bus_width == 8) {
34812178:	e5972044 	ldr	r2, [r7, #68]	; 0x44

	if (mmc->clock != host->clock)
		sdhci_set_clock(mmc, mmc->clock);

	/* Set bus width */
	ctrl = sdhci_readb(host, SDHCI_HOST_CONTROL);
3481217c:	e1a03000 	mov	r3, r0
	if (mmc->bus_width == 8) {
34812180:	e3520008 	cmp	r2, #8
34812184:	e5951010 	ldr	r1, [r5, #16]
34812188:	1a000004 	bne	348121a0 <sdhci_set_ios+0x164>
		ctrl &= ~SDHCI_CTRL_4BITBUS;
		if ((host->version & SDHCI_SPEC_VER_MASK) >= SDHCI_SPEC_300)
3481218c:	e20110ff 	and	r1, r1, #255	; 0xff
		sdhci_set_clock(mmc, mmc->clock);

	/* Set bus width */
	ctrl = sdhci_readb(host, SDHCI_HOST_CONTROL);
	if (mmc->bus_width == 8) {
		ctrl &= ~SDHCI_CTRL_4BITBUS;
34812190:	e3c03002 	bic	r3, r0, #2
		if ((host->version & SDHCI_SPEC_VER_MASK) >= SDHCI_SPEC_300)
34812194:	e3510001 	cmp	r1, #1
			ctrl |= SDHCI_CTRL_8BITBUS;
34812198:	83833020 	orrhi	r3, r3, #32
3481219c:	ea000005 	b	348121b8 <sdhci_set_ios+0x17c>
	} else {
		if ((host->version & SDHCI_SPEC_VER_MASK) >= SDHCI_SPEC_300)
348121a0:	e20110ff 	and	r1, r1, #255	; 0xff
348121a4:	e3510001 	cmp	r1, #1
			ctrl &= ~SDHCI_CTRL_8BITBUS;
348121a8:	83c03020 	bichi	r3, r0, #32
		if (mmc->bus_width == 4)
348121ac:	e3520004 	cmp	r2, #4
			ctrl |= SDHCI_CTRL_4BITBUS;
348121b0:	03833002 	orreq	r3, r3, #2
		else
			ctrl &= ~SDHCI_CTRL_4BITBUS;
348121b4:	13c33002 	bicne	r3, r3, #2
	}

	if (mmc->clock > 26000000)
348121b8:	e5971048 	ldr	r1, [r7, #72]	; 0x48
348121bc:	e59f2028 	ldr	r2, [pc, #40]	; 348121ec <sdhci_set_ios+0x1b0>
348121c0:	e1510002 	cmp	r1, r2
		ctrl |= SDHCI_CTRL_HISPD;
	else
		ctrl &= ~SDHCI_CTRL_HISPD;

	if (host->quirks & SDHCI_QUIRK_NO_HISPD_BIT)
348121c4:	e5952008 	ldr	r2, [r5, #8]
		else
			ctrl &= ~SDHCI_CTRL_4BITBUS;
	}

	if (mmc->clock > 26000000)
		ctrl |= SDHCI_CTRL_HISPD;
348121c8:	83833004 	orrhi	r3, r3, #4
	else
		ctrl &= ~SDHCI_CTRL_HISPD;
348121cc:	93c33004 	bicls	r3, r3, #4

	if (host->quirks & SDHCI_QUIRK_NO_HISPD_BIT)
348121d0:	e3120008 	tst	r2, #8
		ctrl &= ~SDHCI_CTRL_HISPD;
348121d4:	13c33004 	bicne	r3, r3, #4

	sdhci_writeb(host, ctrl, SDHCI_HOST_CONTROL);
348121d8:	e6ef3073 	uxtb	r3, r3
	writew(val, host->ioaddr + reg);
}

static inline void sdhci_writeb(struct sdhci_host *host, u8 val, int reg)
{
	writeb(val, host->ioaddr + reg);
348121dc:	e5952004 	ldr	r2, [r5, #4]
348121e0:	e5c23028 	strb	r3, [r2, #40]	; 0x28
}
348121e4:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
348121e8:	34826fd7 	.word	0x34826fd7
348121ec:	018cba80 	.word	0x018cba80

348121f0 <sdhci_init>:

int sdhci_init(struct mmc *mmc)
{
348121f0:	e92d4070 	push	{r4, r5, r6, lr}
	struct sdhci_host *host = (struct sdhci_host *)mmc->priv;
348121f4:	e5904028 	ldr	r4, [r0, #40]	; 0x28

	sdhci_writeb(host, ctrl, SDHCI_HOST_CONTROL);
}

int sdhci_init(struct mmc *mmc)
{
348121f8:	e1a05000 	mov	r5, r0
	struct sdhci_host *host = (struct sdhci_host *)mmc->priv;

	if ((host->quirks & SDHCI_QUIRK_32BIT_DMA_ADDR) && !aligned_buffer) {
348121fc:	e5943008 	ldr	r3, [r4, #8]
34812200:	e3130001 	tst	r3, #1
34812204:	0a00000d 	beq	34812240 <sdhci_init+0x50>
34812208:	e59f614c 	ldr	r6, [pc, #332]	; 3481235c <sdhci_init+0x16c>
3481220c:	e5963000 	ldr	r3, [r6]
34812210:	e3530000 	cmp	r3, #0
34812214:	1a000009 	bne	34812240 <sdhci_init+0x50>
		aligned_buffer = memalign(8, 512*1024);
34812218:	e3a00008 	mov	r0, #8
3481221c:	e3a01702 	mov	r1, #524288	; 0x80000
34812220:	ebffdeb5 	bl	34809cfc <memalign>
		if (!aligned_buffer) {
34812224:	e3500000 	cmp	r0, #0
int sdhci_init(struct mmc *mmc)
{
	struct sdhci_host *host = (struct sdhci_host *)mmc->priv;

	if ((host->quirks & SDHCI_QUIRK_32BIT_DMA_ADDR) && !aligned_buffer) {
		aligned_buffer = memalign(8, 512*1024);
34812228:	e5860000 	str	r0, [r6]
		if (!aligned_buffer) {
3481222c:	1a000003 	bne	34812240 <sdhci_init+0x50>
			printf("Aligned buffer alloc failed!!!");
34812230:	e59f0128 	ldr	r0, [pc, #296]	; 34812360 <sdhci_init+0x170>
34812234:	ebffdb44 	bl	34808f4c <printf>
			return -1;
34812238:	e3e00000 	mvn	r0, #0
3481223c:	e8bd8070 	pop	{r4, r5, r6, pc}
		}
	}

	sdhci_set_power(host, fls(mmc->voltages) - 1);
34812240:	e595302c 	ldr	r3, [r5, #44]	; 0x2c
 */
static inline int generic_fls(int x)
{
	int r = 32;

	if (!x)
34812244:	e3530000 	cmp	r3, #0
		return 0;
34812248:	01a02003 	moveq	r2, r3
 */
static inline int generic_fls(int x)
{
	int r = 32;

	if (!x)
3481224c:	0a000010 	beq	34812294 <sdhci_init+0xa4>
		return 0;
	if (!(x & 0xffff0000u)) {
34812250:	e1a02823 	lsr	r2, r3, #16
34812254:	e1a02802 	lsl	r2, r2, #16
34812258:	e3520000 	cmp	r2, #0
		x <<= 16;
3481225c:	01a03803 	lsleq	r3, r3, #16
		r -= 16;
34812260:	02822010 	addeq	r2, r2, #16
 * This is defined the same way as ffs.
 * Note fls(0) = 0, fls(1) = 1, fls(0x80000000) = 32.
 */
static inline int generic_fls(int x)
{
	int r = 32;
34812264:	13a02020 	movne	r2, #32
		return 0;
	if (!(x & 0xffff0000u)) {
		x <<= 16;
		r -= 16;
	}
	if (!(x & 0xff000000u)) {
34812268:	e31304ff 	tst	r3, #-16777216	; 0xff000000
		x <<= 8;
3481226c:	01a03403 	lsleq	r3, r3, #8
		r -= 8;
34812270:	02422008 	subeq	r2, r2, #8
	}
	if (!(x & 0xf0000000u)) {
34812274:	e313020f 	tst	r3, #-268435456	; 0xf0000000
		x <<= 4;
34812278:	01a03203 	lsleq	r3, r3, #4
		r -= 4;
3481227c:	02422004 	subeq	r2, r2, #4
	}
	if (!(x & 0xc0000000u)) {
34812280:	e3130103 	tst	r3, #-1073741824	; 0xc0000000
		x <<= 2;
34812284:	01a03103 	lsleq	r3, r3, #2
		r -= 2;
34812288:	02422002 	subeq	r2, r2, #2
	}
	if (!(x & 0x80000000u)) {
3481228c:	e3530000 	cmp	r3, #0
		x <<= 1;
		r -= 1;
34812290:	a2422001 	subge	r2, r2, #1
34812294:	e2422001 	sub	r2, r2, #1
34812298:	e6ff2072 	uxth	r2, r2

static void sdhci_set_power(struct sdhci_host *host, unsigned short power)
{
	u8 pwr = 0;

	if (power != (unsigned short)-1) {
3481229c:	e30f3fff 	movw	r3, #65535	; 0xffff
348122a0:	e1520003 	cmp	r2, r3
348122a4:	0a00000f 	beq	348122e8 <sdhci_init+0xf8>
		switch (1 << power) {
348122a8:	e3a03001 	mov	r3, #1
348122ac:	e1a02213 	lsl	r2, r3, r2
348122b0:	e3520701 	cmp	r2, #262144	; 0x40000
348122b4:	0a000023 	beq	34812348 <sdhci_init+0x158>
348122b8:	ca000004 	bgt	348122d0 <sdhci_init+0xe0>
348122bc:	e3520080 	cmp	r2, #128	; 0x80
348122c0:	0a00001e 	beq	34812340 <sdhci_init+0x150>
348122c4:	e3520802 	cmp	r2, #131072	; 0x20000
348122c8:	1a000006 	bne	348122e8 <sdhci_init+0xf8>
348122cc:	ea00001d 	b	34812348 <sdhci_init+0x158>
348122d0:	e3520601 	cmp	r2, #1048576	; 0x100000
348122d4:	0a000001 	beq	348122e0 <sdhci_init+0xf0>
348122d8:	e3520602 	cmp	r2, #2097152	; 0x200000
348122dc:	1a000001 	bne	348122e8 <sdhci_init+0xf8>
		case MMC_VDD_30_31:
			pwr = SDHCI_POWER_300;
			break;
		case MMC_VDD_32_33:
		case MMC_VDD_33_34:
			pwr = SDHCI_POWER_330;
348122e0:	e3a0300e 	mov	r3, #14
348122e4:	ea000018 	b	3481234c <sdhci_init+0x15c>
348122e8:	e5943004 	ldr	r3, [r4, #4]
348122ec:	e3a02000 	mov	r2, #0
348122f0:	e5c32029 	strb	r2, [r3, #41]	; 0x29
		}
	}

	sdhci_set_power(host, fls(mmc->voltages) - 1);

	if (host->quirks & SDHCI_QUIRK_NO_CD) {
348122f4:	e5943008 	ldr	r3, [r4, #8]
348122f8:	e3130020 	tst	r3, #32
348122fc:	0a000008 	beq	34812324 <sdhci_init+0x134>

#else

static inline void sdhci_writel(struct sdhci_host *host, u32 val, int reg)
{
	writel(val, host->ioaddr + reg);
34812300:	e5943004 	ldr	r3, [r4, #4]
34812304:	e3a020c0 	mov	r2, #192	; 0xc0
34812308:	e5832028 	str	r2, [r3, #40]	; 0x28
3481230c:	ea000000 	b	34812314 <sdhci_init+0x124>
{
	writeb(val, host->ioaddr + reg);
}
static inline u32 sdhci_readl(struct sdhci_host *host, int reg)
{
	return readl(host->ioaddr + reg);
34812310:	e5943004 	ldr	r3, [r4, #4]
34812314:	e5933024 	ldr	r3, [r3, #36]	; 0x24
		sdhci_writel(host, SDHCI_CTRL_CD_TEST_INS | SDHCI_CTRL_CD_TEST,
			SDHCI_HOST_CONTROL);

		status = sdhci_readl(host, SDHCI_PRESENT_STATE);
		while ((!(status & SDHCI_CARD_PRESENT)) ||
		    (!(status & SDHCI_CARD_STATE_STABLE)) ||
34812318:	e2033807 	and	r3, r3, #458752	; 0x70000

		sdhci_writel(host, SDHCI_CTRL_CD_TEST_INS | SDHCI_CTRL_CD_TEST,
			SDHCI_HOST_CONTROL);

		status = sdhci_readl(host, SDHCI_PRESENT_STATE);
		while ((!(status & SDHCI_CARD_PRESENT)) ||
3481231c:	e3530807 	cmp	r3, #458752	; 0x70000
34812320:	1afffffa 	bne	34812310 <sdhci_init+0x120>

#else

static inline void sdhci_writel(struct sdhci_host *host, u32 val, int reg)
{
	writel(val, host->ioaddr + reg);
34812324:	e5942004 	ldr	r2, [r4, #4]
34812328:	e3e03000 	mvn	r3, #0
3481232c:	e5823034 	str	r3, [r2, #52]	; 0x34
34812330:	e5942004 	ldr	r2, [r4, #4]

	/* Eable all state */
	sdhci_writel(host, SDHCI_INT_ALL_MASK, SDHCI_INT_ENABLE);
	sdhci_writel(host, SDHCI_INT_ALL_MASK, SDHCI_SIGNAL_ENABLE);

	return 0;
34812334:	e3a00000 	mov	r0, #0
34812338:	e5823038 	str	r3, [r2, #56]	; 0x38
}
3481233c:	e8bd8070 	pop	{r4, r5, r6, pc}
	u8 pwr = 0;

	if (power != (unsigned short)-1) {
		switch (1 << power) {
		case MMC_VDD_165_195:
			pwr = SDHCI_POWER_180;
34812340:	e3a0300a 	mov	r3, #10
34812344:	ea000000 	b	3481234c <sdhci_init+0x15c>
			break;
		case MMC_VDD_29_30:
		case MMC_VDD_30_31:
			pwr = SDHCI_POWER_300;
34812348:	e3a0300c 	mov	r3, #12
	if (pwr == 0) {
		sdhci_writeb(host, 0, SDHCI_POWER_CONTROL);
		return;
	}

	pwr |= SDHCI_POWER_ON;
3481234c:	e3833001 	orr	r3, r3, #1
	writew(val, host->ioaddr + reg);
}

static inline void sdhci_writeb(struct sdhci_host *host, u8 val, int reg)
{
	writeb(val, host->ioaddr + reg);
34812350:	e5942004 	ldr	r2, [r4, #4]
34812354:	e5c23029 	strb	r3, [r2, #41]	; 0x29
34812358:	eaffffe5 	b	348122f4 <sdhci_init+0x104>
3481235c:	3482b194 	.word	0x3482b194
34812360:	34826ff9 	.word	0x34826ff9

34812364 <sdhci_reset.clone.9>:
#include <mmc.h>
#include <sdhci.h>

void *aligned_buffer;

static void sdhci_reset(struct sdhci_host *host, u8 mask)
34812364:	e92d4070 	push	{r4, r5, r6, lr}
34812368:	e1a04000 	mov	r4, r0
3481236c:	e1a05001 	mov	r5, r1
34812370:	e5903000 	ldr	r3, [r0]
{
	unsigned long timeout;

	/* Wait max 100 ms */
	timeout = 100;
34812374:	e3a06064 	mov	r6, #100	; 0x64
34812378:	e5c3102f 	strb	r1, [r3, #47]	; 0x2f
3481237c:	ea000008 	b	348123a4 <sdhci_reset.clone.9+0x40>
	sdhci_writeb(host, mask, SDHCI_SOFTWARE_RESET);
	while (sdhci_readb(host, SDHCI_SOFTWARE_RESET) & mask) {
		if (timeout == 0) {
34812380:	e3560000 	cmp	r6, #0
34812384:	1a000003 	bne	34812398 <sdhci_reset.clone.9+0x34>
			printf("Reset 0x%x never completed.\n", (int)mask);
34812388:	e59f0028 	ldr	r0, [pc, #40]	; 348123b8 <sdhci_reset.clone.9+0x54>
3481238c:	e1a01005 	mov	r1, r5
			return;
		}
		timeout--;
		udelay(1000);
	}
}
34812390:	e8bd4070 	pop	{r4, r5, r6, lr}
	/* Wait max 100 ms */
	timeout = 100;
	sdhci_writeb(host, mask, SDHCI_SOFTWARE_RESET);
	while (sdhci_readb(host, SDHCI_SOFTWARE_RESET) & mask) {
		if (timeout == 0) {
			printf("Reset 0x%x never completed.\n", (int)mask);
34812394:	eaffdaec 	b	34808f4c <printf>
			return;
		}
		timeout--;
		udelay(1000);
34812398:	e3a00ffa 	mov	r0, #1000	; 0x3e8
	while (sdhci_readb(host, SDHCI_SOFTWARE_RESET) & mask) {
		if (timeout == 0) {
			printf("Reset 0x%x never completed.\n", (int)mask);
			return;
		}
		timeout--;
3481239c:	e2466001 	sub	r6, r6, #1
		udelay(1000);
348123a0:	eb001b45 	bl	348190bc <udelay>
	return readw(host->ioaddr + reg);
}

static inline u8 sdhci_readb(struct sdhci_host *host, int reg)
{
	return readb(host->ioaddr + reg);
348123a4:	e5943000 	ldr	r3, [r4]
348123a8:	e5d3302f 	ldrb	r3, [r3, #47]	; 0x2f
	unsigned long timeout;

	/* Wait max 100 ms */
	timeout = 100;
	sdhci_writeb(host, mask, SDHCI_SOFTWARE_RESET);
	while (sdhci_readb(host, SDHCI_SOFTWARE_RESET) & mask) {
348123ac:	e1130005 	tst	r3, r5
348123b0:	1afffff2 	bne	34812380 <sdhci_reset.clone.9+0x1c>
			return;
		}
		timeout--;
		udelay(1000);
	}
}
348123b4:	e8bd8070 	pop	{r4, r5, r6, pc}
348123b8:	34827018 	.word	0x34827018

348123bc <sdhci_send_command>:
	return 0;
}

int sdhci_send_command(struct mmc *mmc, struct mmc_cmd *cmd,
		       struct mmc_data *data)
{
348123bc:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	struct sdhci_host *host = (struct sdhci_host *)mmc->priv;
348123c0:	e5904028 	ldr	r4, [r0, #40]	; 0x28
	return 0;
}

int sdhci_send_command(struct mmc *mmc, struct mmc_cmd *cmd,
		       struct mmc_data *data)
{
348123c4:	e1a05001 	mov	r5, r1
348123c8:	e1a06002 	mov	r6, r2
	sdhci_writel(host, SDHCI_INT_ALL_MASK, SDHCI_INT_STATUS);
	mask = SDHCI_CMD_INHIBIT | SDHCI_DATA_INHIBIT;

	/* We shouldn't wait for data inihibit for stop commands, even
	   though they might use busy signaling */
	if (cmd->cmdidx == MMC_CMD_STOP_TRANSMISSION)
348123cc:	e1d1a0b0 	ldrh	sl, [r1]

#else

static inline void sdhci_writel(struct sdhci_host *host, u32 val, int reg)
{
	writel(val, host->ioaddr + reg);
348123d0:	e5943004 	ldr	r3, [r4, #4]

	/* Wait max 10 ms */
	timeout = 10;

	sdhci_writel(host, SDHCI_INT_ALL_MASK, SDHCI_INT_STATUS);
	mask = SDHCI_CMD_INHIBIT | SDHCI_DATA_INHIBIT;
348123d4:	e35a000c 	cmp	sl, #12
348123d8:	e3e02000 	mvn	r2, #0
348123dc:	e5832030 	str	r2, [r3, #48]	; 0x30
348123e0:	03a0a001 	moveq	sl, #1
348123e4:	13a0a003 	movne	sl, #3
348123e8:	e3a0700a 	mov	r7, #10
348123ec:	ea000008 	b	34812414 <sdhci_send_command+0x58>
	   though they might use busy signaling */
	if (cmd->cmdidx == MMC_CMD_STOP_TRANSMISSION)
		mask &= ~SDHCI_DATA_INHIBIT;

	while (sdhci_readl(host, SDHCI_PRESENT_STATE) & mask) {
		if (timeout == 0) {
348123f0:	e3570000 	cmp	r7, #0
348123f4:	1a000003 	bne	34812408 <sdhci_send_command+0x4c>
			printf("Controller never released inhibit bit(s).\n");
348123f8:	e59f0300 	ldr	r0, [pc, #768]	; 34812700 <sdhci_send_command+0x344>
348123fc:	ebffdad2 	bl	34808f4c <printf>
			return COMM_ERR;
34812400:	e3e00011 	mvn	r0, #17
34812404:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
		}
		timeout--;
		udelay(1000);
34812408:	e3a00ffa 	mov	r0, #1000	; 0x3e8
	while (sdhci_readl(host, SDHCI_PRESENT_STATE) & mask) {
		if (timeout == 0) {
			printf("Controller never released inhibit bit(s).\n");
			return COMM_ERR;
		}
		timeout--;
3481240c:	e2477001 	sub	r7, r7, #1
		udelay(1000);
34812410:	eb001b29 	bl	348190bc <udelay>
{
	writeb(val, host->ioaddr + reg);
}
static inline u32 sdhci_readl(struct sdhci_host *host, int reg)
{
	return readl(host->ioaddr + reg);
34812414:	e5943004 	ldr	r3, [r4, #4]
34812418:	e5933024 	ldr	r3, [r3, #36]	; 0x24
	/* We shouldn't wait for data inihibit for stop commands, even
	   though they might use busy signaling */
	if (cmd->cmdidx == MMC_CMD_STOP_TRANSMISSION)
		mask &= ~SDHCI_DATA_INHIBIT;

	while (sdhci_readl(host, SDHCI_PRESENT_STATE) & mask) {
3481241c:	e11a0003 	tst	sl, r3
34812420:	1afffff2 	bne	348123f0 <sdhci_send_command+0x34>
		timeout--;
		udelay(1000);
	}

	mask = SDHCI_INT_RESPONSE;
	if (!(cmd->resp_type & MMC_RSP_PRESENT))
34812424:	e5951004 	ldr	r1, [r5, #4]
34812428:	e2113001 	ands	r3, r1, #1
3481242c:	0a000008 	beq	34812454 <sdhci_send_command+0x98>
		flags = SDHCI_CMD_RESP_NONE;
	else if (cmd->resp_type & MMC_RSP_136)
34812430:	e3110002 	tst	r1, #2
		flags = SDHCI_CMD_RESP_LONG;
34812434:	13a03001 	movne	r3, #1
	}

	mask = SDHCI_INT_RESPONSE;
	if (!(cmd->resp_type & MMC_RSP_PRESENT))
		flags = SDHCI_CMD_RESP_NONE;
	else if (cmd->resp_type & MMC_RSP_136)
34812438:	1a000002 	bne	34812448 <sdhci_send_command+0x8c>
		flags = SDHCI_CMD_RESP_LONG;
	else if (cmd->resp_type & MMC_RSP_BUSY) {
3481243c:	e3110008 	tst	r1, #8
		flags = SDHCI_CMD_RESP_SHORT_BUSY;
34812440:	13a03003 	movne	r3, #3
	mask = SDHCI_INT_RESPONSE;
	if (!(cmd->resp_type & MMC_RSP_PRESENT))
		flags = SDHCI_CMD_RESP_NONE;
	else if (cmd->resp_type & MMC_RSP_136)
		flags = SDHCI_CMD_RESP_LONG;
	else if (cmd->resp_type & MMC_RSP_BUSY) {
34812444:	0a000001 	beq	34812450 <sdhci_send_command+0x94>
		}
		timeout--;
		udelay(1000);
	}

	mask = SDHCI_INT_RESPONSE;
34812448:	e1a02003 	mov	r2, r3
3481244c:	ea000001 	b	34812458 <sdhci_send_command+0x9c>
		flags = SDHCI_CMD_RESP_LONG;
	else if (cmd->resp_type & MMC_RSP_BUSY) {
		flags = SDHCI_CMD_RESP_SHORT_BUSY;
		mask |= SDHCI_INT_DATA_END;
	} else
		flags = SDHCI_CMD_RESP_SHORT;
34812450:	e3a03002 	mov	r3, #2
		}
		timeout--;
		udelay(1000);
	}

	mask = SDHCI_INT_RESPONSE;
34812454:	e3a02001 	mov	r2, #1
		flags = SDHCI_CMD_RESP_SHORT_BUSY;
		mask |= SDHCI_INT_DATA_END;
	} else
		flags = SDHCI_CMD_RESP_SHORT;

	if (cmd->resp_type & MMC_RSP_CRC)
34812458:	e3110004 	tst	r1, #4
		flags |= SDHCI_CMD_CRC;
3481245c:	13833008 	orrne	r3, r3, #8
	if (cmd->resp_type & MMC_RSP_OPCODE)
34812460:	e3110010 	tst	r1, #16
		flags |= SDHCI_CMD_INDEX;
34812464:	13833010 	orrne	r3, r3, #16
	if (data)
34812468:	e3560000 	cmp	r6, #0
3481246c:	0a000014 	beq	348124c4 <sdhci_send_command+0x108>
		flags |= SDHCI_CMD_DATA;
34812470:	e3833020 	orr	r3, r3, #32
	writew(val, host->ioaddr + reg);
}

static inline void sdhci_writeb(struct sdhci_host *host, u8 val, int reg)
{
	writeb(val, host->ioaddr + reg);
34812474:	e5941004 	ldr	r1, [r4, #4]
34812478:	e3a0000e 	mov	r0, #14
3481247c:	e5c1002e 	strb	r0, [r1, #46]	; 0x2e
	/*Set Transfer mode regarding to data flag*/
	if (data != 0) {
		sdhci_writeb(host, 0xe, SDHCI_TIMEOUT_CONTROL);
		mode = SDHCI_TRNS_BLK_CNT_EN;
		trans_bytes = data->blocks * data->blocksize;
		if (data->blocks > 1)
34812480:	e9961003 	ldmib	r6, {r0, r1, ip}
		flags |= SDHCI_CMD_DATA;

	/*Set Transfer mode regarding to data flag*/
	if (data != 0) {
		sdhci_writeb(host, 0xe, SDHCI_TIMEOUT_CONTROL);
		mode = SDHCI_TRNS_BLK_CNT_EN;
34812484:	e3510001 	cmp	r1, #1
		}

		sdhci_writel(host, start_addr, SDHCI_DMA_ADDRESS);
		mode |= SDHCI_TRNS_DMA;
#endif
		sdhci_writew(host, SDHCI_MAKE_BLKSZ(SDHCI_DEFAULT_BOUNDARY_ARG,
34812488:	e1a0ca0c 	lsl	ip, ip, #20
		flags |= SDHCI_CMD_DATA;

	/*Set Transfer mode regarding to data flag*/
	if (data != 0) {
		sdhci_writeb(host, 0xe, SDHCI_TIMEOUT_CONTROL);
		mode = SDHCI_TRNS_BLK_CNT_EN;
3481248c:	83a01022 	movhi	r1, #34	; 0x22
34812490:	93a01002 	movls	r1, #2
		}

		sdhci_writel(host, start_addr, SDHCI_DMA_ADDRESS);
		mode |= SDHCI_TRNS_DMA;
#endif
		sdhci_writew(host, SDHCI_MAKE_BLKSZ(SDHCI_DEFAULT_BOUNDARY_ARG,
34812494:	e1a0ca2c 	lsr	ip, ip, #20
		mode = SDHCI_TRNS_BLK_CNT_EN;
		trans_bytes = data->blocks * data->blocksize;
		if (data->blocks > 1)
			mode |= SDHCI_TRNS_MULTI;

		if (data->flags == MMC_DATA_READ)
34812498:	e3500001 	cmp	r0, #1
			mode |= SDHCI_TRNS_READ;
3481249c:	03811010 	orreq	r1, r1, #16
		}

		sdhci_writel(host, start_addr, SDHCI_DMA_ADDRESS);
		mode |= SDHCI_TRNS_DMA;
#endif
		sdhci_writew(host, SDHCI_MAKE_BLKSZ(SDHCI_DEFAULT_BOUNDARY_ARG,
348124a0:	e38cca07 	orr	ip, ip, #28672	; 0x7000
	writel(val, host->ioaddr + reg);
}

static inline void sdhci_writew(struct sdhci_host *host, u16 val, int reg)
{
	writew(val, host->ioaddr + reg);
348124a4:	e5940004 	ldr	r0, [r4, #4]
348124a8:	e1c0c0b4 	strh	ip, [r0, #4]
				data->blocksize),
				SDHCI_BLOCK_SIZE);
		sdhci_writew(host, data->blocks, SDHCI_BLOCK_COUNT);
348124ac:	e1d6c0b8 	ldrh	ip, [r6, #8]
348124b0:	e5940004 	ldr	r0, [r4, #4]
		sdhci_writew(host, mode, SDHCI_TRANSFER_MODE);
348124b4:	e6ff1071 	uxth	r1, r1
348124b8:	e1c0c0b6 	strh	ip, [r0, #6]
348124bc:	e5940004 	ldr	r0, [r4, #4]
348124c0:	e1c010bc 	strh	r1, [r0, #12]
	}

	sdhci_writel(host, cmd->cmdarg, SDHCI_ARGUMENT);
348124c4:	e5950008 	ldr	r0, [r5, #8]

#else

static inline void sdhci_writel(struct sdhci_host *host, u32 val, int reg)
{
	writel(val, host->ioaddr + reg);
348124c8:	e5941004 	ldr	r1, [r4, #4]
#ifdef CONFIG_MMC_SDMA
	flush_cache(start_addr, trans_bytes);
#endif
	sdhci_writew(host, SDHCI_MAKE_CMD(cmd->cmdidx, flags), SDHCI_COMMAND);
348124cc:	e20330ff 	and	r3, r3, #255	; 0xff
348124d0:	e5810008 	str	r0, [r1, #8]
348124d4:	e1d510b0 	ldrh	r1, [r5]
348124d8:	e1833401 	orr	r3, r3, r1, lsl #8
348124dc:	e6ff3073 	uxth	r3, r3
}

static inline void sdhci_writew(struct sdhci_host *host, u16 val, int reg)
{
	writew(val, host->ioaddr + reg);
348124e0:	e5941004 	ldr	r1, [r4, #4]
348124e4:	e1c130be 	strh	r3, [r1, #14]
	unsigned int stat = 0;
	int ret = 0;
	int trans_bytes = 0, is_aligned = 1;
	u32 mask, flags, mode;
	unsigned int timeout, start_addr = 0;
	unsigned int retry = 10000;
348124e8:	e3023710 	movw	r3, #10000	; 0x2710
{
	writeb(val, host->ioaddr + reg);
}
static inline u32 sdhci_readl(struct sdhci_host *host, int reg)
{
	return readl(host->ioaddr + reg);
348124ec:	e5941004 	ldr	r1, [r4, #4]
348124f0:	e5911030 	ldr	r1, [r1, #48]	; 0x30
	flush_cache(start_addr, trans_bytes);
#endif
	sdhci_writew(host, SDHCI_MAKE_CMD(cmd->cmdidx, flags), SDHCI_COMMAND);
	do {
		stat = sdhci_readl(host, SDHCI_INT_STATUS);
		if (stat & SDHCI_INT_ERROR)
348124f4:	e3110902 	tst	r1, #32768	; 0x8000
348124f8:	1a000005 	bne	34812514 <sdhci_send_command+0x158>
			break;
		if (--retry == 0)
348124fc:	e2533001 	subs	r3, r3, #1
34812500:	0a000005 	beq	3481251c <sdhci_send_command+0x160>
			break;
	} while ((stat & mask) != mask);
34812504:	e0020001 	and	r0, r2, r1
34812508:	e1500002 	cmp	r0, r2
3481250c:	1afffff6 	bne	348124ec <sdhci_send_command+0x130>
34812510:	ea000008 	b	34812538 <sdhci_send_command+0x17c>

	if (retry == 0) {
34812514:	e3530000 	cmp	r3, #0
34812518:	1a000006 	bne	34812538 <sdhci_send_command+0x17c>
		if (host->quirks & SDHCI_QUIRK_BROKEN_R1B)
3481251c:	e5943008 	ldr	r3, [r4, #8]
34812520:	e3130004 	tst	r3, #4
34812524:	1a000073 	bne	348126f8 <sdhci_send_command+0x33c>
			return 0;
		else {
			printf("Timeout for status update!\n");
34812528:	e59f01d4 	ldr	r0, [pc, #468]	; 34812704 <sdhci_send_command+0x348>
3481252c:	ebffda86 	bl	34808f4c <printf>
			return TIMEOUT;
34812530:	e3e00012 	mvn	r0, #18
34812534:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
		}
	}

	if ((stat & (SDHCI_INT_ERROR | mask)) == mask) {
34812538:	e3823902 	orr	r3, r2, #32768	; 0x8000
3481253c:	e0011003 	and	r1, r1, r3
34812540:	e1510002 	cmp	r1, r2
		sdhci_cmd_done(host, cmd);
		sdhci_writel(host, mask, SDHCI_INT_STATUS);
	} else
		ret = -1;
34812544:	13e00000 	mvnne	r0, #0
			printf("Timeout for status update!\n");
			return TIMEOUT;
		}
	}

	if ((stat & (SDHCI_INT_ERROR | mask)) == mask) {
34812548:	1a00001b 	bne	348125bc <sdhci_send_command+0x200>
}

static void sdhci_cmd_done(struct sdhci_host *host, struct mmc_cmd *cmd)
{
	int i;
	if (cmd->resp_type & MMC_RSP_136) {
3481254c:	e5953004 	ldr	r3, [r5, #4]
34812550:	e3130002 	tst	r3, #2
34812554:	0a000012 	beq	348125a4 <sdhci_send_command+0x1e8>
		}
	} while (!(stat & SDHCI_INT_DATA_END));
	return 0;
}

int sdhci_send_command(struct mmc *mmc, struct mmc_cmd *cmd,
34812558:	e285500c 	add	r5, r5, #12
3481255c:	e3a0201c 	mov	r2, #28
34812560:	e3a03000 	mov	r3, #0
34812564:	e5940004 	ldr	r0, [r4, #4]
34812568:	e7900002 	ldr	r0, [r0, r2]
	int i;
	if (cmd->resp_type & MMC_RSP_136) {
		/* CRC is stripped so we need to do some shifting. */
		for (i = 0; i < 4; i++) {
			cmd->response[i] = sdhci_readl(host,
					SDHCI_RESPONSE + (3-i)*4) << 8;
3481256c:	e1a00400 	lsl	r0, r0, #8
			if (i != 3)
34812570:	e3530003 	cmp	r3, #3
{
	int i;
	if (cmd->resp_type & MMC_RSP_136) {
		/* CRC is stripped so we need to do some shifting. */
		for (i = 0; i < 4; i++) {
			cmd->response[i] = sdhci_readl(host,
34812574:	e4850004 	str	r0, [r5], #4
					SDHCI_RESPONSE + (3-i)*4) << 8;
			if (i != 3)
34812578:	0a000004 	beq	34812590 <sdhci_send_command+0x1d4>
	return readw(host->ioaddr + reg);
}

static inline u8 sdhci_readb(struct sdhci_host *host, int reg)
{
	return readb(host->ioaddr + reg);
3481257c:	e5947004 	ldr	r7, [r4, #4]
34812580:	e242c001 	sub	ip, r2, #1
34812584:	e7d7c00c 	ldrb	ip, [r7, ip]
				cmd->response[i] |= sdhci_readb(host,
34812588:	e18c0000 	orr	r0, ip, r0
3481258c:	e5050004 	str	r0, [r5, #-4]
static void sdhci_cmd_done(struct sdhci_host *host, struct mmc_cmd *cmd)
{
	int i;
	if (cmd->resp_type & MMC_RSP_136) {
		/* CRC is stripped so we need to do some shifting. */
		for (i = 0; i < 4; i++) {
34812590:	e2833001 	add	r3, r3, #1
34812594:	e3530004 	cmp	r3, #4
34812598:	e2422004 	sub	r2, r2, #4
3481259c:	1afffff0 	bne	34812564 <sdhci_send_command+0x1a8>
348125a0:	ea000002 	b	348125b0 <sdhci_send_command+0x1f4>
{
	writeb(val, host->ioaddr + reg);
}
static inline u32 sdhci_readl(struct sdhci_host *host, int reg)
{
	return readl(host->ioaddr + reg);
348125a4:	e5943004 	ldr	r3, [r4, #4]
348125a8:	e5933010 	ldr	r3, [r3, #16]
			if (i != 3)
				cmd->response[i] |= sdhci_readb(host,
						SDHCI_RESPONSE + (3-i)*4-1);
		}
	} else {
		cmd->response[0] = sdhci_readl(host, SDHCI_RESPONSE);
348125ac:	e585300c 	str	r3, [r5, #12]

#else

static inline void sdhci_writel(struct sdhci_host *host, u32 val, int reg)
{
	writel(val, host->ioaddr + reg);
348125b0:	e5943004 	ldr	r3, [r4, #4]
int sdhci_send_command(struct mmc *mmc, struct mmc_cmd *cmd,
		       struct mmc_data *data)
{
	struct sdhci_host *host = (struct sdhci_host *)mmc->priv;
	unsigned int stat = 0;
	int ret = 0;
348125b4:	e3a00000 	mov	r0, #0
348125b8:	e5831030 	str	r1, [r3, #48]	; 0x30
		sdhci_cmd_done(host, cmd);
		sdhci_writel(host, mask, SDHCI_INT_STATUS);
	} else
		ret = -1;

	if (!ret && data)
348125bc:	e2803001 	add	r3, r0, #1
348125c0:	e3560000 	cmp	r6, #0
348125c4:	03a03000 	moveq	r3, #0
348125c8:	12033001 	andne	r3, r3, #1
348125cc:	e3530000 	cmp	r3, #0
348125d0:	0a000036 	beq	348126b0 <sdhci_send_command+0x2f4>

	sdhci_reset(host, SDHCI_RESET_ALL);
	mmc_register(mmc);

	return 0;
}
348125d4:	e2847004 	add	r7, r4, #4
}

static int sdhci_transfer_data(struct sdhci_host *host, struct mmc_data *data,
				unsigned int start_addr)
{
	unsigned int stat, rdy, mask, timeout, block = 0;
348125d8:	e3a09000 	mov	r9, #0

	timeout = 10000;
348125dc:	e302a710 	movw	sl, #10000	; 0x2710
348125e0:	e3a0b030 	mov	fp, #48	; 0x30
{
	writeb(val, host->ioaddr + reg);
}
static inline u32 sdhci_readl(struct sdhci_host *host, int reg)
{
	return readl(host->ioaddr + reg);
348125e4:	e5973000 	ldr	r3, [r7]
348125e8:	e5935030 	ldr	r5, [r3, #48]	; 0x30
	rdy = SDHCI_INT_SPACE_AVAIL | SDHCI_INT_DATA_AVAIL;
	mask = SDHCI_DATA_AVAILABLE | SDHCI_SPACE_AVAILABLE;
	do {
		stat = sdhci_readl(host, SDHCI_INT_STATUS);
		if (stat & SDHCI_INT_ERROR) {
348125ec:	e2153902 	ands	r3, r5, #32768	; 0x8000
348125f0:	0a000003 	beq	34812604 <sdhci_send_command+0x248>
			printf("Error detected in status(0x%X)!\n", stat);
348125f4:	e1a01005 	mov	r1, r5
348125f8:	e59f0108 	ldr	r0, [pc, #264]	; 34812708 <sdhci_send_command+0x34c>
348125fc:	ebffda52 	bl	34808f4c <printf>
34812600:	ea000025 	b	3481269c <sdhci_send_command+0x2e0>
			return -1;
		}
		if (stat & rdy) {
34812604:	e3150030 	tst	r5, #48	; 0x30
34812608:	0a00001b 	beq	3481267c <sdhci_send_command+0x2c0>
3481260c:	e5972000 	ldr	r2, [r7]
34812610:	e5922024 	ldr	r2, [r2, #36]	; 0x24
			if (!(sdhci_readl(host, SDHCI_PRESENT_STATE) & mask))
34812614:	e3120b03 	tst	r2, #3072	; 0xc00
34812618:	0a000021 	beq	348126a4 <sdhci_send_command+0x2e8>

#else

static inline void sdhci_writel(struct sdhci_host *host, u32 val, int reg)
{
	writel(val, host->ioaddr + reg);
3481261c:	e5972000 	ldr	r2, [r7]
34812620:	e582b030 	str	fp, [r2, #48]	; 0x30
34812624:	ea00000a 	b	34812654 <sdhci_send_command+0x298>
{
	int i;
	char *offs;
	for (i = 0; i < data->blocksize; i += 4) {
		offs = data->dest + i;
		if (data->flags == MMC_DATA_READ)
34812628:	e5961004 	ldr	r1, [r6, #4]
3481262c:	e3510001 	cmp	r1, #1
34812630:	1a000003 	bne	34812644 <sdhci_send_command+0x288>
{
	writeb(val, host->ioaddr + reg);
}
static inline u32 sdhci_readl(struct sdhci_host *host, int reg)
{
	return readl(host->ioaddr + reg);
34812634:	e5971000 	ldr	r1, [r7]
34812638:	e5911020 	ldr	r1, [r1, #32]
			*(u32 *)offs = sdhci_readl(host, SDHCI_BUFFER);
3481263c:	e7821003 	str	r1, [r2, r3]
34812640:	ea000002 	b	34812650 <sdhci_send_command+0x294>
		else
			sdhci_writel(host, *(u32 *)offs, SDHCI_BUFFER);
34812644:	e7921003 	ldr	r1, [r2, r3]

#else

static inline void sdhci_writel(struct sdhci_host *host, u32 val, int reg)
{
	writel(val, host->ioaddr + reg);
34812648:	e5972000 	ldr	r2, [r7]
3481264c:	e5821020 	str	r1, [r2, #32]

static void sdhci_transfer_pio(struct sdhci_host *host, struct mmc_data *data)
{
	int i;
	char *offs;
	for (i = 0; i < data->blocksize; i += 4) {
34812650:	e2833004 	add	r3, r3, #4
34812654:	e596100c 	ldr	r1, [r6, #12]
34812658:	e5962000 	ldr	r2, [r6]
3481265c:	e1530001 	cmp	r3, r1
34812660:	3afffff0 	bcc	34812628 <sdhci_send_command+0x26c>
			if (!(sdhci_readl(host, SDHCI_PRESENT_STATE) & mask))
				continue;
			sdhci_writel(host, rdy, SDHCI_INT_STATUS);
			sdhci_transfer_pio(host, data);
			data->dest += data->blocksize;
			if (++block >= data->blocks)
34812664:	e5963008 	ldr	r3, [r6, #8]
34812668:	e2899001 	add	r9, r9, #1
		if (stat & rdy) {
			if (!(sdhci_readl(host, SDHCI_PRESENT_STATE) & mask))
				continue;
			sdhci_writel(host, rdy, SDHCI_INT_STATUS);
			sdhci_transfer_pio(host, data);
			data->dest += data->blocksize;
3481266c:	e0822001 	add	r2, r2, r1
			if (++block >= data->blocks)
34812670:	e1590003 	cmp	r9, r3
		if (stat & rdy) {
			if (!(sdhci_readl(host, SDHCI_PRESENT_STATE) & mask))
				continue;
			sdhci_writel(host, rdy, SDHCI_INT_STATUS);
			sdhci_transfer_pio(host, data);
			data->dest += data->blocksize;
34812674:	e5862000 	str	r2, [r6]
			if (++block >= data->blocks)
34812678:	2a00000b 	bcs	348126ac <sdhci_send_command+0x2f0>
			start_addr &= ~(SDHCI_DEFAULT_BOUNDARY_SIZE - 1);
			start_addr += SDHCI_DEFAULT_BOUNDARY_SIZE;
			sdhci_writel(host, start_addr, SDHCI_DMA_ADDRESS);
		}
#endif
		if (timeout-- > 0)
3481267c:	e35a0000 	cmp	sl, #0
34812680:	0a000003 	beq	34812694 <sdhci_send_command+0x2d8>
			udelay(10);
34812684:	e3a0000a 	mov	r0, #10
			start_addr &= ~(SDHCI_DEFAULT_BOUNDARY_SIZE - 1);
			start_addr += SDHCI_DEFAULT_BOUNDARY_SIZE;
			sdhci_writel(host, start_addr, SDHCI_DMA_ADDRESS);
		}
#endif
		if (timeout-- > 0)
34812688:	e24aa001 	sub	sl, sl, #1
			udelay(10);
3481268c:	eb001a8a 	bl	348190bc <udelay>
34812690:	ea000003 	b	348126a4 <sdhci_send_command+0x2e8>
		else {
			printf("Transfer data timeout\n");
34812694:	e59f0070 	ldr	r0, [pc, #112]	; 3481270c <sdhci_send_command+0x350>
34812698:	ebffda2b 	bl	34808f4c <printf>
			return -1;
3481269c:	e3e00000 	mvn	r0, #0
348126a0:	ea000002 	b	348126b0 <sdhci_send_command+0x2f4>
		}
	} while (!(stat & SDHCI_INT_DATA_END));
348126a4:	e3150002 	tst	r5, #2
348126a8:	0affffcd 	beq	348125e4 <sdhci_send_command+0x228>
	return 0;
348126ac:	e3a00000 	mov	r0, #0
{
	writeb(val, host->ioaddr + reg);
}
static inline u32 sdhci_readl(struct sdhci_host *host, int reg)
{
	return readl(host->ioaddr + reg);
348126b0:	e5943004 	ldr	r3, [r4, #4]
348126b4:	e5935030 	ldr	r5, [r3, #48]	; 0x30

#else

static inline void sdhci_writel(struct sdhci_host *host, u32 val, int reg)
{
	writel(val, host->ioaddr + reg);
348126b8:	e5943004 	ldr	r3, [r4, #4]
348126bc:	e3e02000 	mvn	r2, #0
	if (!ret && data)
		ret = sdhci_transfer_data(host, data, start_addr);

	stat = sdhci_readl(host, SDHCI_INT_STATUS);
	sdhci_writel(host, SDHCI_INT_ALL_MASK, SDHCI_INT_STATUS);
	if (!ret) {
348126c0:	e3500000 	cmp	r0, #0
348126c4:	e5832030 	str	r2, [r3, #48]	; 0x30
348126c8:	08bd8ef0 	popeq	{r4, r5, r6, r7, r9, sl, fp, pc}

	sdhci_reset(host, SDHCI_RESET_ALL);
	mmc_register(mmc);

	return 0;
}
348126cc:	e2844004 	add	r4, r4, #4
				!is_aligned && (data->flags == MMC_DATA_READ))
			memcpy(data->dest, aligned_buffer, trans_bytes);
		return 0;
	}

	sdhci_reset(host, SDHCI_RESET_CMD);
348126d0:	e1a00004 	mov	r0, r4
348126d4:	e3a01002 	mov	r1, #2
348126d8:	ebffff21 	bl	34812364 <sdhci_reset.clone.9>
	sdhci_reset(host, SDHCI_RESET_DATA);
348126dc:	e1a00004 	mov	r0, r4
348126e0:	e3a01004 	mov	r1, #4
348126e4:	ebffff1e 	bl	34812364 <sdhci_reset.clone.9>
	if (stat & SDHCI_INT_TIMEOUT)
		return TIMEOUT;
348126e8:	e3150801 	tst	r5, #65536	; 0x10000
348126ec:	03e00011 	mvneq	r0, #17
348126f0:	13e00012 	mvnne	r0, #18
348126f4:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
			break;
	} while ((stat & mask) != mask);

	if (retry == 0) {
		if (host->quirks & SDHCI_QUIRK_BROKEN_R1B)
			return 0;
348126f8:	e3a00000 	mov	r0, #0
	sdhci_reset(host, SDHCI_RESET_DATA);
	if (stat & SDHCI_INT_TIMEOUT)
		return TIMEOUT;
	else
		return COMM_ERR;
}
348126fc:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
34812700:	34827035 	.word	0x34827035
34812704:	34827060 	.word	0x34827060
34812708:	3482707c 	.word	0x3482707c
3481270c:	3482709d 	.word	0x3482709d

34812710 <add_sdhci>:

	return 0;
}

int add_sdhci(struct sdhci_host *host, u32 max_clk, u32 min_clk)
{
34812710:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
34812714:	e1a05000 	mov	r5, r0
	struct mmc *mmc;
	unsigned int caps;

	mmc = malloc(sizeof(struct mmc));
34812718:	e3a00f4a 	mov	r0, #296	; 0x128

	return 0;
}

int add_sdhci(struct sdhci_host *host, u32 max_clk, u32 min_clk)
{
3481271c:	e1a07001 	mov	r7, r1
34812720:	e1a06002 	mov	r6, r2
	struct mmc *mmc;
	unsigned int caps;

	mmc = malloc(sizeof(struct mmc));
34812724:	ebffdbcf 	bl	34809668 <malloc>
	if (!mmc) {
34812728:	e2504000 	subs	r4, r0, #0
		printf("mmc malloc fail!\n");
3481272c:	059f0144 	ldreq	r0, [pc, #324]	; 34812878 <add_sdhci+0x168>
{
	struct mmc *mmc;
	unsigned int caps;

	mmc = malloc(sizeof(struct mmc));
	if (!mmc) {
34812730:	0a00001f 	beq	348127b4 <add_sdhci+0xa4>
		printf("mmc malloc fail!\n");
		return -1;
	}

	mmc->priv = host;
34812734:	e5845028 	str	r5, [r4, #40]	; 0x28
	host->mmc = mmc;

	sprintf(mmc->name, "%s", host->name);
34812738:	e2840008 	add	r0, r4, #8
		printf("mmc malloc fail!\n");
		return -1;
	}

	mmc->priv = host;
	host->mmc = mmc;
3481273c:	e5854018 	str	r4, [r5, #24]

	sprintf(mmc->name, "%s", host->name);
34812740:	e59f1134 	ldr	r1, [pc, #308]	; 3481287c <add_sdhci+0x16c>
34812744:	e5952000 	ldr	r2, [r5]
34812748:	eb001dd0 	bl	34819e90 <sprintf>
	mmc->send_cmd = sdhci_send_command;
3481274c:	e59f312c 	ldr	r3, [pc, #300]	; 34812880 <add_sdhci+0x170>
34812750:	e5843110 	str	r3, [r4, #272]	; 0x110
	mmc->set_ios = sdhci_set_ios;
34812754:	e59f3128 	ldr	r3, [pc, #296]	; 34812884 <add_sdhci+0x174>
34812758:	e5843114 	str	r3, [r4, #276]	; 0x114
	mmc->init = sdhci_init;
3481275c:	e59f3124 	ldr	r3, [pc, #292]	; 34812888 <add_sdhci+0x178>
34812760:	e5843118 	str	r3, [r4, #280]	; 0x118
	mmc->getcd = NULL;
34812764:	e3a03000 	mov	r3, #0
34812768:	e584311c 	str	r3, [r4, #284]	; 0x11c
{
	writeb(val, host->ioaddr + reg);
}
static inline u32 sdhci_readl(struct sdhci_host *host, int reg)
{
	return readl(host->ioaddr + reg);
3481276c:	e5953004 	ldr	r3, [r5, #4]
34812770:	e593a040 	ldr	sl, [r3, #64]	; 0x40
		printf("Your controller don't support sdma!!\n");
		return -1;
	}
#endif

	if (max_clk)
34812774:	e3570000 	cmp	r7, #0
		mmc->f_max = max_clk;
34812778:	1584703c 	strne	r7, [r4, #60]	; 0x3c
		printf("Your controller don't support sdma!!\n");
		return -1;
	}
#endif

	if (max_clk)
3481277c:	1a000008 	bne	348127a4 <add_sdhci+0x94>
		mmc->f_max = max_clk;
	else {
		if ((host->version & SDHCI_SPEC_VER_MASK) >= SDHCI_SPEC_300)
34812780:	e5d53010 	ldrb	r3, [r5, #16]
			mmc->f_max = (caps & SDHCI_CLOCK_V3_BASE_MASK)
				>> SDHCI_CLOCK_BASE_SHIFT;
		else
			mmc->f_max = (caps & SDHCI_CLOCK_BASE_MASK)
				>> SDHCI_CLOCK_BASE_SHIFT;
		mmc->f_max *= 1000000;
34812784:	e59f2100 	ldr	r2, [pc, #256]	; 3481288c <add_sdhci+0x17c>
#endif

	if (max_clk)
		mmc->f_max = max_clk;
	else {
		if ((host->version & SDHCI_SPEC_VER_MASK) >= SDHCI_SPEC_300)
34812788:	e3530001 	cmp	r3, #1
			mmc->f_max = (caps & SDHCI_CLOCK_V3_BASE_MASK)
				>> SDHCI_CLOCK_BASE_SHIFT;
3481278c:	87e7345a 	ubfxhi	r3, sl, #8, #8
		else
			mmc->f_max = (caps & SDHCI_CLOCK_BASE_MASK)
				>> SDHCI_CLOCK_BASE_SHIFT;
34812790:	97e5345a 	ubfxls	r3, sl, #8, #6
	else {
		if ((host->version & SDHCI_SPEC_VER_MASK) >= SDHCI_SPEC_300)
			mmc->f_max = (caps & SDHCI_CLOCK_V3_BASE_MASK)
				>> SDHCI_CLOCK_BASE_SHIFT;
		else
			mmc->f_max = (caps & SDHCI_CLOCK_BASE_MASK)
34812794:	e584303c 	str	r3, [r4, #60]	; 0x3c
				>> SDHCI_CLOCK_BASE_SHIFT;
		mmc->f_max *= 1000000;
34812798:	e594303c 	ldr	r3, [r4, #60]	; 0x3c
3481279c:	e0030392 	mul	r3, r2, r3
348127a0:	e584303c 	str	r3, [r4, #60]	; 0x3c
	}
	if (mmc->f_max == 0) {
348127a4:	e594003c 	ldr	r0, [r4, #60]	; 0x3c
348127a8:	e3500000 	cmp	r0, #0
348127ac:	1a000003 	bne	348127c0 <add_sdhci+0xb0>
		printf("Hardware doesn't specify base clock frequency\n");
348127b0:	e59f00d8 	ldr	r0, [pc, #216]	; 34812890 <add_sdhci+0x180>
348127b4:	ebffd9e4 	bl	34808f4c <printf>
		return -1;
348127b8:	e3e00000 	mvn	r0, #0
348127bc:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
	}
	if (min_clk)
348127c0:	e3560000 	cmp	r6, #0
		mmc->f_min = min_clk;
348127c4:	15846038 	strne	r6, [r4, #56]	; 0x38
	}
	if (mmc->f_max == 0) {
		printf("Hardware doesn't specify base clock frequency\n");
		return -1;
	}
	if (min_clk)
348127c8:	1a000006 	bne	348127e8 <add_sdhci+0xd8>
		mmc->f_min = min_clk;
	else {
		if ((host->version & SDHCI_SPEC_VER_MASK) >= SDHCI_SPEC_300)
348127cc:	e5d53010 	ldrb	r3, [r5, #16]
348127d0:	e3530001 	cmp	r3, #1
			mmc->f_min = mmc->f_max / SDHCI_MAX_DIV_SPEC_300;
		else
			mmc->f_min = mmc->f_max / SDHCI_MAX_DIV_SPEC_200;
348127d4:	91a00420 	lsrls	r0, r0, #8
		return -1;
	}
	if (min_clk)
		mmc->f_min = min_clk;
	else {
		if ((host->version & SDHCI_SPEC_VER_MASK) >= SDHCI_SPEC_300)
348127d8:	9a000001 	bls	348127e4 <add_sdhci+0xd4>
			mmc->f_min = mmc->f_max / SDHCI_MAX_DIV_SPEC_300;
348127dc:	e30017fe 	movw	r1, #2046	; 0x7fe
348127e0:	eb0035af 	bl	3481fea4 <__udivsi3>
		else
			mmc->f_min = mmc->f_max / SDHCI_MAX_DIV_SPEC_200;
348127e4:	e5840038 	str	r0, [r4, #56]	; 0x38
	}

	mmc->voltages = 0;
348127e8:	e3a03000 	mov	r3, #0
	if (caps & SDHCI_CAN_VDD_330)
348127ec:	e31a0401 	tst	sl, #16777216	; 0x1000000
			mmc->f_min = mmc->f_max / SDHCI_MAX_DIV_SPEC_300;
		else
			mmc->f_min = mmc->f_max / SDHCI_MAX_DIV_SPEC_200;
	}

	mmc->voltages = 0;
348127f0:	e584302c 	str	r3, [r4, #44]	; 0x2c
	if (caps & SDHCI_CAN_VDD_330)
		mmc->voltages |= MMC_VDD_32_33 | MMC_VDD_33_34;
348127f4:	12833603 	addne	r3, r3, #3145728	; 0x300000
348127f8:	1584302c 	strne	r3, [r4, #44]	; 0x2c
	if (caps & SDHCI_CAN_VDD_300)
348127fc:	e31a0402 	tst	sl, #33554432	; 0x2000000
		mmc->voltages |= MMC_VDD_29_30 | MMC_VDD_30_31;
34812800:	1594302c 	ldrne	r3, [r4, #44]	; 0x2c
	if (caps & SDHCI_CAN_DO_8BIT)
		mmc->host_caps |= MMC_MODE_8BIT;
	if (host->host_caps)
		mmc->host_caps |= host->host_caps;

	sdhci_reset(host, SDHCI_RESET_ALL);
34812804:	e2850004 	add	r0, r5, #4

	mmc->voltages = 0;
	if (caps & SDHCI_CAN_VDD_330)
		mmc->voltages |= MMC_VDD_32_33 | MMC_VDD_33_34;
	if (caps & SDHCI_CAN_VDD_300)
		mmc->voltages |= MMC_VDD_29_30 | MMC_VDD_30_31;
34812808:	13833806 	orrne	r3, r3, #393216	; 0x60000
3481280c:	1584302c 	strne	r3, [r4, #44]	; 0x2c
	if (caps & SDHCI_CAN_VDD_180)
34812810:	e31a0301 	tst	sl, #67108864	; 0x4000000
		mmc->voltages |= MMC_VDD_165_195;
34812814:	1594302c 	ldrne	r3, [r4, #44]	; 0x2c
	if (caps & SDHCI_CAN_DO_8BIT)
		mmc->host_caps |= MMC_MODE_8BIT;
	if (host->host_caps)
		mmc->host_caps |= host->host_caps;

	sdhci_reset(host, SDHCI_RESET_ALL);
34812818:	e3a01001 	mov	r1, #1
	if (caps & SDHCI_CAN_VDD_330)
		mmc->voltages |= MMC_VDD_32_33 | MMC_VDD_33_34;
	if (caps & SDHCI_CAN_VDD_300)
		mmc->voltages |= MMC_VDD_29_30 | MMC_VDD_30_31;
	if (caps & SDHCI_CAN_VDD_180)
		mmc->voltages |= MMC_VDD_165_195;
3481281c:	13833080 	orrne	r3, r3, #128	; 0x80
34812820:	1584302c 	strne	r3, [r4, #44]	; 0x2c

	if (host->quirks & SDHCI_QUIRK_BROKEN_VOLTAGE)
34812824:	e5953008 	ldr	r3, [r5, #8]
34812828:	e3130010 	tst	r3, #16
		mmc->voltages |= host->voltages;
3481282c:	1595302c 	ldrne	r3, [r5, #44]	; 0x2c
34812830:	1594202c 	ldrne	r2, [r4, #44]	; 0x2c
34812834:	11823003 	orrne	r3, r2, r3
34812838:	1584302c 	strne	r3, [r4, #44]	; 0x2c

	mmc->host_caps = MMC_MODE_HS | MMC_MODE_HS_52MHz | MMC_MODE_4BIT;
3481283c:	e3003111 	movw	r3, #273	; 0x111
	if (caps & SDHCI_CAN_DO_8BIT)
34812840:	e31a0701 	tst	sl, #262144	; 0x40000
		mmc->voltages |= MMC_VDD_165_195;

	if (host->quirks & SDHCI_QUIRK_BROKEN_VOLTAGE)
		mmc->voltages |= host->voltages;

	mmc->host_caps = MMC_MODE_HS | MMC_MODE_HS_52MHz | MMC_MODE_4BIT;
34812844:	e5843050 	str	r3, [r4, #80]	; 0x50
	if (caps & SDHCI_CAN_DO_8BIT)
		mmc->host_caps |= MMC_MODE_8BIT;
34812848:	12833c02 	addne	r3, r3, #512	; 0x200
3481284c:	15843050 	strne	r3, [r4, #80]	; 0x50
	if (host->host_caps)
34812850:	e595300c 	ldr	r3, [r5, #12]
34812854:	e3530000 	cmp	r3, #0
		mmc->host_caps |= host->host_caps;
34812858:	15942050 	ldrne	r2, [r4, #80]	; 0x50
3481285c:	11823003 	orrne	r3, r2, r3
34812860:	15843050 	strne	r3, [r4, #80]	; 0x50

	sdhci_reset(host, SDHCI_RESET_ALL);
34812864:	ebfffebe 	bl	34812364 <sdhci_reset.clone.9>
	mmc_register(mmc);
34812868:	e1a00004 	mov	r0, r4
3481286c:	ebfffd5e 	bl	34811dec <mmc_register>

	return 0;
34812870:	e3a00000 	mov	r0, #0
}
34812874:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
34812878:	348270b4 	.word	0x348270b4
3481287c:	34824dd1 	.word	0x34824dd1
34812880:	348123bc 	.word	0x348123bc
34812884:	3481203c 	.word	0x3481203c
34812888:	348121f0 	.word	0x348121f0
3481288c:	000f4240 	.word	0x000f4240
34812890:	348270c6 	.word	0x348270c6

34812894 <s5p_sdhci_set_control_reg>:

#else

static inline void sdhci_writel(struct sdhci_host *host, u32 val, int reg)
{
	writel(val, host->ioaddr + reg);
34812894:	e5903004 	ldr	r3, [r0, #4]
34812898:	e3a02803 	mov	r2, #196608	; 0x30000
3481289c:	e583208c 	str	r2, [r3, #140]	; 0x8c
{
	writeb(val, host->ioaddr + reg);
}
static inline u32 sdhci_readl(struct sdhci_host *host, int reg)
{
	return readl(host->ioaddr + reg);
348128a0:	e5932080 	ldr	r2, [r3, #128]	; 0x80
	 * 11 = 9mA
	 */
	sdhci_writel(host, SDHCI_CTRL4_DRIVE_MASK(0x3), SDHCI_CONTROL4);

	val = sdhci_readl(host, SDHCI_CONTROL2);
	val &= SDHCI_CTRL2_SELBASECLK_SHIFT;
348128a4:	e2022004 	and	r2, r2, #4

	val |=	SDHCI_CTRL2_ENSTAASYNCCLR |
348128a8:	e3822103 	orr	r2, r2, #-1073741824	; 0xc0000000
348128ac:	e3822c41 	orr	r2, r2, #16640	; 0x4100

#else

static inline void sdhci_writel(struct sdhci_host *host, u32 val, int reg)
{
	writel(val, host->ioaddr + reg);
348128b0:	e5903004 	ldr	r3, [r0, #4]
348128b4:	e5832080 	str	r2, [r3, #128]	; 0x80
348128b8:	e5903004 	ldr	r3, [r0, #4]
348128bc:	e3082080 	movw	r2, #32896	; 0x8080
348128c0:	e5832084 	str	r2, [r3, #132]	; 0x84
{
	writeb(val, host->ioaddr + reg);
}
static inline u32 sdhci_readl(struct sdhci_host *host, int reg)
{
	return readl(host->ioaddr + reg);
348128c4:	e5932080 	ldr	r2, [r3, #128]	; 0x80
	 * 00/01 = HCLK
	 * 10 = EPLL
	 * 11 = XTI or XEXTCLK
	 */
	ctrl = sdhci_readl(host, SDHCI_CONTROL2);
	ctrl &= ~SDHCI_CTRL2_SELBASECLK_MASK(0x3);
348128c8:	e3c22030 	bic	r2, r2, #48	; 0x30
	ctrl |= SDHCI_CTRL2_SELBASECLK_MASK(0x2);
348128cc:	e3822020 	orr	r2, r2, #32

#else

static inline void sdhci_writel(struct sdhci_host *host, u32 val, int reg)
{
	writel(val, host->ioaddr + reg);
348128d0:	e5903004 	ldr	r3, [r0, #4]
348128d4:	e5832080 	str	r2, [r3, #128]	; 0x80
	sdhci_writel(host, ctrl, SDHCI_CONTROL2);
}
348128d8:	e12fff1e 	bx	lr

348128dc <s5p_sdhci_init>:

int s5p_sdhci_init(u32 regbase, int index, int bus_width)
{
348128dc:	e92d4038 	push	{r3, r4, r5, lr}
348128e0:	e1a04000 	mov	r4, r0
	struct sdhci_host *host = NULL;
	host = (struct sdhci_host *)malloc(sizeof(struct sdhci_host));
348128e4:	e3a00030 	mov	r0, #48	; 0x30
	ctrl |= SDHCI_CTRL2_SELBASECLK_MASK(0x2);
	sdhci_writel(host, ctrl, SDHCI_CONTROL2);
}

int s5p_sdhci_init(u32 regbase, int index, int bus_width)
{
348128e8:	e1a05001 	mov	r5, r1
	struct sdhci_host *host = NULL;
	host = (struct sdhci_host *)malloc(sizeof(struct sdhci_host));
348128ec:	ebffdb5d 	bl	34809668 <malloc>
	if (!host) {
348128f0:	e2503000 	subs	r3, r0, #0
348128f4:	1a000003 	bne	34812908 <s5p_sdhci_init+0x2c>
		printf("sdhci__host malloc fail!\n");
348128f8:	e59f0058 	ldr	r0, [pc, #88]	; 34812958 <s5p_sdhci_init+0x7c>
348128fc:	ebffd992 	bl	34808f4c <printf>
		return 1;
34812900:	e3a00001 	mov	r0, #1
34812904:	e8bd8038 	pop	{r3, r4, r5, pc}
	}

	host->name = S5P_NAME;
34812908:	e59f204c 	ldr	r2, [pc, #76]	; 3481295c <s5p_sdhci_init+0x80>
	host->ioaddr = (void *)regbase;
3481290c:	e8830014 	stm	r3, {r2, r4}

	host->quirks = SDHCI_QUIRK_NO_HISPD_BIT | SDHCI_QUIRK_BROKEN_VOLTAGE |
34812910:	e3a0201d 	mov	r2, #29
34812914:	e5832008 	str	r2, [r3, #8]
		SDHCI_QUIRK_BROKEN_R1B | SDHCI_QUIRK_32BIT_DMA_ADDR;
	host->voltages = MMC_VDD_32_33 | MMC_VDD_33_34 | MMC_VDD_165_195;
34812918:	e59f2040 	ldr	r2, [pc, #64]	; 34812960 <s5p_sdhci_init+0x84>
3481291c:	e583202c 	str	r2, [r3, #44]	; 0x2c
	return readl(host->ioaddr + reg);
}

static inline u16 sdhci_readw(struct sdhci_host *host, int reg)
{
	return readw(host->ioaddr + reg);
34812920:	e1d42fbe 	ldrh	r2, [r4, #254]	; 0xfe
	host->version = sdhci_readw(host, SDHCI_HOST_VERSION);
34812924:	e5832010 	str	r2, [r3, #16]

	host->set_control_reg = &s5p_sdhci_set_control_reg;
34812928:	e59f2034 	ldr	r2, [pc, #52]	; 34812964 <s5p_sdhci_init+0x88>
	host->set_clock = set_mmc_clk;
	host->index = index;
3481292c:	e5835020 	str	r5, [r3, #32]
	host->quirks = SDHCI_QUIRK_NO_HISPD_BIT | SDHCI_QUIRK_BROKEN_VOLTAGE |
		SDHCI_QUIRK_BROKEN_R1B | SDHCI_QUIRK_32BIT_DMA_ADDR;
	host->voltages = MMC_VDD_32_33 | MMC_VDD_33_34 | MMC_VDD_165_195;
	host->version = sdhci_readw(host, SDHCI_HOST_VERSION);

	host->set_control_reg = &s5p_sdhci_set_control_reg;
34812930:	e5832024 	str	r2, [r3, #36]	; 0x24
	host->set_clock = set_mmc_clk;
34812934:	e59f202c 	ldr	r2, [pc, #44]	; 34812968 <s5p_sdhci_init+0x8c>
	host->index = index;

	host->host_caps = MMC_MODE_HC;

	add_sdhci(host, 52000000, 400000);
34812938:	e59f102c 	ldr	r1, [pc, #44]	; 3481296c <s5p_sdhci_init+0x90>
		SDHCI_QUIRK_BROKEN_R1B | SDHCI_QUIRK_32BIT_DMA_ADDR;
	host->voltages = MMC_VDD_32_33 | MMC_VDD_33_34 | MMC_VDD_165_195;
	host->version = sdhci_readw(host, SDHCI_HOST_VERSION);

	host->set_control_reg = &s5p_sdhci_set_control_reg;
	host->set_clock = set_mmc_clk;
3481293c:	e5832028 	str	r2, [r3, #40]	; 0x28
	host->index = index;

	host->host_caps = MMC_MODE_HC;
34812940:	e3a02b02 	mov	r2, #2048	; 0x800
34812944:	e583200c 	str	r2, [r3, #12]

	add_sdhci(host, 52000000, 400000);
34812948:	e59f2020 	ldr	r2, [pc, #32]	; 34812970 <s5p_sdhci_init+0x94>
3481294c:	ebffff6f 	bl	34812710 <add_sdhci>
	return 0;
34812950:	e3a00000 	mov	r0, #0
}
34812954:	e8bd8038 	pop	{r3, r4, r5, pc}
34812958:	348270f5 	.word	0x348270f5
3481295c:	3482710f 	.word	0x3482710f
34812960:	00300080 	.word	0x00300080
34812964:	34812894 	.word	0x34812894
34812968:	348018f8 	.word	0x348018f8
3481296c:	03197500 	.word	0x03197500
34812970:	00061a80 	.word	0x00061a80

34812974 <add_mtd_device>:

int add_mtd_device(struct mtd_info *mtd)
{
	int i;

	BUG_ON(mtd->writesize == 0);
34812974:	e5903014 	ldr	r3, [r0, #20]
#include <ubi_uboot.h>

struct mtd_info *mtd_table[MAX_MTD_DEVICES];

int add_mtd_device(struct mtd_info *mtd)
{
34812978:	e92d4010 	push	{r4, lr}
	int i;

	BUG_ON(mtd->writesize == 0);
3481297c:	e3530000 	cmp	r3, #0
#include <ubi_uboot.h>

struct mtd_info *mtd_table[MAX_MTD_DEVICES];

int add_mtd_device(struct mtd_info *mtd)
{
34812980:	e1a04000 	mov	r4, r0
	int i;

	BUG_ON(mtd->writesize == 0);
34812984:	1a000003 	bne	34812998 <add_mtd_device+0x24>
34812988:	e59f0044 	ldr	r0, [pc, #68]	; 348129d4 <add_mtd_device+0x60>
3481298c:	e59f1044 	ldr	r1, [pc, #68]	; 348129d8 <add_mtd_device+0x64>
34812990:	e3a02014 	mov	r2, #20
34812994:	ebffd96c 	bl	34808f4c <printf>
34812998:	e59f203c 	ldr	r2, [pc, #60]	; 348129dc <add_mtd_device+0x68>

	for (i = 0; i < MAX_MTD_DEVICES; i++)
3481299c:	e3a03000 	mov	r3, #0
		if (!mtd_table[i]) {
348129a0:	e5b20004 	ldr	r0, [r2, #4]!
348129a4:	e3500000 	cmp	r0, #0
348129a8:	1a000004 	bne	348129c0 <add_mtd_device+0x4c>
			mtd_table[i] = mtd;
348129ac:	e59f202c 	ldr	r2, [pc, #44]	; 348129e0 <add_mtd_device+0x6c>
348129b0:	e7824103 	str	r4, [r2, r3, lsl #2]
			mtd->index = i;
348129b4:	e5843024 	str	r3, [r4, #36]	; 0x24
			mtd->usecount = 0;
348129b8:	e584009c 	str	r0, [r4, #156]	; 0x9c

			/* We _know_ we aren't being removed, because
			   our caller is still holding us here. So none
			   of this try_ nonsense, and no bitching about it
			   either. :) */
			return 0;
348129bc:	e8bd8010 	pop	{r4, pc}
{
	int i;

	BUG_ON(mtd->writesize == 0);

	for (i = 0; i < MAX_MTD_DEVICES; i++)
348129c0:	e2833001 	add	r3, r3, #1
348129c4:	e3530020 	cmp	r3, #32
348129c8:	1afffff4 	bne	348129a0 <add_mtd_device+0x2c>
			   of this try_ nonsense, and no bitching about it
			   either. :) */
			return 0;
		}

	return 1;
348129cc:	e3a00001 	mov	r0, #1
}
348129d0:	e8bd8010 	pop	{r4, pc}
348129d4:	3482711d 	.word	0x3482711d
348129d8:	34827133 	.word	0x34827133
348129dc:	3482b194 	.word	0x3482b194
348129e0:	3482b198 	.word	0x3482b198

348129e4 <del_mtd_device>:
 */
int del_mtd_device(struct mtd_info *mtd)
{
	int ret;

	if (mtd_table[mtd->index] != mtd) {
348129e4:	e5901024 	ldr	r1, [r0, #36]	; 0x24
348129e8:	e59fc03c 	ldr	ip, [pc, #60]	; 34812a2c <del_mtd_device+0x48>
 *      and notify each currently active MTD 'user' of its departure.
 *      Returns zero on success or 1 on failure, which currently will happen
 *      if the requested device does not appear to be present in the list.
 */
int del_mtd_device(struct mtd_info *mtd)
{
348129ec:	e92d4008 	push	{r3, lr}
	int ret;

	if (mtd_table[mtd->index] != mtd) {
348129f0:	e79c2101 	ldr	r2, [ip, r1, lsl #2]
348129f4:	e1520000 	cmp	r2, r0
348129f8:	1a000009 	bne	34812a24 <del_mtd_device+0x40>
		ret = -ENODEV;
	} else if (mtd->usecount) {
348129fc:	e592309c 	ldr	r3, [r2, #156]	; 0x9c
34812a00:	e3530000 	cmp	r3, #0
				mtd->index, mtd->name, mtd->usecount);
		ret = -EBUSY;
	} else {
		/* No need to get a refcount on the module containing
		 * the notifier, since we hold the mtd_table_mutex */
		mtd_table[mtd->index] = NULL;
34812a04:	078c3101 	streq	r3, [ip, r1, lsl #2]

		ret = 0;
34812a08:	01a00003 	moveq	r0, r3
{
	int ret;

	if (mtd_table[mtd->index] != mtd) {
		ret = -ENODEV;
	} else if (mtd->usecount) {
34812a0c:	08bd8008 	popeq	{r3, pc}
		printk(KERN_NOTICE "Removing MTD device #%d (%s)"
34812a10:	e59f0018 	ldr	r0, [pc, #24]	; 34812a30 <del_mtd_device+0x4c>
34812a14:	e5922020 	ldr	r2, [r2, #32]
34812a18:	ebffd94b 	bl	34808f4c <printf>
				" with use count %d\n",
				mtd->index, mtd->name, mtd->usecount);
		ret = -EBUSY;
34812a1c:	e3e0000f 	mvn	r0, #15
34812a20:	e8bd8008 	pop	{r3, pc}
int del_mtd_device(struct mtd_info *mtd)
{
	int ret;

	if (mtd_table[mtd->index] != mtd) {
		ret = -ENODEV;
34812a24:	e3e00012 	mvn	r0, #18

		ret = 0;
	}

	return ret;
}
34812a28:	e8bd8008 	pop	{r3, pc}
34812a2c:	3482b198 	.word	0x3482b198
34812a30:	3482713d 	.word	0x3482713d

34812a34 <get_mtd_device>:
struct mtd_info *get_mtd_device(struct mtd_info *mtd, int num)
{
	struct mtd_info *ret = NULL;
	int i, err = -ENODEV;

	if (num == -1) {
34812a34:	e3710001 	cmn	r1, #1
 *      for a device with that address and return if it's still present. Given
 *      both, return the num'th driver only if its address matches. Return
 *      error code if not.
 */
struct mtd_info *get_mtd_device(struct mtd_info *mtd, int num)
{
34812a38:	e1a03000 	mov	r3, r0
	struct mtd_info *ret = NULL;
	int i, err = -ENODEV;

	if (num == -1) {
34812a3c:	1a000008 	bne	34812a64 <get_mtd_device+0x30>
34812a40:	e59f2060 	ldr	r2, [pc, #96]	; 34812aa8 <get_mtd_device+0x74>
 *      table, if any.  Given an address and num == -1, search the device table
 *      for a device with that address and return if it's still present. Given
 *      both, return the num'th driver only if its address matches. Return
 *      error code if not.
 */
struct mtd_info *get_mtd_device(struct mtd_info *mtd, int num)
34812a44:	e3a00000 	mov	r0, #0
34812a48:	e2821080 	add	r1, r2, #128	; 0x80
	struct mtd_info *ret = NULL;
	int i, err = -ENODEV;

	if (num == -1) {
		for (i = 0; i < MAX_MTD_DEVICES; i++)
			if (mtd_table[i] == mtd)
34812a4c:	e5b2c004 	ldr	ip, [r2, #4]!
34812a50:	e15c0003 	cmp	ip, r3
34812a54:	01a00003 	moveq	r0, r3
{
	struct mtd_info *ret = NULL;
	int i, err = -ENODEV;

	if (num == -1) {
		for (i = 0; i < MAX_MTD_DEVICES; i++)
34812a58:	e1520001 	cmp	r2, r1
34812a5c:	1afffffa 	bne	34812a4c <get_mtd_device+0x18>
34812a60:	ea000006 	b	34812a80 <get_mtd_device+0x4c>
			if (mtd_table[i] == mtd)
				ret = mtd_table[i];
	} else if (num < MAX_MTD_DEVICES) {
34812a64:	e351001f 	cmp	r1, #31
34812a68:	ca00000a 	bgt	34812a98 <get_mtd_device+0x64>
		ret = mtd_table[num];
34812a6c:	e59f2038 	ldr	r2, [pc, #56]	; 34812aac <get_mtd_device+0x78>
34812a70:	e7920101 	ldr	r0, [r2, r1, lsl #2]
		if (mtd && mtd != ret)
34812a74:	e1530000 	cmp	r3, r0
34812a78:	13530000 	cmpne	r3, #0
34812a7c:	1a000005 	bne	34812a98 <get_mtd_device+0x64>
			ret = NULL;
	}

	if (!ret)
34812a80:	e3500000 	cmp	r0, #0
		goto out_unlock;

	ret->usecount++;
34812a84:	1590309c 	ldrne	r3, [r0, #156]	; 0x9c
34812a88:	12833001 	addne	r3, r3, #1
34812a8c:	1580309c 	strne	r3, [r0, #156]	; 0x9c
		ret = mtd_table[num];
		if (mtd && mtd != ret)
			ret = NULL;
	}

	if (!ret)
34812a90:	112fff1e 	bxne	lr
34812a94:	ea000001 	b	34812aa0 <get_mtd_device+0x6c>

	ret->usecount++;
	return ret;

out_unlock:
	return ERR_PTR(err);
34812a98:	e3e00012 	mvn	r0, #18
34812a9c:	e12fff1e 	bx	lr
34812aa0:	e3e00012 	mvn	r0, #18
}
34812aa4:	e12fff1e 	bx	lr
34812aa8:	3482b194 	.word	0x3482b194
34812aac:	3482b198 	.word	0x3482b198

34812ab0 <get_mtd_device_nm>:
 *
 *      This function returns MTD device description structure in case of
 *      success and an error code in case of failure.
 */
struct mtd_info *get_mtd_device_nm(const char *name)
{
34812ab0:	e92d4070 	push	{r4, r5, r6, lr}

	mtd->usecount++;
	return mtd;

out_unlock:
	return ERR_PTR(err);
34812ab4:	e59f5060 	ldr	r5, [pc, #96]	; 34812b1c <get_mtd_device_nm+0x6c>
 *
 *      This function returns MTD device description structure in case of
 *      success and an error code in case of failure.
 */
struct mtd_info *get_mtd_device_nm(const char *name)
{
34812ab8:	e1a06000 	mov	r6, r0
	int i, err = -ENODEV;
	struct mtd_info *mtd = NULL;

	for (i = 0; i < MAX_MTD_DEVICES; i++) {
34812abc:	e3a04000 	mov	r4, #0
		if (mtd_table[i] && !strcmp(name, mtd_table[i]->name)) {
34812ac0:	e5b53004 	ldr	r3, [r5, #4]!
34812ac4:	e3530000 	cmp	r3, #0
34812ac8:	0a00000c 	beq	34812b00 <get_mtd_device_nm+0x50>
34812acc:	e1a00006 	mov	r0, r6
34812ad0:	e5931020 	ldr	r1, [r3, #32]
34812ad4:	eb0017f5 	bl	34818ab0 <strcmp>
34812ad8:	e3500000 	cmp	r0, #0
34812adc:	1a000007 	bne	34812b00 <get_mtd_device_nm+0x50>
			mtd = mtd_table[i];
34812ae0:	e59f3038 	ldr	r3, [pc, #56]	; 34812b20 <get_mtd_device_nm+0x70>
34812ae4:	e7930104 	ldr	r0, [r3, r4, lsl #2]
			break;
		}
	}

	if (!mtd)
34812ae8:	e3500000 	cmp	r0, #0
		goto out_unlock;

	mtd->usecount++;
34812aec:	1590309c 	ldrne	r3, [r0, #156]	; 0x9c
34812af0:	12833001 	addne	r3, r3, #1
34812af4:	1580309c 	strne	r3, [r0, #156]	; 0x9c
			mtd = mtd_table[i];
			break;
		}
	}

	if (!mtd)
34812af8:	18bd8070 	popne	{r4, r5, r6, pc}
34812afc:	ea000004 	b	34812b14 <get_mtd_device_nm+0x64>
struct mtd_info *get_mtd_device_nm(const char *name)
{
	int i, err = -ENODEV;
	struct mtd_info *mtd = NULL;

	for (i = 0; i < MAX_MTD_DEVICES; i++) {
34812b00:	e2844001 	add	r4, r4, #1
34812b04:	e3540020 	cmp	r4, #32
34812b08:	1affffec 	bne	34812ac0 <get_mtd_device_nm+0x10>

	mtd->usecount++;
	return mtd;

out_unlock:
	return ERR_PTR(err);
34812b0c:	e3e00012 	mvn	r0, #18
34812b10:	e8bd8070 	pop	{r4, r5, r6, pc}
34812b14:	e3e00012 	mvn	r0, #18
}
34812b18:	e8bd8070 	pop	{r4, r5, r6, pc}
34812b1c:	3482b194 	.word	0x3482b194
34812b20:	3482b198 	.word	0x3482b198

34812b24 <put_mtd_device>:

void put_mtd_device(struct mtd_info *mtd)
{
	int c;

	c = --mtd->usecount;
34812b24:	e590309c 	ldr	r3, [r0, #156]	; 0x9c
34812b28:	e2433001 	sub	r3, r3, #1
	BUG_ON(c < 0);
34812b2c:	e3530000 	cmp	r3, #0

void put_mtd_device(struct mtd_info *mtd)
{
	int c;

	c = --mtd->usecount;
34812b30:	e580309c 	str	r3, [r0, #156]	; 0x9c
	BUG_ON(c < 0);
34812b34:	a12fff1e 	bxge	lr
34812b38:	e59f0008 	ldr	r0, [pc, #8]	; 34812b48 <put_mtd_device+0x24>
34812b3c:	e59f1008 	ldr	r1, [pc, #8]	; 34812b4c <put_mtd_device+0x28>
34812b40:	e3a0208f 	mov	r2, #143	; 0x8f
34812b44:	eaffd900 	b	34808f4c <printf>
34812b48:	3482711d 	.word	0x3482711d
34812b4c:	34827133 	.word	0x34827133

34812b50 <part_read_user_prot_reg>:
	return res;
}

static int part_read_user_prot_reg(struct mtd_info *mtd, loff_t from,
		size_t len, size_t *retlen, u_char *buf)
{
34812b50:	e92d401f 	push	{r0, r1, r2, r3, r4, lr}
	struct mtd_part *part = PART(mtd);
	return part->master->read_user_prot_reg(part->master, from,
34812b54:	e59d1018 	ldr	r1, [sp, #24]
34812b58:	e59000a8 	ldr	r0, [r0, #168]	; 0xa8
34812b5c:	e58d1000 	str	r1, [sp]
34812b60:	e59d101c 	ldr	r1, [sp, #28]
34812b64:	e58d1004 	str	r1, [sp, #4]
34812b68:	e59d1020 	ldr	r1, [sp, #32]
34812b6c:	e58d1008 	str	r1, [sp, #8]
34812b70:	e5901060 	ldr	r1, [r0, #96]	; 0x60
34812b74:	e12fff31 	blx	r1
					len, retlen, buf);
}
34812b78:	e28dd014 	add	sp, sp, #20
34812b7c:	e8bd8000 	pop	{pc}

34812b80 <part_get_user_prot_info>:

static int part_get_user_prot_info(struct mtd_info *mtd,
		struct otp_info *buf, size_t len)
{
	struct mtd_part *part = PART(mtd);
	return part->master->get_user_prot_info(part->master, buf, len);
34812b80:	e59000a8 	ldr	r0, [r0, #168]	; 0xa8
					len, retlen, buf);
}

static int part_get_user_prot_info(struct mtd_info *mtd,
		struct otp_info *buf, size_t len)
{
34812b84:	e92d4008 	push	{r3, lr}
	struct mtd_part *part = PART(mtd);
	return part->master->get_user_prot_info(part->master, buf, len);
34812b88:	e590305c 	ldr	r3, [r0, #92]	; 0x5c
34812b8c:	e12fff33 	blx	r3
}
34812b90:	e8bd8008 	pop	{r3, pc}

34812b94 <part_read_fact_prot_reg>:

static int part_read_fact_prot_reg(struct mtd_info *mtd, loff_t from,
		size_t len, size_t *retlen, u_char *buf)
{
34812b94:	e92d401f 	push	{r0, r1, r2, r3, r4, lr}
	struct mtd_part *part = PART(mtd);
	return part->master->read_fact_prot_reg(part->master, from,
34812b98:	e59d1018 	ldr	r1, [sp, #24]
34812b9c:	e59000a8 	ldr	r0, [r0, #168]	; 0xa8
34812ba0:	e58d1000 	str	r1, [sp]
34812ba4:	e59d101c 	ldr	r1, [sp, #28]
34812ba8:	e58d1004 	str	r1, [sp, #4]
34812bac:	e59d1020 	ldr	r1, [sp, #32]
34812bb0:	e58d1008 	str	r1, [sp, #8]
34812bb4:	e5901058 	ldr	r1, [r0, #88]	; 0x58
34812bb8:	e12fff31 	blx	r1
					len, retlen, buf);
}
34812bbc:	e28dd014 	add	sp, sp, #20
34812bc0:	e8bd8000 	pop	{pc}

34812bc4 <part_get_fact_prot_info>:

static int part_get_fact_prot_info(struct mtd_info *mtd, struct otp_info *buf,
		size_t len)
{
	struct mtd_part *part = PART(mtd);
	return part->master->get_fact_prot_info(part->master, buf, len);
34812bc4:	e59000a8 	ldr	r0, [r0, #168]	; 0xa8
					len, retlen, buf);
}

static int part_get_fact_prot_info(struct mtd_info *mtd, struct otp_info *buf,
		size_t len)
{
34812bc8:	e92d4008 	push	{r3, lr}
	struct mtd_part *part = PART(mtd);
	return part->master->get_fact_prot_info(part->master, buf, len);
34812bcc:	e5903054 	ldr	r3, [r0, #84]	; 0x54
34812bd0:	e12fff33 	blx	r3
}
34812bd4:	e8bd8008 	pop	{r3, pc}

34812bd8 <part_write>:

static int part_write(struct mtd_info *mtd, loff_t to, size_t len,
		size_t *retlen, const u_char *buf)
{
34812bd8:	e92d4030 	push	{r4, r5, lr}
34812bdc:	e1a01000 	mov	r1, r0
	struct mtd_part *part = PART(mtd);
	if (!(mtd->flags & MTD_WRITEABLE))
34812be0:	e5900004 	ldr	r0, [r0, #4]
	return part->master->get_fact_prot_info(part->master, buf, len);
}

static int part_write(struct mtd_info *mtd, loff_t to, size_t len,
		size_t *retlen, const u_char *buf)
{
34812be4:	e24dd014 	sub	sp, sp, #20
	struct mtd_part *part = PART(mtd);
	if (!(mtd->flags & MTD_WRITEABLE))
34812be8:	e3100b01 	tst	r0, #1024	; 0x400
	return part->master->get_fact_prot_info(part->master, buf, len);
}

static int part_write(struct mtd_info *mtd, loff_t to, size_t len,
		size_t *retlen, const u_char *buf)
{
34812bec:	e59dc020 	ldr	ip, [sp, #32]
	struct mtd_part *part = PART(mtd);
	if (!(mtd->flags & MTD_WRITEABLE))
		return -EROFS;
34812bf0:	03e0001d 	mvneq	r0, #29

static int part_write(struct mtd_info *mtd, loff_t to, size_t len,
		size_t *retlen, const u_char *buf)
{
	struct mtd_part *part = PART(mtd);
	if (!(mtd->flags & MTD_WRITEABLE))
34812bf4:	0a00001b 	beq	34812c68 <part_write+0x90>
		return -EROFS;
	if (to >= mtd->size)
34812bf8:	e591e00c 	ldr	lr, [r1, #12]
34812bfc:	e5910008 	ldr	r0, [r1, #8]
34812c00:	e15e0003 	cmp	lr, r3
34812c04:	8a000002 	bhi	34812c14 <part_write+0x3c>
34812c08:	1a00000a 	bne	34812c38 <part_write+0x60>
34812c0c:	e1500002 	cmp	r0, r2
34812c10:	9a000008 	bls	34812c38 <part_write+0x60>
		len = 0;
	else if (to + len > mtd->size)
34812c14:	e092400c 	adds	r4, r2, ip
34812c18:	e2a35000 	adc	r5, r3, #0
34812c1c:	e155000e 	cmp	r5, lr
34812c20:	8a000002 	bhi	34812c30 <part_write+0x58>
34812c24:	1a000004 	bne	34812c3c <part_write+0x64>
34812c28:	e1540000 	cmp	r4, r0
34812c2c:	9a000002 	bls	34812c3c <part_write+0x64>
		len = mtd->size - to;
34812c30:	e062c000 	rsb	ip, r2, r0
34812c34:	ea000000 	b	34812c3c <part_write+0x64>
{
	struct mtd_part *part = PART(mtd);
	if (!(mtd->flags & MTD_WRITEABLE))
		return -EROFS;
	if (to >= mtd->size)
		len = 0;
34812c38:	e3a0c000 	mov	ip, #0
	else if (to + len > mtd->size)
		len = mtd->size - to;
	return part->master->write(part->master, to + part->offset,
34812c3c:	e1c14bd0 	ldrd	r4, [r1, #176]	; 0xb0
34812c40:	e59100a8 	ldr	r0, [r1, #168]	; 0xa8
34812c44:	e59d1024 	ldr	r1, [sp, #36]	; 0x24
34812c48:	e58dc000 	str	ip, [sp]
34812c4c:	e58d1004 	str	r1, [sp, #4]
34812c50:	e59d1028 	ldr	r1, [sp, #40]	; 0x28
34812c54:	e0922004 	adds	r2, r2, r4
34812c58:	e58d1008 	str	r1, [sp, #8]
34812c5c:	e5901044 	ldr	r1, [r0, #68]	; 0x44
34812c60:	e0a33005 	adc	r3, r3, r5
34812c64:	e12fff31 	blx	r1
				    len, retlen, buf);
}
34812c68:	e28dd014 	add	sp, sp, #20
34812c6c:	e8bd8030 	pop	{r4, r5, pc}

34812c70 <part_panic_write>:

static int part_panic_write(struct mtd_info *mtd, loff_t to, size_t len,
		size_t *retlen, const u_char *buf)
{
34812c70:	e92d4030 	push	{r4, r5, lr}
34812c74:	e1a01000 	mov	r1, r0
	struct mtd_part *part = PART(mtd);
	if (!(mtd->flags & MTD_WRITEABLE))
34812c78:	e5900004 	ldr	r0, [r0, #4]
				    len, retlen, buf);
}

static int part_panic_write(struct mtd_info *mtd, loff_t to, size_t len,
		size_t *retlen, const u_char *buf)
{
34812c7c:	e24dd014 	sub	sp, sp, #20
	struct mtd_part *part = PART(mtd);
	if (!(mtd->flags & MTD_WRITEABLE))
34812c80:	e3100b01 	tst	r0, #1024	; 0x400
				    len, retlen, buf);
}

static int part_panic_write(struct mtd_info *mtd, loff_t to, size_t len,
		size_t *retlen, const u_char *buf)
{
34812c84:	e59dc020 	ldr	ip, [sp, #32]
	struct mtd_part *part = PART(mtd);
	if (!(mtd->flags & MTD_WRITEABLE))
		return -EROFS;
34812c88:	03e0001d 	mvneq	r0, #29

static int part_panic_write(struct mtd_info *mtd, loff_t to, size_t len,
		size_t *retlen, const u_char *buf)
{
	struct mtd_part *part = PART(mtd);
	if (!(mtd->flags & MTD_WRITEABLE))
34812c8c:	0a00001b 	beq	34812d00 <part_panic_write+0x90>
		return -EROFS;
	if (to >= mtd->size)
34812c90:	e591e00c 	ldr	lr, [r1, #12]
34812c94:	e5910008 	ldr	r0, [r1, #8]
34812c98:	e15e0003 	cmp	lr, r3
34812c9c:	8a000002 	bhi	34812cac <part_panic_write+0x3c>
34812ca0:	1a00000a 	bne	34812cd0 <part_panic_write+0x60>
34812ca4:	e1500002 	cmp	r0, r2
34812ca8:	9a000008 	bls	34812cd0 <part_panic_write+0x60>
		len = 0;
	else if (to + len > mtd->size)
34812cac:	e092400c 	adds	r4, r2, ip
34812cb0:	e2a35000 	adc	r5, r3, #0
34812cb4:	e155000e 	cmp	r5, lr
34812cb8:	8a000002 	bhi	34812cc8 <part_panic_write+0x58>
34812cbc:	1a000004 	bne	34812cd4 <part_panic_write+0x64>
34812cc0:	e1540000 	cmp	r4, r0
34812cc4:	9a000002 	bls	34812cd4 <part_panic_write+0x64>
		len = mtd->size - to;
34812cc8:	e062c000 	rsb	ip, r2, r0
34812ccc:	ea000000 	b	34812cd4 <part_panic_write+0x64>
{
	struct mtd_part *part = PART(mtd);
	if (!(mtd->flags & MTD_WRITEABLE))
		return -EROFS;
	if (to >= mtd->size)
		len = 0;
34812cd0:	e3a0c000 	mov	ip, #0
	else if (to + len > mtd->size)
		len = mtd->size - to;
	return part->master->panic_write(part->master, to + part->offset,
34812cd4:	e1c14bd0 	ldrd	r4, [r1, #176]	; 0xb0
34812cd8:	e59100a8 	ldr	r0, [r1, #168]	; 0xa8
34812cdc:	e59d1024 	ldr	r1, [sp, #36]	; 0x24
34812ce0:	e58dc000 	str	ip, [sp]
34812ce4:	e58d1004 	str	r1, [sp, #4]
34812ce8:	e59d1028 	ldr	r1, [sp, #40]	; 0x28
34812cec:	e0922004 	adds	r2, r2, r4
34812cf0:	e58d1008 	str	r1, [sp, #8]
34812cf4:	e5901048 	ldr	r1, [r0, #72]	; 0x48
34812cf8:	e0a33005 	adc	r3, r3, r5
34812cfc:	e12fff31 	blx	r1
				    len, retlen, buf);
}
34812d00:	e28dd014 	add	sp, sp, #20
34812d04:	e8bd8030 	pop	{r4, r5, pc}

34812d08 <part_write_oob>:

static int part_write_oob(struct mtd_info *mtd, loff_t to,
		struct mtd_oob_ops *ops)
{
34812d08:	e92d40f7 	push	{r0, r1, r2, r4, r5, r6, r7, lr}
34812d0c:	e1a01000 	mov	r1, r0
	struct mtd_part *part = PART(mtd);

	if (!(mtd->flags & MTD_WRITEABLE))
34812d10:	e5900004 	ldr	r0, [r0, #4]
				    len, retlen, buf);
}

static int part_write_oob(struct mtd_info *mtd, loff_t to,
		struct mtd_oob_ops *ops)
{
34812d14:	e59dc020 	ldr	ip, [sp, #32]
	struct mtd_part *part = PART(mtd);

	if (!(mtd->flags & MTD_WRITEABLE))
34812d18:	e3100b01 	tst	r0, #1024	; 0x400
		return -EROFS;
34812d1c:	03e0001d 	mvneq	r0, #29
static int part_write_oob(struct mtd_info *mtd, loff_t to,
		struct mtd_oob_ops *ops)
{
	struct mtd_part *part = PART(mtd);

	if (!(mtd->flags & MTD_WRITEABLE))
34812d20:	0a00001a 	beq	34812d90 <part_write_oob+0x88>
		return -EROFS;

	if (to >= mtd->size)
34812d24:	e591600c 	ldr	r6, [r1, #12]
34812d28:	e5910008 	ldr	r0, [r1, #8]
34812d2c:	e1560003 	cmp	r6, r3
34812d30:	8a000002 	bhi	34812d40 <part_write_oob+0x38>
34812d34:	1a000014 	bne	34812d8c <part_write_oob+0x84>
34812d38:	e1500002 	cmp	r0, r2
34812d3c:	9a000012 	bls	34812d8c <part_write_oob+0x84>
		return -EINVAL;
	if (ops->datbuf && to + ops->len > mtd->size)
34812d40:	e59c4018 	ldr	r4, [ip, #24]
34812d44:	e3540000 	cmp	r4, #0
34812d48:	0a000007 	beq	34812d6c <part_write_oob+0x64>
34812d4c:	e59c7004 	ldr	r7, [ip, #4]
34812d50:	e0924007 	adds	r4, r2, r7
34812d54:	e2a35000 	adc	r5, r3, #0
34812d58:	e1550006 	cmp	r5, r6
34812d5c:	8a00000a 	bhi	34812d8c <part_write_oob+0x84>
34812d60:	1a000001 	bne	34812d6c <part_write_oob+0x64>
34812d64:	e1540000 	cmp	r4, r0
34812d68:	8a000007 	bhi	34812d8c <part_write_oob+0x84>
		return -EINVAL;
	return part->master->write_oob(part->master, to + part->offset, ops);
34812d6c:	e59100a8 	ldr	r0, [r1, #168]	; 0xa8
34812d70:	e1c14bd0 	ldrd	r4, [r1, #176]	; 0xb0
34812d74:	e58dc000 	str	ip, [sp]
34812d78:	e0922004 	adds	r2, r2, r4
34812d7c:	e5901050 	ldr	r1, [r0, #80]	; 0x50
34812d80:	e0a33005 	adc	r3, r3, r5
34812d84:	e12fff31 	blx	r1
34812d88:	ea000000 	b	34812d90 <part_write_oob+0x88>
		return -EROFS;

	if (to >= mtd->size)
		return -EINVAL;
	if (ops->datbuf && to + ops->len > mtd->size)
		return -EINVAL;
34812d8c:	e3e00015 	mvn	r0, #21
	return part->master->write_oob(part->master, to + part->offset, ops);
}
34812d90:	e8bd80fe 	pop	{r1, r2, r3, r4, r5, r6, r7, pc}

34812d94 <part_write_user_prot_reg>:

static int part_write_user_prot_reg(struct mtd_info *mtd, loff_t from,
		size_t len, size_t *retlen, u_char *buf)
{
34812d94:	e92d401f 	push	{r0, r1, r2, r3, r4, lr}
	struct mtd_part *part = PART(mtd);
	return part->master->write_user_prot_reg(part->master, from,
34812d98:	e59d1018 	ldr	r1, [sp, #24]
34812d9c:	e59000a8 	ldr	r0, [r0, #168]	; 0xa8
34812da0:	e58d1000 	str	r1, [sp]
34812da4:	e59d101c 	ldr	r1, [sp, #28]
34812da8:	e58d1004 	str	r1, [sp, #4]
34812dac:	e59d1020 	ldr	r1, [sp, #32]
34812db0:	e58d1008 	str	r1, [sp, #8]
34812db4:	e5901064 	ldr	r1, [r0, #100]	; 0x64
34812db8:	e12fff31 	blx	r1
					len, retlen, buf);
}
34812dbc:	e28dd014 	add	sp, sp, #20
34812dc0:	e8bd8000 	pop	{pc}

34812dc4 <part_lock_user_prot_reg>:

static int part_lock_user_prot_reg(struct mtd_info *mtd, loff_t from,
		size_t len)
{
34812dc4:	e92d4007 	push	{r0, r1, r2, lr}
	struct mtd_part *part = PART(mtd);
	return part->master->lock_user_prot_reg(part->master, from, len);
34812dc8:	e59d1010 	ldr	r1, [sp, #16]
34812dcc:	e59000a8 	ldr	r0, [r0, #168]	; 0xa8
34812dd0:	e58d1000 	str	r1, [sp]
34812dd4:	e5901068 	ldr	r1, [r0, #104]	; 0x68
34812dd8:	e12fff31 	blx	r1
}
34812ddc:	e8bd800e 	pop	{r1, r2, r3, pc}

34812de0 <part_erase>:

static int part_erase(struct mtd_info *mtd, struct erase_info *instr)
{
34812de0:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
	struct mtd_part *part = PART(mtd);
	int ret;
	if (!(mtd->flags & MTD_WRITEABLE))
34812de4:	e5903004 	ldr	r3, [r0, #4]
	struct mtd_part *part = PART(mtd);
	return part->master->lock_user_prot_reg(part->master, from, len);
}

static int part_erase(struct mtd_info *mtd, struct erase_info *instr)
{
34812de8:	e1a07000 	mov	r7, r0
	struct mtd_part *part = PART(mtd);
	int ret;
	if (!(mtd->flags & MTD_WRITEABLE))
34812dec:	e3130b01 	tst	r3, #1024	; 0x400
	struct mtd_part *part = PART(mtd);
	return part->master->lock_user_prot_reg(part->master, from, len);
}

static int part_erase(struct mtd_info *mtd, struct erase_info *instr)
{
34812df0:	e1a06001 	mov	r6, r1
	struct mtd_part *part = PART(mtd);
	int ret;
	if (!(mtd->flags & MTD_WRITEABLE))
		return -EROFS;
34812df4:	03e0001d 	mvneq	r0, #29

static int part_erase(struct mtd_info *mtd, struct erase_info *instr)
{
	struct mtd_part *part = PART(mtd);
	int ret;
	if (!(mtd->flags & MTD_WRITEABLE))
34812df8:	08bd80f8 	popeq	{r3, r4, r5, r6, r7, pc}
		return -EROFS;
	if (instr->addr >= mtd->size)
34812dfc:	e1c120d8 	ldrd	r2, [r1, #8]
34812e00:	e597100c 	ldr	r1, [r7, #12]
34812e04:	e1510003 	cmp	r1, r3
34812e08:	8a000003 	bhi	34812e1c <part_erase+0x3c>
34812e0c:	1a00001b 	bne	34812e80 <part_erase+0xa0>
34812e10:	e5971008 	ldr	r1, [r7, #8]
34812e14:	e1510002 	cmp	r1, r2
34812e18:	9a000018 	bls	34812e80 <part_erase+0xa0>
		return -EINVAL;
	instr->addr += part->offset;
34812e1c:	e1c70bd0 	ldrd	r0, [r7, #176]	; 0xb0
34812e20:	e0900002 	adds	r0, r0, r2
34812e24:	e0a11003 	adc	r1, r1, r3
34812e28:	e1c600f8 	strd	r0, [r6, #8]
	ret = part->master->erase(part->master, instr);
34812e2c:	e59700a8 	ldr	r0, [r7, #168]	; 0xa8
34812e30:	e1a01006 	mov	r1, r6
34812e34:	e5903034 	ldr	r3, [r0, #52]	; 0x34
34812e38:	e12fff33 	blx	r3
	if (ret) {
34812e3c:	e3500000 	cmp	r0, #0
34812e40:	08bd80f8 	popeq	{r3, r4, r5, r6, r7, pc}
		if (instr->fail_addr != MTD_FAIL_ADDR_UNKNOWN)
34812e44:	e1c621d8 	ldrd	r2, [r6, #24]
34812e48:	e3720001 	cmn	r2, #1
34812e4c:	1a000001 	bne	34812e58 <part_erase+0x78>
34812e50:	e3730001 	cmn	r3, #1
34812e54:	0a000003 	beq	34812e68 <part_erase+0x88>
			instr->fail_addr -= part->offset;
34812e58:	e1c74bd0 	ldrd	r4, [r7, #176]	; 0xb0
34812e5c:	e0522004 	subs	r2, r2, r4
34812e60:	e0c33005 	sbc	r3, r3, r5
34812e64:	e1c621f8 	strd	r2, [r6, #24]
		instr->addr -= part->offset;
34812e68:	e1c620d8 	ldrd	r2, [r6, #8]
34812e6c:	e1c74bd0 	ldrd	r4, [r7, #176]	; 0xb0
34812e70:	e0522004 	subs	r2, r2, r4
34812e74:	e0c33005 	sbc	r3, r3, r5
34812e78:	e1c620f8 	strd	r2, [r6, #8]
34812e7c:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
	struct mtd_part *part = PART(mtd);
	int ret;
	if (!(mtd->flags & MTD_WRITEABLE))
		return -EROFS;
	if (instr->addr >= mtd->size)
		return -EINVAL;
34812e80:	e3e00015 	mvn	r0, #21
		if (instr->fail_addr != MTD_FAIL_ADDR_UNKNOWN)
			instr->fail_addr -= part->offset;
		instr->addr -= part->offset;
	}
	return ret;
}
34812e84:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}

34812e88 <part_lock>:
	if (instr->callback)
		instr->callback(instr);
}

static int part_lock(struct mtd_info *mtd, loff_t ofs, uint64_t len)
{
34812e88:	e92d40f7 	push	{r0, r1, r2, r4, r5, r6, r7, lr}
34812e8c:	e1cd62d0 	ldrd	r6, [sp, #32]
	struct mtd_part *part = PART(mtd);
	if ((len + ofs) > mtd->size)
34812e90:	e1a04002 	mov	r4, r2
34812e94:	e0962004 	adds	r2, r6, r4
	if (instr->callback)
		instr->callback(instr);
}

static int part_lock(struct mtd_info *mtd, loff_t ofs, uint64_t len)
{
34812e98:	e1a01000 	mov	r1, r0
	struct mtd_part *part = PART(mtd);
	if ((len + ofs) > mtd->size)
34812e9c:	e1a05003 	mov	r5, r3
34812ea0:	e590000c 	ldr	r0, [r0, #12]
34812ea4:	e0a73005 	adc	r3, r7, r5
34812ea8:	e1500003 	cmp	r0, r3
34812eac:	3a00000b 	bcc	34812ee0 <part_lock+0x58>
34812eb0:	1a000002 	bne	34812ec0 <part_lock+0x38>
34812eb4:	e5910008 	ldr	r0, [r1, #8]
34812eb8:	e1500002 	cmp	r0, r2
34812ebc:	3a000007 	bcc	34812ee0 <part_lock+0x58>
		return -EINVAL;
	return part->master->lock(part->master, ofs + part->offset, len);
34812ec0:	e1c12bd0 	ldrd	r2, [r1, #176]	; 0xb0
34812ec4:	e59100a8 	ldr	r0, [r1, #168]	; 0xa8
34812ec8:	e1cd60f0 	strd	r6, [sp]
34812ecc:	e0922004 	adds	r2, r2, r4
34812ed0:	e5901070 	ldr	r1, [r0, #112]	; 0x70
34812ed4:	e0a33005 	adc	r3, r3, r5
34812ed8:	e12fff31 	blx	r1
34812edc:	ea000000 	b	34812ee4 <part_lock+0x5c>

static int part_lock(struct mtd_info *mtd, loff_t ofs, uint64_t len)
{
	struct mtd_part *part = PART(mtd);
	if ((len + ofs) > mtd->size)
		return -EINVAL;
34812ee0:	e3e00015 	mvn	r0, #21
	return part->master->lock(part->master, ofs + part->offset, len);
}
34812ee4:	e8bd80fe 	pop	{r1, r2, r3, r4, r5, r6, r7, pc}

34812ee8 <part_unlock>:

static int part_unlock(struct mtd_info *mtd, loff_t ofs, uint64_t len)
{
34812ee8:	e92d40f7 	push	{r0, r1, r2, r4, r5, r6, r7, lr}
34812eec:	e1cd62d0 	ldrd	r6, [sp, #32]
	struct mtd_part *part = PART(mtd);
	if ((len + ofs) > mtd->size)
34812ef0:	e1a04002 	mov	r4, r2
34812ef4:	e0962004 	adds	r2, r6, r4
		return -EINVAL;
	return part->master->lock(part->master, ofs + part->offset, len);
}

static int part_unlock(struct mtd_info *mtd, loff_t ofs, uint64_t len)
{
34812ef8:	e1a01000 	mov	r1, r0
	struct mtd_part *part = PART(mtd);
	if ((len + ofs) > mtd->size)
34812efc:	e1a05003 	mov	r5, r3
34812f00:	e590000c 	ldr	r0, [r0, #12]
34812f04:	e0a73005 	adc	r3, r7, r5
34812f08:	e1500003 	cmp	r0, r3
34812f0c:	3a00000b 	bcc	34812f40 <part_unlock+0x58>
34812f10:	1a000002 	bne	34812f20 <part_unlock+0x38>
34812f14:	e5910008 	ldr	r0, [r1, #8]
34812f18:	e1500002 	cmp	r0, r2
34812f1c:	3a000007 	bcc	34812f40 <part_unlock+0x58>
		return -EINVAL;
	return part->master->unlock(part->master, ofs + part->offset, len);
34812f20:	e1c12bd0 	ldrd	r2, [r1, #176]	; 0xb0
34812f24:	e59100a8 	ldr	r0, [r1, #168]	; 0xa8
34812f28:	e1cd60f0 	strd	r6, [sp]
34812f2c:	e0922004 	adds	r2, r2, r4
34812f30:	e5901074 	ldr	r1, [r0, #116]	; 0x74
34812f34:	e0a33005 	adc	r3, r3, r5
34812f38:	e12fff31 	blx	r1
34812f3c:	ea000000 	b	34812f44 <part_unlock+0x5c>

static int part_unlock(struct mtd_info *mtd, loff_t ofs, uint64_t len)
{
	struct mtd_part *part = PART(mtd);
	if ((len + ofs) > mtd->size)
		return -EINVAL;
34812f40:	e3e00015 	mvn	r0, #21
	return part->master->unlock(part->master, ofs + part->offset, len);
}
34812f44:	e8bd80fe 	pop	{r1, r2, r3, r4, r5, r6, r7, pc}

34812f48 <part_sync>:

static void part_sync(struct mtd_info *mtd)
{
	struct mtd_part *part = PART(mtd);
	part->master->sync(part->master);
34812f48:	e59000a8 	ldr	r0, [r0, #168]	; 0xa8
		return -EINVAL;
	return part->master->unlock(part->master, ofs + part->offset, len);
}

static void part_sync(struct mtd_info *mtd)
{
34812f4c:	e92d4008 	push	{r3, lr}
	struct mtd_part *part = PART(mtd);
	part->master->sync(part->master);
34812f50:	e590306c 	ldr	r3, [r0, #108]	; 0x6c
34812f54:	e12fff33 	blx	r3
}
34812f58:	e8bd8008 	pop	{r3, pc}

34812f5c <part_block_isbad>:

static int part_block_isbad(struct mtd_info *mtd, loff_t ofs)
{
34812f5c:	e92d4038 	push	{r3, r4, r5, lr}
	struct mtd_part *part = PART(mtd);
	if (ofs >= mtd->size)
34812f60:	e1a05003 	mov	r5, r3
34812f64:	e590300c 	ldr	r3, [r0, #12]
	struct mtd_part *part = PART(mtd);
	part->master->sync(part->master);
}

static int part_block_isbad(struct mtd_info *mtd, loff_t ofs)
{
34812f68:	e1a01000 	mov	r1, r0
	struct mtd_part *part = PART(mtd);
	if (ofs >= mtd->size)
34812f6c:	e1530005 	cmp	r3, r5
34812f70:	e1a04002 	mov	r4, r2
34812f74:	8a000003 	bhi	34812f88 <part_block_isbad+0x2c>
34812f78:	1a000009 	bne	34812fa4 <part_block_isbad+0x48>
34812f7c:	e5903008 	ldr	r3, [r0, #8]
34812f80:	e1530002 	cmp	r3, r2
34812f84:	9a000006 	bls	34812fa4 <part_block_isbad+0x48>
		return -EINVAL;
	ofs += part->offset;
	return part->master->block_isbad(part->master, ofs);
34812f88:	e59100a8 	ldr	r0, [r1, #168]	; 0xa8
static int part_block_isbad(struct mtd_info *mtd, loff_t ofs)
{
	struct mtd_part *part = PART(mtd);
	if (ofs >= mtd->size)
		return -EINVAL;
	ofs += part->offset;
34812f8c:	e1c12bd0 	ldrd	r2, [r1, #176]	; 0xb0
	return part->master->block_isbad(part->master, ofs);
34812f90:	e0922004 	adds	r2, r2, r4
34812f94:	e5901078 	ldr	r1, [r0, #120]	; 0x78
34812f98:	e0a33005 	adc	r3, r3, r5
34812f9c:	e12fff31 	blx	r1
34812fa0:	e8bd8038 	pop	{r3, r4, r5, pc}

static int part_block_isbad(struct mtd_info *mtd, loff_t ofs)
{
	struct mtd_part *part = PART(mtd);
	if (ofs >= mtd->size)
		return -EINVAL;
34812fa4:	e3e00015 	mvn	r0, #21
	ofs += part->offset;
	return part->master->block_isbad(part->master, ofs);
}
34812fa8:	e8bd8038 	pop	{r3, r4, r5, pc}

34812fac <part_block_markbad>:
static int part_block_markbad(struct mtd_info *mtd, loff_t ofs)
{
	struct mtd_part *part = PART(mtd);
	int res;

	if (!(mtd->flags & MTD_WRITEABLE))
34812fac:	e5901004 	ldr	r1, [r0, #4]
	ofs += part->offset;
	return part->master->block_isbad(part->master, ofs);
}

static int part_block_markbad(struct mtd_info *mtd, loff_t ofs)
{
34812fb0:	e92d4070 	push	{r4, r5, r6, lr}
	struct mtd_part *part = PART(mtd);
	int res;

	if (!(mtd->flags & MTD_WRITEABLE))
34812fb4:	e3110b01 	tst	r1, #1024	; 0x400
	ofs += part->offset;
	return part->master->block_isbad(part->master, ofs);
}

static int part_block_markbad(struct mtd_info *mtd, loff_t ofs)
{
34812fb8:	e1a06000 	mov	r6, r0
	struct mtd_part *part = PART(mtd);
	int res;

	if (!(mtd->flags & MTD_WRITEABLE))
		return -EROFS;
34812fbc:	03e0001d 	mvneq	r0, #29
static int part_block_markbad(struct mtd_info *mtd, loff_t ofs)
{
	struct mtd_part *part = PART(mtd);
	int res;

	if (!(mtd->flags & MTD_WRITEABLE))
34812fc0:	08bd8070 	popeq	{r4, r5, r6, pc}
		return -EROFS;
	if (ofs >= mtd->size)
34812fc4:	e1a05003 	mov	r5, r3
34812fc8:	e596300c 	ldr	r3, [r6, #12]
34812fcc:	e1a04002 	mov	r4, r2
34812fd0:	e1530005 	cmp	r3, r5
34812fd4:	8a000003 	bhi	34812fe8 <part_block_markbad+0x3c>
34812fd8:	1a00000d 	bne	34813014 <part_block_markbad+0x68>
34812fdc:	e5963008 	ldr	r3, [r6, #8]
34812fe0:	e1530002 	cmp	r3, r2
34812fe4:	9a00000a 	bls	34813014 <part_block_markbad+0x68>
		return -EINVAL;
	ofs += part->offset;
	res = part->master->block_markbad(part->master, ofs);
34812fe8:	e59600a8 	ldr	r0, [r6, #168]	; 0xa8

	if (!(mtd->flags & MTD_WRITEABLE))
		return -EROFS;
	if (ofs >= mtd->size)
		return -EINVAL;
	ofs += part->offset;
34812fec:	e1c62bd0 	ldrd	r2, [r6, #176]	; 0xb0
	res = part->master->block_markbad(part->master, ofs);
34812ff0:	e0922004 	adds	r2, r2, r4
34812ff4:	e0a33005 	adc	r3, r3, r5
34812ff8:	e590107c 	ldr	r1, [r0, #124]	; 0x7c
34812ffc:	e12fff31 	blx	r1
	if (!res)
34813000:	e3500000 	cmp	r0, #0
		mtd->ecc_stats.badblocks++;
34813004:	05963088 	ldreq	r3, [r6, #136]	; 0x88
34813008:	02833001 	addeq	r3, r3, #1
3481300c:	05863088 	streq	r3, [r6, #136]	; 0x88
34813010:	e8bd8070 	pop	{r4, r5, r6, pc}
	int res;

	if (!(mtd->flags & MTD_WRITEABLE))
		return -EROFS;
	if (ofs >= mtd->size)
		return -EINVAL;
34813014:	e3e00015 	mvn	r0, #21
	ofs += part->offset;
	res = part->master->block_markbad(part->master, ofs);
	if (!res)
		mtd->ecc_stats.badblocks++;
	return res;
}
34813018:	e8bd8070 	pop	{r4, r5, r6, pc}

3481301c <part_read_oob>:
	return res;
}

static int part_read_oob(struct mtd_info *mtd, loff_t from,
		struct mtd_oob_ops *ops)
{
3481301c:	e92d40f7 	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	struct mtd_part *part = PART(mtd);
	int res;

	if (from >= mtd->size)
34813020:	e590500c 	ldr	r5, [r0, #12]
	return res;
}

static int part_read_oob(struct mtd_info *mtd, loff_t from,
		struct mtd_oob_ops *ops)
{
34813024:	e1a04000 	mov	r4, r0
	struct mtd_part *part = PART(mtd);
	int res;

	if (from >= mtd->size)
34813028:	e1550003 	cmp	r5, r3
	return res;
}

static int part_read_oob(struct mtd_info *mtd, loff_t from,
		struct mtd_oob_ops *ops)
{
3481302c:	e59dc020 	ldr	ip, [sp, #32]
	struct mtd_part *part = PART(mtd);
	int res;

	if (from >= mtd->size)
34813030:	e5906008 	ldr	r6, [r0, #8]
34813034:	8a000002 	bhi	34813044 <part_read_oob+0x28>
34813038:	1a00001f 	bne	348130bc <part_read_oob+0xa0>
3481303c:	e1560002 	cmp	r6, r2
34813040:	9a00001d 	bls	348130bc <part_read_oob+0xa0>
		return -EINVAL;
	if (ops->datbuf && from + ops->len > mtd->size)
34813044:	e59c1018 	ldr	r1, [ip, #24]
34813048:	e3510000 	cmp	r1, #0
3481304c:	0a000007 	beq	34813070 <part_read_oob+0x54>
34813050:	e59c7004 	ldr	r7, [ip, #4]
34813054:	e0920007 	adds	r0, r2, r7
34813058:	e2a31000 	adc	r1, r3, #0
3481305c:	e1510005 	cmp	r1, r5
34813060:	8a000015 	bhi	348130bc <part_read_oob+0xa0>
34813064:	1a000001 	bne	34813070 <part_read_oob+0x54>
34813068:	e1500006 	cmp	r0, r6
3481306c:	8a000012 	bhi	348130bc <part_read_oob+0xa0>
		return -EINVAL;
	res = part->master->read_oob(part->master, from + part->offset, ops);
34813070:	e59400a8 	ldr	r0, [r4, #168]	; 0xa8
34813074:	e1c46bd0 	ldrd	r6, [r4, #176]	; 0xb0
34813078:	e58dc000 	str	ip, [sp]
3481307c:	e0922006 	adds	r2, r2, r6
34813080:	e0a33007 	adc	r3, r3, r7
34813084:	e590104c 	ldr	r1, [r0, #76]	; 0x4c
34813088:	e12fff31 	blx	r1

	if (unlikely(res)) {
3481308c:	e3500000 	cmp	r0, #0
34813090:	0a00000a 	beq	348130c0 <part_read_oob+0xa4>
		if (res == -EUCLEAN)
34813094:	e3700075 	cmn	r0, #117	; 0x75
			mtd->ecc_stats.corrected++;
34813098:	05943080 	ldreq	r3, [r4, #128]	; 0x80
3481309c:	02833001 	addeq	r3, r3, #1
348130a0:	05843080 	streq	r3, [r4, #128]	; 0x80
	if (ops->datbuf && from + ops->len > mtd->size)
		return -EINVAL;
	res = part->master->read_oob(part->master, from + part->offset, ops);

	if (unlikely(res)) {
		if (res == -EUCLEAN)
348130a4:	0a000005 	beq	348130c0 <part_read_oob+0xa4>
			mtd->ecc_stats.corrected++;
		if (res == -EBADMSG)
348130a8:	e370004a 	cmn	r0, #74	; 0x4a
			mtd->ecc_stats.failed++;
348130ac:	05943084 	ldreq	r3, [r4, #132]	; 0x84
348130b0:	02833001 	addeq	r3, r3, #1
348130b4:	05843084 	streq	r3, [r4, #132]	; 0x84
348130b8:	ea000000 	b	348130c0 <part_read_oob+0xa4>
	int res;

	if (from >= mtd->size)
		return -EINVAL;
	if (ops->datbuf && from + ops->len > mtd->size)
		return -EINVAL;
348130bc:	e3e00015 	mvn	r0, #21
			mtd->ecc_stats.corrected++;
		if (res == -EBADMSG)
			mtd->ecc_stats.failed++;
	}
	return res;
}
348130c0:	e8bd80fe 	pop	{r1, r2, r3, r4, r5, r6, r7, pc}

348130c4 <part_read>:
 * to the _real_ device.
 */

static int part_read(struct mtd_info *mtd, loff_t from, size_t len,
		size_t *retlen, u_char *buf)
{
348130c4:	e92d4c7f 	push	{r0, r1, r2, r3, r4, r5, r6, sl, fp, lr}
348130c8:	e1a04000 	mov	r4, r0
	struct mtd_ecc_stats stats;
	int res;

	stats = part->master->ecc_stats;

	if (from >= mtd->size)
348130cc:	e594e00c 	ldr	lr, [r4, #12]
{
	struct mtd_part *part = PART(mtd);
	struct mtd_ecc_stats stats;
	int res;

	stats = part->master->ecc_stats;
348130d0:	e59000a8 	ldr	r0, [r0, #168]	; 0xa8

	if (from >= mtd->size)
348130d4:	e15e0003 	cmp	lr, r3
 * to the _real_ device.
 */

static int part_read(struct mtd_info *mtd, loff_t from, size_t len,
		size_t *retlen, u_char *buf)
{
348130d8:	e59d1028 	ldr	r1, [sp, #40]	; 0x28
	struct mtd_part *part = PART(mtd);
	struct mtd_ecc_stats stats;
	int res;

	stats = part->master->ecc_stats;
348130dc:	e5905080 	ldr	r5, [r0, #128]	; 0x80
348130e0:	e5906084 	ldr	r6, [r0, #132]	; 0x84

	if (from >= mtd->size)
348130e4:	e594c008 	ldr	ip, [r4, #8]
348130e8:	8a000002 	bhi	348130f8 <part_read+0x34>
348130ec:	1a00000a 	bne	3481311c <part_read+0x58>
348130f0:	e15c0002 	cmp	ip, r2
348130f4:	9a000008 	bls	3481311c <part_read+0x58>
		len = 0;
	else if (from + len > mtd->size)
348130f8:	e092a001 	adds	sl, r2, r1
348130fc:	e2a3b000 	adc	fp, r3, #0
34813100:	e15b000e 	cmp	fp, lr
34813104:	8a000002 	bhi	34813114 <part_read+0x50>
34813108:	1a000004 	bne	34813120 <part_read+0x5c>
3481310c:	e15a000c 	cmp	sl, ip
34813110:	9a000002 	bls	34813120 <part_read+0x5c>
		len = mtd->size - from;
34813114:	e062100c 	rsb	r1, r2, ip
34813118:	ea000000 	b	34813120 <part_read+0x5c>
	int res;

	stats = part->master->ecc_stats;

	if (from >= mtd->size)
		len = 0;
3481311c:	e3a01000 	mov	r1, #0
	else if (from + len > mtd->size)
		len = mtd->size - from;
	res = part->master->read(part->master, from + part->offset,
34813120:	e58d1000 	str	r1, [sp]
34813124:	e59d102c 	ldr	r1, [sp, #44]	; 0x2c
34813128:	e1c4abd0 	ldrd	sl, [r4, #176]	; 0xb0
3481312c:	e58d1004 	str	r1, [sp, #4]
34813130:	e59d1030 	ldr	r1, [sp, #48]	; 0x30
34813134:	e092200a 	adds	r2, r2, sl
34813138:	e58d1008 	str	r1, [sp, #8]
3481313c:	e0a3300b 	adc	r3, r3, fp
34813140:	e5901040 	ldr	r1, [r0, #64]	; 0x40
34813144:	e12fff31 	blx	r1
				   len, retlen, buf);
	if (unlikely(res)) {
34813148:	e3500000 	cmp	r0, #0
3481314c:	0a000010 	beq	34813194 <part_read+0xd0>
		if (res == -EUCLEAN)
34813150:	e3700075 	cmn	r0, #117	; 0x75
34813154:	1a000006 	bne	34813174 <part_read+0xb0>
			mtd->ecc_stats.corrected += part->master->ecc_stats.corrected - stats.corrected;
34813158:	e59430a8 	ldr	r3, [r4, #168]	; 0xa8
3481315c:	e5932080 	ldr	r2, [r3, #128]	; 0x80
34813160:	e5943080 	ldr	r3, [r4, #128]	; 0x80
34813164:	e0823003 	add	r3, r2, r3
34813168:	e0655003 	rsb	r5, r5, r3
3481316c:	e5845080 	str	r5, [r4, #128]	; 0x80
34813170:	ea000007 	b	34813194 <part_read+0xd0>
		if (res == -EBADMSG)
34813174:	e370004a 	cmn	r0, #74	; 0x4a
34813178:	1a000005 	bne	34813194 <part_read+0xd0>
			mtd->ecc_stats.failed += part->master->ecc_stats.failed - stats.failed;
3481317c:	e59430a8 	ldr	r3, [r4, #168]	; 0xa8
34813180:	e5932084 	ldr	r2, [r3, #132]	; 0x84
34813184:	e5943084 	ldr	r3, [r4, #132]	; 0x84
34813188:	e0823003 	add	r3, r2, r3
3481318c:	e0666003 	rsb	r6, r6, r3
34813190:	e5846084 	str	r6, [r4, #132]	; 0x84
	}
	return res;
}
34813194:	e28dd010 	add	sp, sp, #16
34813198:	e8bd8c70 	pop	{r4, r5, r6, sl, fp, pc}

3481319c <mtd_erase_callback>:
	return ret;
}

void mtd_erase_callback(struct erase_info *instr)
{
	if (instr->mtd->erase == part_erase) {
3481319c:	e5901000 	ldr	r1, [r0]
	}
	return ret;
}

void mtd_erase_callback(struct erase_info *instr)
{
348131a0:	e92d4038 	push	{r3, r4, r5, lr}
	if (instr->mtd->erase == part_erase) {
348131a4:	e5912034 	ldr	r2, [r1, #52]	; 0x34
348131a8:	e59f3050 	ldr	r3, [pc, #80]	; 34813200 <mtd_erase_callback+0x64>
348131ac:	e1520003 	cmp	r2, r3
348131b0:	1a00000d 	bne	348131ec <mtd_erase_callback+0x50>
		struct mtd_part *part = PART(instr->mtd);

		if (instr->fail_addr != MTD_FAIL_ADDR_UNKNOWN)
348131b4:	e1c021d8 	ldrd	r2, [r0, #24]
348131b8:	e3720001 	cmn	r2, #1
348131bc:	1a000001 	bne	348131c8 <mtd_erase_callback+0x2c>
348131c0:	e3730001 	cmn	r3, #1
348131c4:	0a000003 	beq	348131d8 <mtd_erase_callback+0x3c>
			instr->fail_addr -= part->offset;
348131c8:	e1c14bd0 	ldrd	r4, [r1, #176]	; 0xb0
348131cc:	e0522004 	subs	r2, r2, r4
348131d0:	e0c33005 	sbc	r3, r3, r5
348131d4:	e1c021f8 	strd	r2, [r0, #24]
		instr->addr -= part->offset;
348131d8:	e1c020d8 	ldrd	r2, [r0, #8]
348131dc:	e1c14bd0 	ldrd	r4, [r1, #176]	; 0xb0
348131e0:	e0522004 	subs	r2, r2, r4
348131e4:	e0c33005 	sbc	r3, r3, r5
348131e8:	e1c020f8 	strd	r2, [r0, #8]
	}
	if (instr->callback)
348131ec:	e5903030 	ldr	r3, [r0, #48]	; 0x30
348131f0:	e3530000 	cmp	r3, #0
348131f4:	08bd8038 	popeq	{r3, r4, r5, pc}
		instr->callback(instr);
348131f8:	e12fff33 	blx	r3
348131fc:	e8bd8038 	pop	{r3, r4, r5, pc}
34813200:	34812de0 	.word	0x34812de0

34813204 <del_mtd_partitions>:
 * This function unregisters and destroy all slave MTD objects which are
 * attached to the given master MTD object.
 */

int del_mtd_partitions(struct mtd_info *master)
{
34813204:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
	struct mtd_part *slave, *next;

	list_for_each_entry_safe(slave, next, &mtd_partitions, list)
34813208:	e59f7074 	ldr	r7, [pc, #116]	; 34813284 <del_mtd_partitions+0x80>
 * This function unregisters and destroy all slave MTD objects which are
 * attached to the given master MTD object.
 */

int del_mtd_partitions(struct mtd_info *master)
{
3481320c:	e1a0a000 	mov	sl, r0
	struct mtd_part *slave, *next;

	list_for_each_entry_safe(slave, next, &mtd_partitions, list)
34813210:	e5974000 	ldr	r4, [r7]
 * in an undefined state.
 */
static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
34813214:	e3a06000 	mov	r6, #0
34813218:	e41450bc 	ldr	r5, [r4], #-188	; 0xbc
3481321c:	e24550bc 	sub	r5, r5, #188	; 0xbc
34813220:	ea000012 	b	34813270 <del_mtd_partitions+0x6c>
		if (slave->master == master) {
34813224:	e59430a8 	ldr	r3, [r4, #168]	; 0xa8
34813228:	e153000a 	cmp	r3, sl
3481322c:	1a00000c 	bne	34813264 <del_mtd_partitions+0x60>
 * Note: list_empty() on entry does not return true after this, the entry is
 * in an undefined state.
 */
static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
34813230:	e59430c0 	ldr	r3, [r4, #192]	; 0xc0
34813234:	e59420bc 	ldr	r2, [r4, #188]	; 0xbc
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head *prev, struct list_head *next)
{
	next->prev = prev;
34813238:	e5823004 	str	r3, [r2, #4]
	prev->next = next;
3481323c:	e5832000 	str	r2, [r3]
			list_del(&slave->list);
			if (slave->registered)
34813240:	e59430c4 	ldr	r3, [r4, #196]	; 0xc4
 * in an undefined state.
 */
static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
34813244:	e58460bc 	str	r6, [r4, #188]	; 0xbc
34813248:	e3530000 	cmp	r3, #0
	entry->prev = LIST_POISON2;
3481324c:	e58460c0 	str	r6, [r4, #192]	; 0xc0
34813250:	0a000001 	beq	3481325c <del_mtd_partitions+0x58>
				del_mtd_device(&slave->mtd);
34813254:	e1a00004 	mov	r0, r4
34813258:	ebfffde1 	bl	348129e4 <del_mtd_device>
			kfree(slave);
3481325c:	e1a00004 	mov	r0, r4
34813260:	ebffd877 	bl	34809444 <free>

int del_mtd_partitions(struct mtd_info *master)
{
	struct mtd_part *slave, *next;

	list_for_each_entry_safe(slave, next, &mtd_partitions, list)
34813264:	e59530bc 	ldr	r3, [r5, #188]	; 0xbc
34813268:	e1a04005 	mov	r4, r5
3481326c:	e24350bc 	sub	r5, r3, #188	; 0xbc
34813270:	e28430bc 	add	r3, r4, #188	; 0xbc
34813274:	e1570003 	cmp	r7, r3
34813278:	1affffe9 	bne	34813224 <del_mtd_partitions+0x20>
				del_mtd_device(&slave->mtd);
			kfree(slave);
		}

	return 0;
}
3481327c:	e3a00000 	mov	r0, #0
34813280:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
34813284:	3482b218 	.word	0x3482b218

34813288 <add_mtd_partitions>:
 */

int add_mtd_partitions(struct mtd_info *master,
		       const struct mtd_partition *parts,
		       int nbparts)
{
34813288:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	/*
	 * Need to init the list here, since LIST_INIT() does not
	 * work on platforms where relocation has problems (like MIPS
	 * & PPC).
	 */
	if (mtd_partitions.next == NULL)
3481328c:	e59f35d4 	ldr	r3, [pc, #1492]	; 34813868 <add_mtd_partitions+0x5e0>
 */

int add_mtd_partitions(struct mtd_info *master,
		       const struct mtd_partition *parts,
		       int nbparts)
{
34813290:	e24dd028 	sub	sp, sp, #40	; 0x28
34813294:	e58d201c 	str	r2, [sp, #28]
	/*
	 * Need to init the list here, since LIST_INIT() does not
	 * work on platforms where relocation has problems (like MIPS
	 * & PPC).
	 */
	if (mtd_partitions.next == NULL)
34813298:	e5932000 	ldr	r2, [r3]
 */

int add_mtd_partitions(struct mtd_info *master,
		       const struct mtd_partition *parts,
		       int nbparts)
{
3481329c:	e1a04000 	mov	r4, r0
	/*
	 * Need to init the list here, since LIST_INIT() does not
	 * work on platforms where relocation has problems (like MIPS
	 * & PPC).
	 */
	if (mtd_partitions.next == NULL)
348132a0:	e3520000 	cmp	r2, #0
 */

int add_mtd_partitions(struct mtd_info *master,
		       const struct mtd_partition *parts,
		       int nbparts)
{
348132a4:	e1a05001 	mov	r5, r1
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
348132a8:	05833000 	streq	r3, [r3]
	list->prev = list;
348132ac:	05833004 	streq	r3, [r3, #4]
	 * & PPC).
	 */
	if (mtd_partitions.next == NULL)
		INIT_LIST_HEAD(&mtd_partitions);

	printk(KERN_NOTICE "Creating %d MTD partitions on \"%s\":\n", nbparts, master->name);
348132b0:	e59f05b4 	ldr	r0, [pc, #1460]	; 3481386c <add_mtd_partitions+0x5e4>
348132b4:	e59d101c 	ldr	r1, [sp, #28]
348132b8:	e5942020 	ldr	r2, [r4, #32]
348132bc:	ebffd722 	bl	34808f4c <printf>
 *
 * We don't register the master, or expect the caller to have done so,
 * for reasons of data integrity.
 */

int add_mtd_partitions(struct mtd_info *master,
348132c0:	e2855020 	add	r5, r5, #32
	if (mtd_partitions.next == NULL)
		INIT_LIST_HEAD(&mtd_partitions);

	printk(KERN_NOTICE "Creating %d MTD partitions on \"%s\":\n", nbparts, master->name);

	for (i = 0; i < nbparts; i++) {
348132c4:	e3a07000 	mov	r7, #0
int add_mtd_partitions(struct mtd_info *master,
		       const struct mtd_partition *parts,
		       int nbparts)
{
	struct mtd_part *slave;
	uint64_t cur_offset = 0;
348132c8:	e3a0a000 	mov	sl, #0
348132cc:	e3a0b000 	mov	fp, #0
	if (mtd_partitions.next == NULL)
		INIT_LIST_HEAD(&mtd_partitions);

	printk(KERN_NOTICE "Creating %d MTD partitions on \"%s\":\n", nbparts, master->name);

	for (i = 0; i < nbparts; i++) {
348132d0:	ea00015e 	b	34813850 <add_mtd_partitions+0x5c8>
		uint64_t cur_offset)
{
	struct mtd_part *slave;

	/* allocate the partition structure */
	slave = kzalloc(sizeof(*slave), GFP_KERNEL);
348132d4:	e3a000c8 	mov	r0, #200	; 0xc8
348132d8:	e3a01001 	mov	r1, #1
348132dc:	ebffda4e 	bl	34809c1c <calloc>
	if (!slave) {
348132e0:	e2506000 	subs	r6, r0, #0
348132e4:	1a000006 	bne	34813304 <add_mtd_partitions+0x7c>
		printk(KERN_ERR"memory allocation error while creating partitions for \"%s\"\n",
348132e8:	e5941020 	ldr	r1, [r4, #32]
348132ec:	e59f057c 	ldr	r0, [pc, #1404]	; 34813870 <add_mtd_partitions+0x5e8>
348132f0:	ebffd715 	bl	34808f4c <printf>
			master->name);
		del_mtd_partitions(master);
348132f4:	e1a00004 	mov	r0, r4
348132f8:	ebffffc1 	bl	34813204 <del_mtd_partitions>
	printk(KERN_NOTICE "Creating %d MTD partitions on \"%s\":\n", nbparts, master->name);

	for (i = 0; i < nbparts; i++) {
		slave = add_one_partition(master, parts + i, i, cur_offset);
		if (!slave)
			return -ENOMEM;
348132fc:	e3e0000b 	mvn	r0, #11
34813300:	ea000156 	b	34813860 <add_mtd_partitions+0x5d8>
 * Insert a new entry after the specified head.
 * This is good for implementing stacks.
 */
static inline void list_add(struct list_head *new, struct list_head *head)
{
	__list_add(new, head, head->next);
34813304:	e59f055c 	ldr	r0, [pc, #1372]	; 34813868 <add_mtd_partitions+0x5e0>
		printk(KERN_ERR"memory allocation error while creating partitions for \"%s\"\n",
			master->name);
		del_mtd_partitions(master);
		return NULL;
	}
	list_add(&slave->list, &mtd_partitions);
34813308:	e28630bc 	add	r3, r6, #188	; 0xbc
3481330c:	e5902000 	ldr	r2, [r0]
			      struct list_head *next)
{
	next->prev = new;
	new->next = next;
	new->prev = prev;
	prev->next = new;
34813310:	e5803000 	str	r3, [r0]
 */
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
34813314:	e5823004 	str	r3, [r2, #4]
	new->next = next;
34813318:	e58620bc 	str	r2, [r6, #188]	; 0xbc
	new->prev = prev;
3481331c:	e58600c0 	str	r0, [r6, #192]	; 0xc0

	/* set up the MTD object for this partition */
	slave->mtd.type = master->type;
34813320:	e5d43000 	ldrb	r3, [r4]
	slave->mtd.subpage_sft = master->subpage_sft;

	slave->mtd.name = part->name;
	slave->mtd.owner = master->owner;

	slave->mtd.read = part_read;
34813324:	e59f1548 	ldr	r1, [pc, #1352]	; 34813874 <add_mtd_partitions+0x5ec>
		return NULL;
	}
	list_add(&slave->list, &mtd_partitions);

	/* set up the MTD object for this partition */
	slave->mtd.type = master->type;
34813328:	e5c63000 	strb	r3, [r6]
	slave->mtd.flags = master->flags & ~part->mask_flags;
3481332c:	e5152008 	ldr	r2, [r5, #-8]
34813330:	e5943004 	ldr	r3, [r4, #4]
34813334:	e1c33002 	bic	r3, r3, r2
34813338:	e5863004 	str	r3, [r6, #4]
	slave->mtd.size = part->size;
3481333c:	e14521d8 	ldrd	r2, [r5, #-24]	; 0xffffffe8
34813340:	e1c620f8 	strd	r2, [r6, #8]
	slave->mtd.writesize = master->writesize;
34813344:	e5943014 	ldr	r3, [r4, #20]

	slave->mtd.name = part->name;
	slave->mtd.owner = master->owner;

	slave->mtd.read = part_read;
	slave->mtd.write = part_write;
34813348:	e59f2528 	ldr	r2, [pc, #1320]	; 34813878 <add_mtd_partitions+0x5f0>

	/* set up the MTD object for this partition */
	slave->mtd.type = master->type;
	slave->mtd.flags = master->flags & ~part->mask_flags;
	slave->mtd.size = part->size;
	slave->mtd.writesize = master->writesize;
3481334c:	e5863014 	str	r3, [r6, #20]
	slave->mtd.oobsize = master->oobsize;
34813350:	e5943018 	ldr	r3, [r4, #24]
34813354:	e5863018 	str	r3, [r6, #24]
	slave->mtd.oobavail = master->oobavail;
34813358:	e594301c 	ldr	r3, [r4, #28]
3481335c:	e586301c 	str	r3, [r6, #28]
	slave->mtd.subpage_sft = master->subpage_sft;
34813360:	e5943090 	ldr	r3, [r4, #144]	; 0x90
34813364:	e5863090 	str	r3, [r6, #144]	; 0x90

	slave->mtd.name = part->name;
34813368:	e5153020 	ldr	r3, [r5, #-32]
	slave->mtd.owner = master->owner;

	slave->mtd.read = part_read;
3481336c:	e5861040 	str	r1, [r6, #64]	; 0x40
	slave->mtd.writesize = master->writesize;
	slave->mtd.oobsize = master->oobsize;
	slave->mtd.oobavail = master->oobavail;
	slave->mtd.subpage_sft = master->subpage_sft;

	slave->mtd.name = part->name;
34813370:	e5863020 	str	r3, [r6, #32]
	slave->mtd.owner = master->owner;
34813374:	e5943098 	ldr	r3, [r4, #152]	; 0x98

	slave->mtd.read = part_read;
	slave->mtd.write = part_write;
34813378:	e5862044 	str	r2, [r6, #68]	; 0x44
	slave->mtd.oobsize = master->oobsize;
	slave->mtd.oobavail = master->oobavail;
	slave->mtd.subpage_sft = master->subpage_sft;

	slave->mtd.name = part->name;
	slave->mtd.owner = master->owner;
3481337c:	e5863098 	str	r3, [r6, #152]	; 0x98

	slave->mtd.read = part_read;
	slave->mtd.write = part_write;

	if (master->panic_write)
34813380:	e5943048 	ldr	r3, [r4, #72]	; 0x48
34813384:	e3530000 	cmp	r3, #0
		slave->mtd.panic_write = part_panic_write;
34813388:	159f34ec 	ldrne	r3, [pc, #1260]	; 3481387c <add_mtd_partitions+0x5f4>
3481338c:	15863048 	strne	r3, [r6, #72]	; 0x48

	if (master->read_oob)
34813390:	e594304c 	ldr	r3, [r4, #76]	; 0x4c
34813394:	e3530000 	cmp	r3, #0
		slave->mtd.read_oob = part_read_oob;
34813398:	159f04e0 	ldrne	r0, [pc, #1248]	; 34813880 <add_mtd_partitions+0x5f8>
	if (master->write_oob)
3481339c:	e5943050 	ldr	r3, [r4, #80]	; 0x50

	if (master->panic_write)
		slave->mtd.panic_write = part_panic_write;

	if (master->read_oob)
		slave->mtd.read_oob = part_read_oob;
348133a0:	1586004c 	strne	r0, [r6, #76]	; 0x4c
	if (master->write_oob)
348133a4:	e3530000 	cmp	r3, #0
		slave->mtd.write_oob = part_write_oob;
348133a8:	159f14d4 	ldrne	r1, [pc, #1236]	; 34813884 <add_mtd_partitions+0x5fc>
	if (master->read_user_prot_reg)
348133ac:	e5943060 	ldr	r3, [r4, #96]	; 0x60
		slave->mtd.panic_write = part_panic_write;

	if (master->read_oob)
		slave->mtd.read_oob = part_read_oob;
	if (master->write_oob)
		slave->mtd.write_oob = part_write_oob;
348133b0:	15861050 	strne	r1, [r6, #80]	; 0x50
	if (master->read_user_prot_reg)
348133b4:	e3530000 	cmp	r3, #0
		slave->mtd.read_user_prot_reg = part_read_user_prot_reg;
348133b8:	159f24c8 	ldrne	r2, [pc, #1224]	; 34813888 <add_mtd_partitions+0x600>
348133bc:	15862060 	strne	r2, [r6, #96]	; 0x60
	if (master->read_fact_prot_reg)
348133c0:	e5943058 	ldr	r3, [r4, #88]	; 0x58
		slave->mtd.block_isbad = part_block_isbad;
	if (master->block_markbad)
		slave->mtd.block_markbad = part_block_markbad;
	slave->mtd.erase = part_erase;
	slave->master = master;
	slave->offset = part->offset;
348133c4:	e5152010 	ldr	r2, [r5, #-16]
		slave->mtd.read_oob = part_read_oob;
	if (master->write_oob)
		slave->mtd.write_oob = part_write_oob;
	if (master->read_user_prot_reg)
		slave->mtd.read_user_prot_reg = part_read_user_prot_reg;
	if (master->read_fact_prot_reg)
348133c8:	e3530000 	cmp	r3, #0
		slave->mtd.read_fact_prot_reg = part_read_fact_prot_reg;
348133cc:	159f34b8 	ldrne	r3, [pc, #1208]	; 3481388c <add_mtd_partitions+0x604>
348133d0:	15863058 	strne	r3, [r6, #88]	; 0x58
	if (master->write_user_prot_reg)
348133d4:	e5943064 	ldr	r3, [r4, #100]	; 0x64
348133d8:	e3530000 	cmp	r3, #0
		slave->mtd.write_user_prot_reg = part_write_user_prot_reg;
348133dc:	159f34ac 	ldrne	r3, [pc, #1196]	; 34813890 <add_mtd_partitions+0x608>
348133e0:	15863064 	strne	r3, [r6, #100]	; 0x64
	if (master->lock_user_prot_reg)
348133e4:	e5943068 	ldr	r3, [r4, #104]	; 0x68
348133e8:	e3530000 	cmp	r3, #0
		slave->mtd.lock_user_prot_reg = part_lock_user_prot_reg;
348133ec:	159f34a0 	ldrne	r3, [pc, #1184]	; 34813894 <add_mtd_partitions+0x60c>
348133f0:	15863068 	strne	r3, [r6, #104]	; 0x68
	if (master->get_user_prot_info)
348133f4:	e594305c 	ldr	r3, [r4, #92]	; 0x5c
348133f8:	e3530000 	cmp	r3, #0
		slave->mtd.get_user_prot_info = part_get_user_prot_info;
348133fc:	159f3494 	ldrne	r3, [pc, #1172]	; 34813898 <add_mtd_partitions+0x610>
34813400:	1586305c 	strne	r3, [r6, #92]	; 0x5c
	if (master->get_fact_prot_info)
34813404:	e5943054 	ldr	r3, [r4, #84]	; 0x54
34813408:	e3530000 	cmp	r3, #0
		slave->mtd.get_fact_prot_info = part_get_fact_prot_info;
3481340c:	159f3488 	ldrne	r3, [pc, #1160]	; 3481389c <add_mtd_partitions+0x614>
34813410:	15863054 	strne	r3, [r6, #84]	; 0x54
	if (master->sync)
34813414:	e594306c 	ldr	r3, [r4, #108]	; 0x6c
34813418:	e3530000 	cmp	r3, #0
		slave->mtd.sync = part_sync;
3481341c:	159f347c 	ldrne	r3, [pc, #1148]	; 348138a0 <add_mtd_partitions+0x618>
34813420:	1586306c 	strne	r3, [r6, #108]	; 0x6c
	if (master->lock)
34813424:	e5943070 	ldr	r3, [r4, #112]	; 0x70
34813428:	e3530000 	cmp	r3, #0
		slave->mtd.lock = part_lock;
3481342c:	159f3470 	ldrne	r3, [pc, #1136]	; 348138a4 <add_mtd_partitions+0x61c>
34813430:	15863070 	strne	r3, [r6, #112]	; 0x70
	if (master->unlock)
34813434:	e5943074 	ldr	r3, [r4, #116]	; 0x74
34813438:	e3530000 	cmp	r3, #0
		slave->mtd.unlock = part_unlock;
3481343c:	159f3464 	ldrne	r3, [pc, #1124]	; 348138a8 <add_mtd_partitions+0x620>
34813440:	15863074 	strne	r3, [r6, #116]	; 0x74
	if (master->block_isbad)
34813444:	e5943078 	ldr	r3, [r4, #120]	; 0x78
34813448:	e3530000 	cmp	r3, #0
		slave->mtd.block_isbad = part_block_isbad;
3481344c:	159f3458 	ldrne	r3, [pc, #1112]	; 348138ac <add_mtd_partitions+0x624>
34813450:	15863078 	strne	r3, [r6, #120]	; 0x78
	if (master->block_markbad)
34813454:	e594307c 	ldr	r3, [r4, #124]	; 0x7c
		slave->mtd.block_markbad = part_block_markbad;
	slave->mtd.erase = part_erase;
	slave->master = master;
34813458:	e58640a8 	str	r4, [r6, #168]	; 0xa8
		slave->mtd.lock = part_lock;
	if (master->unlock)
		slave->mtd.unlock = part_unlock;
	if (master->block_isbad)
		slave->mtd.block_isbad = part_block_isbad;
	if (master->block_markbad)
3481345c:	e3530000 	cmp	r3, #0
		slave->mtd.block_markbad = part_block_markbad;
34813460:	159f3448 	ldrne	r3, [pc, #1096]	; 348138b0 <add_mtd_partitions+0x628>
34813464:	1586307c 	strne	r3, [r6, #124]	; 0x7c
	slave->mtd.erase = part_erase;
34813468:	e59f3444 	ldr	r3, [pc, #1092]	; 348138b4 <add_mtd_partitions+0x62c>
	slave->master = master;
	slave->offset = part->offset;
	slave->index = partno;

	if (slave->offset == MTDPART_OFS_APPEND)
3481346c:	e3720001 	cmn	r2, #1
		slave->mtd.unlock = part_unlock;
	if (master->block_isbad)
		slave->mtd.block_isbad = part_block_isbad;
	if (master->block_markbad)
		slave->mtd.block_markbad = part_block_markbad;
	slave->mtd.erase = part_erase;
34813470:	e5863034 	str	r3, [r6, #52]	; 0x34
	slave->master = master;
	slave->offset = part->offset;
34813474:	e515300c 	ldr	r3, [r5, #-12]
34813478:	e58620b0 	str	r2, [r6, #176]	; 0xb0
3481347c:	e58630b4 	str	r3, [r6, #180]	; 0xb4
	slave->index = partno;
34813480:	e58670b8 	str	r7, [r6, #184]	; 0xb8

	if (slave->offset == MTDPART_OFS_APPEND)
34813484:	1a000001 	bne	34813490 <add_mtd_partitions+0x208>
34813488:	e3730001 	cmn	r3, #1
		slave->offset = cur_offset;
3481348c:	01c6abf0 	strdeq	sl, [r6, #176]	; 0xb0
	if (slave->offset == MTDPART_OFS_NXTBLK) {
34813490:	e59630b0 	ldr	r3, [r6, #176]	; 0xb0
34813494:	e3730002 	cmn	r3, #2
34813498:	1a000027 	bne	3481353c <add_mtd_partitions+0x2b4>
3481349c:	e59630b4 	ldr	r3, [r6, #180]	; 0xb4
348134a0:	e3730001 	cmn	r3, #1
348134a4:	1a000024 	bne	3481353c <add_mtd_partitions+0x2b4>
	return sz;
}

static inline uint32_t mtd_mod_by_eb(uint64_t sz, struct mtd_info *mtd)
{
	return do_div(sz, mtd->erasesize);
348134a8:	e25b9000 	subs	r9, fp, #0
		slave->offset = cur_offset;
348134ac:	e1c6abf0 	strd	sl, [r6, #176]	; 0xb0
			return -ENOMEM;
		cur_offset = slave->offset + slave->mtd.size;
	}

	return 0;
}
348134b0:	e5941010 	ldr	r1, [r4, #16]
348134b4:	e1cda2f0 	strd	sl, [sp, #32]
348134b8:	1a000002 	bne	348134c8 <add_mtd_partitions+0x240>
348134bc:	e1a0000a 	mov	r0, sl
348134c0:	eb0032f2 	bl	34820090 <__aeabi_uidivmod>
348134c4:	ea000002 	b	348134d4 <add_mtd_partitions+0x24c>
348134c8:	e28d0020 	add	r0, sp, #32
348134cc:	eb000faa 	bl	3481737c <__div64_32>
348134d0:	e1a01000 	mov	r1, r0

	if (slave->offset == MTDPART_OFS_APPEND)
		slave->offset = cur_offset;
	if (slave->offset == MTDPART_OFS_NXTBLK) {
		slave->offset = cur_offset;
		if (mtd_mod_by_eb(cur_offset, master) != 0) {
348134d4:	e3510000 	cmp	r1, #0
348134d8:	0a000017 	beq	3481353c <add_mtd_partitions+0x2b4>
	void (*put_device) (struct mtd_info *mtd);
};

static inline uint32_t mtd_div_by_eb(uint64_t sz, struct mtd_info *mtd)
{
	do_div(sz, mtd->erasesize);
348134dc:	e3590000 	cmp	r9, #0
			return -ENOMEM;
		cur_offset = slave->offset + slave->mtd.size;
	}

	return 0;
}
348134e0:	e5941010 	ldr	r1, [r4, #16]
348134e4:	e1cda2f0 	strd	sl, [sp, #32]
348134e8:	1a000004 	bne	34813500 <add_mtd_partitions+0x278>
348134ec:	e1a0000a 	mov	r0, sl
348134f0:	eb00326b 	bl	3481fea4 <__udivsi3>
348134f4:	e58d9024 	str	r9, [sp, #36]	; 0x24
348134f8:	e58d0020 	str	r0, [sp, #32]
348134fc:	ea000001 	b	34813508 <add_mtd_partitions+0x280>
34813500:	e28d0020 	add	r0, sp, #32
34813504:	eb000f9c 	bl	3481737c <__div64_32>
		slave->offset = cur_offset;
	if (slave->offset == MTDPART_OFS_NXTBLK) {
		slave->offset = cur_offset;
		if (mtd_mod_by_eb(cur_offset, master) != 0) {
			/* Round up to next erasesize */
			slave->offset = (mtd_div_by_eb(cur_offset, master) + 1) * master->erasesize;
34813508:	e59d2020 	ldr	r2, [sp, #32]
3481350c:	e5943010 	ldr	r3, [r4, #16]
34813510:	e2822001 	add	r2, r2, #1
34813514:	e0020293 	mul	r2, r3, r2
34813518:	e3a03000 	mov	r3, #0
3481351c:	e58620b0 	str	r2, [r6, #176]	; 0xb0
34813520:	e58630b4 	str	r3, [r6, #180]	; 0xb4
			printk(KERN_NOTICE "Moving partition %d: "
34813524:	e59f038c 	ldr	r0, [pc, #908]	; 348138b8 <add_mtd_partitions+0x630>
34813528:	e88d000c 	stm	sp, {r2, r3}
3481352c:	e1a01007 	mov	r1, r7
34813530:	e1a0200a 	mov	r2, sl
34813534:	e1a0300b 	mov	r3, fp
34813538:	ebffd683 	bl	34808f4c <printf>
			       "0x%012llx -> 0x%012llx\n", partno,
			       (unsigned long long)cur_offset, (unsigned long long)slave->offset);
		}
	}
	if (slave->mtd.size == MTDPART_SIZ_FULL)
3481353c:	e5962008 	ldr	r2, [r6, #8]
34813540:	e596300c 	ldr	r3, [r6, #12]
34813544:	e1923003 	orrs	r3, r2, r3
34813548:	1a000004 	bne	34813560 <add_mtd_partitions+0x2d8>
		slave->mtd.size = master->size - slave->offset;
3481354c:	e1c400d8 	ldrd	r0, [r4, #8]
34813550:	e1c62bd0 	ldrd	r2, [r6, #176]	; 0xb0
34813554:	e0500002 	subs	r0, r0, r2
34813558:	e0c11003 	sbc	r1, r1, r3
3481355c:	e1c600f8 	strd	r0, [r6, #8]

	printk(KERN_NOTICE "0x%012llx-0x%012llx : \"%s\"\n", (unsigned long long)slave->offset,
		(unsigned long long)(slave->offset + slave->mtd.size), slave->mtd.name);
34813560:	e1c6abd0 	ldrd	sl, [r6, #176]	; 0xb0
		}
	}
	if (slave->mtd.size == MTDPART_SIZ_FULL)
		slave->mtd.size = master->size - slave->offset;

	printk(KERN_NOTICE "0x%012llx-0x%012llx : \"%s\"\n", (unsigned long long)slave->offset,
34813564:	e1c620d8 	ldrd	r2, [r6, #8]
34813568:	e092200a 	adds	r2, r2, sl
3481356c:	e0a3300b 	adc	r3, r3, fp
34813570:	e1cd20f0 	strd	r2, [sp]
34813574:	e5963020 	ldr	r3, [r6, #32]
34813578:	e1a0200a 	mov	r2, sl
3481357c:	e58d3008 	str	r3, [sp, #8]
34813580:	e59f0334 	ldr	r0, [pc, #820]	; 348138bc <add_mtd_partitions+0x634>
34813584:	e1a0300b 	mov	r3, fp
34813588:	ebffd66f 	bl	34808f4c <printf>
		(unsigned long long)(slave->offset + slave->mtd.size), slave->mtd.name);

	/* let's do some sanity checks */
	if (slave->offset >= master->size) {
3481358c:	e1c6abd0 	ldrd	sl, [r6, #176]	; 0xb0
34813590:	e1c400d8 	ldrd	r0, [r4, #8]
34813594:	e151000b 	cmp	r1, fp
34813598:	8a00000a 	bhi	348135c8 <add_mtd_partitions+0x340>
3481359c:	1a000001 	bne	348135a8 <add_mtd_partitions+0x320>
348135a0:	e150000a 	cmp	r0, sl
348135a4:	8a000007 	bhi	348135c8 <add_mtd_partitions+0x340>
		/* let's register it anyway to preserve ordering */
		slave->offset = 0;
348135a8:	e3a02000 	mov	r2, #0
348135ac:	e3a03000 	mov	r3, #0
348135b0:	e1c62bf0 	strd	r2, [r6, #176]	; 0xb0
		slave->mtd.size = 0;
348135b4:	e1c620f8 	strd	r2, [r6, #8]
		printk(KERN_ERR"mtd: partition \"%s\" is out of reach -- disabled\n",
348135b8:	e5151020 	ldr	r1, [r5, #-32]
348135bc:	e59f02fc 	ldr	r0, [pc, #764]	; 348138c0 <add_mtd_partitions+0x638>
348135c0:	ebffd661 	bl	34808f4c <printf>
348135c4:	ea000092 	b	34813814 <add_mtd_partitions+0x58c>
			part->name);
		goto out_register;
	}
	if (slave->offset + slave->mtd.size > master->size) {
348135c8:	e1c620d8 	ldrd	r2, [r6, #8]
348135cc:	e092200a 	adds	r2, r2, sl
348135d0:	e0a3300b 	adc	r3, r3, fp
348135d4:	e1530001 	cmp	r3, r1
348135d8:	8a000002 	bhi	348135e8 <add_mtd_partitions+0x360>
348135dc:	1a000009 	bne	34813608 <add_mtd_partitions+0x380>
348135e0:	e1520000 	cmp	r2, r0
348135e4:	9a000007 	bls	34813608 <add_mtd_partitions+0x380>
		slave->mtd.size = master->size - slave->offset;
348135e8:	e050000a 	subs	r0, r0, sl
348135ec:	e0c1100b 	sbc	r1, r1, fp
348135f0:	e1c600f8 	strd	r0, [r6, #8]
		printk(KERN_WARNING"mtd: partition \"%s\" extends beyond the end of device \"%s\" -- size truncated to %#llx\n",
348135f4:	e1cd00f0 	strd	r0, [sp]
348135f8:	e5942020 	ldr	r2, [r4, #32]
348135fc:	e59f02c0 	ldr	r0, [pc, #704]	; 348138c4 <add_mtd_partitions+0x63c>
34813600:	e5151020 	ldr	r1, [r5, #-32]
34813604:	ebffd650 	bl	34808f4c <printf>
			part->name, master->name, (unsigned long long)slave->mtd.size);
	}
	if (master->numeraseregions > 1) {
34813608:	e594a02c 	ldr	sl, [r4, #44]	; 0x2c
3481360c:	e35a0001 	cmp	sl, #1
34813610:	da000033 	ble	348136e4 <add_mtd_partitions+0x45c>
		/* Deal with variable erase size stuff */
		int i, max = master->numeraseregions;
		u64 end = slave->offset + slave->mtd.size;
34813614:	e1c60bd0 	ldrd	r0, [r6, #176]	; 0xb0
34813618:	e1c620d8 	ldrd	r2, [r6, #8]
3481361c:	e1cd01f0 	strd	r0, [sp, #16]
34813620:	e0922000 	adds	r2, r2, r0
		struct mtd_erase_region_info *regions = master->eraseregions;
34813624:	e3a00000 	mov	r0, #0
			part->name, master->name, (unsigned long long)slave->mtd.size);
	}
	if (master->numeraseregions > 1) {
		/* Deal with variable erase size stuff */
		int i, max = master->numeraseregions;
		u64 end = slave->offset + slave->mtd.size;
34813628:	e0a33001 	adc	r3, r3, r1
		struct mtd_erase_region_info *regions = master->eraseregions;
3481362c:	e594c030 	ldr	ip, [r4, #48]	; 0x30

		/* Find the first erase regions which is part of this
		 * partition. */
		for (i = 0; i < max && regions[i].offset <= slave->offset; i++)
34813630:	e1a01000 	mov	r1, r0
34813634:	ea000003 	b	34813648 <add_mtd_partitions+0x3c0>
34813638:	e2811001 	add	r1, r1, #1
3481363c:	e151000a 	cmp	r1, sl
34813640:	e2800018 	add	r0, r0, #24
34813644:	aa000009 	bge	34813670 <add_mtd_partitions+0x3e8>
34813648:	e08c9000 	add	r9, ip, r0
3481364c:	e5999004 	ldr	r9, [r9, #4]
34813650:	e59db014 	ldr	fp, [sp, #20]
34813654:	e159000b 	cmp	r9, fp
34813658:	8a000004 	bhi	34813670 <add_mtd_partitions+0x3e8>
3481365c:	1afffff5 	bne	34813638 <add_mtd_partitions+0x3b0>
34813660:	e79c9000 	ldr	r9, [ip, r0]
34813664:	e59db010 	ldr	fp, [sp, #16]
34813668:	e159000b 	cmp	r9, fp
3481366c:	9afffff1 	bls	34813638 <add_mtd_partitions+0x3b0>
 *
 * We don't register the master, or expect the caller to have done so,
 * for reasons of data integrity.
 */

int add_mtd_partitions(struct mtd_info *master,
34813670:	e3a09018 	mov	r9, #24
		/* Find the first erase regions which is part of this
		 * partition. */
		for (i = 0; i < max && regions[i].offset <= slave->offset; i++)
			;
		/* The loop searched for the region _behind_ the first one */
		i--;
34813674:	e2410001 	sub	r0, r1, #1
 *
 * We don't register the master, or expect the caller to have done so,
 * for reasons of data integrity.
 */

int add_mtd_partitions(struct mtd_info *master,
34813678:	e021c199 	mla	r1, r9, r1, ip
3481367c:	ea000005 	b	34813698 <add_mtd_partitions+0x410>
		/* The loop searched for the region _behind_ the first one */
		i--;

		/* Pick biggest erasesize */
		for (; i < max && regions[i].offset < end; i++) {
			if (slave->mtd.erasesize < regions[i].erasesize) {
34813680:	e511c010 	ldr	ip, [r1, #-16]
34813684:	e5969010 	ldr	r9, [r6, #16]
			;
		/* The loop searched for the region _behind_ the first one */
		i--;

		/* Pick biggest erasesize */
		for (; i < max && regions[i].offset < end; i++) {
34813688:	e2800001 	add	r0, r0, #1
			if (slave->mtd.erasesize < regions[i].erasesize) {
3481368c:	e159000c 	cmp	r9, ip
				slave->mtd.erasesize = regions[i].erasesize;
34813690:	3586c010 	strcc	ip, [r6, #16]
			;
		/* The loop searched for the region _behind_ the first one */
		i--;

		/* Pick biggest erasesize */
		for (; i < max && regions[i].offset < end; i++) {
34813694:	e2811018 	add	r1, r1, #24
34813698:	e150000a 	cmp	r0, sl
3481369c:	aa000006 	bge	348136bc <add_mtd_partitions+0x434>
348136a0:	e511c014 	ldr	ip, [r1, #-20]
348136a4:	e15c0003 	cmp	ip, r3
348136a8:	3afffff4 	bcc	34813680 <add_mtd_partitions+0x3f8>
348136ac:	1a000002 	bne	348136bc <add_mtd_partitions+0x434>
348136b0:	e511c018 	ldr	ip, [r1, #-24]
348136b4:	e15c0002 	cmp	ip, r2
348136b8:	3afffff0 	bcc	34813680 <add_mtd_partitions+0x3f8>
			if (slave->mtd.erasesize < regions[i].erasesize) {
				slave->mtd.erasesize = regions[i].erasesize;
			}
		}
		BUG_ON(slave->mtd.erasesize == 0);
348136bc:	e5963010 	ldr	r3, [r6, #16]
348136c0:	e3530000 	cmp	r3, #0
348136c4:	1a000008 	bne	348136ec <add_mtd_partitions+0x464>
348136c8:	e59f01f8 	ldr	r0, [pc, #504]	; 348138c8 <add_mtd_partitions+0x640>
348136cc:	e59f11f8 	ldr	r1, [pc, #504]	; 348138cc <add_mtd_partitions+0x644>
348136d0:	e300218a 	movw	r2, #394	; 0x18a
348136d4:	e59f31f4 	ldr	r3, [pc, #500]	; 348138d0 <add_mtd_partitions+0x648>
348136d8:	ebffd61b 	bl	34808f4c <printf>
348136dc:	e59f01f0 	ldr	r0, [pc, #496]	; 348138d4 <add_mtd_partitions+0x64c>
348136e0:	eb0019f3 	bl	34819eb4 <panic>
	} else {
		/* Single erase size */
		slave->mtd.erasesize = master->erasesize;
348136e4:	e5943010 	ldr	r3, [r4, #16]
348136e8:	e5863010 	str	r3, [r6, #16]
	}

	if ((slave->mtd.flags & MTD_WRITEABLE) &&
348136ec:	e5963004 	ldr	r3, [r6, #4]
348136f0:	e3130b01 	tst	r3, #1024	; 0x400
348136f4:	0a000013 	beq	34813748 <add_mtd_partitions+0x4c0>
	    mtd_mod_by_eb(slave->offset, &slave->mtd)) {
348136f8:	e59630b4 	ldr	r3, [r6, #180]	; 0xb4
348136fc:	e59600b0 	ldr	r0, [r6, #176]	; 0xb0
	return sz;
}

static inline uint32_t mtd_mod_by_eb(uint64_t sz, struct mtd_info *mtd)
{
	return do_div(sz, mtd->erasesize);
34813700:	e3530000 	cmp	r3, #0
			return -ENOMEM;
		cur_offset = slave->offset + slave->mtd.size;
	}

	return 0;
}
34813704:	e5961010 	ldr	r1, [r6, #16]
34813708:	e58d0020 	str	r0, [sp, #32]
3481370c:	e58d3024 	str	r3, [sp, #36]	; 0x24
34813710:	1a000001 	bne	3481371c <add_mtd_partitions+0x494>
34813714:	eb00325d 	bl	34820090 <__aeabi_uidivmod>
34813718:	ea000002 	b	34813728 <add_mtd_partitions+0x4a0>
3481371c:	e28d0020 	add	r0, sp, #32
34813720:	eb000f15 	bl	3481737c <__div64_32>
34813724:	e1a01000 	mov	r1, r0
	} else {
		/* Single erase size */
		slave->mtd.erasesize = master->erasesize;
	}

	if ((slave->mtd.flags & MTD_WRITEABLE) &&
34813728:	e3510000 	cmp	r1, #0
3481372c:	0a000005 	beq	34813748 <add_mtd_partitions+0x4c0>
	    mtd_mod_by_eb(slave->offset, &slave->mtd)) {
		/* Doesn't start on a boundary of major erase size */
		/* FIXME: Let it be writable if it is on a boundary of
		 * _minor_ erase size though */
		slave->mtd.flags &= ~MTD_WRITEABLE;
34813730:	e5963004 	ldr	r3, [r6, #4]
		printk(KERN_WARNING"mtd: partition \"%s\" doesn't start on an erase block boundary -- force read-only\n",
34813734:	e59f019c 	ldr	r0, [pc, #412]	; 348138d8 <add_mtd_partitions+0x650>
	if ((slave->mtd.flags & MTD_WRITEABLE) &&
	    mtd_mod_by_eb(slave->offset, &slave->mtd)) {
		/* Doesn't start on a boundary of major erase size */
		/* FIXME: Let it be writable if it is on a boundary of
		 * _minor_ erase size though */
		slave->mtd.flags &= ~MTD_WRITEABLE;
34813738:	e3c33b01 	bic	r3, r3, #1024	; 0x400
3481373c:	e5863004 	str	r3, [r6, #4]
		printk(KERN_WARNING"mtd: partition \"%s\" doesn't start on an erase block boundary -- force read-only\n",
34813740:	e5151020 	ldr	r1, [r5, #-32]
34813744:	ebffd600 	bl	34808f4c <printf>
			part->name);
	}
	if ((slave->mtd.flags & MTD_WRITEABLE) &&
34813748:	e5963004 	ldr	r3, [r6, #4]
3481374c:	e3130b01 	tst	r3, #1024	; 0x400
34813750:	0a000013 	beq	348137a4 <add_mtd_partitions+0x51c>
	    mtd_mod_by_eb(slave->mtd.size, &slave->mtd)) {
34813754:	e596300c 	ldr	r3, [r6, #12]
34813758:	e5960008 	ldr	r0, [r6, #8]
3481375c:	e3530000 	cmp	r3, #0
			return -ENOMEM;
		cur_offset = slave->offset + slave->mtd.size;
	}

	return 0;
}
34813760:	e5961010 	ldr	r1, [r6, #16]
34813764:	e58d0020 	str	r0, [sp, #32]
34813768:	e58d3024 	str	r3, [sp, #36]	; 0x24
3481376c:	1a000001 	bne	34813778 <add_mtd_partitions+0x4f0>
34813770:	eb003246 	bl	34820090 <__aeabi_uidivmod>
34813774:	ea000002 	b	34813784 <add_mtd_partitions+0x4fc>
34813778:	e28d0020 	add	r0, sp, #32
3481377c:	eb000efe 	bl	3481737c <__div64_32>
34813780:	e1a01000 	mov	r1, r0
		 * _minor_ erase size though */
		slave->mtd.flags &= ~MTD_WRITEABLE;
		printk(KERN_WARNING"mtd: partition \"%s\" doesn't start on an erase block boundary -- force read-only\n",
			part->name);
	}
	if ((slave->mtd.flags & MTD_WRITEABLE) &&
34813784:	e3510000 	cmp	r1, #0
34813788:	0a000005 	beq	348137a4 <add_mtd_partitions+0x51c>
	    mtd_mod_by_eb(slave->mtd.size, &slave->mtd)) {
		slave->mtd.flags &= ~MTD_WRITEABLE;
3481378c:	e5963004 	ldr	r3, [r6, #4]
		printk(KERN_WARNING"mtd: partition \"%s\" doesn't end on an erase block -- force read-only\n",
34813790:	e59f0144 	ldr	r0, [pc, #324]	; 348138dc <add_mtd_partitions+0x654>
		printk(KERN_WARNING"mtd: partition \"%s\" doesn't start on an erase block boundary -- force read-only\n",
			part->name);
	}
	if ((slave->mtd.flags & MTD_WRITEABLE) &&
	    mtd_mod_by_eb(slave->mtd.size, &slave->mtd)) {
		slave->mtd.flags &= ~MTD_WRITEABLE;
34813794:	e3c33b01 	bic	r3, r3, #1024	; 0x400
34813798:	e5863004 	str	r3, [r6, #4]
		printk(KERN_WARNING"mtd: partition \"%s\" doesn't end on an erase block -- force read-only\n",
3481379c:	e5151020 	ldr	r1, [r5, #-32]
348137a0:	ebffd5e9 	bl	34808f4c <printf>
			part->name);
	}

	slave->mtd.ecclayout = master->ecclayout;
348137a4:	e5943028 	ldr	r3, [r4, #40]	; 0x28
348137a8:	e5863028 	str	r3, [r6, #40]	; 0x28
	if (master->block_isbad) {
348137ac:	e5943078 	ldr	r3, [r4, #120]	; 0x78
348137b0:	e3530000 	cmp	r3, #0
348137b4:	13a0a000 	movne	sl, #0
348137b8:	13a0b000 	movne	fp, #0
348137bc:	1a00000d 	bne	348137f8 <add_mtd_partitions+0x570>
348137c0:	ea000013 	b	34813814 <add_mtd_partitions+0x58c>
		uint64_t offs = 0;

		while (offs < slave->mtd.size) {
			if (master->block_isbad(master,
						offs + slave->offset))
348137c4:	e1c62bd0 	ldrd	r2, [r6, #176]	; 0xb0
	slave->mtd.ecclayout = master->ecclayout;
	if (master->block_isbad) {
		uint64_t offs = 0;

		while (offs < slave->mtd.size) {
			if (master->block_isbad(master,
348137c8:	e092200a 	adds	r2, r2, sl
348137cc:	e0a3300b 	adc	r3, r3, fp
348137d0:	e5941078 	ldr	r1, [r4, #120]	; 0x78
348137d4:	e1a00004 	mov	r0, r4
348137d8:	e12fff31 	blx	r1
348137dc:	e3500000 	cmp	r0, #0
						offs + slave->offset))
				slave->mtd.ecc_stats.badblocks++;
348137e0:	15963088 	ldrne	r3, [r6, #136]	; 0x88
348137e4:	12833001 	addne	r3, r3, #1
348137e8:	15863088 	strne	r3, [r6, #136]	; 0x88
			offs += slave->mtd.erasesize;
348137ec:	e5963010 	ldr	r3, [r6, #16]
348137f0:	e09aa003 	adds	sl, sl, r3
348137f4:	e2abb000 	adc	fp, fp, #0

	slave->mtd.ecclayout = master->ecclayout;
	if (master->block_isbad) {
		uint64_t offs = 0;

		while (offs < slave->mtd.size) {
348137f8:	e596300c 	ldr	r3, [r6, #12]
348137fc:	e153000b 	cmp	r3, fp
34813800:	8affffef 	bhi	348137c4 <add_mtd_partitions+0x53c>
34813804:	1a000002 	bne	34813814 <add_mtd_partitions+0x58c>
34813808:	e5963008 	ldr	r3, [r6, #8]
3481380c:	e153000a 	cmp	r3, sl
34813810:	8affffeb 	bhi	348137c4 <add_mtd_partitions+0x53c>
			offs += slave->mtd.erasesize;
		}
	}

out_register:
	if (part->mtdp) {
34813814:	e5953000 	ldr	r3, [r5]
34813818:	e3530000 	cmp	r3, #0
		/* store the object pointer (caller may or may not register it*/
		*part->mtdp = &slave->mtd;
3481381c:	15836000 	strne	r6, [r3]
		slave->registered = 0;
34813820:	13a03000 	movne	r3, #0
			offs += slave->mtd.erasesize;
		}
	}

out_register:
	if (part->mtdp) {
34813824:	1a000002 	bne	34813834 <add_mtd_partitions+0x5ac>
		/* store the object pointer (caller may or may not register it*/
		*part->mtdp = &slave->mtd;
		slave->registered = 0;
	} else {
		/* register our partition */
		add_mtd_device(&slave->mtd);
34813828:	e1a00006 	mov	r0, r6
3481382c:	ebfffc50 	bl	34812974 <add_mtd_device>
		slave->registered = 1;
34813830:	e3a03001 	mov	r3, #1

	for (i = 0; i < nbparts; i++) {
		slave = add_one_partition(master, parts + i, i, cur_offset);
		if (!slave)
			return -ENOMEM;
		cur_offset = slave->offset + slave->mtd.size;
34813834:	e1c6a0d8 	ldrd	sl, [r6, #8]
		*part->mtdp = &slave->mtd;
		slave->registered = 0;
	} else {
		/* register our partition */
		add_mtd_device(&slave->mtd);
		slave->registered = 1;
34813838:	e58630c4 	str	r3, [r6, #196]	; 0xc4

	for (i = 0; i < nbparts; i++) {
		slave = add_one_partition(master, parts + i, i, cur_offset);
		if (!slave)
			return -ENOMEM;
		cur_offset = slave->offset + slave->mtd.size;
3481383c:	e1c62bd0 	ldrd	r2, [r6, #176]	; 0xb0
34813840:	e09aa002 	adds	sl, sl, r2
34813844:	e0abb003 	adc	fp, fp, r3
	if (mtd_partitions.next == NULL)
		INIT_LIST_HEAD(&mtd_partitions);

	printk(KERN_NOTICE "Creating %d MTD partitions on \"%s\":\n", nbparts, master->name);

	for (i = 0; i < nbparts; i++) {
34813848:	e2877001 	add	r7, r7, #1
3481384c:	e2855028 	add	r5, r5, #40	; 0x28
34813850:	e59d001c 	ldr	r0, [sp, #28]
34813854:	e1570000 	cmp	r7, r0
34813858:	bafffe9d 	blt	348132d4 <add_mtd_partitions+0x4c>
		if (!slave)
			return -ENOMEM;
		cur_offset = slave->offset + slave->mtd.size;
	}

	return 0;
3481385c:	e3a00000 	mov	r0, #0
}
34813860:	e28dd028 	add	sp, sp, #40	; 0x28
34813864:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
34813868:	3482b218 	.word	0x3482b218
3481386c:	3482716d 	.word	0x3482716d
34813870:	34827192 	.word	0x34827192
34813874:	348130c4 	.word	0x348130c4
34813878:	34812bd8 	.word	0x34812bd8
3481387c:	34812c70 	.word	0x34812c70
34813880:	3481301c 	.word	0x3481301c
34813884:	34812d08 	.word	0x34812d08
34813888:	34812b50 	.word	0x34812b50
3481388c:	34812b94 	.word	0x34812b94
34813890:	34812d94 	.word	0x34812d94
34813894:	34812dc4 	.word	0x34812dc4
34813898:	34812b80 	.word	0x34812b80
3481389c:	34812bc4 	.word	0x34812bc4
348138a0:	34812f48 	.word	0x34812f48
348138a4:	34812e88 	.word	0x34812e88
348138a8:	34812ee8 	.word	0x34812ee8
348138ac:	34812f5c 	.word	0x34812f5c
348138b0:	34812fac 	.word	0x34812fac
348138b4:	34812de0 	.word	0x34812de0
348138b8:	348271ce 	.word	0x348271ce
348138bc:	348271fb 	.word	0x348271fb
348138c0:	34827217 	.word	0x34827217
348138c4:	34827248 	.word	0x34827248
348138c8:	3482729e 	.word	0x3482729e
348138cc:	348272bb 	.word	0x348272bb
348138d0:	3482180c 	.word	0x3482180c
348138d4:	348272c5 	.word	0x348272c5
348138d8:	348272ca 	.word	0x348272ca
348138dc:	3482731b 	.word	0x3482731b

348138e0 <s3c_read_cmd>:

static struct s3c_onenand *onenand;

static int s3c_read_cmd(unsigned int cmd)
{
	return readl(onenand->ahb_addr + cmd);
348138e0:	e59f300c 	ldr	r3, [pc, #12]	; 348138f4 <s3c_read_cmd+0x14>
348138e4:	e5933000 	ldr	r3, [r3]
348138e8:	e5933008 	ldr	r3, [r3, #8]
348138ec:	e7930000 	ldr	r0, [r3, r0]
}
348138f0:	e12fff1e 	bx	lr
348138f4:	3482b220 	.word	0x3482b220

348138f8 <s3c_write_cmd>:

static void s3c_write_cmd(int value, unsigned int cmd)
{
	writel(value, onenand->ahb_addr + cmd);
348138f8:	e59f300c 	ldr	r3, [pc, #12]	; 3481390c <s3c_write_cmd+0x14>
348138fc:	e5933000 	ldr	r3, [r3]
34813900:	e5933008 	ldr	r3, [r3, #8]
34813904:	e7830001 	str	r0, [r3, r1]
}
34813908:	e12fff1e 	bx	lr
3481390c:	3482b220 	.word	0x3482b220

34813910 <s3c_mem_addr>:
	return (fba << 12) | (fpa << 6) | (fsa << 4);
}
#elif defined(CONFIG_S5P)
static unsigned int s3c_mem_addr(int fba, int fpa, int fsa)
{
	return (fba << 13) | (fpa << 7) | (fsa << 5);
34813910:	e1a00680 	lsl	r0, r0, #13
34813914:	e1800381 	orr	r0, r0, r1, lsl #7
}
34813918:	e1800282 	orr	r0, r0, r2, lsl #5
3481391c:	e12fff1e 	bx	lr

34813920 <s3c_onenand_reset>:
static void s3c_onenand_reset(void)
{
	unsigned long timeout = 0x10000;
	int stat;

	writel(ONENAND_MEM_RESET_COLD, &onenand->reg->mem_reset);
34813920:	e59f206c 	ldr	r2, [pc, #108]	; 34813994 <s3c_onenand_reset+0x74>
34813924:	e3a01002 	mov	r1, #2
34813928:	e5923000 	ldr	r3, [r2]
3481392c:	e593301c 	ldr	r3, [r3, #28]
34813930:	e5831020 	str	r1, [r3, #32]
}
#endif

static void s3c_onenand_reset(void)
{
	unsigned long timeout = 0x10000;
34813934:	e3a03801 	mov	r3, #65536	; 0x10000
	int stat;

	writel(ONENAND_MEM_RESET_COLD, &onenand->reg->mem_reset);
	while (timeout--) {
34813938:	ea000004 	b	34813950 <s3c_onenand_reset+0x30>
		stat = readl(&onenand->reg->int_err_stat);
3481393c:	e5921000 	ldr	r1, [r2]
34813940:	e591101c 	ldr	r1, [r1, #28]
34813944:	e5911030 	ldr	r1, [r1, #48]	; 0x30
		if (stat & RST_CMP)
34813948:	e3110a01 	tst	r1, #4096	; 0x1000
3481394c:	1a000001 	bne	34813958 <s3c_onenand_reset+0x38>
{
	unsigned long timeout = 0x10000;
	int stat;

	writel(ONENAND_MEM_RESET_COLD, &onenand->reg->mem_reset);
	while (timeout--) {
34813950:	e2533001 	subs	r3, r3, #1
34813954:	2afffff8 	bcs	3481393c <s3c_onenand_reset+0x1c>
		stat = readl(&onenand->reg->int_err_stat);
		if (stat & RST_CMP)
			break;
	}
	stat = readl(&onenand->reg->int_err_stat);
34813958:	e59f3034 	ldr	r3, [pc, #52]	; 34813994 <s3c_onenand_reset+0x74>
3481395c:	e5932000 	ldr	r2, [r3]
34813960:	e592201c 	ldr	r2, [r2, #28]
34813964:	e5921030 	ldr	r1, [r2, #48]	; 0x30
	writel(stat, &onenand->reg->int_err_ack);
34813968:	e5932000 	ldr	r2, [r3]
3481396c:	e592201c 	ldr	r2, [r2, #28]
34813970:	e5821050 	str	r1, [r2, #80]	; 0x50

	/* Clear interrupt */
	writel(0x0, &onenand->reg->int_err_ack);
34813974:	e5932000 	ldr	r2, [r3]
34813978:	e592101c 	ldr	r1, [r2, #28]
3481397c:	e3a02000 	mov	r2, #0
34813980:	e5812050 	str	r2, [r1, #80]	; 0x50
	/* Clear the ECC status */
	writel(0x0, &onenand->reg->ecc_err_stat);
34813984:	e5933000 	ldr	r3, [r3]
34813988:	e593301c 	ldr	r3, [r3, #28]
3481398c:	e5832060 	str	r2, [r3, #96]	; 0x60
}
34813990:	e12fff1e 	bx	lr
34813994:	3482b220 	.word	0x3482b220

34813998 <s3c_onenand_command>:
	return 0;
}

static int s3c_onenand_command(struct mtd_info *mtd, int cmd,
		loff_t addr, size_t len)
{
34813998:	e92d4ef3 	push	{r0, r1, r4, r5, r6, r7, r9, sl, fp, lr}
	struct onenand_chip *this = mtd->priv;
3481399c:	e5906094 	ldr	r6, [r0, #148]	; 0x94
	return 0;
}

static int s3c_onenand_command(struct mtd_info *mtd, int cmd,
		loff_t addr, size_t len)
{
348139a0:	e1cd20f0 	strd	r2, [sp]
348139a4:	e1a04001 	mov	r4, r1
348139a8:	e1a05000 	mov	r5, r0
	unsigned int mem_addr;
	int i, mcount, scount;
	int index;

	fba = (int) (addr >> this->erase_shift);
	fpa = (int) (addr >> this->page_shift);
348139ac:	e1a01003 	mov	r1, r3
348139b0:	e1a00002 	mov	r0, r2
348139b4:	e5962034 	ldr	r2, [r6, #52]	; 0x34
348139b8:	eb003253 	bl	3482030c <__ashrdi3>
	fpa &= this->page_mask;

	mem_addr = onenand->mem_addr(fba, fpa, fsa);
348139bc:	e59f3230 	ldr	r3, [pc, #560]	; 34813bf4 <s3c_onenand_command+0x25c>
	int i, mcount, scount;
	int index;

	fba = (int) (addr >> this->erase_shift);
	fpa = (int) (addr >> this->page_shift);
	fpa &= this->page_mask;
348139c0:	e596703c 	ldr	r7, [r6, #60]	; 0x3c

	mem_addr = onenand->mem_addr(fba, fpa, fsa);
348139c4:	e593a000 	ldr	sl, [r3]
	int i, mcount, scount;
	int index;

	fba = (int) (addr >> this->erase_shift);
	fpa = (int) (addr >> this->page_shift);
	fpa &= this->page_mask;
348139c8:	e0077000 	and	r7, r7, r0
	int fba, fpa, fsa = 0;
	unsigned int mem_addr;
	int i, mcount, scount;
	int index;

	fba = (int) (addr >> this->erase_shift);
348139cc:	e5962030 	ldr	r2, [r6, #48]	; 0x30
348139d0:	e1cd00d0 	ldrd	r0, [sp]
348139d4:	eb00324c 	bl	3482030c <__ashrdi3>
	fpa = (int) (addr >> this->page_shift);
	fpa &= this->page_mask;

	mem_addr = onenand->mem_addr(fba, fpa, fsa);
348139d8:	e1a01007 	mov	r1, r7
348139dc:	e59a3018 	ldr	r3, [sl, #24]
348139e0:	e3a02000 	mov	r2, #0
348139e4:	e12fff33 	blx	r3

	switch (cmd) {
348139e8:	e3540013 	cmp	r4, #19

	fba = (int) (addr >> this->erase_shift);
	fpa = (int) (addr >> this->page_shift);
	fpa &= this->page_mask;

	mem_addr = onenand->mem_addr(fba, fpa, fsa);
348139ec:	e1a07000 	mov	r7, r0

	switch (cmd) {
348139f0:	0a000004 	beq	34813a08 <s3c_onenand_command+0x70>
348139f4:	e3013978 	movw	r3, #6520	; 0x1978
348139f8:	e1540003 	cmp	r4, r3
348139fc:	0a000001 	beq	34813a08 <s3c_onenand_command+0x70>
34813a00:	e3540000 	cmp	r4, #0
34813a04:	1a000002 	bne	34813a14 <s3c_onenand_command+0x7c>
	case ONENAND_CMD_READ:
	case ONENAND_CMD_READOOB:
	case ONENAND_CMD_BUFFERRAM:
		ONENAND_SET_NEXT_BUFFERRAM(this);
34813a08:	e5963044 	ldr	r3, [r6, #68]	; 0x44
34813a0c:	e2233001 	eor	r3, r3, #1
34813a10:	e5863044 	str	r3, [r6, #68]	; 0x44
	index = ONENAND_CURRENT_BUFFERRAM(this);

	/*
	 * Emulate Two BufferRAMs and access with 4 bytes pointer
	 */
	m = (unsigned int *) onenand->page_buf;
34813a14:	e59f31d8 	ldr	r3, [pc, #472]	; 34813bf4 <s3c_onenand_command+0x25c>
34813a18:	e5933000 	ldr	r3, [r3]
34813a1c:	e593a010 	ldr	sl, [r3, #16]
	s = (unsigned int *) onenand->oob_buf;
34813a20:	e5939014 	ldr	r9, [r3, #20]

	if (index) {
34813a24:	e5963044 	ldr	r3, [r6, #68]	; 0x44
34813a28:	e3530000 	cmp	r3, #0
34813a2c:	0a000005 	beq	34813a48 <s3c_onenand_command+0xb0>
		m += (this->writesize >> 2);
34813a30:	e5963040 	ldr	r3, [r6, #64]	; 0x40
34813a34:	e3c33003 	bic	r3, r3, #3
34813a38:	e08aa003 	add	sl, sl, r3
		s += (mtd->oobsize >> 2);
34813a3c:	e5953018 	ldr	r3, [r5, #24]
34813a40:	e3c33003 	bic	r3, r3, #3
34813a44:	e0899003 	add	r9, r9, r3
	}

	mcount = mtd->writesize >> 2;
34813a48:	e5956014 	ldr	r6, [r5, #20]
	scount = mtd->oobsize >> 2;
34813a4c:	e5955018 	ldr	r5, [r5, #24]

	switch (cmd) {
34813a50:	e3540027 	cmp	r4, #39	; 0x27
	if (index) {
		m += (this->writesize >> 2);
		s += (mtd->oobsize >> 2);
	}

	mcount = mtd->writesize >> 2;
34813a54:	e1a06126 	lsr	r6, r6, #2
	scount = mtd->oobsize >> 2;
34813a58:	e1a05125 	lsr	r5, r5, #2

	switch (cmd) {
34813a5c:	0a000059 	beq	34813bc8 <s3c_onenand_command+0x230>
34813a60:	ca000007 	bgt	34813a84 <s3c_onenand_command+0xec>
34813a64:	e3540013 	cmp	r4, #19
34813a68:	0a00001a 	beq	34813ad8 <s3c_onenand_command+0x140>
34813a6c:	e354001a 	cmp	r4, #26
34813a70:	0a000037 	beq	34813b54 <s3c_onenand_command+0x1bc>
34813a74:	e3540000 	cmp	r4, #0
	case ONENAND_CMD_READ:
		/* Main */
		for (i = 0; i < mcount; i++)
			*m++ = s3c_read_cmd(CMD_MAP_01(mem_addr));
34813a78:	03877301 	orreq	r7, r7, #67108864	; 0x4000000
	}

	mcount = mtd->writesize >> 2;
	scount = mtd->oobsize >> 2;

	switch (cmd) {
34813a7c:	0a000012 	beq	34813acc <s3c_onenand_command+0x134>
34813a80:	ea000059 	b	34813bec <s3c_onenand_command+0x254>
34813a84:	e3540080 	cmp	r4, #128	; 0x80
34813a88:	0a000008 	beq	34813ab0 <s3c_onenand_command+0x118>
34813a8c:	ca000002 	bgt	34813a9c <s3c_onenand_command+0x104>
34813a90:	e3540071 	cmp	r4, #113	; 0x71
34813a94:	1a000054 	bne	34813bec <s3c_onenand_command+0x254>
34813a98:	ea000050 	b	34813be0 <s3c_onenand_command+0x248>
34813a9c:	e3540094 	cmp	r4, #148	; 0x94
34813aa0:	0a00004a 	beq	34813bd0 <s3c_onenand_command+0x238>
34813aa4:	e3540095 	cmp	r4, #149	; 0x95
34813aa8:	1a00004f 	bne	34813bec <s3c_onenand_command+0x254>
34813aac:	ea000049 	b	34813bd8 <s3c_onenand_command+0x240>
34813ab0:	e3a04000 	mov	r4, #0
		return 0;

	case ONENAND_CMD_PROG:
		/* Main */
		for (i = 0; i < mcount; i++)
			s3c_write_cmd(*m++, CMD_MAP_01(mem_addr));
34813ab4:	e3877301 	orr	r7, r7, #67108864	; 0x4000000
34813ab8:	ea000022 	b	34813b48 <s3c_onenand_command+0x1b0>

	switch (cmd) {
	case ONENAND_CMD_READ:
		/* Main */
		for (i = 0; i < mcount; i++)
			*m++ = s3c_read_cmd(CMD_MAP_01(mem_addr));
34813abc:	e1a00007 	mov	r0, r7
34813ac0:	ebffff86 	bl	348138e0 <s3c_read_cmd>
	scount = mtd->oobsize >> 2;

	switch (cmd) {
	case ONENAND_CMD_READ:
		/* Main */
		for (i = 0; i < mcount; i++)
34813ac4:	e2844001 	add	r4, r4, #1
			*m++ = s3c_read_cmd(CMD_MAP_01(mem_addr));
34813ac8:	e48a0004 	str	r0, [sl], #4
	scount = mtd->oobsize >> 2;

	switch (cmd) {
	case ONENAND_CMD_READ:
		/* Main */
		for (i = 0; i < mcount; i++)
34813acc:	e1540006 	cmp	r4, r6
34813ad0:	bafffff9 	blt	34813abc <s3c_onenand_command+0x124>
34813ad4:	ea000044 	b	34813bec <s3c_onenand_command+0x254>
			*m++ = s3c_read_cmd(CMD_MAP_01(mem_addr));
		return 0;

	case ONENAND_CMD_READOOB:
		writel(TSRF, &onenand->reg->trans_spare);
34813ad8:	e59f3114 	ldr	r3, [pc, #276]	; 34813bf4 <s3c_onenand_command+0x25c>
34813adc:	e3a02001 	mov	r2, #1
34813ae0:	e5933000 	ldr	r3, [r3]
		/* Main */
		for (i = 0; i < mcount; i++)
34813ae4:	e3a04000 	mov	r4, #0
		for (i = 0; i < mcount; i++)
			*m++ = s3c_read_cmd(CMD_MAP_01(mem_addr));
		return 0;

	case ONENAND_CMD_READOOB:
		writel(TSRF, &onenand->reg->trans_spare);
34813ae8:	e593301c 	ldr	r3, [r3, #28]
		/* Main */
		for (i = 0; i < mcount; i++)
			*m++ = s3c_read_cmd(CMD_MAP_01(mem_addr));
34813aec:	e387b301 	orr	fp, r7, #67108864	; 0x4000000
		for (i = 0; i < mcount; i++)
			*m++ = s3c_read_cmd(CMD_MAP_01(mem_addr));
		return 0;

	case ONENAND_CMD_READOOB:
		writel(TSRF, &onenand->reg->trans_spare);
34813af0:	e5832140 	str	r2, [r3, #320]	; 0x140
		/* Main */
		for (i = 0; i < mcount; i++)
34813af4:	ea000003 	b	34813b08 <s3c_onenand_command+0x170>
			*m++ = s3c_read_cmd(CMD_MAP_01(mem_addr));
34813af8:	e1a0000b 	mov	r0, fp
34813afc:	ebffff77 	bl	348138e0 <s3c_read_cmd>
		return 0;

	case ONENAND_CMD_READOOB:
		writel(TSRF, &onenand->reg->trans_spare);
		/* Main */
		for (i = 0; i < mcount; i++)
34813b00:	e2844001 	add	r4, r4, #1
			*m++ = s3c_read_cmd(CMD_MAP_01(mem_addr));
34813b04:	e48a0004 	str	r0, [sl], #4
		return 0;

	case ONENAND_CMD_READOOB:
		writel(TSRF, &onenand->reg->trans_spare);
		/* Main */
		for (i = 0; i < mcount; i++)
34813b08:	e1540006 	cmp	r4, r6
34813b0c:	bafffff9 	blt	34813af8 <s3c_onenand_command+0x160>
34813b10:	e3a04000 	mov	r4, #0
			*m++ = s3c_read_cmd(CMD_MAP_01(mem_addr));

		/* Spare */
		for (i = 0; i < scount; i++)
			*s++ = s3c_read_cmd(CMD_MAP_01(mem_addr));
34813b14:	e3877301 	orr	r7, r7, #67108864	; 0x4000000
34813b18:	ea000003 	b	34813b2c <s3c_onenand_command+0x194>
34813b1c:	e1a00007 	mov	r0, r7
34813b20:	ebffff6e 	bl	348138e0 <s3c_read_cmd>
		/* Main */
		for (i = 0; i < mcount; i++)
			*m++ = s3c_read_cmd(CMD_MAP_01(mem_addr));

		/* Spare */
		for (i = 0; i < scount; i++)
34813b24:	e2844001 	add	r4, r4, #1
			*s++ = s3c_read_cmd(CMD_MAP_01(mem_addr));
34813b28:	e4890004 	str	r0, [r9], #4
		/* Main */
		for (i = 0; i < mcount; i++)
			*m++ = s3c_read_cmd(CMD_MAP_01(mem_addr));

		/* Spare */
		for (i = 0; i < scount; i++)
34813b2c:	e1540005 	cmp	r4, r5
34813b30:	bafffff9 	blt	34813b1c <s3c_onenand_command+0x184>
			*s++ = s3c_read_cmd(CMD_MAP_01(mem_addr));

		writel(0, &onenand->reg->trans_spare);
34813b34:	ea00001d 	b	34813bb0 <s3c_onenand_command+0x218>
		return 0;

	case ONENAND_CMD_PROG:
		/* Main */
		for (i = 0; i < mcount; i++)
			s3c_write_cmd(*m++, CMD_MAP_01(mem_addr));
34813b38:	e49a0004 	ldr	r0, [sl], #4
34813b3c:	e1a01007 	mov	r1, r7
34813b40:	ebffff6c 	bl	348138f8 <s3c_write_cmd>
		writel(0, &onenand->reg->trans_spare);
		return 0;

	case ONENAND_CMD_PROG:
		/* Main */
		for (i = 0; i < mcount; i++)
34813b44:	e2844001 	add	r4, r4, #1
34813b48:	e1540006 	cmp	r4, r6
34813b4c:	bafffff9 	blt	34813b38 <s3c_onenand_command+0x1a0>
34813b50:	ea000025 	b	34813bec <s3c_onenand_command+0x254>
			s3c_write_cmd(*m++, CMD_MAP_01(mem_addr));
		return 0;

	case ONENAND_CMD_PROGOOB:
		writel(TSRF, &onenand->reg->trans_spare);
34813b54:	e59f3098 	ldr	r3, [pc, #152]	; 34813bf4 <s3c_onenand_command+0x25c>
34813b58:	e3a02001 	mov	r2, #1
34813b5c:	e5933000 	ldr	r3, [r3]

		/* Main - dummy write */
		for (i = 0; i < mcount; i++)
34813b60:	e3a04000 	mov	r4, #0
		for (i = 0; i < mcount; i++)
			s3c_write_cmd(*m++, CMD_MAP_01(mem_addr));
		return 0;

	case ONENAND_CMD_PROGOOB:
		writel(TSRF, &onenand->reg->trans_spare);
34813b64:	e593301c 	ldr	r3, [r3, #28]

		/* Main - dummy write */
		for (i = 0; i < mcount; i++)
			s3c_write_cmd(0xffffffff, CMD_MAP_01(mem_addr));
34813b68:	e387a301 	orr	sl, r7, #67108864	; 0x4000000
		for (i = 0; i < mcount; i++)
			s3c_write_cmd(*m++, CMD_MAP_01(mem_addr));
		return 0;

	case ONENAND_CMD_PROGOOB:
		writel(TSRF, &onenand->reg->trans_spare);
34813b6c:	e5832140 	str	r2, [r3, #320]	; 0x140

		/* Main - dummy write */
		for (i = 0; i < mcount; i++)
34813b70:	ea000003 	b	34813b84 <s3c_onenand_command+0x1ec>
			s3c_write_cmd(0xffffffff, CMD_MAP_01(mem_addr));
34813b74:	e3e00000 	mvn	r0, #0
34813b78:	e1a0100a 	mov	r1, sl
34813b7c:	ebffff5d 	bl	348138f8 <s3c_write_cmd>

	case ONENAND_CMD_PROGOOB:
		writel(TSRF, &onenand->reg->trans_spare);

		/* Main - dummy write */
		for (i = 0; i < mcount; i++)
34813b80:	e2844001 	add	r4, r4, #1
34813b84:	e1540006 	cmp	r4, r6
34813b88:	bafffff9 	blt	34813b74 <s3c_onenand_command+0x1dc>
34813b8c:	e3a04000 	mov	r4, #0
			s3c_write_cmd(0xffffffff, CMD_MAP_01(mem_addr));

		/* Spare */
		for (i = 0; i < scount; i++)
			s3c_write_cmd(*s++, CMD_MAP_01(mem_addr));
34813b90:	e3877301 	orr	r7, r7, #67108864	; 0x4000000
34813b94:	ea000003 	b	34813ba8 <s3c_onenand_command+0x210>
34813b98:	e4990004 	ldr	r0, [r9], #4
34813b9c:	e1a01007 	mov	r1, r7
34813ba0:	ebffff54 	bl	348138f8 <s3c_write_cmd>
		/* Main - dummy write */
		for (i = 0; i < mcount; i++)
			s3c_write_cmd(0xffffffff, CMD_MAP_01(mem_addr));

		/* Spare */
		for (i = 0; i < scount; i++)
34813ba4:	e2844001 	add	r4, r4, #1
34813ba8:	e1540005 	cmp	r4, r5
34813bac:	bafffff9 	blt	34813b98 <s3c_onenand_command+0x200>
			s3c_write_cmd(*s++, CMD_MAP_01(mem_addr));

		writel(0, &onenand->reg->trans_spare);
34813bb0:	e59f303c 	ldr	r3, [pc, #60]	; 34813bf4 <s3c_onenand_command+0x25c>
34813bb4:	e3a02000 	mov	r2, #0
34813bb8:	e5933000 	ldr	r3, [r3]
34813bbc:	e593301c 	ldr	r3, [r3, #28]
34813bc0:	e5832140 	str	r2, [r3, #320]	; 0x140
		return 0;
34813bc4:	ea000008 	b	34813bec <s3c_onenand_command+0x254>

	case ONENAND_CMD_UNLOCK_ALL:
		s3c_write_cmd(ONENAND_UNLOCK_ALL, CMD_MAP_10(mem_addr));
34813bc8:	e3a0000e 	mov	r0, #14
34813bcc:	ea000004 	b	34813be4 <s3c_onenand_command+0x24c>
		return 0;

	case ONENAND_CMD_ERASE:
		s3c_write_cmd(ONENAND_ERASE_START, CMD_MAP_10(mem_addr));
34813bd0:	e3a00003 	mov	r0, #3
34813bd4:	ea000002 	b	34813be4 <s3c_onenand_command+0x24c>
		return 0;

	case ONENAND_CMD_MULTIBLOCK_ERASE:
		s3c_write_cmd(ONENAND_MULTI_ERASE_SET, CMD_MAP_10(mem_addr));
34813bd8:	e3a00001 	mov	r0, #1
34813bdc:	ea000000 	b	34813be4 <s3c_onenand_command+0x24c>
		return 0;

	case ONENAND_CMD_ERASE_VERIFY:
		s3c_write_cmd(ONENAND_ERASE_VERIFY, CMD_MAP_10(mem_addr));
34813be0:	e3a00015 	mov	r0, #21
34813be4:	e3871302 	orr	r1, r7, #134217728	; 0x8000000
34813be8:	ebffff42 	bl	348138f8 <s3c_write_cmd>
	default:
		break;
	}

	return 0;
}
34813bec:	e3a00000 	mov	r0, #0
34813bf0:	e8bd8efc 	pop	{r2, r3, r4, r5, r6, r7, r9, sl, fp, pc}
34813bf4:	3482b220 	.word	0x3482b220

34813bf8 <s3c_get_bufferram>:

static unsigned char *s3c_get_bufferram(struct mtd_info *mtd, int area)
{
	struct onenand_chip *this = mtd->priv;
34813bf8:	e590c094 	ldr	ip, [r0, #148]	; 0x94
	int index = ONENAND_CURRENT_BUFFERRAM(this);
	unsigned char *p;

	if (area == ONENAND_DATARAM) {
34813bfc:	e3510b01 	cmp	r1, #1024	; 0x400

	return 0;
}

static unsigned char *s3c_get_bufferram(struct mtd_info *mtd, int area)
{
34813c00:	e1a03000 	mov	r3, r0
	struct onenand_chip *this = mtd->priv;
	int index = ONENAND_CURRENT_BUFFERRAM(this);
34813c04:	e59c2044 	ldr	r2, [ip, #68]	; 0x44
34813c08:	e59f1030 	ldr	r1, [pc, #48]	; 34813c40 <s3c_get_bufferram+0x48>
	unsigned char *p;

	if (area == ONENAND_DATARAM) {
34813c0c:	1a000005 	bne	34813c28 <s3c_get_bufferram+0x30>
		p = (unsigned char *) onenand->page_buf;
34813c10:	e5913000 	ldr	r3, [r1]
		if (index == 1)
34813c14:	e3520001 	cmp	r2, #1
	struct onenand_chip *this = mtd->priv;
	int index = ONENAND_CURRENT_BUFFERRAM(this);
	unsigned char *p;

	if (area == ONENAND_DATARAM) {
		p = (unsigned char *) onenand->page_buf;
34813c18:	e5930010 	ldr	r0, [r3, #16]
		if (index == 1)
			p += this->writesize;
34813c1c:	059c3040 	ldreq	r3, [ip, #64]	; 0x40
34813c20:	00800003 	addeq	r0, r0, r3
34813c24:	e12fff1e 	bx	lr
	} else {
		p = (unsigned char *) onenand->oob_buf;
34813c28:	e5911000 	ldr	r1, [r1]
		if (index == 1)
34813c2c:	e3520001 	cmp	r2, #1
	if (area == ONENAND_DATARAM) {
		p = (unsigned char *) onenand->page_buf;
		if (index == 1)
			p += this->writesize;
	} else {
		p = (unsigned char *) onenand->oob_buf;
34813c30:	e5910014 	ldr	r0, [r1, #20]
		if (index == 1)
			p += mtd->oobsize;
34813c34:	05933018 	ldreq	r3, [r3, #24]
34813c38:	00800003 	addeq	r0, r0, r3
	}

	return p;
}
34813c3c:	e12fff1e 	bx	lr
34813c40:	3482b220 	.word	0x3482b220

34813c44 <s3c_onenand_bbt_wait>:
	memcpy(p + offset, buffer, count);
	return 0;
}

static int s3c_onenand_bbt_wait(struct mtd_info *mtd, int state)
{
34813c44:	e92d4008 	push	{r3, lr}
	struct samsung_onenand *reg = (struct samsung_onenand *)onenand->base;
34813c48:	e59f3078 	ldr	r3, [pc, #120]	; 34813cc8 <s3c_onenand_bbt_wait+0x84>
34813c4c:	e5933000 	ldr	r3, [r3]
34813c50:	e5932004 	ldr	r2, [r3, #4]
	unsigned int flags = INT_ACT | LOAD_CMP;
	unsigned int stat;
	unsigned long timeout = 0x10000;
34813c54:	e3a03801 	mov	r3, #65536	; 0x10000

	while (timeout--) {
34813c58:	ea000002 	b	34813c68 <s3c_onenand_bbt_wait+0x24>
		stat = readl(&reg->int_err_stat);
34813c5c:	e5921030 	ldr	r1, [r2, #48]	; 0x30
		if (stat & flags)
34813c60:	e3110e41 	tst	r1, #1040	; 0x410
34813c64:	1a000001 	bne	34813c70 <s3c_onenand_bbt_wait+0x2c>
	struct samsung_onenand *reg = (struct samsung_onenand *)onenand->base;
	unsigned int flags = INT_ACT | LOAD_CMP;
	unsigned int stat;
	unsigned long timeout = 0x10000;

	while (timeout--) {
34813c68:	e2533001 	subs	r3, r3, #1
34813c6c:	2afffffa 	bcs	34813c5c <s3c_onenand_bbt_wait+0x18>
		stat = readl(&reg->int_err_stat);
		if (stat & flags)
			break;
	}
	/* To get correct interrupt status in timeout case */
	stat = readl(&onenand->reg->int_err_stat);
34813c70:	e59f3050 	ldr	r3, [pc, #80]	; 34813cc8 <s3c_onenand_bbt_wait+0x84>
34813c74:	e5932000 	ldr	r2, [r3]
34813c78:	e592201c 	ldr	r2, [r2, #28]
34813c7c:	e5920030 	ldr	r0, [r2, #48]	; 0x30
	writel(stat, &onenand->reg->int_err_ack);
34813c80:	e5933000 	ldr	r3, [r3]

	if (stat & LD_FAIL_ECC_ERR) {
34813c84:	e3100001 	tst	r0, #1
		if (stat & flags)
			break;
	}
	/* To get correct interrupt status in timeout case */
	stat = readl(&onenand->reg->int_err_stat);
	writel(stat, &onenand->reg->int_err_ack);
34813c88:	e593301c 	ldr	r3, [r3, #28]
34813c8c:	e5830050 	str	r0, [r3, #80]	; 0x50

	if (stat & LD_FAIL_ECC_ERR) {
34813c90:	0a000002 	beq	34813ca0 <s3c_onenand_bbt_wait+0x5c>
		s3c_onenand_reset();
34813c94:	ebffff21 	bl	34813920 <s3c_onenand_reset>
		return ONENAND_BBT_READ_ERROR;
34813c98:	e3a00001 	mov	r0, #1
34813c9c:	e8bd8008 	pop	{r3, pc}
	}

	if (stat & LOAD_CMP) {
34813ca0:	e2100010 	ands	r0, r0, #16
34813ca4:	08bd8008 	popeq	{r3, pc}
		int ecc = readl(&onenand->reg->ecc_err_stat);
34813ca8:	e5933060 	ldr	r3, [r3, #96]	; 0x60
		if (ecc & ONENAND_ECC_4BIT_UNCORRECTABLE) {
34813cac:	e3010010 	movw	r0, #4112	; 0x1010
34813cb0:	e0030000 	and	r0, r3, r0
34813cb4:	e3500000 	cmp	r0, #0
34813cb8:	08bd8008 	popeq	{r3, pc}
			s3c_onenand_reset();
34813cbc:	ebffff17 	bl	34813920 <s3c_onenand_reset>
			return ONENAND_BBT_READ_ERROR;
34813cc0:	e3a00001 	mov	r0, #1
		}
	}

	return 0;
}
34813cc4:	e8bd8008 	pop	{r3, pc}
34813cc8:	3482b220 	.word	0x3482b220

34813ccc <onenand_write_bufferram>:
}

static int onenand_write_bufferram(struct mtd_info *mtd, loff_t addr, int area,
				   const unsigned char *buffer, int offset,
				   size_t count)
{
34813ccc:	e92d4008 	push	{r3, lr}
	unsigned char *p;

	p = s3c_get_bufferram(mtd, area);
34813cd0:	e59d1008 	ldr	r1, [sp, #8]
34813cd4:	ebffffc7 	bl	34813bf8 <s3c_get_bufferram>
	memcpy(p + offset, buffer, count);
34813cd8:	e59d3010 	ldr	r3, [sp, #16]
34813cdc:	e59d100c 	ldr	r1, [sp, #12]
34813ce0:	e0800003 	add	r0, r0, r3
34813ce4:	e59d2014 	ldr	r2, [sp, #20]
34813ce8:	eb001468 	bl	34818e90 <memcpy>
	return 0;
}
34813cec:	e3a00000 	mov	r0, #0
34813cf0:	e8bd8008 	pop	{r3, pc}

34813cf4 <onenand_read_bufferram>:
}

static int onenand_read_bufferram(struct mtd_info *mtd, loff_t addr, int area,
				  unsigned char *buffer, int offset,
				  size_t count)
{
34813cf4:	e92d4008 	push	{r3, lr}
	unsigned char *p;

	p = s3c_get_bufferram(mtd, area);
34813cf8:	e59d1008 	ldr	r1, [sp, #8]
34813cfc:	ebffffbd 	bl	34813bf8 <s3c_get_bufferram>
	memcpy(buffer, p + offset, count);
34813d00:	e59d1010 	ldr	r1, [sp, #16]
34813d04:	e59d2014 	ldr	r2, [sp, #20]
34813d08:	e0801001 	add	r1, r0, r1
34813d0c:	e59d000c 	ldr	r0, [sp, #12]
34813d10:	eb00145e 	bl	34818e90 <memcpy>
	return 0;
}
34813d14:	e3a00000 	mov	r0, #0
34813d18:	e8bd8008 	pop	{r3, pc}

34813d1c <s3c_onenand_wait>:
				__func__, stat);
		if (stat & LOCKED_BLK)
			printk(KERN_INFO "%s: it's locked error = 0x%04x\n",
					__func__, stat);

		return -EIO;
34813d1c:	e2411001 	sub	r1, r1, #1
34813d20:	e3510007 	cmp	r1, #7

	s3c_write_cmd(value, CMD_MAP_11(word_addr));
}

static int s3c_onenand_wait(struct mtd_info *mtd, int state)
{
34813d24:	e92d4038 	push	{r3, r4, r5, lr}
				__func__, stat);
		if (stat & LOCKED_BLK)
			printk(KERN_INFO "%s: it's locked error = 0x%04x\n",
					__func__, stat);

		return -EIO;
34813d28:	959f30d8 	ldrls	r3, [pc, #216]	; 34813e08 <s3c_onenand_wait+0xec>

	s3c_write_cmd(value, CMD_MAP_11(word_addr));
}

static int s3c_onenand_wait(struct mtd_info *mtd, int state)
{
34813d2c:	e1a05000 	mov	r5, r0
				__func__, stat);
		if (stat & LOCKED_BLK)
			printk(KERN_INFO "%s: it's locked error = 0x%04x\n",
					__func__, stat);

		return -EIO;
34813d30:	97932101 	ldrls	r2, [r3, r1, lsl #2]
34813d34:	9a000007 	bls	34813d58 <s3c_onenand_wait+0x3c>
34813d38:	ea000005 	b	34813d54 <s3c_onenand_wait+0x38>
	default:
		break;
	}

	while (timeout--) {
		stat = readl(&onenand->reg->int_err_stat);
34813d3c:	e5910000 	ldr	r0, [r1]
34813d40:	e590001c 	ldr	r0, [r0, #28]
34813d44:	e5900030 	ldr	r0, [r0, #48]	; 0x30
		if (stat & flags)
34813d48:	e1120000 	tst	r2, r0
34813d4c:	0a000003 	beq	34813d60 <s3c_onenand_wait+0x44>
34813d50:	ea000004 	b	34813d68 <s3c_onenand_wait+0x4c>

	s3c_write_cmd(value, CMD_MAP_11(word_addr));
}

static int s3c_onenand_wait(struct mtd_info *mtd, int state)
{
34813d54:	e3a02b01 	mov	r2, #1024	; 0x400
	default:
		break;
	}

	while (timeout--) {
		stat = readl(&onenand->reg->int_err_stat);
34813d58:	e59f10ac 	ldr	r1, [pc, #172]	; 34813e0c <s3c_onenand_wait+0xf0>

	s3c_write_cmd(value, CMD_MAP_11(word_addr));
}

static int s3c_onenand_wait(struct mtd_info *mtd, int state)
{
34813d5c:	e3a03601 	mov	r3, #1048576	; 0x100000
		break;
	default:
		break;
	}

	while (timeout--) {
34813d60:	e2533001 	subs	r3, r3, #1
34813d64:	2afffff4 	bcs	34813d3c <s3c_onenand_wait+0x20>
		if (stat & flags)
			break;
	}

	/* To get correct interrupt status in timeout case */
	stat = readl(&onenand->reg->int_err_stat);
34813d68:	e59f309c 	ldr	r3, [pc, #156]	; 34813e0c <s3c_onenand_wait+0xf0>
34813d6c:	e5932000 	ldr	r2, [r3]
34813d70:	e592201c 	ldr	r2, [r2, #28]
34813d74:	e5924030 	ldr	r4, [r2, #48]	; 0x30
	writel(stat, &onenand->reg->int_err_ack);
34813d78:	e5933000 	ldr	r3, [r3]
	/*
	 * In the Spec. it checks the controller status first
	 * However if you get the correct information in case of
	 * power off recovery (POR) test, it should read ECC status first
	 */
	if (stat & LOAD_CMP) {
34813d7c:	e3140010 	tst	r4, #16
			break;
	}

	/* To get correct interrupt status in timeout case */
	stat = readl(&onenand->reg->int_err_stat);
	writel(stat, &onenand->reg->int_err_ack);
34813d80:	e593301c 	ldr	r3, [r3, #28]
34813d84:	e5834050 	str	r4, [r3, #80]	; 0x50
	/*
	 * In the Spec. it checks the controller status first
	 * However if you get the correct information in case of
	 * power off recovery (POR) test, it should read ECC status first
	 */
	if (stat & LOAD_CMP) {
34813d88:	0a00000c 	beq	34813dc0 <s3c_onenand_wait+0xa4>
		ecc = readl(&onenand->reg->ecc_err_stat);
34813d8c:	e5932060 	ldr	r2, [r3, #96]	; 0x60
		if (ecc & ONENAND_ECC_4BIT_UNCORRECTABLE) {
34813d90:	e3013010 	movw	r3, #4112	; 0x1010
34813d94:	e0023003 	and	r3, r2, r3
34813d98:	e3530000 	cmp	r3, #0
34813d9c:	0a000007 	beq	34813dc0 <s3c_onenand_wait+0xa4>
			printk(KERN_INFO "%s: ECC error = 0x%04x\n",
34813da0:	e59f0068 	ldr	r0, [pc, #104]	; 34813e10 <s3c_onenand_wait+0xf4>
34813da4:	e59f1068 	ldr	r1, [pc, #104]	; 34813e14 <s3c_onenand_wait+0xf8>
34813da8:	ebffd467 	bl	34808f4c <printf>
					__func__, ecc);
			mtd->ecc_stats.failed++;
34813dac:	e5953084 	ldr	r3, [r5, #132]	; 0x84
			return -EBADMSG;
34813db0:	e3e00049 	mvn	r0, #73	; 0x49
	if (stat & LOAD_CMP) {
		ecc = readl(&onenand->reg->ecc_err_stat);
		if (ecc & ONENAND_ECC_4BIT_UNCORRECTABLE) {
			printk(KERN_INFO "%s: ECC error = 0x%04x\n",
					__func__, ecc);
			mtd->ecc_stats.failed++;
34813db4:	e2833001 	add	r3, r3, #1
34813db8:	e5853084 	str	r3, [r5, #132]	; 0x84
			return -EBADMSG;
34813dbc:	e8bd8038 	pop	{r3, r4, r5, pc}
		}
	}

	if (stat & (LOCKED_BLK | ERS_FAIL | PGM_FAIL | LD_FAIL_ECC_ERR)) {
34813dc0:	e300010d 	movw	r0, #269	; 0x10d
34813dc4:	e0040000 	and	r0, r4, r0
34813dc8:	e3500000 	cmp	r0, #0
34813dcc:	08bd8038 	popeq	{r3, r4, r5, pc}
		printk(KERN_INFO "%s: controller error = 0x%04x\n",
34813dd0:	e59f0040 	ldr	r0, [pc, #64]	; 34813e18 <s3c_onenand_wait+0xfc>
34813dd4:	e59f1038 	ldr	r1, [pc, #56]	; 34813e14 <s3c_onenand_wait+0xf8>
34813dd8:	e1a02004 	mov	r2, r4
34813ddc:	ebffd45a 	bl	34808f4c <printf>
				__func__, stat);
		if (stat & LOCKED_BLK)
34813de0:	e3140c01 	tst	r4, #256	; 0x100
34813de4:	0a000005 	beq	34813e00 <s3c_onenand_wait+0xe4>
			printk(KERN_INFO "%s: it's locked error = 0x%04x\n",
34813de8:	e59f002c 	ldr	r0, [pc, #44]	; 34813e1c <s3c_onenand_wait+0x100>
34813dec:	e59f1020 	ldr	r1, [pc, #32]	; 34813e14 <s3c_onenand_wait+0xf8>
34813df0:	e1a02004 	mov	r2, r4
34813df4:	ebffd454 	bl	34808f4c <printf>
					__func__, stat);

		return -EIO;
34813df8:	e3e00004 	mvn	r0, #4
34813dfc:	e8bd8038 	pop	{r3, r4, r5, pc}
34813e00:	e3e00004 	mvn	r0, #4
	}

	return 0;
}
34813e04:	e8bd8038 	pop	{r3, r4, r5, pc}
34813e08:	34821820 	.word	0x34821820
34813e0c:	3482b220 	.word	0x3482b220
34813e10:	34827361 	.word	0x34827361
34813e14:	34821840 	.word	0x34821840
34813e18:	34827379 	.word	0x34827379
34813e1c:	34827398 	.word	0x34827398

34813e20 <s3c_onenand_writew>:
	return value;
}

static void s3c_onenand_writew(unsigned short value, void __iomem *addr)
{
	struct onenand_chip *this = onenand->mtd->priv;
34813e20:	e59f20c8 	ldr	r2, [pc, #200]	; 34813ef0 <s3c_onenand_writew+0xd0>
		" at reg 0x%x, value 0x%x\n", word_addr, value);
	return value;
}

static void s3c_onenand_writew(unsigned short value, void __iomem *addr)
{
34813e24:	e92d4070 	push	{r4, r5, r6, lr}
	struct onenand_chip *this = onenand->mtd->priv;
34813e28:	e5923000 	ldr	r3, [r2]
		" at reg 0x%x, value 0x%x\n", word_addr, value);
	return value;
}

static void s3c_onenand_writew(unsigned short value, void __iomem *addr)
{
34813e2c:	e1a04000 	mov	r4, r0
	struct onenand_chip *this = onenand->mtd->priv;
34813e30:	e5930000 	ldr	r0, [r3]
	int reg = addr - this->base;
34813e34:	e5900094 	ldr	r0, [r0, #148]	; 0x94
34813e38:	e5905000 	ldr	r5, [r0]
34813e3c:	e0655001 	rsb	r5, r5, r1
	int word_addr = reg >> 1;

	/* It's used for probing time */
	switch (reg) {
34813e40:	e59f10ac 	ldr	r1, [pc, #172]	; 34813ef4 <s3c_onenand_writew+0xd4>
34813e44:	e1550001 	cmp	r5, r1
34813e48:	08bd8070 	popeq	{r4, r5, r6, pc}
34813e4c:	ca000003 	bgt	34813e60 <s3c_onenand_writew+0x40>
34813e50:	e59f20a0 	ldr	r2, [pc, #160]	; 34813ef8 <s3c_onenand_writew+0xd8>
34813e54:	e1550002 	cmp	r5, r2
34813e58:	1a00000b 	bne	34813e8c <s3c_onenand_writew+0x6c>
34813e5c:	e8bd8070 	pop	{r4, r5, r6, pc}
34813e60:	e59f1094 	ldr	r1, [pc, #148]	; 34813efc <s3c_onenand_writew+0xdc>
34813e64:	e1550001 	cmp	r5, r1
34813e68:	0a000003 	beq	34813e7c <s3c_onenand_writew+0x5c>
34813e6c:	e59f208c 	ldr	r2, [pc, #140]	; 34813f00 <s3c_onenand_writew+0xe0>
34813e70:	e1550002 	cmp	r5, r2
34813e74:	1a000004 	bne	34813e8c <s3c_onenand_writew+0x6c>
34813e78:	e8bd8070 	pop	{r4, r5, r6, pc}
	case ONENAND_REG_SYS_CFG1:
		writel(value, &onenand->reg->mem_cfg);
34813e7c:	e5923000 	ldr	r3, [r2]
34813e80:	e593301c 	ldr	r3, [r3, #28]
34813e84:	e5834000 	str	r4, [r3]
		return;
34813e88:	e8bd8070 	pop	{r4, r5, r6, pc}
	default:
		break;
	}

	/* BootRAM access control */
	if (reg < ONENAND_DATARAM) {
34813e8c:	e3550b01 	cmp	r5, #1024	; 0x400
34813e90:	aa00000c 	bge	34813ec8 <s3c_onenand_writew+0xa8>
		if (value == ONENAND_CMD_READID) {
34813e94:	e3540090 	cmp	r4, #144	; 0x90
			onenand->bootram_command = 1;
34813e98:	03a02001 	moveq	r2, #1
		break;
	}

	/* BootRAM access control */
	if (reg < ONENAND_DATARAM) {
		if (value == ONENAND_CMD_READID) {
34813e9c:	0a000007 	beq	34813ec0 <s3c_onenand_writew+0xa0>
			onenand->bootram_command = 1;
			return;
		}
		if (value == ONENAND_CMD_RESET) {
34813ea0:	e35400f0 	cmp	r4, #240	; 0xf0
34813ea4:	1a000007 	bne	34813ec8 <s3c_onenand_writew+0xa8>
			writel(ONENAND_MEM_RESET_COLD,
34813ea8:	e59f3040 	ldr	r3, [pc, #64]	; 34813ef0 <s3c_onenand_writew+0xd0>
34813eac:	e3a01002 	mov	r1, #2
34813eb0:	e5933000 	ldr	r3, [r3]
34813eb4:	e593201c 	ldr	r2, [r3, #28]
34813eb8:	e5821020 	str	r1, [r2, #32]
					&onenand->reg->mem_reset);
			onenand->bootram_command = 0;
34813ebc:	e3a02000 	mov	r2, #0
34813ec0:	e583200c 	str	r2, [r3, #12]
34813ec4:	e8bd8070 	pop	{r4, r5, r6, pc}

static void s3c_onenand_writew(unsigned short value, void __iomem *addr)
{
	struct onenand_chip *this = onenand->mtd->priv;
	int reg = addr - this->base;
	int word_addr = reg >> 1;
34813ec8:	e1a050c5 	asr	r5, r5, #1
			onenand->bootram_command = 0;
			return;
		}
	}

	printk(KERN_INFO "s3c_onenand_writew: Illegal access"
34813ecc:	e1a01005 	mov	r1, r5
34813ed0:	e1a02004 	mov	r2, r4
34813ed4:	e59f0028 	ldr	r0, [pc, #40]	; 34813f04 <s3c_onenand_writew+0xe4>
34813ed8:	ebffd41b 	bl	34808f4c <printf>
		" at reg 0x%x, value 0x%x\n", word_addr, value);

	s3c_write_cmd(value, CMD_MAP_11(word_addr));
34813edc:	e1a01105 	lsl	r1, r5, #2
34813ee0:	e1a00004 	mov	r0, r4
34813ee4:	e3811303 	orr	r1, r1, #201326592	; 0xc000000
}
34813ee8:	e8bd4070 	pop	{r4, r5, r6, lr}
	}

	printk(KERN_INFO "s3c_onenand_writew: Illegal access"
		" at reg 0x%x, value 0x%x\n", word_addr, value);

	s3c_write_cmd(value, CMD_MAP_11(word_addr));
34813eec:	eafffe81 	b	348138f8 <s3c_write_cmd>
34813ef0:	3482b220 	.word	0x3482b220
34813ef4:	0001e202 	.word	0x0001e202
34813ef8:	0001e200 	.word	0x0001e200
34813efc:	0001e442 	.word	0x0001e442
34813f00:	0001e498 	.word	0x0001e498
34813f04:	348273b8 	.word	0x348273b8

34813f08 <s3c_onenand_readw>:
	/* Clear the ECC status */
	writel(0x0, &onenand->reg->ecc_err_stat);
}

static unsigned short s3c_onenand_readw(void __iomem *addr)
{
34813f08:	e92d4038 	push	{r3, r4, r5, lr}
	struct onenand_chip *this = onenand->mtd->priv;
34813f0c:	e59f3154 	ldr	r3, [pc, #340]	; 34814068 <s3c_onenand_readw+0x160>
	int reg = addr - this->base;
	int word_addr = reg >> 1;
	int value;

	/* It's used for probing time */
	switch (reg) {
34813f10:	e59f1154 	ldr	r1, [pc, #340]	; 3481406c <s3c_onenand_readw+0x164>
	writel(0x0, &onenand->reg->ecc_err_stat);
}

static unsigned short s3c_onenand_readw(void __iomem *addr)
{
	struct onenand_chip *this = onenand->mtd->priv;
34813f14:	e5933000 	ldr	r3, [r3]
34813f18:	e5932000 	ldr	r2, [r3]
	int reg = addr - this->base;
34813f1c:	e5922094 	ldr	r2, [r2, #148]	; 0x94
34813f20:	e5922000 	ldr	r2, [r2]
34813f24:	e0622000 	rsb	r2, r2, r0
	int word_addr = reg >> 1;
	int value;

	/* It's used for probing time */
	switch (reg) {
34813f28:	e1520001 	cmp	r2, r1
34813f2c:	0a000022 	beq	34813fbc <s3c_onenand_readw+0xb4>
34813f30:	ca000008 	bgt	34813f58 <s3c_onenand_readw+0x50>
34813f34:	e2411004 	sub	r1, r1, #4
34813f38:	e1520001 	cmp	r2, r1
34813f3c:	0a000018 	beq	34813fa4 <s3c_onenand_readw+0x9c>
34813f40:	e2811002 	add	r1, r1, #2
34813f44:	e1520001 	cmp	r2, r1
34813f48:	0a000018 	beq	34813fb0 <s3c_onenand_readw+0xa8>
34813f4c:	e3520a1e 	cmp	r2, #122880	; 0x1e000
34813f50:	1a000022 	bne	34813fe0 <s3c_onenand_readw+0xd8>
34813f54:	ea00000f 	b	34813f98 <s3c_onenand_readw+0x90>
34813f58:	e59f1110 	ldr	r1, [pc, #272]	; 34814070 <s3c_onenand_readw+0x168>
34813f5c:	e1520001 	cmp	r2, r1
34813f60:	0a00001b 	beq	34813fd4 <s3c_onenand_readw+0xcc>
34813f64:	ca000003 	bgt	34813f78 <s3c_onenand_readw+0x70>
34813f68:	e59f1104 	ldr	r1, [pc, #260]	; 34814074 <s3c_onenand_readw+0x16c>
34813f6c:	e1520001 	cmp	r2, r1
34813f70:	1a00001a 	bne	34813fe0 <s3c_onenand_readw+0xd8>
34813f74:	ea000013 	b	34813fc8 <s3c_onenand_readw+0xc0>
34813f78:	e59f10f8 	ldr	r1, [pc, #248]	; 34814078 <s3c_onenand_readw+0x170>
34813f7c:	e1520001 	cmp	r2, r1
	case ONENAND_REG_SYS_CFG1:
		return readl(&onenand->reg->mem_cfg);

	/* Used at unlock all status */
	case ONENAND_REG_CTRL_STATUS:
		return 0;
34813f80:	03a00000 	moveq	r0, #0
	int reg = addr - this->base;
	int word_addr = reg >> 1;
	int value;

	/* It's used for probing time */
	switch (reg) {
34813f84:	08bd8038 	popeq	{r3, r4, r5, pc}
34813f88:	e281101c 	add	r1, r1, #28
34813f8c:	e1520001 	cmp	r2, r1
34813f90:	1a000012 	bne	34813fe0 <s3c_onenand_readw+0xd8>
34813f94:	ea000031 	b	34814060 <s3c_onenand_readw+0x158>
	case ONENAND_REG_MANUFACTURER_ID:
		return readl(&onenand->reg->manufact_id);
34813f98:	e593301c 	ldr	r3, [r3, #28]
34813f9c:	e5930070 	ldr	r0, [r3, #112]	; 0x70
34813fa0:	ea000018 	b	34814008 <s3c_onenand_readw+0x100>
	case ONENAND_REG_DEVICE_ID:
		return readl(&onenand->reg->device_id);
34813fa4:	e593301c 	ldr	r3, [r3, #28]
34813fa8:	e5930080 	ldr	r0, [r3, #128]	; 0x80
34813fac:	ea000015 	b	34814008 <s3c_onenand_readw+0x100>
	case ONENAND_REG_VERSION_ID:
		return readl(&onenand->reg->flash_ver_id);
34813fb0:	e593301c 	ldr	r3, [r3, #28]
34813fb4:	e59301f0 	ldr	r0, [r3, #496]	; 0x1f0
34813fb8:	ea000012 	b	34814008 <s3c_onenand_readw+0x100>
	case ONENAND_REG_DATA_BUFFER_SIZE:
		return readl(&onenand->reg->data_buf_size);
34813fbc:	e593301c 	ldr	r3, [r3, #28]
34813fc0:	e5930090 	ldr	r0, [r3, #144]	; 0x90
34813fc4:	ea00000f 	b	34814008 <s3c_onenand_readw+0x100>
	case ONENAND_REG_TECHNOLOGY:
		return readl(&onenand->reg->tech);
34813fc8:	e593301c 	ldr	r3, [r3, #28]
34813fcc:	e59300c0 	ldr	r0, [r3, #192]	; 0xc0
34813fd0:	ea00000c 	b	34814008 <s3c_onenand_readw+0x100>
	case ONENAND_REG_SYS_CFG1:
		return readl(&onenand->reg->mem_cfg);
34813fd4:	e593301c 	ldr	r3, [r3, #28]
34813fd8:	e5930000 	ldr	r0, [r3]
34813fdc:	ea000009 	b	34814008 <s3c_onenand_readw+0x100>
	default:
		break;
	}

	/* BootRAM access control */
	if (reg < ONENAND_DATARAM && onenand->bootram_command) {
34813fe0:	e3520b01 	cmp	r2, #1024	; 0x400

static unsigned short s3c_onenand_readw(void __iomem *addr)
{
	struct onenand_chip *this = onenand->mtd->priv;
	int reg = addr - this->base;
	int word_addr = reg >> 1;
34813fe4:	e1a050c2 	asr	r5, r2, #1
	default:
		break;
	}

	/* BootRAM access control */
	if (reg < ONENAND_DATARAM && onenand->bootram_command) {
34813fe8:	aa000012 	bge	34814038 <s3c_onenand_readw+0x130>
34813fec:	e593200c 	ldr	r2, [r3, #12]
34813ff0:	e3520000 	cmp	r2, #0
34813ff4:	0a00000f 	beq	34814038 <s3c_onenand_readw+0x130>
		if (word_addr == 0)
34813ff8:	e3550000 	cmp	r5, #0
34813ffc:	1a000003 	bne	34814010 <s3c_onenand_readw+0x108>
			return readl(&onenand->reg->manufact_id);
34814000:	e593301c 	ldr	r3, [r3, #28]
34814004:	e5930070 	ldr	r0, [r3, #112]	; 0x70
34814008:	e6ff0070 	uxth	r0, r0
3481400c:	e8bd8038 	pop	{r3, r4, r5, pc}
		if (word_addr == 1)
34814010:	e3550001 	cmp	r5, #1
34814014:	1a000002 	bne	34814024 <s3c_onenand_readw+0x11c>
			return readl(&onenand->reg->device_id);
34814018:	e593301c 	ldr	r3, [r3, #28]
3481401c:	e5930080 	ldr	r0, [r3, #128]	; 0x80
34814020:	eafffff8 	b	34814008 <s3c_onenand_readw+0x100>
		if (word_addr == 2)
34814024:	e3550002 	cmp	r5, #2
34814028:	1a000002 	bne	34814038 <s3c_onenand_readw+0x130>
			return readl(&onenand->reg->flash_ver_id);
3481402c:	e593301c 	ldr	r3, [r3, #28]
34814030:	e59301f0 	ldr	r0, [r3, #496]	; 0x1f0
34814034:	eafffff3 	b	34814008 <s3c_onenand_readw+0x100>
	}

	value = s3c_read_cmd(CMD_MAP_11(word_addr)) & 0xffff;
34814038:	e1a00105 	lsl	r0, r5, #2
3481403c:	e3800303 	orr	r0, r0, #201326592	; 0xc000000
34814040:	ebfffe26 	bl	348138e0 <s3c_read_cmd>
34814044:	e6ff4070 	uxth	r4, r0
	printk(KERN_INFO "s3c_onenand_readw:  Illegal access"
34814048:	e1a01005 	mov	r1, r5
3481404c:	e59f0028 	ldr	r0, [pc, #40]	; 3481407c <s3c_onenand_readw+0x174>
34814050:	e1a02004 	mov	r2, r4
34814054:	ebffd3bc 	bl	34808f4c <printf>
		" at reg 0x%x, value 0x%x\n", word_addr, value);
	return value;
34814058:	e6ff0074 	uxth	r0, r4
3481405c:	e8bd8038 	pop	{r3, r4, r5, pc}
	/* Used at unlock all status */
	case ONENAND_REG_CTRL_STATUS:
		return 0;

	case ONENAND_REG_WP_STATUS:
		return ONENAND_WP_US;
34814060:	e3a00004 	mov	r0, #4

	value = s3c_read_cmd(CMD_MAP_11(word_addr)) & 0xffff;
	printk(KERN_INFO "s3c_onenand_readw:  Illegal access"
		" at reg 0x%x, value 0x%x\n", word_addr, value);
	return value;
}
34814064:	e8bd8038 	pop	{r3, r4, r5, pc}
34814068:	3482b220 	.word	0x3482b220
3481406c:	0001e006 	.word	0x0001e006
34814070:	0001e442 	.word	0x0001e442
34814074:	0001e00c 	.word	0x0001e00c
34814078:	0001e480 	.word	0x0001e480
3481407c:	348273f4 	.word	0x348273f4

34814080 <s3c_onenand_check_lock_status.clone.0>:
	}

	return 0;
}

static void s3c_onenand_check_lock_status(struct mtd_info *mtd)
34814080:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
{
	struct onenand_chip *this = mtd->priv;
	unsigned int block, end;

	end = this->chipsize >> this->erase_shift;
34814084:	e5907018 	ldr	r7, [r0, #24]
34814088:	e5903030 	ldr	r3, [r0, #48]	; 0x30

	for (block = 0; block < end; block++) {
3481408c:	e3a04000 	mov	r4, #0
static void s3c_onenand_check_lock_status(struct mtd_info *mtd)
{
	struct onenand_chip *this = mtd->priv;
	unsigned int block, end;

	end = this->chipsize >> this->erase_shift;
34814090:	e1a07337 	lsr	r7, r7, r3

	for (block = 0; block < end; block++) {
		s3c_read_cmd(CMD_MAP_01(onenand->mem_addr(block, 0, 0)));
34814094:	e59f5060 	ldr	r5, [pc, #96]	; 348140fc <s3c_onenand_check_lock_status.clone.0+0x7c>

		if (readl(&onenand->reg->int_err_stat) & LOCKED_BLK) {
			printf("block %d is write-protected!\n", block);
			writel(LOCKED_BLK, &onenand->reg->int_err_ack);
34814098:	e3a06c01 	mov	r6, #256	; 0x100
3481409c:	ea000013 	b	348140f0 <s3c_onenand_check_lock_status.clone.0+0x70>
	unsigned int block, end;

	end = this->chipsize >> this->erase_shift;

	for (block = 0; block < end; block++) {
		s3c_read_cmd(CMD_MAP_01(onenand->mem_addr(block, 0, 0)));
348140a0:	e5953000 	ldr	r3, [r5]
348140a4:	e3a01000 	mov	r1, #0
348140a8:	e5933018 	ldr	r3, [r3, #24]
348140ac:	e1a02001 	mov	r2, r1
348140b0:	e1a00004 	mov	r0, r4
348140b4:	e12fff33 	blx	r3
348140b8:	e3800301 	orr	r0, r0, #67108864	; 0x4000000
348140bc:	ebfffe07 	bl	348138e0 <s3c_read_cmd>

		if (readl(&onenand->reg->int_err_stat) & LOCKED_BLK) {
348140c0:	e5953000 	ldr	r3, [r5]
348140c4:	e593301c 	ldr	r3, [r3, #28]
348140c8:	e5933030 	ldr	r3, [r3, #48]	; 0x30
348140cc:	e3130c01 	tst	r3, #256	; 0x100
348140d0:	0a000005 	beq	348140ec <s3c_onenand_check_lock_status.clone.0+0x6c>
			printf("block %d is write-protected!\n", block);
348140d4:	e1a01004 	mov	r1, r4
348140d8:	e59f0020 	ldr	r0, [pc, #32]	; 34814100 <s3c_onenand_check_lock_status.clone.0+0x80>
348140dc:	ebffd39a 	bl	34808f4c <printf>
			writel(LOCKED_BLK, &onenand->reg->int_err_ack);
348140e0:	e5953000 	ldr	r3, [r5]
348140e4:	e593301c 	ldr	r3, [r3, #28]
348140e8:	e5836050 	str	r6, [r3, #80]	; 0x50
	struct onenand_chip *this = mtd->priv;
	unsigned int block, end;

	end = this->chipsize >> this->erase_shift;

	for (block = 0; block < end; block++) {
348140ec:	e2844001 	add	r4, r4, #1
348140f0:	e1540007 	cmp	r4, r7
348140f4:	3affffe9 	bcc	348140a0 <s3c_onenand_check_lock_status.clone.0+0x20>
		if (readl(&onenand->reg->int_err_stat) & LOCKED_BLK) {
			printf("block %d is write-protected!\n", block);
			writel(LOCKED_BLK, &onenand->reg->int_err_ack);
		}
	}
}
348140f8:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
348140fc:	3482b220 	.word	0x3482b220
34814100:	34827430 	.word	0x34827430

34814104 <s3c_onenand_unlock_all>:

	this->wait(mtd, FL_LOCKING);
}

static void s3c_onenand_unlock_all(struct mtd_info *mtd)
{
34814104:	e92d46f7 	push	{r0, r1, r2, r4, r5, r6, r7, r9, sl, lr}
	struct onenand_chip *this = mtd->priv;
34814108:	e5905094 	ldr	r5, [r0, #148]	; 0x94
	loff_t ofs = 0;
	size_t len = this->chipsize;

	/* FIXME workaround */
	this->subpagesize = mtd->writesize;
3481410c:	e5903014 	ldr	r3, [r0, #20]
	mtd->subpage_sft = 0;

	if (this->options & ONENAND_HAS_UNLOCK_ALL) {
34814110:	e595202c 	ldr	r2, [r5, #44]	; 0x2c
	struct onenand_chip *this = mtd->priv;
	loff_t ofs = 0;
	size_t len = this->chipsize;

	/* FIXME workaround */
	this->subpagesize = mtd->writesize;
34814114:	e5853098 	str	r3, [r5, #152]	; 0x98
	mtd->subpage_sft = 0;

	if (this->options & ONENAND_HAS_UNLOCK_ALL) {
34814118:	e3120002 	tst	r2, #2
	loff_t ofs = 0;
	size_t len = this->chipsize;

	/* FIXME workaround */
	this->subpagesize = mtd->writesize;
	mtd->subpage_sft = 0;
3481411c:	e3a03000 	mov	r3, #0

	this->wait(mtd, FL_LOCKING);
}

static void s3c_onenand_unlock_all(struct mtd_info *mtd)
{
34814120:	e1a04000 	mov	r4, r0
	struct onenand_chip *this = mtd->priv;
	loff_t ofs = 0;
	size_t len = this->chipsize;
34814124:	e5956018 	ldr	r6, [r5, #24]
}

static void s3c_onenand_unlock_all(struct mtd_info *mtd)
{
	struct onenand_chip *this = mtd->priv;
	loff_t ofs = 0;
34814128:	03a01000 	moveq	r1, #0
	size_t len = this->chipsize;

	/* FIXME workaround */
	this->subpagesize = mtd->writesize;
	mtd->subpage_sft = 0;
3481412c:	e5803090 	str	r3, [r0, #144]	; 0x90
}

static void s3c_onenand_unlock_all(struct mtd_info *mtd)
{
	struct onenand_chip *this = mtd->priv;
	loff_t ofs = 0;
34814130:	03a00000 	moveq	r0, #0

	/* FIXME workaround */
	this->subpagesize = mtd->writesize;
	mtd->subpage_sft = 0;

	if (this->options & ONENAND_HAS_UNLOCK_ALL) {
34814134:	0a000010 	beq	3481417c <s3c_onenand_unlock_all+0x78>
		/* Write unlock command */
		this->command(mtd, ONENAND_CMD_UNLOCK_ALL, 0, 0);
34814138:	e58d3000 	str	r3, [sp]
3481413c:	e595c050 	ldr	ip, [r5, #80]	; 0x50
34814140:	e3a01027 	mov	r1, #39	; 0x27
34814144:	e3a02000 	mov	r2, #0
34814148:	e3a03000 	mov	r3, #0
3481414c:	e12fff3c 	blx	ip

		/* No need to check return value */
		this->wait(mtd, FL_LOCKING);
34814150:	e5953054 	ldr	r3, [r5, #84]	; 0x54
34814154:	e3a01008 	mov	r1, #8
34814158:	e1a00004 	mov	r0, r4
3481415c:	e12fff33 	blx	r3

		/* Workaround for all block unlock in DDP */
		if (!ONENAND_IS_DDP(this)) {
34814160:	e595301c 	ldr	r3, [r5, #28]
34814164:	e3130008 	tst	r3, #8
			s3c_onenand_check_lock_status(mtd);
			return;
		}

		/* All blocks on another chip */
		ofs = this->chipsize >> 1;
34814168:	15956018 	ldrne	r6, [r5, #24]
3481416c:	11a060a6 	lsrne	r6, r6, #1
34814170:	11a00006 	movne	r0, r6
34814174:	13a01000 	movne	r1, #0

		/* No need to check return value */
		this->wait(mtd, FL_LOCKING);

		/* Workaround for all block unlock in DDP */
		if (!ONENAND_IS_DDP(this)) {
34814178:	0a00001e 	beq	348141f8 <s3c_onenand_unlock_all+0xf4>
}

static void s3c_onenand_do_lock_cmd(struct mtd_info *mtd, loff_t ofs,
		size_t len, int cmd)
{
	struct onenand_chip *this = mtd->priv;
3481417c:	e5945094 	ldr	r5, [r4, #148]	; 0x94
	int start, end, start_mem_addr, end_mem_addr;

	start = ofs >> this->erase_shift;
	start_mem_addr = onenand->mem_addr(start, 0, 0);
34814180:	e59f7080 	ldr	r7, [pc, #128]	; 34814208 <s3c_onenand_unlock_all+0x104>
		size_t len, int cmd)
{
	struct onenand_chip *this = mtd->priv;
	int start, end, start_mem_addr, end_mem_addr;

	start = ofs >> this->erase_shift;
34814184:	e5952030 	ldr	r2, [r5, #48]	; 0x30
34814188:	eb00305f 	bl	3482030c <__ashrdi3>
	start_mem_addr = onenand->mem_addr(start, 0, 0);
3481418c:	e5973000 	ldr	r3, [r7]
34814190:	e3a01000 	mov	r1, #0
34814194:	e1a02001 	mov	r2, r1
34814198:	e5933018 	ldr	r3, [r3, #24]
		size_t len, int cmd)
{
	struct onenand_chip *this = mtd->priv;
	int start, end, start_mem_addr, end_mem_addr;

	start = ofs >> this->erase_shift;
3481419c:	e1a09000 	mov	r9, r0
	start_mem_addr = onenand->mem_addr(start, 0, 0);
348141a0:	e12fff33 	blx	r3
348141a4:	e1a0a000 	mov	sl, r0
	end = start + (len >> this->erase_shift) - 1;
348141a8:	e5950030 	ldr	r0, [r5, #48]	; 0x30
	end_mem_addr = onenand->mem_addr(end, 0, 0);
348141ac:	e5973000 	ldr	r3, [r7]
	struct onenand_chip *this = mtd->priv;
	int start, end, start_mem_addr, end_mem_addr;

	start = ofs >> this->erase_shift;
	start_mem_addr = onenand->mem_addr(start, 0, 0);
	end = start + (len >> this->erase_shift) - 1;
348141b0:	e1a06036 	lsr	r6, r6, r0
	end_mem_addr = onenand->mem_addr(end, 0, 0);
348141b4:	e3a01000 	mov	r1, #0
	struct onenand_chip *this = mtd->priv;
	int start, end, start_mem_addr, end_mem_addr;

	start = ofs >> this->erase_shift;
	start_mem_addr = onenand->mem_addr(start, 0, 0);
	end = start + (len >> this->erase_shift) - 1;
348141b8:	e2460001 	sub	r0, r6, #1
	end_mem_addr = onenand->mem_addr(end, 0, 0);
348141bc:	e5933018 	ldr	r3, [r3, #24]
348141c0:	e1a02001 	mov	r2, r1
348141c4:	e0800009 	add	r0, r0, r9
348141c8:	e12fff33 	blx	r3

	if (cmd == ONENAND_CMD_LOCK) {
		s3c_write_cmd(ONENAND_LOCK_START, CMD_MAP_10(start_mem_addr));
		s3c_write_cmd(ONENAND_LOCK_END, CMD_MAP_10(end_mem_addr));
	} else {
		s3c_write_cmd(ONENAND_UNLOCK_START, CMD_MAP_10(start_mem_addr));
348141cc:	e38a1302 	orr	r1, sl, #134217728	; 0x8000000
	int start, end, start_mem_addr, end_mem_addr;

	start = ofs >> this->erase_shift;
	start_mem_addr = onenand->mem_addr(start, 0, 0);
	end = start + (len >> this->erase_shift) - 1;
	end_mem_addr = onenand->mem_addr(end, 0, 0);
348141d0:	e1a06000 	mov	r6, r0

	if (cmd == ONENAND_CMD_LOCK) {
		s3c_write_cmd(ONENAND_LOCK_START, CMD_MAP_10(start_mem_addr));
		s3c_write_cmd(ONENAND_LOCK_END, CMD_MAP_10(end_mem_addr));
	} else {
		s3c_write_cmd(ONENAND_UNLOCK_START, CMD_MAP_10(start_mem_addr));
348141d4:	e3a00008 	mov	r0, #8
348141d8:	ebfffdc6 	bl	348138f8 <s3c_write_cmd>
		s3c_write_cmd(ONENAND_UNLOCK_END, CMD_MAP_10(end_mem_addr));
348141dc:	e3a00009 	mov	r0, #9
348141e0:	e3861302 	orr	r1, r6, #134217728	; 0x8000000
348141e4:	ebfffdc3 	bl	348138f8 <s3c_write_cmd>
	}

	this->wait(mtd, FL_LOCKING);
348141e8:	e5953054 	ldr	r3, [r5, #84]	; 0x54
348141ec:	e1a00004 	mov	r0, r4
348141f0:	e3a01008 	mov	r1, #8
348141f4:	e12fff33 	blx	r3
		ofs = this->chipsize >> 1;
		len = this->chipsize >> 1;
	}

	s3c_onenand_do_lock_cmd(mtd, ofs, len, ONENAND_CMD_UNLOCK);
	s3c_onenand_check_lock_status(mtd);
348141f8:	e5940094 	ldr	r0, [r4, #148]	; 0x94
}
348141fc:	e28dd00c 	add	sp, sp, #12
34814200:	e8bd46f0 	pop	{r4, r5, r6, r7, r9, sl, lr}
		ofs = this->chipsize >> 1;
		len = this->chipsize >> 1;
	}

	s3c_onenand_do_lock_cmd(mtd, ofs, len, ONENAND_CMD_UNLOCK);
	s3c_onenand_check_lock_status(mtd);
34814204:	eaffff9d 	b	34814080 <s3c_onenand_check_lock_status.clone.0>
34814208:	3482b220 	.word	0x3482b220

3481420c <s5pc110_chip_probe>:
#endif

int s5pc110_chip_probe(struct mtd_info *mtd)
{
	return 0;
}
3481420c:	e3a00000 	mov	r0, #0
34814210:	e12fff1e 	bx	lr

34814214 <s5pc210_chip_probe>:

int s5pc210_chip_probe(struct mtd_info *mtd)
{
	return 0;
}
34814214:	e3a00000 	mov	r0, #0
34814218:	e12fff1e 	bx	lr

3481421c <s3c_onenand_init>:

void s3c_onenand_init(struct mtd_info *mtd)
{
3481421c:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
	struct onenand_chip *this = mtd->priv;
34814220:	e5904094 	ldr	r4, [r0, #148]	; 0x94
{
	return 0;
}

void s3c_onenand_init(struct mtd_info *mtd)
{
34814224:	e1a06000 	mov	r6, r0
	struct onenand_chip *this = mtd->priv;
	u32 size = (4 << 10);	/* 4 KiB */

	onenand = malloc(sizeof(struct s3c_onenand));
34814228:	e3a00020 	mov	r0, #32
3481422c:	ebffd50d 	bl	34809668 <malloc>
34814230:	e59f50d4 	ldr	r5, [pc, #212]	; 3481430c <s3c_onenand_init+0xf0>
	if (!onenand)
34814234:	e3500000 	cmp	r0, #0
void s3c_onenand_init(struct mtd_info *mtd)
{
	struct onenand_chip *this = mtd->priv;
	u32 size = (4 << 10);	/* 4 KiB */

	onenand = malloc(sizeof(struct s3c_onenand));
34814238:	e1a07000 	mov	r7, r0
3481423c:	e5850000 	str	r0, [r5]
	if (!onenand)
34814240:	08bd80f8 	popeq	{r3, r4, r5, r6, r7, pc}
		return;

	onenand->page_buf = malloc(size * sizeof(char));
34814244:	e3a00a01 	mov	r0, #4096	; 0x1000
34814248:	ebffd506 	bl	34809668 <malloc>
	if (!onenand->page_buf)
3481424c:	e5953000 	ldr	r3, [r5]

	onenand = malloc(sizeof(struct s3c_onenand));
	if (!onenand)
		return;

	onenand->page_buf = malloc(size * sizeof(char));
34814250:	e5870010 	str	r0, [r7, #16]
	if (!onenand->page_buf)
34814254:	e5930010 	ldr	r0, [r3, #16]
34814258:	e3500000 	cmp	r0, #0
3481425c:	08bd80f8 	popeq	{r3, r4, r5, r6, r7, pc}
		return;
	memset(onenand->page_buf, 0xff, size);
34814260:	e3a010ff 	mov	r1, #255	; 0xff
34814264:	e3a02a01 	mov	r2, #4096	; 0x1000
34814268:	eb0012e4 	bl	34818e00 <memset>

	onenand->oob_buf = malloc(128 * sizeof(char));
3481426c:	e3a00080 	mov	r0, #128	; 0x80
34814270:	e5957000 	ldr	r7, [r5]
34814274:	ebffd4fb 	bl	34809668 <malloc>
	if (!onenand->oob_buf)
34814278:	e5953000 	ldr	r3, [r5]
	onenand->page_buf = malloc(size * sizeof(char));
	if (!onenand->page_buf)
		return;
	memset(onenand->page_buf, 0xff, size);

	onenand->oob_buf = malloc(128 * sizeof(char));
3481427c:	e5870014 	str	r0, [r7, #20]
	if (!onenand->oob_buf)
34814280:	e5930014 	ldr	r0, [r3, #20]
34814284:	e3500000 	cmp	r0, #0
34814288:	08bd80f8 	popeq	{r3, r4, r5, r6, r7, pc}
		return;
	memset(onenand->oob_buf, 0xff, 128);
3481428c:	e3a010ff 	mov	r1, #255	; 0xff
34814290:	e3a02080 	mov	r2, #128	; 0x80
34814294:	eb0012d9 	bl	34818e00 <memset>

	onenand->mtd = mtd;
34814298:	e5953000 	ldr	r3, [r5]
#if defined(CONFIG_S3C64XX)
	onenand->base = (void *)0x70100000;
	onenand->ahb_addr = (void *)0x20000000;
#elif defined(CONFIG_S5P)
	onenand->base = (void *)0xE7100000;
	onenand->ahb_addr = (void *)0xB0000000;
3481429c:	e3a0120b 	mov	r1, #-1342177280	; 0xb0000000
348142a0:	e5831008 	str	r1, [r3, #8]

#if defined(CONFIG_S3C64XX)
	onenand->base = (void *)0x70100000;
	onenand->ahb_addr = (void *)0x20000000;
#elif defined(CONFIG_S5P)
	onenand->base = (void *)0xE7100000;
348142a4:	e59f2064 	ldr	r2, [pc, #100]	; 34814310 <s3c_onenand_init+0xf4>
	onenand->ahb_addr = (void *)0xB0000000;
#endif
	onenand->mem_addr = s3c_mem_addr;
348142a8:	e59f1064 	ldr	r1, [pc, #100]	; 34814314 <s3c_onenand_init+0xf8>
	onenand->oob_buf = malloc(128 * sizeof(char));
	if (!onenand->oob_buf)
		return;
	memset(onenand->oob_buf, 0xff, 128);

	onenand->mtd = mtd;
348142ac:	e5836000 	str	r6, [r3]

#if defined(CONFIG_S3C64XX)
	onenand->base = (void *)0x70100000;
	onenand->ahb_addr = (void *)0x20000000;
#elif defined(CONFIG_S5P)
	onenand->base = (void *)0xE7100000;
348142b0:	e5832004 	str	r2, [r3, #4]
	onenand->ahb_addr = (void *)0xB0000000;
#endif
	onenand->mem_addr = s3c_mem_addr;
348142b4:	e5831018 	str	r1, [r3, #24]
	onenand->reg = (struct samsung_onenand *)onenand->base;
348142b8:	e583201c 	str	r2, [r3, #28]

	this->read_word = s3c_onenand_readw;
348142bc:	e59f3054 	ldr	r3, [pc, #84]	; 34814318 <s3c_onenand_init+0xfc>
348142c0:	e5843068 	str	r3, [r4, #104]	; 0x68
	this->write_word = s3c_onenand_writew;
348142c4:	e59f3050 	ldr	r3, [pc, #80]	; 3481431c <s3c_onenand_init+0x100>
348142c8:	e584306c 	str	r3, [r4, #108]	; 0x6c

	this->wait = s3c_onenand_wait;
348142cc:	e59f304c 	ldr	r3, [pc, #76]	; 34814320 <s3c_onenand_init+0x104>
348142d0:	e5843054 	str	r3, [r4, #84]	; 0x54
	this->bbt_wait = s3c_onenand_bbt_wait;
348142d4:	e59f3048 	ldr	r3, [pc, #72]	; 34814324 <s3c_onenand_init+0x108>
348142d8:	e5843058 	str	r3, [r4, #88]	; 0x58
	this->unlock_all = s3c_onenand_unlock_all;
348142dc:	e59f3044 	ldr	r3, [pc, #68]	; 34814328 <s3c_onenand_init+0x10c>
348142e0:	e584305c 	str	r3, [r4, #92]	; 0x5c
	this->command = s3c_onenand_command;
348142e4:	e59f3040 	ldr	r3, [pc, #64]	; 3481432c <s3c_onenand_init+0x110>
348142e8:	e5843050 	str	r3, [r4, #80]	; 0x50

	this->read_bufferram = onenand_read_bufferram;
348142ec:	e59f303c 	ldr	r3, [pc, #60]	; 34814330 <s3c_onenand_init+0x114>
348142f0:	e5843060 	str	r3, [r4, #96]	; 0x60
	this->write_bufferram = onenand_write_bufferram;
348142f4:	e59f3038 	ldr	r3, [pc, #56]	; 34814334 <s3c_onenand_init+0x118>
348142f8:	e5843064 	str	r3, [r4, #100]	; 0x64

	this->options |= ONENAND_RUNTIME_BADBLOCK_CHECK;
348142fc:	e594302c 	ldr	r3, [r4, #44]	; 0x2c
34814300:	e3833c02 	orr	r3, r3, #512	; 0x200
34814304:	e584302c 	str	r3, [r4, #44]	; 0x2c
34814308:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
3481430c:	3482b220 	.word	0x3482b220
34814310:	e7100000 	.word	0xe7100000
34814314:	34813910 	.word	0x34813910
34814318:	34813f08 	.word	0x34813f08
3481431c:	34813e20 	.word	0x34813e20
34814320:	34813d1c 	.word	0x34813d1c
34814324:	34813c44 	.word	0x34813c44
34814328:	34814104 	.word	0x34814104
3481432c:	34813998 	.word	0x34813998
34814330:	34813cf4 	.word	0x34813cf4
34814334:	34813ccc 	.word	0x34813ccc

34814338 <dm9000_outblk_8bit>:
#endif

static void dm9000_outblk_8bit(volatile void *data_ptr, int count)
{
	int i;
	for (i = 0; i < count; i++)
34814338:	e3a03000 	mov	r3, #0
		DM9000_outb((((u8 *) data_ptr)[i] & 0xff), DM9000_DATA);
3481433c:	e3a02322 	mov	r2, #-2013265920	; 0x88000000
#endif

static void dm9000_outblk_8bit(volatile void *data_ptr, int count)
{
	int i;
	for (i = 0; i < count; i++)
34814340:	ea000002 	b	34814350 <dm9000_outblk_8bit+0x18>
		DM9000_outb((((u8 *) data_ptr)[i] & 0xff), DM9000_DATA);
34814344:	e7d0c003 	ldrb	ip, [r0, r3]
34814348:	e5c2c008 	strb	ip, [r2, #8]
#endif

static void dm9000_outblk_8bit(volatile void *data_ptr, int count)
{
	int i;
	for (i = 0; i < count; i++)
3481434c:	e2833001 	add	r3, r3, #1
34814350:	e1530001 	cmp	r3, r1
34814354:	bafffffa 	blt	34814344 <dm9000_outblk_8bit+0xc>
		DM9000_outb((((u8 *) data_ptr)[i] & 0xff), DM9000_DATA);
}
34814358:	e12fff1e 	bx	lr

3481435c <dm9000_outblk_16bit>:

static void dm9000_outblk_16bit(volatile void *data_ptr, int count)
{
	int i;
	u32 tmplen = (count + 1) / 2;
3481435c:	e2811001 	add	r1, r1, #1
34814360:	e0811fa1 	add	r1, r1, r1, lsr #31
34814364:	e1a010c1 	asr	r1, r1, #1

	for (i = 0; i < tmplen; i++)
34814368:	e3a03000 	mov	r3, #0
		DM9000_outw(((u16 *) data_ptr)[i], DM9000_DATA);
3481436c:	e3a02322 	mov	r2, #-2013265920	; 0x88000000
static void dm9000_outblk_16bit(volatile void *data_ptr, int count)
{
	int i;
	u32 tmplen = (count + 1) / 2;

	for (i = 0; i < tmplen; i++)
34814370:	ea000002 	b	34814380 <dm9000_outblk_16bit+0x24>
		DM9000_outw(((u16 *) data_ptr)[i], DM9000_DATA);
34814374:	e0d0c0b2 	ldrh	ip, [r0], #2
34814378:	e1c2c0b8 	strh	ip, [r2, #8]
static void dm9000_outblk_16bit(volatile void *data_ptr, int count)
{
	int i;
	u32 tmplen = (count + 1) / 2;

	for (i = 0; i < tmplen; i++)
3481437c:	e2833001 	add	r3, r3, #1
34814380:	e1530001 	cmp	r3, r1
34814384:	1afffffa 	bne	34814374 <dm9000_outblk_16bit+0x18>
		DM9000_outw(((u16 *) data_ptr)[i], DM9000_DATA);
}
34814388:	e12fff1e 	bx	lr

3481438c <dm9000_outblk_32bit>:
static void dm9000_outblk_32bit(volatile void *data_ptr, int count)
{
	int i;
	u32 tmplen = (count + 3) / 4;
3481438c:	e2913003 	adds	r3, r1, #3
34814390:	42811006 	addmi	r1, r1, #6
34814394:	51a01003 	movpl	r1, r3
34814398:	e1a01141 	asr	r1, r1, #2

	for (i = 0; i < tmplen; i++)
3481439c:	e3a03000 	mov	r3, #0
		DM9000_outl(((u32 *) data_ptr)[i], DM9000_DATA);
348143a0:	e3a02322 	mov	r2, #-2013265920	; 0x88000000
static void dm9000_outblk_32bit(volatile void *data_ptr, int count)
{
	int i;
	u32 tmplen = (count + 3) / 4;

	for (i = 0; i < tmplen; i++)
348143a4:	ea000002 	b	348143b4 <dm9000_outblk_32bit+0x28>
		DM9000_outl(((u32 *) data_ptr)[i], DM9000_DATA);
348143a8:	e490c004 	ldr	ip, [r0], #4
348143ac:	e582c008 	str	ip, [r2, #8]
static void dm9000_outblk_32bit(volatile void *data_ptr, int count)
{
	int i;
	u32 tmplen = (count + 3) / 4;

	for (i = 0; i < tmplen; i++)
348143b0:	e2833001 	add	r3, r3, #1
348143b4:	e1530001 	cmp	r3, r1
348143b8:	1afffffa 	bne	348143a8 <dm9000_outblk_32bit+0x1c>
		DM9000_outl(((u32 *) data_ptr)[i], DM9000_DATA);
}
348143bc:	e12fff1e 	bx	lr

348143c0 <dm9000_inblk_8bit>:

static void dm9000_inblk_8bit(void *data_ptr, int count)
{
	int i;
	for (i = 0; i < count; i++)
348143c0:	e3a03000 	mov	r3, #0
		((u8 *) data_ptr)[i] = DM9000_inb(DM9000_DATA);
348143c4:	e3a02322 	mov	r2, #-2013265920	; 0x88000000
}

static void dm9000_inblk_8bit(void *data_ptr, int count)
{
	int i;
	for (i = 0; i < count; i++)
348143c8:	ea000002 	b	348143d8 <dm9000_inblk_8bit+0x18>
		((u8 *) data_ptr)[i] = DM9000_inb(DM9000_DATA);
348143cc:	e5d2c008 	ldrb	ip, [r2, #8]
348143d0:	e7c0c003 	strb	ip, [r0, r3]
}

static void dm9000_inblk_8bit(void *data_ptr, int count)
{
	int i;
	for (i = 0; i < count; i++)
348143d4:	e2833001 	add	r3, r3, #1
348143d8:	e1530001 	cmp	r3, r1
348143dc:	bafffffa 	blt	348143cc <dm9000_inblk_8bit+0xc>
		((u8 *) data_ptr)[i] = DM9000_inb(DM9000_DATA);
}
348143e0:	e12fff1e 	bx	lr

348143e4 <dm9000_inblk_16bit>:

static void dm9000_inblk_16bit(void *data_ptr, int count)
{
	int i;
	u32 tmplen = (count + 1) / 2;
348143e4:	e2811001 	add	r1, r1, #1
348143e8:	e0811fa1 	add	r1, r1, r1, lsr #31
348143ec:	e1a010c1 	asr	r1, r1, #1

	for (i = 0; i < tmplen; i++)
348143f0:	e3a03000 	mov	r3, #0
		((u16 *) data_ptr)[i] = DM9000_inw(DM9000_DATA);
348143f4:	e3a02322 	mov	r2, #-2013265920	; 0x88000000
static void dm9000_inblk_16bit(void *data_ptr, int count)
{
	int i;
	u32 tmplen = (count + 1) / 2;

	for (i = 0; i < tmplen; i++)
348143f8:	ea000002 	b	34814408 <dm9000_inblk_16bit+0x24>
		((u16 *) data_ptr)[i] = DM9000_inw(DM9000_DATA);
348143fc:	e1d2c0b8 	ldrh	ip, [r2, #8]
34814400:	e0c0c0b2 	strh	ip, [r0], #2
static void dm9000_inblk_16bit(void *data_ptr, int count)
{
	int i;
	u32 tmplen = (count + 1) / 2;

	for (i = 0; i < tmplen; i++)
34814404:	e2833001 	add	r3, r3, #1
34814408:	e1530001 	cmp	r3, r1
3481440c:	1afffffa 	bne	348143fc <dm9000_inblk_16bit+0x18>
		((u16 *) data_ptr)[i] = DM9000_inw(DM9000_DATA);
}
34814410:	e12fff1e 	bx	lr

34814414 <dm9000_inblk_32bit>:
static void dm9000_inblk_32bit(void *data_ptr, int count)
{
	int i;
	u32 tmplen = (count + 3) / 4;
34814414:	e2913003 	adds	r3, r1, #3
34814418:	42811006 	addmi	r1, r1, #6
3481441c:	51a01003 	movpl	r1, r3
34814420:	e1a01141 	asr	r1, r1, #2

	for (i = 0; i < tmplen; i++)
34814424:	e3a03000 	mov	r3, #0
		((u32 *) data_ptr)[i] = DM9000_inl(DM9000_DATA);
34814428:	e3a02322 	mov	r2, #-2013265920	; 0x88000000
static void dm9000_inblk_32bit(void *data_ptr, int count)
{
	int i;
	u32 tmplen = (count + 3) / 4;

	for (i = 0; i < tmplen; i++)
3481442c:	ea000002 	b	3481443c <dm9000_inblk_32bit+0x28>
		((u32 *) data_ptr)[i] = DM9000_inl(DM9000_DATA);
34814430:	e592c008 	ldr	ip, [r2, #8]
34814434:	e480c004 	str	ip, [r0], #4
static void dm9000_inblk_32bit(void *data_ptr, int count)
{
	int i;
	u32 tmplen = (count + 3) / 4;

	for (i = 0; i < tmplen; i++)
34814438:	e2833001 	add	r3, r3, #1
3481443c:	e1530001 	cmp	r3, r1
34814440:	1afffffa 	bne	34814430 <dm9000_inblk_32bit+0x1c>
		((u32 *) data_ptr)[i] = DM9000_inl(DM9000_DATA);
}
34814444:	e12fff1e 	bx	lr

34814448 <dm9000_rx_status_32bit>:

static void dm9000_rx_status_32bit(u16 *RxStatus, u16 *RxLen)
{
	u32 tmpdata;

	DM9000_outb(DM9000_MRCMD, DM9000_IO);
34814448:	e3a03322 	mov	r3, #-2013265920	; 0x88000000
3481444c:	e3e0200d 	mvn	r2, #13
34814450:	e5c32000 	strb	r2, [r3]

	tmpdata = DM9000_inl(DM9000_DATA);
34814454:	e5933008 	ldr	r3, [r3, #8]
	*RxStatus = __le16_to_cpu(tmpdata);
34814458:	e1c030b0 	strh	r3, [r0]
	*RxLen = __le16_to_cpu(tmpdata >> 16);
3481445c:	e1a03823 	lsr	r3, r3, #16
34814460:	e1c130b0 	strh	r3, [r1]
}
34814464:	e12fff1e 	bx	lr

34814468 <dm9000_rx_status_16bit>:

static void dm9000_rx_status_16bit(u16 *RxStatus, u16 *RxLen)
{
	DM9000_outb(DM9000_MRCMD, DM9000_IO);
34814468:	e3a03322 	mov	r3, #-2013265920	; 0x88000000
3481446c:	e3e0200d 	mvn	r2, #13
34814470:	e5c32000 	strb	r2, [r3]

	*RxStatus = __le16_to_cpu(DM9000_inw(DM9000_DATA));
34814474:	e1d320b8 	ldrh	r2, [r3, #8]
34814478:	e1c020b0 	strh	r2, [r0]
	*RxLen = __le16_to_cpu(DM9000_inw(DM9000_DATA));
3481447c:	e1d330b8 	ldrh	r3, [r3, #8]
34814480:	e1c130b0 	strh	r3, [r1]
}
34814484:	e12fff1e 	bx	lr

34814488 <dm9000_rx_status_8bit>:

static void dm9000_rx_status_8bit(u16 *RxStatus, u16 *RxLen)
{
	DM9000_outb(DM9000_MRCMD, DM9000_IO);
34814488:	e3a03322 	mov	r3, #-2013265920	; 0x88000000
3481448c:	e3e0200d 	mvn	r2, #13
34814490:	e5c32000 	strb	r2, [r3]

	*RxStatus =
	    __le16_to_cpu(DM9000_inb(DM9000_DATA) +
34814494:	e5d3c008 	ldrb	ip, [r3, #8]
34814498:	e5d32008 	ldrb	r2, [r3, #8]
3481449c:	e08c2402 	add	r2, ip, r2, lsl #8

static void dm9000_rx_status_8bit(u16 *RxStatus, u16 *RxLen)
{
	DM9000_outb(DM9000_MRCMD, DM9000_IO);

	*RxStatus =
348144a0:	e1c020b0 	strh	r2, [r0]
	    __le16_to_cpu(DM9000_inb(DM9000_DATA) +
			  (DM9000_inb(DM9000_DATA) << 8));
	*RxLen =
	    __le16_to_cpu(DM9000_inb(DM9000_DATA) +
348144a4:	e5d32008 	ldrb	r2, [r3, #8]
348144a8:	e5d33008 	ldrb	r3, [r3, #8]
348144ac:	e0823403 	add	r3, r2, r3, lsl #8
	DM9000_outb(DM9000_MRCMD, DM9000_IO);

	*RxStatus =
	    __le16_to_cpu(DM9000_inb(DM9000_DATA) +
			  (DM9000_inb(DM9000_DATA) << 8));
	*RxLen =
348144b0:	e1c130b0 	strh	r3, [r1]
	    __le16_to_cpu(DM9000_inb(DM9000_DATA) +
			  (DM9000_inb(DM9000_DATA) << 8));
}
348144b4:	e12fff1e 	bx	lr

348144b8 <dm9000_reset>:
}

/* General Purpose dm9000 reset routine */
static void
dm9000_reset(void)
{
348144b8:	e92d4070 	push	{r4, r5, r6, lr}
   Write a byte to I/O port
*/
static void
DM9000_iow(int reg, u8 value)
{
	DM9000_outb(reg, DM9000_IO);
348144bc:	e3a05322 	mov	r5, #-2013265920	; 0x88000000
348144c0:	e3a0301e 	mov	r3, #30
348144c4:	e5c53000 	strb	r3, [r5]
	DM9000_outb(value, DM9000_DATA);
348144c8:	e3a03001 	mov	r3, #1
348144cc:	e5c53008 	strb	r3, [r5, #8]
   Write a byte to I/O port
*/
static void
DM9000_iow(int reg, u8 value)
{
	DM9000_outb(reg, DM9000_IO);
348144d0:	e283301e 	add	r3, r3, #30
348144d4:	e5c53000 	strb	r3, [r5]
	DM9000_outb(value, DM9000_DATA);
348144d8:	e3a06000 	mov	r6, #0
348144dc:	e5c56008 	strb	r6, [r5, #8]
   Write a byte to I/O port
*/
static void
DM9000_iow(int reg, u8 value)
{
	DM9000_outb(reg, DM9000_IO);
348144e0:	e5c56000 	strb	r6, [r5]
	DM9000_outb(value, DM9000_DATA);
348144e4:	e3a03003 	mov	r3, #3
348144e8:	e5c53008 	strb	r3, [r5, #8]
	/* Step 2: Software reset */
	DM9000_iow(DM9000_NCR, (NCR_LBK_INT_MAC | NCR_RST));

	do {
		DM9000_DBG("resetting the DM9000, 1st reset\n");
		udelay(25); /* Wait at least 20 us */
348144ec:	e3a00019 	mov	r0, #25
348144f0:	eb0012f1 	bl	348190bc <udelay>
   Read a byte from I/O port
*/
static u8
DM9000_ior(int reg)
{
	DM9000_outb(reg, DM9000_IO);
348144f4:	e5c56000 	strb	r6, [r5]
348144f8:	e3a04322 	mov	r4, #-2013265920	; 0x88000000
	return DM9000_inb(DM9000_DATA);
348144fc:	e5d53008 	ldrb	r3, [r5, #8]
	DM9000_iow(DM9000_NCR, (NCR_LBK_INT_MAC | NCR_RST));

	do {
		DM9000_DBG("resetting the DM9000, 1st reset\n");
		udelay(25); /* Wait at least 20 us */
	} while (DM9000_ior(DM9000_NCR) & 1);
34814500:	e2133001 	ands	r3, r3, #1
34814504:	1afffff8 	bne	348144ec <dm9000_reset+0x34>
   Write a byte to I/O port
*/
static void
DM9000_iow(int reg, u8 value)
{
	DM9000_outb(reg, DM9000_IO);
34814508:	e5c43000 	strb	r3, [r4]
	DM9000_outb(value, DM9000_DATA);
3481450c:	e5c43008 	strb	r3, [r4, #8]
   Write a byte to I/O port
*/
static void
DM9000_iow(int reg, u8 value)
{
	DM9000_outb(reg, DM9000_IO);
34814510:	e5c43000 	strb	r3, [r4]
	DM9000_outb(value, DM9000_DATA);
34814514:	e3a02003 	mov	r2, #3
34814518:	e5c42008 	strb	r2, [r4, #8]
   Read a byte from I/O port
*/
static u8
DM9000_ior(int reg)
{
	DM9000_outb(reg, DM9000_IO);
3481451c:	e1a05003 	mov	r5, r3
	DM9000_iow(DM9000_NCR, 0);
	DM9000_iow(DM9000_NCR, (NCR_LBK_INT_MAC | NCR_RST)); /* Issue a second reset */

	do {
		DM9000_DBG("resetting the DM9000, 2nd reset\n");
		udelay(25); /* Wait at least 20 us */
34814520:	e3a00019 	mov	r0, #25
34814524:	eb0012e4 	bl	348190bc <udelay>
   Read a byte from I/O port
*/
static u8
DM9000_ior(int reg)
{
	DM9000_outb(reg, DM9000_IO);
34814528:	e5c45000 	strb	r5, [r4]
3481452c:	e3a03322 	mov	r3, #-2013265920	; 0x88000000
	return DM9000_inb(DM9000_DATA);
34814530:	e5d42008 	ldrb	r2, [r4, #8]
	DM9000_iow(DM9000_NCR, (NCR_LBK_INT_MAC | NCR_RST)); /* Issue a second reset */

	do {
		DM9000_DBG("resetting the DM9000, 2nd reset\n");
		udelay(25); /* Wait at least 20 us */
	} while (DM9000_ior(DM9000_NCR) & 1);
34814534:	e3120001 	tst	r2, #1
34814538:	1afffff8 	bne	34814520 <dm9000_reset+0x68>
   Read a byte from I/O port
*/
static u8
DM9000_ior(int reg)
{
	DM9000_outb(reg, DM9000_IO);
3481453c:	e3a0202a 	mov	r2, #42	; 0x2a
34814540:	e5c32000 	strb	r2, [r3]
	return DM9000_inb(DM9000_DATA);
34814544:	e5d32008 	ldrb	r2, [r3, #8]
		DM9000_DBG("resetting the DM9000, 2nd reset\n");
		udelay(25); /* Wait at least 20 us */
	} while (DM9000_ior(DM9000_NCR) & 1);

	/* Check whether the ethernet controller is present */
	if ((DM9000_ior(DM9000_PIDL) != 0x0) ||
34814548:	e3520000 	cmp	r2, #0
3481454c:	1a000004 	bne	34814564 <dm9000_reset+0xac>
   Read a byte from I/O port
*/
static u8
DM9000_ior(int reg)
{
	DM9000_outb(reg, DM9000_IO);
34814550:	e282202b 	add	r2, r2, #43	; 0x2b
34814554:	e5c32000 	strb	r2, [r3]
	return DM9000_inb(DM9000_DATA);
34814558:	e5d33008 	ldrb	r3, [r3, #8]
		DM9000_DBG("resetting the DM9000, 2nd reset\n");
		udelay(25); /* Wait at least 20 us */
	} while (DM9000_ior(DM9000_NCR) & 1);

	/* Check whether the ethernet controller is present */
	if ((DM9000_ior(DM9000_PIDL) != 0x0) ||
3481455c:	e3530090 	cmp	r3, #144	; 0x90
34814560:	08bd8070 	popeq	{r4, r5, r6, pc}
	    (DM9000_ior(DM9000_PIDH) != 0x90))
		printf("ERROR: resetting DM9000 -> not responding\n");
34814564:	e59f0004 	ldr	r0, [pc, #4]	; 34814570 <dm9000_reset+0xb8>
}
34814568:	e8bd4070 	pop	{r4, r5, r6, lr}
	} while (DM9000_ior(DM9000_NCR) & 1);

	/* Check whether the ethernet controller is present */
	if ((DM9000_ior(DM9000_PIDL) != 0x0) ||
	    (DM9000_ior(DM9000_PIDH) != 0x90))
		printf("ERROR: resetting DM9000 -> not responding\n");
3481456c:	eaffd276 	b	34808f4c <printf>
34814570:	3482744e 	.word	0x3482744e

34814574 <dm9000_rx>:

/*
  Received a packet and pass to upper layer
*/
static int dm9000_rx(struct eth_device *netdev)
{
34814574:	e92d4ef3 	push	{r0, r1, r4, r5, r6, r7, r9, sl, fp, lr}
	u8 rxbyte, *rdptr = (u8 *) NetRxPackets[0];
34814578:	e59fb130 	ldr	fp, [pc, #304]	; 348146b0 <dm9000_rx+0x13c>
	u16 RxStatus, RxLen = 0;
3481457c:	e3a03000 	mov	r3, #0
34814580:	e1cd30b4 	strh	r3, [sp, #4]
/*
  Received a packet and pass to upper layer
*/
static int dm9000_rx(struct eth_device *netdev)
{
	u8 rxbyte, *rdptr = (u8 *) NetRxPackets[0];
34814584:	e59b9000 	ldr	r9, [fp]
   Read a byte from I/O port
*/
static u8
DM9000_ior(int reg)
{
	DM9000_outb(reg, DM9000_IO);
34814588:	e3a04322 	mov	r4, #-2013265920	; 0x88000000
3481458c:	e3e03001 	mvn	r3, #1
34814590:	e5c43000 	strb	r3, [r4]
	return DM9000_inb(DM9000_DATA);
34814594:	e5d42008 	ldrb	r2, [r4, #8]
	u16 RxStatus, RxLen = 0;
	struct board_info *db = &dm9000_info;

	/* Check packet ready or not, we must check
	   the ISR status first for DM9000A */
	if (!(DM9000_ior(DM9000_ISR) & 0x01)) /* Rx-ISR bit must be set. */
34814598:	e3120001 	tst	r2, #1
3481459c:	0a000041 	beq	348146a8 <dm9000_rx+0x134>
   Write a byte to I/O port
*/
static void
DM9000_iow(int reg, u8 value)
{
	DM9000_outb(reg, DM9000_IO);
348145a0:	e5c43000 	strb	r3, [r4]
			return 0; /* No packet received, ignore */

		DM9000_DBG("receiving packet\n");

		/* A packet ready now  & Get status/length */
		(db->rx_status)(&RxStatus, &RxLen);
348145a4:	e59f5108 	ldr	r5, [pc, #264]	; 348146b4 <dm9000_rx+0x140>
*/
static void
DM9000_iow(int reg, u8 value)
{
	DM9000_outb(reg, DM9000_IO);
	DM9000_outb(value, DM9000_DATA);
348145a8:	e2833003 	add	r3, r3, #3
348145ac:	e5c43008 	strb	r3, [r4, #8]
   Read a byte from I/O port
*/
static u8
DM9000_ior(int reg)
{
	DM9000_outb(reg, DM9000_IO);
348145b0:	e3e0a00f 	mvn	sl, #15
			return 0; /* No packet received, ignore */

		DM9000_DBG("receiving packet\n");

		/* A packet ready now  & Get status/length */
		(db->rx_status)(&RxStatus, &RxLen);
348145b4:	e28d7006 	add	r7, sp, #6
348145b8:	e28d6004 	add	r6, sp, #4
   Read a byte from I/O port
*/
static u8
DM9000_ior(int reg)
{
	DM9000_outb(reg, DM9000_IO);
348145bc:	e5c4a000 	strb	sl, [r4]
	return DM9000_inb(DM9000_DATA);
348145c0:	e5d42008 	ldrb	r2, [r4, #8]
   Read a byte from I/O port
*/
static u8
DM9000_ior(int reg)
{
	DM9000_outb(reg, DM9000_IO);
348145c4:	e3a03322 	mov	r3, #-2013265920	; 0x88000000
	for (;;) {
		DM9000_ior(DM9000_MRCMDX);	/* Dummy read */

		/* Get most updated data,
		   only look at bits 0:1, See application notes DM9000 */
		rxbyte = DM9000_inb(DM9000_DATA) & 0x03;
348145c8:	e5d41008 	ldrb	r1, [r4, #8]
348145cc:	e2011003 	and	r1, r1, #3

		/* Status check: this byte must be 0 or 1 */
		if (rxbyte > DM9000_PKT_RDY) {
348145d0:	e3510001 	cmp	r1, #1
348145d4:	9a00000a 	bls	34814604 <dm9000_rx+0x90>
   Write a byte to I/O port
*/
static void
DM9000_iow(int reg, u8 value)
{
	DM9000_outb(reg, DM9000_IO);
348145d8:	e3a02005 	mov	r2, #5
348145dc:	e5c32000 	strb	r2, [r3]
	DM9000_outb(value, DM9000_DATA);
348145e0:	e3a02000 	mov	r2, #0
348145e4:	e5c32008 	strb	r2, [r3, #8]
   Write a byte to I/O port
*/
static void
DM9000_iow(int reg, u8 value)
{
	DM9000_outb(reg, DM9000_IO);
348145e8:	e3e02001 	mvn	r2, #1
348145ec:	e5c32000 	strb	r2, [r3]
	DM9000_outb(value, DM9000_DATA);
348145f0:	e3e0207f 	mvn	r2, #127	; 0x7f
348145f4:	e5c32008 	strb	r2, [r3, #8]

		/* Status check: this byte must be 0 or 1 */
		if (rxbyte > DM9000_PKT_RDY) {
			DM9000_iow(DM9000_RCR, 0x00);	/* Stop Device */
			DM9000_iow(DM9000_ISR, 0x80);	/* Stop INT request */
			printf("DM9000 error: status check fail: 0x%x\n",
348145f8:	e59f00b8 	ldr	r0, [pc, #184]	; 348146b8 <dm9000_rx+0x144>
348145fc:	ebffd252 	bl	34808f4c <printf>
				rxbyte);
			return 0;
34814600:	ea000028 	b	348146a8 <dm9000_rx+0x134>
		}

		if (rxbyte != DM9000_PKT_RDY)
34814604:	1a000027 	bne	348146a8 <dm9000_rx+0x134>
			return 0; /* No packet received, ignore */

		DM9000_DBG("receiving packet\n");

		/* A packet ready now  & Get status/length */
		(db->rx_status)(&RxStatus, &RxLen);
34814608:	e59530a4 	ldr	r3, [r5, #164]	; 0xa4
3481460c:	e1a00007 	mov	r0, r7
34814610:	e1a01006 	mov	r1, r6
34814614:	e12fff33 	blx	r3

		DM9000_DBG("rx status: 0x%04x rx len: %d\n", RxStatus, RxLen);

		/* Move data from DM9000 */
		/* Read received packet from RX SRAM */
		(db->inblk)(rdptr, RxLen);
34814618:	e59530a0 	ldr	r3, [r5, #160]	; 0xa0
3481461c:	e1a00009 	mov	r0, r9
34814620:	e1dd10b4 	ldrh	r1, [sp, #4]
34814624:	e12fff33 	blx	r3

		if ((RxStatus & 0xbf00) || (RxLen < 0x40)
34814628:	e1dd30b6 	ldrh	r3, [sp, #6]
3481462c:	e3130cbf 	tst	r3, #48896	; 0xbf00
34814630:	1a000004 	bne	34814648 <dm9000_rx+0xd4>
34814634:	e1dd10b4 	ldrh	r1, [sp, #4]
34814638:	e351003f 	cmp	r1, #63	; 0x3f
3481463c:	9a000001 	bls	34814648 <dm9000_rx+0xd4>
			|| (RxLen > DM9000_PKT_MAX)) {
34814640:	e3510c06 	cmp	r1, #1536	; 0x600
34814644:	9a000014 	bls	3481469c <dm9000_rx+0x128>
			if (RxStatus & 0x100) {
34814648:	e3130c01 	tst	r3, #256	; 0x100
3481464c:	0a000001 	beq	34814658 <dm9000_rx+0xe4>
				printf("rx fifo error\n");
34814650:	e59f0064 	ldr	r0, [pc, #100]	; 348146bc <dm9000_rx+0x148>
34814654:	ebffd23c 	bl	34808f4c <printf>
			}
			if (RxStatus & 0x200) {
34814658:	e1dd30b6 	ldrh	r3, [sp, #6]
3481465c:	e3130c02 	tst	r3, #512	; 0x200
34814660:	0a000001 	beq	3481466c <dm9000_rx+0xf8>
				printf("rx crc error\n");
34814664:	e59f0054 	ldr	r0, [pc, #84]	; 348146c0 <dm9000_rx+0x14c>
34814668:	ebffd237 	bl	34808f4c <printf>
			}
			if (RxStatus & 0x8000) {
3481466c:	e1dd30f6 	ldrsh	r3, [sp, #6]
34814670:	e3530000 	cmp	r3, #0
34814674:	aa000001 	bge	34814680 <dm9000_rx+0x10c>
				printf("rx length error\n");
34814678:	e59f0044 	ldr	r0, [pc, #68]	; 348146c4 <dm9000_rx+0x150>
3481467c:	ebffd232 	bl	34808f4c <printf>
			}
			if (RxLen > DM9000_PKT_MAX) {
34814680:	e1dd30b4 	ldrh	r3, [sp, #4]
34814684:	e3530c06 	cmp	r3, #1536	; 0x600
34814688:	9affffcb 	bls	348145bc <dm9000_rx+0x48>
				printf("rx length too big\n");
3481468c:	e59f0034 	ldr	r0, [pc, #52]	; 348146c8 <dm9000_rx+0x154>
34814690:	ebffd22d 	bl	34808f4c <printf>
				dm9000_reset();
34814694:	ebffff87 	bl	348144b8 <dm9000_reset>
34814698:	eaffffc7 	b	348145bc <dm9000_rx+0x48>
			}
		} else {
			DM9000_DMP_PACKET(__func__ , rdptr, RxLen);

			DM9000_DBG("passing packet to upper layer\n");
			NetReceive(NetRxPackets[0], RxLen);
3481469c:	e59b0000 	ldr	r0, [fp]
348146a0:	eb002528 	bl	3481db48 <NetReceive>
348146a4:	eaffffc4 	b	348145bc <dm9000_rx+0x48>
		}
	}
	return 0;
}
348146a8:	e3a00000 	mov	r0, #0
348146ac:	e8bd8efc 	pop	{r2, r3, r4, r5, r6, r7, r9, sl, fp, pc}
348146b0:	3482d870 	.word	0x3482d870
348146b4:	3482b224 	.word	0x3482b224
348146b8:	34827479 	.word	0x34827479
348146bc:	348274a0 	.word	0x348274a0
348146c0:	348274af 	.word	0x348274af
348146c4:	348274bd 	.word	0x348274bd
348146c8:	348274ce 	.word	0x348274ce

348146cc <dm9000_halt>:
/*
  Stop the interface.
  The interface is stopped when it is brought.
*/
static void dm9000_halt(struct eth_device *netdev)
{
348146cc:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
   Write a byte to I/O port
*/
static void
DM9000_iow(int reg, u8 value)
{
	DM9000_outb(reg, DM9000_IO);
348146d0:	e3a04322 	mov	r4, #-2013265920	; 0x88000000
348146d4:	e3a0300c 	mov	r3, #12
348146d8:	e5c43000 	strb	r3, [r4]
	DM9000_outb(value, DM9000_DATA);
348146dc:	e2833034 	add	r3, r3, #52	; 0x34
348146e0:	e5c43008 	strb	r3, [r4, #8]
   Write a byte to I/O port
*/
static void
DM9000_iow(int reg, u8 value)
{
	DM9000_outb(reg, DM9000_IO);
348146e4:	e3a0300d 	mov	r3, #13
348146e8:	e5c43000 	strb	r3, [r4]
	DM9000_outb(value, DM9000_DATA);
348146ec:	e3a05000 	mov	r5, #0
348146f0:	e5c45008 	strb	r5, [r4, #8]
   Write a byte to I/O port
*/
static void
DM9000_iow(int reg, u8 value)
{
	DM9000_outb(reg, DM9000_IO);
348146f4:	e2833001 	add	r3, r3, #1
348146f8:	e5c43000 	strb	r3, [r4]
	DM9000_outb(value, DM9000_DATA);
348146fc:	e3e0607f 	mvn	r6, #127	; 0x7f
34814700:	e5c46008 	strb	r6, [r4, #8]
   Write a byte to I/O port
*/
static void
DM9000_iow(int reg, u8 value)
{
	DM9000_outb(reg, DM9000_IO);
34814704:	e3a0700b 	mov	r7, #11
34814708:	e5c47000 	strb	r7, [r4]
	DM9000_outb(value, DM9000_DATA);
3481470c:	e3a0300a 	mov	r3, #10
34814710:	e5c43008 	strb	r3, [r4, #8]

	/* Fill the written data into REG_0D & REG_0E */
	DM9000_iow(DM9000_EPDRL, (value & 0xff));
	DM9000_iow(DM9000_EPDRH, ((value >> 8) & 0xff));
	DM9000_iow(DM9000_EPCR, 0xa);	/* Issue phyxcer write command */
	udelay(500);			/* Wait write complete */
34814714:	e3a00f7d 	mov	r0, #500	; 0x1f4
34814718:	eb001267 	bl	348190bc <udelay>
   Write a byte to I/O port
*/
static void
DM9000_iow(int reg, u8 value)
{
	DM9000_outb(reg, DM9000_IO);
3481471c:	e5c47000 	strb	r7, [r4]
	DM9000_outb(value, DM9000_DATA);
34814720:	e5c45008 	strb	r5, [r4, #8]
   Write a byte to I/O port
*/
static void
DM9000_iow(int reg, u8 value)
{
	DM9000_outb(reg, DM9000_IO);
34814724:	e3a0301f 	mov	r3, #31
34814728:	e5c43000 	strb	r3, [r4]
	DM9000_outb(value, DM9000_DATA);
3481472c:	e3a03001 	mov	r3, #1
34814730:	e5c43008 	strb	r3, [r4, #8]
   Write a byte to I/O port
*/
static void
DM9000_iow(int reg, u8 value)
{
	DM9000_outb(reg, DM9000_IO);
34814734:	e3e03000 	mvn	r3, #0
34814738:	e5c43000 	strb	r3, [r4]
	DM9000_outb(value, DM9000_DATA);
3481473c:	e5c46008 	strb	r6, [r4, #8]
   Write a byte to I/O port
*/
static void
DM9000_iow(int reg, u8 value)
{
	DM9000_outb(reg, DM9000_IO);
34814740:	e2833006 	add	r3, r3, #6
34814744:	e5c43000 	strb	r3, [r4]
	DM9000_outb(value, DM9000_DATA);
34814748:	e5c45008 	strb	r5, [r4, #8]
	/* RESET devie */
	dm9000_phy_write(0, 0x8000);	/* PHY RESET */
	DM9000_iow(DM9000_GPR, 0x01);	/* Power-Down PHY */
	DM9000_iow(DM9000_IMR, 0x80);	/* Disable all interrupt */
	DM9000_iow(DM9000_RCR, 0x00);	/* Disable RX */
}
3481474c:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}

34814750 <dm9000_phy_read>:
dm9000_phy_read(int reg)
{
	u16 val;

	/* Fill the phyxcer register into REG_0C */
	DM9000_iow(DM9000_EPAR, DM9000_PHY | reg);
34814750:	e3800040 	orr	r0, r0, #64	; 0x40
/*
   Read a word from phyxcer
*/
static u16
dm9000_phy_read(int reg)
{
34814754:	e92d4038 	push	{r3, r4, r5, lr}
	u16 val;

	/* Fill the phyxcer register into REG_0C */
	DM9000_iow(DM9000_EPAR, DM9000_PHY | reg);
34814758:	e6ef0070 	uxtb	r0, r0
   Write a byte to I/O port
*/
static void
DM9000_iow(int reg, u8 value)
{
	DM9000_outb(reg, DM9000_IO);
3481475c:	e3a04322 	mov	r4, #-2013265920	; 0x88000000
34814760:	e3a0300c 	mov	r3, #12
34814764:	e5c43000 	strb	r3, [r4]
	DM9000_outb(value, DM9000_DATA);
34814768:	e5c40008 	strb	r0, [r4, #8]
   Write a byte to I/O port
*/
static void
DM9000_iow(int reg, u8 value)
{
	DM9000_outb(reg, DM9000_IO);
3481476c:	e3a0500b 	mov	r5, #11
34814770:	e5c45000 	strb	r5, [r4]
	u16 val;

	/* Fill the phyxcer register into REG_0C */
	DM9000_iow(DM9000_EPAR, DM9000_PHY | reg);
	DM9000_iow(DM9000_EPCR, 0xc);	/* Issue phyxcer read command */
	udelay(100);			/* Wait read complete */
34814774:	e3a00064 	mov	r0, #100	; 0x64
*/
static void
DM9000_iow(int reg, u8 value)
{
	DM9000_outb(reg, DM9000_IO);
	DM9000_outb(value, DM9000_DATA);
34814778:	e5c43008 	strb	r3, [r4, #8]
	u16 val;

	/* Fill the phyxcer register into REG_0C */
	DM9000_iow(DM9000_EPAR, DM9000_PHY | reg);
	DM9000_iow(DM9000_EPCR, 0xc);	/* Issue phyxcer read command */
	udelay(100);			/* Wait read complete */
3481477c:	eb00124e 	bl	348190bc <udelay>
   Write a byte to I/O port
*/
static void
DM9000_iow(int reg, u8 value)
{
	DM9000_outb(reg, DM9000_IO);
34814780:	e5c45000 	strb	r5, [r4]
	DM9000_outb(value, DM9000_DATA);
34814784:	e3a03000 	mov	r3, #0
34814788:	e5c43008 	strb	r3, [r4, #8]
   Read a byte from I/O port
*/
static u8
DM9000_ior(int reg)
{
	DM9000_outb(reg, DM9000_IO);
3481478c:	e283300e 	add	r3, r3, #14
34814790:	e5c43000 	strb	r3, [r4]
	return DM9000_inb(DM9000_DATA);
34814794:	e5d40008 	ldrb	r0, [r4, #8]
   Read a byte from I/O port
*/
static u8
DM9000_ior(int reg)
{
	DM9000_outb(reg, DM9000_IO);
34814798:	e3a0300d 	mov	r3, #13
3481479c:	e5c43000 	strb	r3, [r4]
	return DM9000_inb(DM9000_DATA);
348147a0:	e5d43008 	ldrb	r3, [r4, #8]
	val = (DM9000_ior(DM9000_EPDRH) << 8) | DM9000_ior(DM9000_EPDRL);

	/* The read data keeps on REG_0D & REG_0E */
	DM9000_DBG("dm9000_phy_read(0x%x): 0x%x\n", reg, val);
	return val;
}
348147a4:	e1830400 	orr	r0, r3, r0, lsl #8
348147a8:	e8bd8038 	pop	{r3, r4, r5, pc}

348147ac <dm9000_init>:
}

/* Initialize dm9000 board
*/
static int dm9000_init(struct eth_device *dev, bd_t *bd)
{
348147ac:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
348147b0:	e1a05000 	mov	r5, r0
	struct board_info *db = &dm9000_info;

	DM9000_DBG("%s\n", __func__);

	/* RESET device */
	dm9000_reset();
348147b4:	ebffff3f 	bl	348144b8 <dm9000_reset>
   Read a byte from I/O port
*/
static u8
DM9000_ior(int reg)
{
	DM9000_outb(reg, DM9000_IO);
348147b8:	e3a04322 	mov	r4, #-2013265920	; 0x88000000
348147bc:	e3a03028 	mov	r3, #40	; 0x28
348147c0:	e5c43000 	strb	r3, [r4]
	return DM9000_inb(DM9000_DATA);
348147c4:	e5d41008 	ldrb	r1, [r4, #8]
   Read a byte from I/O port
*/
static u8
DM9000_ior(int reg)
{
	DM9000_outb(reg, DM9000_IO);
348147c8:	e2833001 	add	r3, r3, #1
348147cc:	e5c43000 	strb	r3, [r4]
	return DM9000_inb(DM9000_DATA);
348147d0:	e5d43008 	ldrb	r3, [r4, #8]
   Read a byte from I/O port
*/
static u8
DM9000_ior(int reg)
{
	DM9000_outb(reg, DM9000_IO);
348147d4:	e3a0202a 	mov	r2, #42	; 0x2a
348147d8:	e5c42000 	strb	r2, [r4]
	return DM9000_inb(DM9000_DATA);
348147dc:	e5d40008 	ldrb	r0, [r4, #8]
dm9000_probe(void)
{
	u32 id_val;
	id_val = DM9000_ior(DM9000_VIDL);
	id_val |= DM9000_ior(DM9000_VIDH) << 8;
	id_val |= DM9000_ior(DM9000_PIDL) << 16;
348147e0:	e1a00800 	lsl	r0, r0, #16
int
dm9000_probe(void)
{
	u32 id_val;
	id_val = DM9000_ior(DM9000_VIDL);
	id_val |= DM9000_ior(DM9000_VIDH) << 8;
348147e4:	e1803403 	orr	r3, r0, r3, lsl #8
	id_val |= DM9000_ior(DM9000_PIDL) << 16;
348147e8:	e1833001 	orr	r3, r3, r1
   Read a byte from I/O port
*/
static u8
DM9000_ior(int reg)
{
	DM9000_outb(reg, DM9000_IO);
348147ec:	e2822001 	add	r2, r2, #1
348147f0:	e5c42000 	strb	r2, [r4]
	return DM9000_inb(DM9000_DATA);
348147f4:	e5d42008 	ldrb	r2, [r4, #8]
{
	u32 id_val;
	id_val = DM9000_ior(DM9000_VIDL);
	id_val |= DM9000_ior(DM9000_VIDH) << 8;
	id_val |= DM9000_ior(DM9000_PIDL) << 16;
	id_val |= DM9000_ior(DM9000_PIDH) << 24;
348147f8:	e1832c02 	orr	r2, r3, r2, lsl #24
	if (id_val == DM9000_ID) {
348147fc:	e59f3270 	ldr	r3, [pc, #624]	; 34814a74 <dm9000_init+0x2c8>
34814800:	e1520003 	cmp	r2, r3
34814804:	1a000010 	bne	3481484c <dm9000_init+0xa0>
		printf("dm9000 i/o: 0x%x, id: 0x%x \n", CONFIG_DM9000_BASE,
34814808:	e1a01004 	mov	r1, r4
3481480c:	e59f0264 	ldr	r0, [pc, #612]	; 34814a78 <dm9000_init+0x2cc>
34814810:	ebffd1cd 	bl	34808f4c <printf>
   Read a byte from I/O port
*/
static u8
DM9000_ior(int reg)
{
	DM9000_outb(reg, DM9000_IO);
34814814:	e3e03001 	mvn	r3, #1
34814818:	e5c43000 	strb	r3, [r4]
	return DM9000_inb(DM9000_DATA);
3481481c:	e5d41008 	ldrb	r1, [r4, #8]

	if (dm9000_probe() < 0)
		return -1;

	/* Auto-detect 8/16/32 bit mode, ISR Bit 6+7 indicate bus width */
	io_mode = DM9000_ior(DM9000_ISR) >> 6;
34814820:	e1a01321 	lsr	r1, r1, #6

	switch (io_mode) {
34814824:	e3510001 	cmp	r1, #1
34814828:	0a000015 	beq	34814884 <dm9000_init+0xd8>
3481482c:	3a00000b 	bcc	34814860 <dm9000_init+0xb4>
34814830:	e3510002 	cmp	r1, #2
34814834:	e59f4240 	ldr	r4, [pc, #576]	; 34814a7c <dm9000_init+0x2d0>
34814838:	e59fa240 	ldr	sl, [pc, #576]	; 34814a80 <dm9000_init+0x2d4>
3481483c:	e59f7240 	ldr	r7, [pc, #576]	; 34814a84 <dm9000_init+0x2d8>
34814840:	e59f6240 	ldr	r6, [pc, #576]	; 34814a88 <dm9000_init+0x2dc>
34814844:	1a00001b 	bne	348148b8 <dm9000_init+0x10c>
34814848:	ea000017 	b	348148ac <dm9000_init+0x100>
	if (id_val == DM9000_ID) {
		printf("dm9000 i/o: 0x%x, id: 0x%x \n", CONFIG_DM9000_BASE,
		       id_val);
		return 0;
	} else {
		printf("dm9000 not found at 0x%08x id: 0x%08x\n",
3481484c:	e59f0238 	ldr	r0, [pc, #568]	; 34814a8c <dm9000_init+0x2e0>
34814850:	e1a01004 	mov	r1, r4
34814854:	ebffd1bc 	bl	34808f4c <printf>

	/* RESET device */
	dm9000_reset();

	if (dm9000_probe() < 0)
		return -1;
34814858:	e3e00000 	mvn	r0, #0
3481485c:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
	/* Auto-detect 8/16/32 bit mode, ISR Bit 6+7 indicate bus width */
	io_mode = DM9000_ior(DM9000_ISR) >> 6;

	switch (io_mode) {
	case 0x0:  /* 16-bit mode */
		printf("DM9000: running in 16 bit mode\n");
34814860:	e59f0228 	ldr	r0, [pc, #552]	; 34814a90 <dm9000_init+0x2e4>
34814864:	ebffd1b8 	bl	34808f4c <printf>
		db->outblk    = dm9000_outblk_16bit;
34814868:	e59f320c 	ldr	r3, [pc, #524]	; 34814a7c <dm9000_init+0x2d0>
3481486c:	e59f2220 	ldr	r2, [pc, #544]	; 34814a94 <dm9000_init+0x2e8>
34814870:	e583209c 	str	r2, [r3, #156]	; 0x9c
		db->inblk     = dm9000_inblk_16bit;
34814874:	e59f221c 	ldr	r2, [pc, #540]	; 34814a98 <dm9000_init+0x2ec>
34814878:	e58320a0 	str	r2, [r3, #160]	; 0xa0
		db->rx_status = dm9000_rx_status_16bit;
3481487c:	e59f2218 	ldr	r2, [pc, #536]	; 34814a9c <dm9000_init+0x2f0>
34814880:	ea000007 	b	348148a4 <dm9000_init+0xf8>
		break;
	case 0x01:  /* 32-bit mode */
		printf("DM9000: running in 32 bit mode\n");
34814884:	e59f0214 	ldr	r0, [pc, #532]	; 34814aa0 <dm9000_init+0x2f4>
34814888:	ebffd1af 	bl	34808f4c <printf>
		db->outblk    = dm9000_outblk_32bit;
3481488c:	e59f31e8 	ldr	r3, [pc, #488]	; 34814a7c <dm9000_init+0x2d0>
34814890:	e59f220c 	ldr	r2, [pc, #524]	; 34814aa4 <dm9000_init+0x2f8>
34814894:	e583209c 	str	r2, [r3, #156]	; 0x9c
		db->inblk     = dm9000_inblk_32bit;
34814898:	e59f2208 	ldr	r2, [pc, #520]	; 34814aa8 <dm9000_init+0x2fc>
3481489c:	e58320a0 	str	r2, [r3, #160]	; 0xa0
		db->rx_status = dm9000_rx_status_32bit;
348148a0:	e59f2204 	ldr	r2, [pc, #516]	; 34814aac <dm9000_init+0x300>
348148a4:	e58320a4 	str	r2, [r3, #164]	; 0xa4
		break;
348148a8:	ea000007 	b	348148cc <dm9000_init+0x120>
	case 0x02: /* 8 bit mode */
		printf("DM9000: running in 8 bit mode\n");
348148ac:	e59f01fc 	ldr	r0, [pc, #508]	; 34814ab0 <dm9000_init+0x304>
348148b0:	ebffd1a5 	bl	34808f4c <printf>
348148b4:	ea000001 	b	348148c0 <dm9000_init+0x114>
		db->inblk     = dm9000_inblk_8bit;
		db->rx_status = dm9000_rx_status_8bit;
		break;
	default:
		/* Assume 8 bit mode, will probably not work anyway */
		printf("DM9000: Undefined IO-mode:0x%x\n", io_mode);
348148b8:	e59f01f4 	ldr	r0, [pc, #500]	; 34814ab4 <dm9000_init+0x308>
348148bc:	ebffd1a2 	bl	34808f4c <printf>
		db->outblk    = dm9000_outblk_8bit;
348148c0:	e584a09c 	str	sl, [r4, #156]	; 0x9c
		db->inblk     = dm9000_inblk_8bit;
348148c4:	e58470a0 	str	r7, [r4, #160]	; 0xa0
		db->rx_status = dm9000_rx_status_8bit;
348148c8:	e58460a4 	str	r6, [r4, #164]	; 0xa4
   Write a byte to I/O port
*/
static void
DM9000_iow(int reg, u8 value)
{
	DM9000_outb(reg, DM9000_IO);
348148cc:	e3a04322 	mov	r4, #-2013265920	; 0x88000000
348148d0:	e3a03000 	mov	r3, #0
348148d4:	e5c43000 	strb	r3, [r4]
	DM9000_outb(value, DM9000_DATA);
348148d8:	e5c43008 	strb	r3, [r4, #8]
   Write a byte to I/O port
*/
static void
DM9000_iow(int reg, u8 value)
{
	DM9000_outb(reg, DM9000_IO);
348148dc:	e3a02002 	mov	r2, #2
348148e0:	e5c42000 	strb	r2, [r4]
	DM9000_outb(value, DM9000_DATA);
348148e4:	e5c43008 	strb	r3, [r4, #8]
   Write a byte to I/O port
*/
static void
DM9000_iow(int reg, u8 value)
{
	DM9000_outb(reg, DM9000_IO);
348148e8:	e2822006 	add	r2, r2, #6
348148ec:	e5c42000 	strb	r2, [r4]
	DM9000_outb(value, DM9000_DATA);
348148f0:	e2822037 	add	r2, r2, #55	; 0x37
348148f4:	e5c42008 	strb	r2, [r4, #8]
   Write a byte to I/O port
*/
static void
DM9000_iow(int reg, u8 value)
{
	DM9000_outb(reg, DM9000_IO);
348148f8:	e3a02009 	mov	r2, #9
348148fc:	e5c42000 	strb	r2, [r4]
	DM9000_outb(value, DM9000_DATA);
34814900:	e282202f 	add	r2, r2, #47	; 0x2f
34814904:	e5c42008 	strb	r2, [r4, #8]
   Write a byte to I/O port
*/
static void
DM9000_iow(int reg, u8 value)
{
	DM9000_outb(reg, DM9000_IO);
34814908:	e3a0200a 	mov	r2, #10
3481490c:	e5c42000 	strb	r2, [r4]
	DM9000_outb(value, DM9000_DATA);
34814910:	e5c43008 	strb	r3, [r4, #8]
   Write a byte to I/O port
*/
static void
DM9000_iow(int reg, u8 value)
{
	DM9000_outb(reg, DM9000_IO);
34814914:	e2822025 	add	r2, r2, #37	; 0x25
34814918:	e5c42000 	strb	r2, [r4]
	DM9000_outb(value, DM9000_DATA);
3481491c:	e5c43008 	strb	r3, [r4, #8]
   Write a byte to I/O port
*/
static void
DM9000_iow(int reg, u8 value)
{
	DM9000_outb(reg, DM9000_IO);
34814920:	e2833001 	add	r3, r3, #1
34814924:	e5c43000 	strb	r3, [r4]
	DM9000_outb(value, DM9000_DATA);
34814928:	e283302b 	add	r3, r3, #43	; 0x2b
3481492c:	e5c43008 	strb	r3, [r4, #8]
   Write a byte to I/O port
*/
static void
DM9000_iow(int reg, u8 value)
{
	DM9000_outb(reg, DM9000_IO);
34814930:	e3e03001 	mvn	r3, #1
34814934:	e5c43000 	strb	r3, [r4]
	DM9000_outb(value, DM9000_DATA);
34814938:	e2833011 	add	r3, r3, #17
3481493c:	e5c43008 	strb	r3, [r4, #8]
	/* clear TX status */
	DM9000_iow(DM9000_NSR, NSR_WAKEST | NSR_TX2END | NSR_TX1END);
	/* Clear interrupt status */
	DM9000_iow(DM9000_ISR, ISR_ROOS | ISR_ROS | ISR_PTS | ISR_PRS);

	printf("MAC: %pM\n", dev->enetaddr);
34814940:	e59f0170 	ldr	r0, [pc, #368]	; 34814ab8 <dm9000_init+0x30c>
34814944:	e2851010 	add	r1, r5, #16
34814948:	ebffd17f 	bl	34808f4c <printf>

	/* fill device MAC address registers */
	for (i = 0, oft = DM9000_PAR; i < 6; i++, oft++)
3481494c:	e3a03010 	mov	r3, #16
		DM9000_iow(oft, dev->enetaddr[i]);
34814950:	e7d52003 	ldrb	r2, [r5, r3]
34814954:	e6ef1073 	uxtb	r1, r3
   Write a byte to I/O port
*/
static void
DM9000_iow(int reg, u8 value)
{
	DM9000_outb(reg, DM9000_IO);
34814958:	e5c41000 	strb	r1, [r4]
	DM9000_iow(DM9000_ISR, ISR_ROOS | ISR_ROS | ISR_PTS | ISR_PRS);

	printf("MAC: %pM\n", dev->enetaddr);

	/* fill device MAC address registers */
	for (i = 0, oft = DM9000_PAR; i < 6; i++, oft++)
3481495c:	e2833001 	add	r3, r3, #1
34814960:	e3530016 	cmp	r3, #22
*/
static void
DM9000_iow(int reg, u8 value)
{
	DM9000_outb(reg, DM9000_IO);
	DM9000_outb(value, DM9000_DATA);
34814964:	e5c42008 	strb	r2, [r4, #8]
	DM9000_iow(DM9000_ISR, ISR_ROOS | ISR_ROS | ISR_PTS | ISR_PRS);

	printf("MAC: %pM\n", dev->enetaddr);

	/* fill device MAC address registers */
	for (i = 0, oft = DM9000_PAR; i < 6; i++, oft++)
34814968:	1afffff8 	bne	34814950 <dm9000_init+0x1a4>
   Write a byte to I/O port
*/
static void
DM9000_iow(int reg, u8 value)
{
	DM9000_outb(reg, DM9000_IO);
3481496c:	e3a01322 	mov	r1, #-2013265920	; 0x88000000
	DM9000_outb(value, DM9000_DATA);
34814970:	e3e00000 	mvn	r0, #0
	DM9000_iow(DM9000_ISR, ISR_ROOS | ISR_ROS | ISR_PTS | ISR_PRS);

	printf("MAC: %pM\n", dev->enetaddr);

	/* fill device MAC address registers */
	for (i = 0, oft = DM9000_PAR; i < 6; i++, oft++)
34814974:	e6efc073 	uxtb	ip, r3
   Write a byte to I/O port
*/
static void
DM9000_iow(int reg, u8 value)
{
	DM9000_outb(reg, DM9000_IO);
34814978:	e3a02322 	mov	r2, #-2013265920	; 0x88000000
3481497c:	e5c1c000 	strb	ip, [r1]
	printf("MAC: %pM\n", dev->enetaddr);

	/* fill device MAC address registers */
	for (i = 0, oft = DM9000_PAR; i < 6; i++, oft++)
		DM9000_iow(oft, dev->enetaddr[i]);
	for (i = 0, oft = 0x16; i < 8; i++, oft++)
34814980:	e2833001 	add	r3, r3, #1
34814984:	e353001e 	cmp	r3, #30
*/
static void
DM9000_iow(int reg, u8 value)
{
	DM9000_outb(reg, DM9000_IO);
	DM9000_outb(value, DM9000_DATA);
34814988:	e5c10008 	strb	r0, [r1, #8]
	printf("MAC: %pM\n", dev->enetaddr);

	/* fill device MAC address registers */
	for (i = 0, oft = DM9000_PAR; i < 6; i++, oft++)
		DM9000_iow(oft, dev->enetaddr[i]);
	for (i = 0, oft = 0x16; i < 8; i++, oft++)
3481498c:	1afffff8 	bne	34814974 <dm9000_init+0x1c8>
   Write a byte to I/O port
*/
static void
DM9000_iow(int reg, u8 value)
{
	DM9000_outb(reg, DM9000_IO);
34814990:	e3a03005 	mov	r3, #5
34814994:	e5c23000 	strb	r3, [r2]
	DM9000_outb(value, DM9000_DATA);
34814998:	e283302c 	add	r3, r3, #44	; 0x2c
3481499c:	e5c23008 	strb	r3, [r2, #8]
   Write a byte to I/O port
*/
static void
DM9000_iow(int reg, u8 value)
{
	DM9000_outb(reg, DM9000_IO);
348149a0:	e3e03000 	mvn	r3, #0
348149a4:	e5c23000 	strb	r3, [r2]
	DM9000_outb(value, DM9000_DATA);
348149a8:	e3e0307f 	mvn	r3, #127	; 0x7f
348149ac:	e5c23008 	strb	r3, [r2, #8]
	/* RX enable */
	DM9000_iow(DM9000_RCR, RCR_DIS_LONG | RCR_DIS_CRC | RCR_RXEN);
	/* Enable TX/RX interrupt mask */
	DM9000_iow(DM9000_IMR, IMR_PAR);

	i = 0;
348149b0:	e3a04000 	mov	r4, #0
	while (!(dm9000_phy_read(1) & 0x20)) {	/* autonegation complete bit */
		udelay(1000);
		i++;
		if (i == 10000) {
348149b4:	e3026710 	movw	r6, #10000	; 0x2710
	DM9000_iow(DM9000_RCR, RCR_DIS_LONG | RCR_DIS_CRC | RCR_RXEN);
	/* Enable TX/RX interrupt mask */
	DM9000_iow(DM9000_IMR, IMR_PAR);

	i = 0;
	while (!(dm9000_phy_read(1) & 0x20)) {	/* autonegation complete bit */
348149b8:	ea000008 	b	348149e0 <dm9000_init+0x234>
		udelay(1000);
348149bc:	e3a00ffa 	mov	r0, #1000	; 0x3e8
		i++;
348149c0:	e2844001 	add	r4, r4, #1
	/* Enable TX/RX interrupt mask */
	DM9000_iow(DM9000_IMR, IMR_PAR);

	i = 0;
	while (!(dm9000_phy_read(1) & 0x20)) {	/* autonegation complete bit */
		udelay(1000);
348149c4:	eb0011bc 	bl	348190bc <udelay>
		i++;
		if (i == 10000) {
348149c8:	e1540006 	cmp	r4, r6
348149cc:	1a000003 	bne	348149e0 <dm9000_init+0x234>
			printf("could not establish link\n");
348149d0:	e59f00e4 	ldr	r0, [pc, #228]	; 34814abc <dm9000_init+0x310>
348149d4:	ebffd15c 	bl	34808f4c <printf>
			return 0;
348149d8:	e1a00005 	mov	r0, r5
348149dc:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
	DM9000_iow(DM9000_RCR, RCR_DIS_LONG | RCR_DIS_CRC | RCR_RXEN);
	/* Enable TX/RX interrupt mask */
	DM9000_iow(DM9000_IMR, IMR_PAR);

	i = 0;
	while (!(dm9000_phy_read(1) & 0x20)) {	/* autonegation complete bit */
348149e0:	e3a00001 	mov	r0, #1
348149e4:	ebffff59 	bl	34814750 <dm9000_phy_read>
348149e8:	e2105020 	ands	r5, r0, #32
348149ec:	0afffff2 	beq	348149bc <dm9000_init+0x210>
			return 0;
		}
	}

	/* see what we've got */
	lnk = dm9000_phy_read(17) >> 12;
348149f0:	e3a00011 	mov	r0, #17
348149f4:	ebffff55 	bl	34814750 <dm9000_phy_read>
348149f8:	e7ef4650 	ubfx	r4, r0, #12, #16
	printf("operating at ");
348149fc:	e59f00bc 	ldr	r0, [pc, #188]	; 34814ac0 <dm9000_init+0x314>
34814a00:	ebffd151 	bl	34808f4c <printf>
	switch (lnk) {
34814a04:	e2443001 	sub	r3, r4, #1
34814a08:	e3530007 	cmp	r3, #7
34814a0c:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
34814a10:	ea000010 	b	34814a58 <dm9000_init+0x2ac>
34814a14:	34814a34 	.word	0x34814a34
34814a18:	34814a3c 	.word	0x34814a3c
34814a1c:	34814a58 	.word	0x34814a58
34814a20:	34814a48 	.word	0x34814a48
34814a24:	34814a58 	.word	0x34814a58
34814a28:	34814a58 	.word	0x34814a58
34814a2c:	34814a58 	.word	0x34814a58
34814a30:	34814a50 	.word	0x34814a50
	case 1:
		printf("10M half duplex ");
34814a34:	e59f0088 	ldr	r0, [pc, #136]	; 34814ac4 <dm9000_init+0x318>
34814a38:	ea000000 	b	34814a40 <dm9000_init+0x294>
		break;
	case 2:
		printf("10M full duplex ");
34814a3c:	e59f0084 	ldr	r0, [pc, #132]	; 34814ac8 <dm9000_init+0x31c>
34814a40:	ebffd141 	bl	34808f4c <printf>
		break;
34814a44:	ea000006 	b	34814a64 <dm9000_init+0x2b8>
	case 4:
		printf("100M half duplex ");
34814a48:	e59f007c 	ldr	r0, [pc, #124]	; 34814acc <dm9000_init+0x320>
34814a4c:	eafffffb 	b	34814a40 <dm9000_init+0x294>
		break;
	case 8:
		printf("100M full duplex ");
34814a50:	e59f0078 	ldr	r0, [pc, #120]	; 34814ad0 <dm9000_init+0x324>
34814a54:	eafffff9 	b	34814a40 <dm9000_init+0x294>
		break;
	default:
		printf("unknown: %d ", lnk);
34814a58:	e59f0074 	ldr	r0, [pc, #116]	; 34814ad4 <dm9000_init+0x328>
34814a5c:	e1a01004 	mov	r1, r4
34814a60:	ebffd139 	bl	34808f4c <printf>
		break;
	}
	printf("mode\n");
34814a64:	e59f006c 	ldr	r0, [pc, #108]	; 34814ad8 <dm9000_init+0x32c>
34814a68:	ebffd137 	bl	34808f4c <printf>
	return 0;
34814a6c:	e3a00000 	mov	r0, #0
}
34814a70:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
34814a74:	90000a46 	.word	0x90000a46
34814a78:	348274e1 	.word	0x348274e1
34814a7c:	3482b224 	.word	0x3482b224
34814a80:	34814338 	.word	0x34814338
34814a84:	348143c0 	.word	0x348143c0
34814a88:	34814488 	.word	0x34814488
34814a8c:	348274fe 	.word	0x348274fe
34814a90:	34827525 	.word	0x34827525
34814a94:	3481435c 	.word	0x3481435c
34814a98:	348143e4 	.word	0x348143e4
34814a9c:	34814468 	.word	0x34814468
34814aa0:	34827545 	.word	0x34827545
34814aa4:	3481438c 	.word	0x3481438c
34814aa8:	34814414 	.word	0x34814414
34814aac:	34814448 	.word	0x34814448
34814ab0:	34827565 	.word	0x34827565
34814ab4:	34827584 	.word	0x34827584
34814ab8:	348275a4 	.word	0x348275a4
34814abc:	348275ae 	.word	0x348275ae
34814ac0:	348275c8 	.word	0x348275c8
34814ac4:	348275d6 	.word	0x348275d6
34814ac8:	348275e7 	.word	0x348275e7
34814acc:	348275f8 	.word	0x348275f8
34814ad0:	3482760a 	.word	0x3482760a
34814ad4:	3482761c 	.word	0x3482761c
34814ad8:	3482755f 	.word	0x3482755f

34814adc <dm9000_send>:
/*
  Hardware start transmission.
  Send a packet to media from the upper layer.
*/
static int dm9000_send(struct eth_device *netdev, void *packet, int length)
{
34814adc:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
34814ae0:	e1a05002 	mov	r5, r2
   Write a byte to I/O port
*/
static void
DM9000_iow(int reg, u8 value)
{
	DM9000_outb(reg, DM9000_IO);
34814ae4:	e3a04322 	mov	r4, #-2013265920	; 0x88000000
34814ae8:	e3e06001 	mvn	r6, #1
34814aec:	e5c46000 	strb	r6, [r4]
	DM9000_outb(value, DM9000_DATA);
34814af0:	e3a07002 	mov	r7, #2
34814af4:	e5c47008 	strb	r7, [r4, #8]
	DM9000_DMP_PACKET(__func__ , packet, length);

	DM9000_iow(DM9000_ISR, IMR_PTM); /* Clear Tx bit in ISR */

	/* Move data to DM9000 TX RAM */
	DM9000_outb(DM9000_MWCMD, DM9000_IO); /* Prepare for TX-data */
34814af8:	e3e03007 	mvn	r3, #7
34814afc:	e5c43000 	strb	r3, [r4]

	/* push the data to the TX-fifo */
	(db->outblk)(packet, length);
34814b00:	e59f30a4 	ldr	r3, [pc, #164]	; 34814bac <dm9000_send+0xd0>
34814b04:	e1a00001 	mov	r0, r1
34814b08:	e593309c 	ldr	r3, [r3, #156]	; 0x9c
34814b0c:	e1a01002 	mov	r1, r2
34814b10:	e12fff33 	blx	r3

	/* Set TX length to DM9000 */
	DM9000_iow(DM9000_TXPLL, length & 0xff);
34814b14:	e6ef3075 	uxtb	r3, r5
   Write a byte to I/O port
*/
static void
DM9000_iow(int reg, u8 value)
{
	DM9000_outb(reg, DM9000_IO);
34814b18:	e3e02003 	mvn	r2, #3
34814b1c:	e5c42000 	strb	r2, [r4]
	DM9000_outb(value, DM9000_DATA);
34814b20:	e5c43008 	strb	r3, [r4, #8]
	/* push the data to the TX-fifo */
	(db->outblk)(packet, length);

	/* Set TX length to DM9000 */
	DM9000_iow(DM9000_TXPLL, length & 0xff);
	DM9000_iow(DM9000_TXPLH, (length >> 8) & 0xff);
34814b24:	e7e75455 	ubfx	r5, r5, #8, #8
   Write a byte to I/O port
*/
static void
DM9000_iow(int reg, u8 value)
{
	DM9000_outb(reg, DM9000_IO);
34814b28:	e3e03002 	mvn	r3, #2
34814b2c:	e5c43000 	strb	r3, [r4]
	DM9000_outb(value, DM9000_DATA);
34814b30:	e5c45008 	strb	r5, [r4, #8]
   Write a byte to I/O port
*/
static void
DM9000_iow(int reg, u8 value)
{
	DM9000_outb(reg, DM9000_IO);
34814b34:	e5c47000 	strb	r7, [r4]
	DM9000_outb(value, DM9000_DATA);
34814b38:	e3a05001 	mov	r5, #1
34814b3c:	e5c45008 	strb	r5, [r4, #8]

	/* Issue TX polling command */
	DM9000_iow(DM9000_TCR, TCR_TXREQ); /* Cleared after TX complete */

	/* wait for end of transmission */
	tmo = get_timer(0) + 5 * CONFIG_SYS_HZ;
34814b40:	e3a00000 	mov	r0, #0
34814b44:	ebffb1c2 	bl	34801254 <get_timer>
34814b48:	e2800d4e 	add	r0, r0, #4992	; 0x1380
34814b4c:	e2807008 	add	r7, r0, #8
	while ( !(DM9000_ior(DM9000_NSR) & (NSR_TX1END | NSR_TX2END)) ||
34814b50:	ea000006 	b	34814b70 <dm9000_send+0x94>
		!(DM9000_ior(DM9000_ISR) & IMR_PTM) ) {
		if (get_timer(0) >= tmo) {
34814b54:	e3a00000 	mov	r0, #0
34814b58:	ebffb1bd 	bl	34801254 <get_timer>
34814b5c:	e1500007 	cmp	r0, r7
34814b60:	3a000002 	bcc	34814b70 <dm9000_send+0x94>
			printf("transmission timeout\n");
34814b64:	e59f0044 	ldr	r0, [pc, #68]	; 34814bb0 <dm9000_send+0xd4>
34814b68:	ebffd0f7 	bl	34808f4c <printf>
			break;
34814b6c:	ea000007 	b	34814b90 <dm9000_send+0xb4>
   Read a byte from I/O port
*/
static u8
DM9000_ior(int reg)
{
	DM9000_outb(reg, DM9000_IO);
34814b70:	e5c45000 	strb	r5, [r4]
	return DM9000_inb(DM9000_DATA);
34814b74:	e5d43008 	ldrb	r3, [r4, #8]
	/* Issue TX polling command */
	DM9000_iow(DM9000_TCR, TCR_TXREQ); /* Cleared after TX complete */

	/* wait for end of transmission */
	tmo = get_timer(0) + 5 * CONFIG_SYS_HZ;
	while ( !(DM9000_ior(DM9000_NSR) & (NSR_TX1END | NSR_TX2END)) ||
34814b78:	e313000c 	tst	r3, #12
34814b7c:	0afffff4 	beq	34814b54 <dm9000_send+0x78>
   Read a byte from I/O port
*/
static u8
DM9000_ior(int reg)
{
	DM9000_outb(reg, DM9000_IO);
34814b80:	e5c46000 	strb	r6, [r4]
	return DM9000_inb(DM9000_DATA);
34814b84:	e5d43008 	ldrb	r3, [r4, #8]
	/* Issue TX polling command */
	DM9000_iow(DM9000_TCR, TCR_TXREQ); /* Cleared after TX complete */

	/* wait for end of transmission */
	tmo = get_timer(0) + 5 * CONFIG_SYS_HZ;
	while ( !(DM9000_ior(DM9000_NSR) & (NSR_TX1END | NSR_TX2END)) ||
34814b88:	e3130002 	tst	r3, #2
34814b8c:	0afffff0 	beq	34814b54 <dm9000_send+0x78>
   Write a byte to I/O port
*/
static void
DM9000_iow(int reg, u8 value)
{
	DM9000_outb(reg, DM9000_IO);
34814b90:	e3a03322 	mov	r3, #-2013265920	; 0x88000000
34814b94:	e3e02001 	mvn	r2, #1
34814b98:	e5c32000 	strb	r2, [r3]
	DM9000_outb(value, DM9000_DATA);
34814b9c:	e2822004 	add	r2, r2, #4
34814ba0:	e5c32008 	strb	r2, [r3, #8]
	}
	DM9000_iow(DM9000_ISR, IMR_PTM); /* Clear Tx bit in ISR */

	DM9000_DBG("transmit done\n\n");
	return 0;
}
34814ba4:	e3a00000 	mov	r0, #0
34814ba8:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
34814bac:	3482b224 	.word	0x3482b224
34814bb0:	34827629 	.word	0x34827629

34814bb4 <dm9000_read_srom_word>:
/*
  Read a word data from SROM
*/
#if !defined(CONFIG_DM9000_NO_SROM)
void dm9000_read_srom_word(int offset, u8 *to)
{
34814bb4:	e92d4070 	push	{r4, r5, r6, lr}
	DM9000_iow(DM9000_EPAR, offset);
34814bb8:	e6ef0070 	uxtb	r0, r0
/*
  Read a word data from SROM
*/
#if !defined(CONFIG_DM9000_NO_SROM)
void dm9000_read_srom_word(int offset, u8 *to)
{
34814bbc:	e1a05001 	mov	r5, r1
   Write a byte to I/O port
*/
static void
DM9000_iow(int reg, u8 value)
{
	DM9000_outb(reg, DM9000_IO);
34814bc0:	e3a04322 	mov	r4, #-2013265920	; 0x88000000
34814bc4:	e3a0300c 	mov	r3, #12
34814bc8:	e5c43000 	strb	r3, [r4]
	DM9000_outb(value, DM9000_DATA);
34814bcc:	e5c40008 	strb	r0, [r4, #8]
   Write a byte to I/O port
*/
static void
DM9000_iow(int reg, u8 value)
{
	DM9000_outb(reg, DM9000_IO);
34814bd0:	e3a0600b 	mov	r6, #11
34814bd4:	e5c46000 	strb	r6, [r4]
	DM9000_outb(value, DM9000_DATA);
34814bd8:	e3a03004 	mov	r3, #4
34814bdc:	e5c43008 	strb	r3, [r4, #8]
#if !defined(CONFIG_DM9000_NO_SROM)
void dm9000_read_srom_word(int offset, u8 *to)
{
	DM9000_iow(DM9000_EPAR, offset);
	DM9000_iow(DM9000_EPCR, 0x4);
	udelay(8000);
34814be0:	e3a00d7d 	mov	r0, #8000	; 0x1f40
34814be4:	eb001134 	bl	348190bc <udelay>
   Write a byte to I/O port
*/
static void
DM9000_iow(int reg, u8 value)
{
	DM9000_outb(reg, DM9000_IO);
34814be8:	e5c46000 	strb	r6, [r4]
	DM9000_outb(value, DM9000_DATA);
34814bec:	e3a03000 	mov	r3, #0
34814bf0:	e5c43008 	strb	r3, [r4, #8]
   Read a byte from I/O port
*/
static u8
DM9000_ior(int reg)
{
	DM9000_outb(reg, DM9000_IO);
34814bf4:	e283300d 	add	r3, r3, #13
34814bf8:	e5c43000 	strb	r3, [r4]
	return DM9000_inb(DM9000_DATA);
34814bfc:	e5d43008 	ldrb	r3, [r4, #8]
{
	DM9000_iow(DM9000_EPAR, offset);
	DM9000_iow(DM9000_EPCR, 0x4);
	udelay(8000);
	DM9000_iow(DM9000_EPCR, 0x0);
	to[0] = DM9000_ior(DM9000_EPDRL);
34814c00:	e5c53000 	strb	r3, [r5]
   Read a byte from I/O port
*/
static u8
DM9000_ior(int reg)
{
	DM9000_outb(reg, DM9000_IO);
34814c04:	e3a0300e 	mov	r3, #14
34814c08:	e5c43000 	strb	r3, [r4]
	return DM9000_inb(DM9000_DATA);
34814c0c:	e5d43008 	ldrb	r3, [r4, #8]
	DM9000_iow(DM9000_EPAR, offset);
	DM9000_iow(DM9000_EPCR, 0x4);
	udelay(8000);
	DM9000_iow(DM9000_EPCR, 0x0);
	to[0] = DM9000_ior(DM9000_EPDRL);
	to[1] = DM9000_ior(DM9000_EPDRH);
34814c10:	e5c53001 	strb	r3, [r5, #1]
}
34814c14:	e8bd8070 	pop	{r4, r5, r6, pc}

34814c18 <dm9000_write_srom_word>:

void dm9000_write_srom_word(int offset, u16 val)
{
34814c18:	e92d4038 	push	{r3, r4, r5, lr}
	DM9000_iow(DM9000_EPAR, offset);
34814c1c:	e6ef0070 	uxtb	r0, r0
   Write a byte to I/O port
*/
static void
DM9000_iow(int reg, u8 value)
{
	DM9000_outb(reg, DM9000_IO);
34814c20:	e3a04322 	mov	r4, #-2013265920	; 0x88000000
34814c24:	e3a0300c 	mov	r3, #12
34814c28:	e5c43000 	strb	r3, [r4]
	DM9000_outb(value, DM9000_DATA);
34814c2c:	e5c40008 	strb	r0, [r4, #8]
}

void dm9000_write_srom_word(int offset, u16 val)
{
	DM9000_iow(DM9000_EPAR, offset);
	DM9000_iow(DM9000_EPDRH, ((val >> 8) & 0xff));
34814c30:	e1a03421 	lsr	r3, r1, #8
   Write a byte to I/O port
*/
static void
DM9000_iow(int reg, u8 value)
{
	DM9000_outb(reg, DM9000_IO);
34814c34:	e3a0200e 	mov	r2, #14
34814c38:	e5c42000 	strb	r2, [r4]
	DM9000_outb(value, DM9000_DATA);
34814c3c:	e5c43008 	strb	r3, [r4, #8]

void dm9000_write_srom_word(int offset, u16 val)
{
	DM9000_iow(DM9000_EPAR, offset);
	DM9000_iow(DM9000_EPDRH, ((val >> 8) & 0xff));
	DM9000_iow(DM9000_EPDRL, (val & 0xff));
34814c40:	e6ef1071 	uxtb	r1, r1
   Write a byte to I/O port
*/
static void
DM9000_iow(int reg, u8 value)
{
	DM9000_outb(reg, DM9000_IO);
34814c44:	e3a0300d 	mov	r3, #13
34814c48:	e5c43000 	strb	r3, [r4]
	DM9000_outb(value, DM9000_DATA);
34814c4c:	e5c41008 	strb	r1, [r4, #8]
   Write a byte to I/O port
*/
static void
DM9000_iow(int reg, u8 value)
{
	DM9000_outb(reg, DM9000_IO);
34814c50:	e3a0500b 	mov	r5, #11
34814c54:	e5c45000 	strb	r5, [r4]
	DM9000_outb(value, DM9000_DATA);
34814c58:	e2833005 	add	r3, r3, #5
34814c5c:	e5c43008 	strb	r3, [r4, #8]
{
	DM9000_iow(DM9000_EPAR, offset);
	DM9000_iow(DM9000_EPDRH, ((val >> 8) & 0xff));
	DM9000_iow(DM9000_EPDRL, (val & 0xff));
	DM9000_iow(DM9000_EPCR, 0x12);
	udelay(8000);
34814c60:	e3a00d7d 	mov	r0, #8000	; 0x1f40
34814c64:	eb001114 	bl	348190bc <udelay>
   Write a byte to I/O port
*/
static void
DM9000_iow(int reg, u8 value)
{
	DM9000_outb(reg, DM9000_IO);
34814c68:	e5c45000 	strb	r5, [r4]
	DM9000_outb(value, DM9000_DATA);
34814c6c:	e3a03000 	mov	r3, #0
34814c70:	e5c43008 	strb	r3, [r4, #8]
	DM9000_iow(DM9000_EPDRH, ((val >> 8) & 0xff));
	DM9000_iow(DM9000_EPDRL, (val & 0xff));
	DM9000_iow(DM9000_EPCR, 0x12);
	udelay(8000);
	DM9000_iow(DM9000_EPCR, 0);
}
34814c74:	e8bd8038 	pop	{r3, r4, r5, pc}

34814c78 <dm9000_initialize>:
	DM9000_iow(DM9000_EPCR, 0x0);	/* Clear phyxcer write command */
	DM9000_DBG("dm9000_phy_write(reg:0x%x, value:0x%x)\n", reg, value);
}

int dm9000_initialize(bd_t *bis)
{
34814c78:	e92d4010 	push	{r4, lr}
static void dm9000_get_enetaddr(struct eth_device *dev)
{
#if !defined(CONFIG_DM9000_NO_SROM)
	int i;
	for (i = 0; i < 3; i++)
		dm9000_read_srom_word(i, dev->enetaddr + (2 * i));
34814c7c:	e59f4060 	ldr	r4, [pc, #96]	; 34814ce4 <dm9000_initialize+0x6c>
34814c80:	e3a00000 	mov	r0, #0
34814c84:	e28410b8 	add	r1, r4, #184	; 0xb8
34814c88:	ebffffc9 	bl	34814bb4 <dm9000_read_srom_word>
34814c8c:	e28410ba 	add	r1, r4, #186	; 0xba
34814c90:	e3a00001 	mov	r0, #1
34814c94:	ebffffc6 	bl	34814bb4 <dm9000_read_srom_word>
34814c98:	e28410bc 	add	r1, r4, #188	; 0xbc
34814c9c:	e3a00002 	mov	r0, #2
34814ca0:	ebffffc3 	bl	34814bb4 <dm9000_read_srom_word>
	struct eth_device *dev = &(dm9000_info.netdev);

	/* Load MAC address from EEPROM */
	dm9000_get_enetaddr(dev);

	dev->init = dm9000_init;
34814ca4:	e59f303c 	ldr	r3, [pc, #60]	; 34814ce8 <dm9000_initialize+0x70>
	dev->halt = dm9000_halt;
	dev->send = dm9000_send;
	dev->recv = dm9000_rx;
	sprintf(dev->name, "dm9000");
34814ca8:	e59f103c 	ldr	r1, [pc, #60]	; 34814cec <dm9000_initialize+0x74>
	struct eth_device *dev = &(dm9000_info.netdev);

	/* Load MAC address from EEPROM */
	dm9000_get_enetaddr(dev);

	dev->init = dm9000_init;
34814cac:	e58430c8 	str	r3, [r4, #200]	; 0xc8
	dev->halt = dm9000_halt;
34814cb0:	e59f3038 	ldr	r3, [pc, #56]	; 34814cf0 <dm9000_initialize+0x78>
34814cb4:	e58430d4 	str	r3, [r4, #212]	; 0xd4
	dev->send = dm9000_send;
34814cb8:	e59f3034 	ldr	r3, [pc, #52]	; 34814cf4 <dm9000_initialize+0x7c>
34814cbc:	e58430cc 	str	r3, [r4, #204]	; 0xcc
	dev->recv = dm9000_rx;
34814cc0:	e59f3030 	ldr	r3, [pc, #48]	; 34814cf8 <dm9000_initialize+0x80>
34814cc4:	e58430d0 	str	r3, [r4, #208]	; 0xd0
	sprintf(dev->name, "dm9000");
34814cc8:	e28440a8 	add	r4, r4, #168	; 0xa8
34814ccc:	e1a00004 	mov	r0, r4
34814cd0:	eb00146e 	bl	34819e90 <sprintf>

	eth_register(dev);
34814cd4:	e1a00004 	mov	r0, r4
34814cd8:	eb00219b 	bl	3481d34c <eth_register>

	return 0;
}
34814cdc:	e3a00000 	mov	r0, #0
34814ce0:	e8bd8010 	pop	{r4, pc}
34814ce4:	3482b224 	.word	0x3482b224
34814ce8:	348147ac 	.word	0x348147ac
34814cec:	3482763f 	.word	0x3482763f
34814cf0:	348146cc 	.word	0x348146cc
34814cf4:	34814adc 	.word	0x34814adc
34814cf8:	34814574 	.word	0x34814574

34814cfc <samsung_get_base_uart>:
static inline int cpu_is_##type(void)			\
{							\
	return s5p_cpu_id == id ? 1 : 0;		\
}

IS_SAMSUNG_TYPE(s5pc100, 0xc100)
34814cfc:	e59f3028 	ldr	r3, [pc, #40]	; 34814d2c <samsung_get_base_uart+0x30>
34814d00:	e5933000 	ldr	r3, [r3]
SAMSUNG_BASE(gpio, GPIO_BASE)
SAMSUNG_BASE(pro_id, PRO_ID)
SAMSUNG_BASE(mmc, MMC_BASE)
SAMSUNG_BASE(sromc, SROMC_BASE)
SAMSUNG_BASE(timer, PWMTIMER_BASE)
SAMSUNG_BASE(uart, UART_BASE)
34814d04:	e3530cc1 	cmp	r3, #49408	; 0xc100
34814d08:	0a000005 	beq	34814d24 <samsung_get_base_uart+0x28>
34814d0c:	e30c0110 	movw	r0, #49424	; 0xc110
34814d10:	e59f2018 	ldr	r2, [pc, #24]	; 34814d30 <samsung_get_base_uart+0x34>
34814d14:	e1530000 	cmp	r3, r0
34814d18:	01a00002 	moveq	r0, r2
34814d1c:	13a00000 	movne	r0, #0
34814d20:	e12fff1e 	bx	lr
34814d24:	e3a0033b 	mov	r0, #-335544320	; 0xec000000
34814d28:	e12fff1e 	bx	lr
34814d2c:	34828214 	.word	0x34828214
34814d30:	e2900000 	.word	0xe2900000

34814d34 <serial_setbrg_dev>:
	0xdfdf,
	0xffdf,
};

void serial_setbrg_dev(const int dev_index)
{
34814d34:	e92d4038 	push	{r3, r4, r5, lr}
34814d38:	e1a05000 	mov	r5, r0
DECLARE_GLOBAL_DATA_PTR;

static inline struct s5p_uart *s5p_get_base_uart(int dev_index)
{
	u32 offset = dev_index * sizeof(struct s5p_uart);
	return (struct s5p_uart *)(samsung_get_base_uart() + offset);
34814d3c:	ebffffee 	bl	34814cfc <samsung_get_base_uart>
34814d40:	e0804505 	add	r4, r0, r5, lsl #10
};

void serial_setbrg_dev(const int dev_index)
{
	struct s5p_uart *const uart = s5p_get_base_uart(dev_index);
	u32 uclk = get_uart_clk(dev_index);
34814d44:	e1a00005 	mov	r0, r5
34814d48:	ebffb2e2 	bl	348018d8 <get_uart_clk>
	u32 baudrate = gd->baudrate;
34814d4c:	e5981008 	ldr	r1, [r8, #8]
	u32 val;

	val = uclk / baudrate;
34814d50:	eb002c53 	bl	3481fea4 <__udivsi3>

	writel(val / 16 - 1, &uart->ubrdiv);
34814d54:	e1a03220 	lsr	r3, r0, #4
34814d58:	e2433001 	sub	r3, r3, #1
34814d5c:	e5843028 	str	r3, [r4, #40]	; 0x28

	if (s5p_uart_divslot())
		writew(udivslot[val % 16], &uart->rest.slot);
34814d60:	e59f3010 	ldr	r3, [pc, #16]	; 34814d78 <serial_setbrg_dev+0x44>
34814d64:	e200000f 	and	r0, r0, #15
34814d68:	e7933100 	ldr	r3, [r3, r0, lsl #2]
34814d6c:	e6ff3073 	uxth	r3, r3
34814d70:	e1c432bc 	strh	r3, [r4, #44]	; 0x2c
	else
		writeb(val % 16, &uart->rest.value);
}
34814d74:	e8bd8038 	pop	{r3, r4, r5, pc}
34814d78:	34821854 	.word	0x34821854

34814d7c <s5p_serial3_setbrg>:
struct serial_device s5p_serial1_device =
	INIT_S5P_SERIAL_STRUCTURE(1, "s5pser1");
DECLARE_S5P_SERIAL_FUNCTIONS(2);
struct serial_device s5p_serial2_device =
	INIT_S5P_SERIAL_STRUCTURE(2, "s5pser2");
DECLARE_S5P_SERIAL_FUNCTIONS(3);
34814d7c:	e3a00003 	mov	r0, #3
34814d80:	eaffffeb 	b	34814d34 <serial_setbrg_dev>

34814d84 <s5p_serial2_setbrg>:
struct serial_device s5p_serial0_device =
	INIT_S5P_SERIAL_STRUCTURE(0, "s5pser0");
DECLARE_S5P_SERIAL_FUNCTIONS(1);
struct serial_device s5p_serial1_device =
	INIT_S5P_SERIAL_STRUCTURE(1, "s5pser1");
DECLARE_S5P_SERIAL_FUNCTIONS(2);
34814d84:	e3a00002 	mov	r0, #2
34814d88:	eaffffe9 	b	34814d34 <serial_setbrg_dev>

34814d8c <s5p_serial1_setbrg>:
	s5p_serial##port##_puts, }

DECLARE_S5P_SERIAL_FUNCTIONS(0);
struct serial_device s5p_serial0_device =
	INIT_S5P_SERIAL_STRUCTURE(0, "s5pser0");
DECLARE_S5P_SERIAL_FUNCTIONS(1);
34814d8c:	e3a00001 	mov	r0, #1
34814d90:	eaffffe7 	b	34814d34 <serial_setbrg_dev>

34814d94 <s5p_serial0_setbrg>:
	s5p_serial##port##_getc, \
	s5p_serial##port##_tstc, \
	s5p_serial##port##_putc, \
	s5p_serial##port##_puts, }

DECLARE_S5P_SERIAL_FUNCTIONS(0);
34814d94:	e3a00000 	mov	r0, #0
34814d98:	eaffffe5 	b	34814d34 <serial_setbrg_dev>

34814d9c <serial_init_dev>:
/*
 * Initialise the serial port with the given baudrate. The settings
 * are always 8 data bits, no parity, 1 stop bit, no start bits.
 */
int serial_init_dev(const int dev_index)
{
34814d9c:	e92d4038 	push	{r3, r4, r5, lr}
34814da0:	e1a05000 	mov	r5, r0
DECLARE_GLOBAL_DATA_PTR;

static inline struct s5p_uart *s5p_get_base_uart(int dev_index)
{
	u32 offset = dev_index * sizeof(struct s5p_uart);
	return (struct s5p_uart *)(samsung_get_base_uart() + offset);
34814da4:	ebffffd4 	bl	34814cfc <samsung_get_base_uart>
34814da8:	e0803505 	add	r3, r0, r5, lsl #10
int serial_init_dev(const int dev_index)
{
	struct s5p_uart *const uart = s5p_get_base_uart(dev_index);

	/* reset and enable FIFOs, set triggers to the maximum */
	writel(0, &uart->ufcon);
34814dac:	e3a04000 	mov	r4, #0
34814db0:	e5834008 	str	r4, [r3, #8]
	writel(0, &uart->umcon);
34814db4:	e583400c 	str	r4, [r3, #12]
	/* 8N1 */
	writel(0x3, &uart->ulcon);
34814db8:	e3a02003 	mov	r2, #3
34814dbc:	e7802505 	str	r2, [r0, r5, lsl #10]
	/* No interrupts, no DMA, pure polling */
	writel(0x245, &uart->ucon);
34814dc0:	e3002245 	movw	r2, #581	; 0x245

	serial_setbrg_dev(dev_index);
34814dc4:	e1a00005 	mov	r0, r5
	writel(0, &uart->ufcon);
	writel(0, &uart->umcon);
	/* 8N1 */
	writel(0x3, &uart->ulcon);
	/* No interrupts, no DMA, pure polling */
	writel(0x245, &uart->ucon);
34814dc8:	e5832004 	str	r2, [r3, #4]

	serial_setbrg_dev(dev_index);
34814dcc:	ebffffd8 	bl	34814d34 <serial_setbrg_dev>

	return 0;
}
34814dd0:	e1a00004 	mov	r0, r4
34814dd4:	e8bd8038 	pop	{r3, r4, r5, pc}

34814dd8 <s5p_serial3_init>:
struct serial_device s5p_serial1_device =
	INIT_S5P_SERIAL_STRUCTURE(1, "s5pser1");
DECLARE_S5P_SERIAL_FUNCTIONS(2);
struct serial_device s5p_serial2_device =
	INIT_S5P_SERIAL_STRUCTURE(2, "s5pser2");
DECLARE_S5P_SERIAL_FUNCTIONS(3);
34814dd8:	e3a00003 	mov	r0, #3
34814ddc:	eaffffee 	b	34814d9c <serial_init_dev>

34814de0 <s5p_serial2_init>:
struct serial_device s5p_serial0_device =
	INIT_S5P_SERIAL_STRUCTURE(0, "s5pser0");
DECLARE_S5P_SERIAL_FUNCTIONS(1);
struct serial_device s5p_serial1_device =
	INIT_S5P_SERIAL_STRUCTURE(1, "s5pser1");
DECLARE_S5P_SERIAL_FUNCTIONS(2);
34814de0:	e3a00002 	mov	r0, #2
34814de4:	eaffffec 	b	34814d9c <serial_init_dev>

34814de8 <s5p_serial1_init>:
	s5p_serial##port##_puts, }

DECLARE_S5P_SERIAL_FUNCTIONS(0);
struct serial_device s5p_serial0_device =
	INIT_S5P_SERIAL_STRUCTURE(0, "s5pser0");
DECLARE_S5P_SERIAL_FUNCTIONS(1);
34814de8:	e3a00001 	mov	r0, #1
34814dec:	eaffffea 	b	34814d9c <serial_init_dev>

34814df0 <s5p_serial0_init>:
	s5p_serial##port##_getc, \
	s5p_serial##port##_tstc, \
	s5p_serial##port##_putc, \
	s5p_serial##port##_puts, }

DECLARE_S5P_SERIAL_FUNCTIONS(0);
34814df0:	e3a00000 	mov	r0, #0
34814df4:	eaffffe8 	b	34814d9c <serial_init_dev>

34814df8 <serial_getc_dev>:
 * Read a single byte from the serial port. Returns 1 on success, 0
 * otherwise. When the function is succesfull, the character read is
 * written into its argument c.
 */
int serial_getc_dev(const int dev_index)
{
34814df8:	e92d4070 	push	{r4, r5, r6, lr}

DECLARE_GLOBAL_DATA_PTR;

static inline struct s5p_uart *s5p_get_base_uart(int dev_index)
{
	u32 offset = dev_index * sizeof(struct s5p_uart);
34814dfc:	e1a05500 	lsl	r5, r0, #10
	return (struct s5p_uart *)(samsung_get_base_uart() + offset);
34814e00:	ebffffbd 	bl	34814cfc <samsung_get_base_uart>
34814e04:	e0804005 	add	r4, r0, r5
int serial_getc_dev(const int dev_index)
{
	struct s5p_uart *const uart = s5p_get_base_uart(dev_index);

	/* wait for character to arrive */
	while (!(readl(&uart->utrstat) & 0x1)) {
34814e08:	ea000004 	b	34814e20 <serial_getc_dev+0x28>
DECLARE_GLOBAL_DATA_PTR;

static inline struct s5p_uart *s5p_get_base_uart(int dev_index)
{
	u32 offset = dev_index * sizeof(struct s5p_uart);
	return (struct s5p_uart *)(samsung_get_base_uart() + offset);
34814e0c:	ebffffba 	bl	34814cfc <samsung_get_base_uart>
	if (op)
		mask = 0x8;
	else
		mask = 0xf;

	return readl(&uart->uerstat) & mask;
34814e10:	e0800005 	add	r0, r0, r5
34814e14:	e5903014 	ldr	r3, [r0, #20]
{
	struct s5p_uart *const uart = s5p_get_base_uart(dev_index);

	/* wait for character to arrive */
	while (!(readl(&uart->utrstat) & 0x1)) {
		if (serial_err_check(dev_index, 0))
34814e18:	e313000f 	tst	r3, #15
34814e1c:	1a000004 	bne	34814e34 <serial_getc_dev+0x3c>
int serial_getc_dev(const int dev_index)
{
	struct s5p_uart *const uart = s5p_get_base_uart(dev_index);

	/* wait for character to arrive */
	while (!(readl(&uart->utrstat) & 0x1)) {
34814e20:	e5946010 	ldr	r6, [r4, #16]
34814e24:	e2166001 	ands	r6, r6, #1
34814e28:	0afffff7 	beq	34814e0c <serial_getc_dev+0x14>
		if (serial_err_check(dev_index, 0))
			return 0;
	}

	return (int)(readb(&uart->urxh) & 0xff);
34814e2c:	e5d40024 	ldrb	r0, [r4, #36]	; 0x24
34814e30:	e8bd8070 	pop	{r4, r5, r6, pc}
	struct s5p_uart *const uart = s5p_get_base_uart(dev_index);

	/* wait for character to arrive */
	while (!(readl(&uart->utrstat) & 0x1)) {
		if (serial_err_check(dev_index, 0))
			return 0;
34814e34:	e1a00006 	mov	r0, r6
	}

	return (int)(readb(&uart->urxh) & 0xff);
}
34814e38:	e8bd8070 	pop	{r4, r5, r6, pc}

34814e3c <s5p_serial3_getc>:
struct serial_device s5p_serial1_device =
	INIT_S5P_SERIAL_STRUCTURE(1, "s5pser1");
DECLARE_S5P_SERIAL_FUNCTIONS(2);
struct serial_device s5p_serial2_device =
	INIT_S5P_SERIAL_STRUCTURE(2, "s5pser2");
DECLARE_S5P_SERIAL_FUNCTIONS(3);
34814e3c:	e3a00003 	mov	r0, #3
34814e40:	eaffffec 	b	34814df8 <serial_getc_dev>

34814e44 <s5p_serial2_getc>:
struct serial_device s5p_serial0_device =
	INIT_S5P_SERIAL_STRUCTURE(0, "s5pser0");
DECLARE_S5P_SERIAL_FUNCTIONS(1);
struct serial_device s5p_serial1_device =
	INIT_S5P_SERIAL_STRUCTURE(1, "s5pser1");
DECLARE_S5P_SERIAL_FUNCTIONS(2);
34814e44:	e3a00002 	mov	r0, #2
34814e48:	eaffffea 	b	34814df8 <serial_getc_dev>

34814e4c <s5p_serial1_getc>:
	s5p_serial##port##_puts, }

DECLARE_S5P_SERIAL_FUNCTIONS(0);
struct serial_device s5p_serial0_device =
	INIT_S5P_SERIAL_STRUCTURE(0, "s5pser0");
DECLARE_S5P_SERIAL_FUNCTIONS(1);
34814e4c:	e3a00001 	mov	r0, #1
34814e50:	eaffffe8 	b	34814df8 <serial_getc_dev>

34814e54 <s5p_serial0_getc>:
	s5p_serial##port##_getc, \
	s5p_serial##port##_tstc, \
	s5p_serial##port##_putc, \
	s5p_serial##port##_puts, }

DECLARE_S5P_SERIAL_FUNCTIONS(0);
34814e54:	e3a00000 	mov	r0, #0
34814e58:	eaffffe6 	b	34814df8 <serial_getc_dev>

34814e5c <serial_putc_dev>:

/*
 * Output a single byte to the serial port.
 */
void serial_putc_dev(const char c, const int dev_index)
{
34814e5c:	e92d4070 	push	{r4, r5, r6, lr}

DECLARE_GLOBAL_DATA_PTR;

static inline struct s5p_uart *s5p_get_base_uart(int dev_index)
{
	u32 offset = dev_index * sizeof(struct s5p_uart);
34814e60:	e1a06501 	lsl	r6, r1, #10

/*
 * Output a single byte to the serial port.
 */
void serial_putc_dev(const char c, const int dev_index)
{
34814e64:	e1a04000 	mov	r4, r0
DECLARE_GLOBAL_DATA_PTR;

static inline struct s5p_uart *s5p_get_base_uart(int dev_index)
{
	u32 offset = dev_index * sizeof(struct s5p_uart);
	return (struct s5p_uart *)(samsung_get_base_uart() + offset);
34814e68:	ebffffa3 	bl	34814cfc <samsung_get_base_uart>
34814e6c:	e0805006 	add	r5, r0, r6
void serial_putc_dev(const char c, const int dev_index)
{
	struct s5p_uart *const uart = s5p_get_base_uart(dev_index);

	/* wait for room in the tx FIFO */
	while (!(readl(&uart->utrstat) & 0x2)) {
34814e70:	ea000004 	b	34814e88 <serial_putc_dev+0x2c>
DECLARE_GLOBAL_DATA_PTR;

static inline struct s5p_uart *s5p_get_base_uart(int dev_index)
{
	u32 offset = dev_index * sizeof(struct s5p_uart);
	return (struct s5p_uart *)(samsung_get_base_uart() + offset);
34814e74:	ebffffa0 	bl	34814cfc <samsung_get_base_uart>
	if (op)
		mask = 0x8;
	else
		mask = 0xf;

	return readl(&uart->uerstat) & mask;
34814e78:	e0800006 	add	r0, r0, r6
34814e7c:	e5903014 	ldr	r3, [r0, #20]
{
	struct s5p_uart *const uart = s5p_get_base_uart(dev_index);

	/* wait for room in the tx FIFO */
	while (!(readl(&uart->utrstat) & 0x2)) {
		if (serial_err_check(dev_index, 1))
34814e80:	e3130008 	tst	r3, #8
34814e84:	18bd8070 	popne	{r4, r5, r6, pc}
void serial_putc_dev(const char c, const int dev_index)
{
	struct s5p_uart *const uart = s5p_get_base_uart(dev_index);

	/* wait for room in the tx FIFO */
	while (!(readl(&uart->utrstat) & 0x2)) {
34814e88:	e5953010 	ldr	r3, [r5, #16]
34814e8c:	e3130002 	tst	r3, #2
34814e90:	0afffff7 	beq	34814e74 <serial_putc_dev+0x18>
	}

	writeb(c, &uart->utxh);

	/* If \n, also do \r */
	if (c == '\n')
34814e94:	e354000a 	cmp	r4, #10
	while (!(readl(&uart->utrstat) & 0x2)) {
		if (serial_err_check(dev_index, 1))
			return;
	}

	writeb(c, &uart->utxh);
34814e98:	e5c54020 	strb	r4, [r5, #32]

	/* If \n, also do \r */
	if (c == '\n')
34814e9c:	18bd8070 	popne	{r4, r5, r6, pc}
		serial_putc('\r');
34814ea0:	e3a0000d 	mov	r0, #13
}
34814ea4:	e8bd4070 	pop	{r4, r5, r6, lr}

	writeb(c, &uart->utxh);

	/* If \n, also do \r */
	if (c == '\n')
		serial_putc('\r');
34814ea8:	eaffe4f7 	b	3480e28c <serial_putc>

34814eac <s5p_serial3_putc>:
struct serial_device s5p_serial1_device =
	INIT_S5P_SERIAL_STRUCTURE(1, "s5pser1");
DECLARE_S5P_SERIAL_FUNCTIONS(2);
struct serial_device s5p_serial2_device =
	INIT_S5P_SERIAL_STRUCTURE(2, "s5pser2");
DECLARE_S5P_SERIAL_FUNCTIONS(3);
34814eac:	e3a01003 	mov	r1, #3
34814eb0:	eaffffe9 	b	34814e5c <serial_putc_dev>

34814eb4 <s5p_serial2_putc>:
struct serial_device s5p_serial0_device =
	INIT_S5P_SERIAL_STRUCTURE(0, "s5pser0");
DECLARE_S5P_SERIAL_FUNCTIONS(1);
struct serial_device s5p_serial1_device =
	INIT_S5P_SERIAL_STRUCTURE(1, "s5pser1");
DECLARE_S5P_SERIAL_FUNCTIONS(2);
34814eb4:	e3a01002 	mov	r1, #2
34814eb8:	eaffffe7 	b	34814e5c <serial_putc_dev>

34814ebc <s5p_serial1_putc>:
	s5p_serial##port##_puts, }

DECLARE_S5P_SERIAL_FUNCTIONS(0);
struct serial_device s5p_serial0_device =
	INIT_S5P_SERIAL_STRUCTURE(0, "s5pser0");
DECLARE_S5P_SERIAL_FUNCTIONS(1);
34814ebc:	e3a01001 	mov	r1, #1
34814ec0:	eaffffe5 	b	34814e5c <serial_putc_dev>

34814ec4 <s5p_serial0_putc>:
	s5p_serial##port##_getc, \
	s5p_serial##port##_tstc, \
	s5p_serial##port##_putc, \
	s5p_serial##port##_puts, }

DECLARE_S5P_SERIAL_FUNCTIONS(0);
34814ec4:	e3a01000 	mov	r1, #0
34814ec8:	eaffffe3 	b	34814e5c <serial_putc_dev>

34814ecc <serial_tstc_dev>:

/*
 * Test whether a character is in the RX buffer
 */
int serial_tstc_dev(const int dev_index)
{
34814ecc:	e92d4010 	push	{r4, lr}
34814ed0:	e1a04000 	mov	r4, r0
DECLARE_GLOBAL_DATA_PTR;

static inline struct s5p_uart *s5p_get_base_uart(int dev_index)
{
	u32 offset = dev_index * sizeof(struct s5p_uart);
	return (struct s5p_uart *)(samsung_get_base_uart() + offset);
34814ed4:	ebffff88 	bl	34814cfc <samsung_get_base_uart>
 */
int serial_tstc_dev(const int dev_index)
{
	struct s5p_uart *const uart = s5p_get_base_uart(dev_index);

	return (int)(readl(&uart->utrstat) & 0x1);
34814ed8:	e0800504 	add	r0, r0, r4, lsl #10
34814edc:	e5900010 	ldr	r0, [r0, #16]
}
34814ee0:	e2000001 	and	r0, r0, #1
34814ee4:	e8bd8010 	pop	{r4, pc}

34814ee8 <s5p_serial3_tstc>:
struct serial_device s5p_serial1_device =
	INIT_S5P_SERIAL_STRUCTURE(1, "s5pser1");
DECLARE_S5P_SERIAL_FUNCTIONS(2);
struct serial_device s5p_serial2_device =
	INIT_S5P_SERIAL_STRUCTURE(2, "s5pser2");
DECLARE_S5P_SERIAL_FUNCTIONS(3);
34814ee8:	e3a00003 	mov	r0, #3
34814eec:	eafffff6 	b	34814ecc <serial_tstc_dev>

34814ef0 <s5p_serial2_tstc>:
struct serial_device s5p_serial0_device =
	INIT_S5P_SERIAL_STRUCTURE(0, "s5pser0");
DECLARE_S5P_SERIAL_FUNCTIONS(1);
struct serial_device s5p_serial1_device =
	INIT_S5P_SERIAL_STRUCTURE(1, "s5pser1");
DECLARE_S5P_SERIAL_FUNCTIONS(2);
34814ef0:	e3a00002 	mov	r0, #2
34814ef4:	eafffff4 	b	34814ecc <serial_tstc_dev>

34814ef8 <s5p_serial1_tstc>:
	s5p_serial##port##_puts, }

DECLARE_S5P_SERIAL_FUNCTIONS(0);
struct serial_device s5p_serial0_device =
	INIT_S5P_SERIAL_STRUCTURE(0, "s5pser0");
DECLARE_S5P_SERIAL_FUNCTIONS(1);
34814ef8:	e3a00001 	mov	r0, #1
34814efc:	eafffff2 	b	34814ecc <serial_tstc_dev>

34814f00 <s5p_serial0_tstc>:
	s5p_serial##port##_getc, \
	s5p_serial##port##_tstc, \
	s5p_serial##port##_putc, \
	s5p_serial##port##_puts, }

DECLARE_S5P_SERIAL_FUNCTIONS(0);
34814f00:	e3a00000 	mov	r0, #0
34814f04:	eafffff0 	b	34814ecc <serial_tstc_dev>

34814f08 <serial_puts_dev>:

	return (int)(readl(&uart->utrstat) & 0x1);
}

void serial_puts_dev(const char *s, const int dev_index)
{
34814f08:	e92d4038 	push	{r3, r4, r5, lr}
34814f0c:	e1a05001 	mov	r5, r1
34814f10:	e1a04000 	mov	r4, r0
	while (*s)
34814f14:	ea000001 	b	34814f20 <serial_puts_dev+0x18>
		serial_putc_dev(*s++, dev_index);
34814f18:	e1a01005 	mov	r1, r5
34814f1c:	ebffffce 	bl	34814e5c <serial_putc_dev>
	return (int)(readl(&uart->utrstat) & 0x1);
}

void serial_puts_dev(const char *s, const int dev_index)
{
	while (*s)
34814f20:	e4d40001 	ldrb	r0, [r4], #1
34814f24:	e3500000 	cmp	r0, #0
34814f28:	1afffffa 	bne	34814f18 <serial_puts_dev+0x10>
		serial_putc_dev(*s++, dev_index);
}
34814f2c:	e8bd8038 	pop	{r3, r4, r5, pc}

34814f30 <s5p_serial3_puts>:
struct serial_device s5p_serial1_device =
	INIT_S5P_SERIAL_STRUCTURE(1, "s5pser1");
DECLARE_S5P_SERIAL_FUNCTIONS(2);
struct serial_device s5p_serial2_device =
	INIT_S5P_SERIAL_STRUCTURE(2, "s5pser2");
DECLARE_S5P_SERIAL_FUNCTIONS(3);
34814f30:	e3a01003 	mov	r1, #3
34814f34:	eafffff3 	b	34814f08 <serial_puts_dev>

34814f38 <s5p_serial2_puts>:
struct serial_device s5p_serial0_device =
	INIT_S5P_SERIAL_STRUCTURE(0, "s5pser0");
DECLARE_S5P_SERIAL_FUNCTIONS(1);
struct serial_device s5p_serial1_device =
	INIT_S5P_SERIAL_STRUCTURE(1, "s5pser1");
DECLARE_S5P_SERIAL_FUNCTIONS(2);
34814f38:	e3a01002 	mov	r1, #2
34814f3c:	eafffff1 	b	34814f08 <serial_puts_dev>

34814f40 <s5p_serial1_puts>:
	s5p_serial##port##_puts, }

DECLARE_S5P_SERIAL_FUNCTIONS(0);
struct serial_device s5p_serial0_device =
	INIT_S5P_SERIAL_STRUCTURE(0, "s5pser0");
DECLARE_S5P_SERIAL_FUNCTIONS(1);
34814f40:	e3a01001 	mov	r1, #1
34814f44:	eaffffef 	b	34814f08 <serial_puts_dev>

34814f48 <s5p_serial0_puts>:
	s5p_serial##port##_getc, \
	s5p_serial##port##_tstc, \
	s5p_serial##port##_putc, \
	s5p_serial##port##_puts, }

DECLARE_S5P_SERIAL_FUNCTIONS(0);
34814f48:	e3a01000 	mov	r1, #0
34814f4c:	eaffffed 	b	34814f08 <serial_puts_dev>

34814f50 <default_serial_console>:
#elif defined(CONFIG_SERIAL3)
	return &s5p_serial3_device;
#else
#error "CONFIG_SERIAL? missing."
#endif
}
34814f50:	e59f0000 	ldr	r0, [pc, #0]	; 34814f58 <default_serial_console+0x8>
34814f54:	e12fff1e 	bx	lr
34814f58:	34828950 	.word	0x34828950

34814f5c <usb_ep_autoconfig>:
 */
struct usb_ep *usb_ep_autoconfig(
	struct usb_gadget		*gadget,
	struct usb_endpoint_descriptor	*desc
)
{
34814f5c:	e92d4ef3 	push	{r0, r1, r4, r5, r6, r7, r9, sl, fp, lr}
		if (ep && ep_matches(gadget, ep, desc))
			return ep;
	}

	/* Second, look at endpoints until an unclaimed one looks usable */
	list_for_each_entry(ep, &gadget->ep_list, ep_list) {
34814f60:	e1a07000 	mov	r7, r0
34814f64:	e5b74008 	ldr	r4, [r7, #8]!
 */
struct usb_ep *usb_ep_autoconfig(
	struct usb_gadget		*gadget,
	struct usb_endpoint_descriptor	*desc
)
{
34814f68:	e1a0a000 	mov	sl, r0
34814f6c:	e1a05001 	mov	r5, r1
		if (ep && ep_matches(gadget, ep, desc))
			return ep;
	}

	/* Second, look at endpoints until an unclaimed one looks usable */
	list_for_each_entry(ep, &gadget->ep_list, ep_list) {
34814f70:	e244400c 	sub	r4, r4, #12
		if (++in_epnum > 15)
			return 0;
		desc->bEndpointAddress = USB_DIR_IN | in_epnum;
#endif
	} else {
		if (++epnum > 15)
34814f74:	e59f9200 	ldr	r9, [pc, #512]	; 3481517c <usb_ep_autoconfig+0x220>

	case USB_ENDPOINT_XFER_ISOC:
		/* ISO:  limit 1023 bytes full speed, 1024 high speed */
		if (ep->maxpacket < max)
			return 0;
		if (!gadget->is_dualspeed && max > 1023)
34814f78:	e300b3ff 	movw	fp, #1023	; 0x3ff
		if (ep && ep_matches(gadget, ep, desc))
			return ep;
	}

	/* Second, look at endpoints until an unclaimed one looks usable */
	list_for_each_entry(ep, &gadget->ep_list, ep_list) {
34814f7c:	ea000078 	b	34815164 <usb_ep_autoconfig+0x208>
	u8		type;
	const char	*tmp;
	u16		max;

	/* endpoint already claimed? */
	if (NULL != ep->driver_data)
34814f80:	e5943000 	ldr	r3, [r4]
34814f84:	e3530000 	cmp	r3, #0
34814f88:	1a000073 	bne	3481515c <usb_ep_autoconfig+0x200>
		return 0;

	/* only support ep0 for portable CONTROL traffic */
	type = desc->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK;
34814f8c:	e5d56003 	ldrb	r6, [r5, #3]
	if (USB_ENDPOINT_XFER_CONTROL == type)
34814f90:	e2166003 	ands	r6, r6, #3
34814f94:	0a000070 	beq	3481515c <usb_ep_autoconfig+0x200>
		return 0;

	/* some other naming convention */
	if ('e' != ep->name[0])
34814f98:	e5940004 	ldr	r0, [r4, #4]
34814f9c:	e5d03000 	ldrb	r3, [r0]
34814fa0:	e3530065 	cmp	r3, #101	; 0x65
34814fa4:	1a00006c 	bne	3481515c <usb_ep_autoconfig+0x200>
		return 0;

	/* type-restriction:  "-iso", "-bulk", or "-int".
	 * direction-restriction:  "in", "out".
	 */
	if ('-' != ep->name[2]) {
34814fa8:	e5d03002 	ldrb	r3, [r0, #2]
34814fac:	e353002d 	cmp	r3, #45	; 0x2d
34814fb0:	0a000023 	beq	34815044 <usb_ep_autoconfig+0xe8>
		tmp = strrchr(ep->name, '-');
34814fb4:	e3a0102d 	mov	r1, #45	; 0x2d
34814fb8:	eb000f0c 	bl	34818bf0 <strrchr>
		if (tmp) {
34814fbc:	e3500000 	cmp	r0, #0
34814fc0:	0a00000d 	beq	34814ffc <usb_ep_autoconfig+0xa0>
			switch (type) {
34814fc4:	e3560002 	cmp	r6, #2
34814fc8:	0a000005 	beq	34814fe4 <usb_ep_autoconfig+0x88>
34814fcc:	e3560003 	cmp	r6, #3
34814fd0:	e5d03002 	ldrb	r3, [r0, #2]
34814fd4:	1a000005 	bne	34814ff0 <usb_ep_autoconfig+0x94>
			case USB_ENDPOINT_XFER_INT:
				/* bulk endpoints handle interrupt transfers,
				 * except the toggle-quirky iso-synch kind
				 */
				if ('s' == tmp[2])	/* == "-iso" */
34814fd8:	e3530073 	cmp	r3, #115	; 0x73
34814fdc:	1a00000c 	bne	34815014 <usb_ep_autoconfig+0xb8>
34814fe0:	ea00005d 	b	3481515c <usb_ep_autoconfig+0x200>
				if (gadget_is_pxa(gadget)
						&& 'i' == tmp[1])
					return 0;
				break;
			case USB_ENDPOINT_XFER_BULK:
				if ('b' != tmp[1])	/* != "-bulk" */
34814fe4:	e5d03001 	ldrb	r3, [r0, #1]
34814fe8:	e3530062 	cmp	r3, #98	; 0x62
34814fec:	ea000000 	b	34814ff4 <usb_ep_autoconfig+0x98>
					return 0;
				break;
			case USB_ENDPOINT_XFER_ISOC:
				if ('s' != tmp[2])	/* != "-iso" */
34814ff0:	e3530073 	cmp	r3, #115	; 0x73
34814ff4:	1a000058 	bne	3481515c <usb_ep_autoconfig+0x200>
34814ff8:	ea000005 	b	34815014 <usb_ep_autoconfig+0xb8>
					return 0;
			}
		} else {
			tmp = ep->name + strlen(ep->name);
34814ffc:	e5943004 	ldr	r3, [r4, #4]
34815000:	e1a00003 	mov	r0, r3
34815004:	e58d3000 	str	r3, [sp]
34815008:	eb000edc 	bl	34818b80 <strlen>
3481500c:	e59d3000 	ldr	r3, [sp]
34815010:	e0830000 	add	r0, r3, r0
		}

		/* direction-restriction:  "..in-..", "out-.." */
		tmp--;
		if (!isdigit(*tmp)) {
34815014:	e5503001 	ldrb	r3, [r0, #-1]
34815018:	e2432030 	sub	r2, r3, #48	; 0x30
3481501c:	e6ef2072 	uxtb	r2, r2
34815020:	e3520009 	cmp	r2, #9
34815024:	9a000006 	bls	34815044 <usb_ep_autoconfig+0xe8>
			if (desc->bEndpointAddress & USB_DIR_IN) {
34815028:	e1d520d2 	ldrsb	r2, [r5, #2]
3481502c:	e3520000 	cmp	r2, #0
34815030:	aa000001 	bge	3481503c <usb_ep_autoconfig+0xe0>
				if ('n' != *tmp)
34815034:	e353006e 	cmp	r3, #110	; 0x6e
34815038:	ea000000 	b	34815040 <usb_ep_autoconfig+0xe4>
					return 0;
			} else {
				if ('t' != *tmp)
3481503c:	e3530074 	cmp	r3, #116	; 0x74
34815040:	1a000045 	bne	3481515c <usb_ep_autoconfig+0x200>

#include <linux/types.h>

static inline u16 __get_unaligned_le16(const u8 *p)
{
	return p[0] | p[1] << 8;
34815044:	e5d52004 	ldrb	r2, [r5, #4]
34815048:	e5d50005 	ldrb	r0, [r5, #5]
	/* endpoint maxpacket size is an input parameter, except for bulk
	 * where it's an output parameter representing the full speed limit.
	 * the usb spec fixes high speed bulk maxpacket at 512 bytes.
	 */
	max = 0x7ff & le16_to_cpu(get_unaligned(&desc->wMaxPacketSize));
	switch (type) {
3481504c:	e3560001 	cmp	r6, #1
34815050:	e1820400 	orr	r0, r2, r0, lsl #8

	/* endpoint maxpacket size is an input parameter, except for bulk
	 * where it's an output parameter representing the full speed limit.
	 * the usb spec fixes high speed bulk maxpacket at 512 bytes.
	 */
	max = 0x7ff & le16_to_cpu(get_unaligned(&desc->wMaxPacketSize));
34815054:	e1a02a80 	lsl	r2, r0, #21
34815058:	e2853004 	add	r3, r5, #4
3481505c:	e285c005 	add	ip, r5, #5
34815060:	e1a02aa2 	lsr	r2, r2, #21
	switch (type) {
34815064:	0a00000a 	beq	34815094 <usb_ep_autoconfig+0x138>
34815068:	e3560003 	cmp	r6, #3
3481506c:	1a000018 	bne	348150d4 <usb_ep_autoconfig+0x178>
	case USB_ENDPOINT_XFER_INT:
		/* INT:  limit 64 bytes full speed, 1024 high speed */
		if (!gadget->is_dualspeed && max > 64)
34815070:	e5da1014 	ldrb	r1, [sl, #20]
34815074:	e3110001 	tst	r1, #1
34815078:	13a01000 	movne	r1, #0
3481507c:	03a01001 	moveq	r1, #1
34815080:	e3520040 	cmp	r2, #64	; 0x40
34815084:	93a01000 	movls	r1, #0
34815088:	82011001 	andhi	r1, r1, #1
3481508c:	e3510000 	cmp	r1, #0
34815090:	1a000031 	bne	3481515c <usb_ep_autoconfig+0x200>
			return 0;
		/* FALLTHROUGH */

	case USB_ENDPOINT_XFER_ISOC:
		/* ISO:  limit 1023 bytes full speed, 1024 high speed */
		if (ep->maxpacket < max)
34815094:	e1d411b4 	ldrh	r1, [r4, #20]
34815098:	e1510002 	cmp	r1, r2
3481509c:	3a00002e 	bcc	3481515c <usb_ep_autoconfig+0x200>
			return 0;
		if (!gadget->is_dualspeed && max > 1023)
348150a0:	e5da1014 	ldrb	r1, [sl, #20]
348150a4:	e3110001 	tst	r1, #1
348150a8:	13a01000 	movne	r1, #0
348150ac:	03a01001 	moveq	r1, #1
348150b0:	e152000b 	cmp	r2, fp
348150b4:	93a02000 	movls	r2, #0
348150b8:	82012001 	andhi	r2, r1, #1
348150bc:	e3520000 	cmp	r2, #0
348150c0:	1a000025 	bne	3481515c <usb_ep_autoconfig+0x200>
			return 0;

		/* BOTH:  "high bandwidth" works only at high speed */
		if ((get_unaligned(&desc->wMaxPacketSize) &
348150c4:	e3100b06 	tst	r0, #6144	; 0x1800
348150c8:	0a000001 	beq	348150d4 <usb_ep_autoconfig+0x178>
					__constant_cpu_to_le16(3<<11))) {
			if (!gadget->is_dualspeed)
348150cc:	e3510000 	cmp	r1, #0
348150d0:	1a000021 	bne	3481515c <usb_ep_autoconfig+0x200>
	}

	/* MATCH!! */

	/* report address */
	if (isdigit(ep->name[2])) {
348150d4:	e5942004 	ldr	r2, [r4, #4]
348150d8:	e2820002 	add	r0, r2, #2
348150dc:	e5d22002 	ldrb	r2, [r2, #2]
348150e0:	e2422030 	sub	r2, r2, #48	; 0x30
348150e4:	e6ef2072 	uxtb	r2, r2
348150e8:	e3520009 	cmp	r2, #9
348150ec:	8a000009 	bhi	34815118 <usb_ep_autoconfig+0x1bc>
		u8	num = simple_strtoul(&ep->name[2], NULL, 10);
348150f0:	e3a0200a 	mov	r2, #10
348150f4:	e3a01000 	mov	r1, #0
348150f8:	e88d1008 	stm	sp, {r3, ip}
348150fc:	eb0012bd 	bl	34819bf8 <simple_strtoul>
		desc->bEndpointAddress |= num;
34815100:	e5d52002 	ldrb	r2, [r5, #2]
34815104:	e59d3000 	ldr	r3, [sp]
34815108:	e1802002 	orr	r2, r0, r2
3481510c:	e5c52002 	strb	r2, [r5, #2]
34815110:	e59dc004 	ldr	ip, [sp, #4]
34815114:	ea000007 	b	34815138 <usb_ep_autoconfig+0x1dc>
		if (++in_epnum > 15)
			return 0;
		desc->bEndpointAddress = USB_DIR_IN | in_epnum;
#endif
	} else {
		if (++epnum > 15)
34815118:	e5992000 	ldr	r2, [r9]
3481511c:	e2822001 	add	r2, r2, #1
34815120:	e352000f 	cmp	r2, #15
34815124:	e5892000 	str	r2, [r9]
34815128:	8a00000b 	bhi	3481515c <usb_ep_autoconfig+0x200>
			return 0;
		desc->bEndpointAddress |= epnum;
3481512c:	e5d51002 	ldrb	r1, [r5, #2]
34815130:	e1822001 	orr	r2, r2, r1
34815134:	e5c52002 	strb	r2, [r5, #2]
	}

	/* report (variable) full speed bulk maxpacket */
	if (USB_ENDPOINT_XFER_BULK == type) {
34815138:	e3560002 	cmp	r6, #2
3481513c:	1a00000c 	bne	34815174 <usb_ep_autoconfig+0x218>
		int size = ep->maxpacket;
34815140:	e1d421b4 	ldrh	r2, [r4, #20]

		/* min() doesn't work on bitfields with gcc-3.5 */
		if (size > 64)
			size = 64;
		put_unaligned(cpu_to_le16(size), &desc->wMaxPacketSize);
34815144:	e3520040 	cmp	r2, #64	; 0x40
34815148:	a3a02040 	movge	r2, #64	; 0x40
	       __get_unaligned_le32(p);
}

static inline void __put_unaligned_le16(u16 val, u8 *p)
{
	*p++ = val;
3481514c:	e5c32000 	strb	r2, [r3]
	*p++ = val >> 8;
34815150:	e3a03000 	mov	r3, #0
34815154:	e5cc3000 	strb	r3, [ip]
34815158:	ea000005 	b	34815174 <usb_ep_autoconfig+0x218>
		if (ep && ep_matches(gadget, ep, desc))
			return ep;
	}

	/* Second, look at endpoints until an unclaimed one looks usable */
	list_for_each_entry(ep, &gadget->ep_list, ep_list) {
3481515c:	e594400c 	ldr	r4, [r4, #12]
34815160:	e244400c 	sub	r4, r4, #12
34815164:	e284300c 	add	r3, r4, #12
34815168:	e1530007 	cmp	r3, r7
3481516c:	1affff83 	bne	34814f80 <usb_ep_autoconfig+0x24>
		if (ep_matches(gadget, ep, desc))
			return ep;
	}

	/* Fail */
	return NULL;
34815170:	e3a04000 	mov	r4, #0
}
34815174:	e1a00004 	mov	r0, r4
34815178:	e8bd8efc 	pop	{r2, r3, r4, r5, r6, r7, r9, sl, fp, pc}
3481517c:	3482b30c 	.word	0x3482b30c

34815180 <usb_ep_autoconfig_reset>:
 */
void usb_ep_autoconfig_reset(struct usb_gadget *gadget)
{
	struct usb_ep	*ep;

	list_for_each_entry(ep, &gadget->ep_list, ep_list) {
34815180:	e5b03008 	ldr	r3, [r0, #8]!
		ep->driver_data = NULL;
34815184:	e3a02000 	mov	r2, #0
 */
void usb_ep_autoconfig_reset(struct usb_gadget *gadget)
{
	struct usb_ep	*ep;

	list_for_each_entry(ep, &gadget->ep_list, ep_list) {
34815188:	e243300c 	sub	r3, r3, #12
3481518c:	ea000002 	b	3481519c <usb_ep_autoconfig_reset+0x1c>
		ep->driver_data = NULL;
34815190:	e5832000 	str	r2, [r3]
 */
void usb_ep_autoconfig_reset(struct usb_gadget *gadget)
{
	struct usb_ep	*ep;

	list_for_each_entry(ep, &gadget->ep_list, ep_list) {
34815194:	e593300c 	ldr	r3, [r3, #12]
34815198:	e243300c 	sub	r3, r3, #12
3481519c:	e283100c 	add	r1, r3, #12
348151a0:	e1510000 	cmp	r1, r0
348151a4:	1afffff9 	bne	34815190 <usb_ep_autoconfig_reset+0x10>
		ep->driver_data = NULL;
	}
#ifdef	MANY_ENDPOINTS
	in_epnum = 0;
#endif
	epnum = 0;
348151a8:	e59f3008 	ldr	r3, [pc, #8]	; 348151b8 <usb_ep_autoconfig_reset+0x38>
348151ac:	e3a02000 	mov	r2, #0
348151b0:	e5832000 	str	r2, [r3]
}
348151b4:	e12fff1e 	bx	lr
348151b8:	3482b30c 	.word	0x3482b30c

348151bc <usb_descriptor_fillbuf>:
 * sets of descriptors need to be marshaled.
 */
int
usb_descriptor_fillbuf(void *buf, unsigned buflen,
		const struct usb_descriptor_header **src)
{
348151bc:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
	u8	*dest = buf;

	if (!src)
348151c0:	e252a000 	subs	sl, r2, #0
 * sets of descriptors need to be marshaled.
 */
int
usb_descriptor_fillbuf(void *buf, unsigned buflen,
		const struct usb_descriptor_header **src)
{
348151c4:	e1a07000 	mov	r7, r0
348151c8:	e1a06001 	mov	r6, r1
	u8	*dest = buf;
348151cc:	11a04000 	movne	r4, r0

	if (!src)
348151d0:	1a000008 	bne	348151f8 <usb_descriptor_fillbuf+0x3c>
348151d4:	ea00000c 	b	3481520c <usb_descriptor_fillbuf+0x50>
		return -EINVAL;

	/* fill buffer from src[] until null descriptor ptr */
	for (; NULL != *src; src++) {
		unsigned		len = (*src)->bLength;
348151d8:	e5d15000 	ldrb	r5, [r1]

		if (len > buflen)
348151dc:	e1550006 	cmp	r5, r6
348151e0:	8a00000b 	bhi	34815214 <usb_descriptor_fillbuf+0x58>
			return -EINVAL;
		memcpy(dest, *src, len);
348151e4:	e1a00004 	mov	r0, r4
348151e8:	e1a02005 	mov	r2, r5
348151ec:	eb000f27 	bl	34818e90 <memcpy>
		buflen -= len;
348151f0:	e0656006 	rsb	r6, r5, r6
		dest += len;
348151f4:	e0844005 	add	r4, r4, r5

	if (!src)
		return -EINVAL;

	/* fill buffer from src[] until null descriptor ptr */
	for (; NULL != *src; src++) {
348151f8:	e49a1004 	ldr	r1, [sl], #4
348151fc:	e3510000 	cmp	r1, #0
34815200:	1afffff4 	bne	348151d8 <usb_descriptor_fillbuf+0x1c>
			return -EINVAL;
		memcpy(dest, *src, len);
		buflen -= len;
		dest += len;
	}
	return dest - (u8 *)buf;
34815204:	e0670004 	rsb	r0, r7, r4
34815208:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
		const struct usb_descriptor_header **src)
{
	u8	*dest = buf;

	if (!src)
		return -EINVAL;
3481520c:	e3e00015 	mvn	r0, #21
34815210:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
	/* fill buffer from src[] until null descriptor ptr */
	for (; NULL != *src; src++) {
		unsigned		len = (*src)->bLength;

		if (len > buflen)
			return -EINVAL;
34815214:	e3e00015 	mvn	r0, #21
		memcpy(dest, *src, len);
		buflen -= len;
		dest += len;
	}
	return dest - (u8 *)buf;
}
34815218:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}

3481521c <usb_gadget_config_buf>:
{
	struct usb_config_descriptor		*cp = buf;
	int					len;

	/* config descriptor first */
	if (length < USB_DT_CONFIG_SIZE || !desc)
3481521c:	e3530000 	cmp	r3, #0
34815220:	13520008 	cmpne	r2, #8
	const struct usb_config_descriptor	*config,
	void					*buf,
	unsigned				length,
	const struct usb_descriptor_header	**desc
)
{
34815224:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
34815228:	e1a0c000 	mov	ip, r0
3481522c:	e1a04001 	mov	r4, r1
34815230:	e1a05002 	mov	r5, r2
	struct usb_config_descriptor		*cp = buf;
	int					len;

	/* config descriptor first */
	if (length < USB_DT_CONFIG_SIZE || !desc)
34815234:	e1a07003 	mov	r7, r3
		return -EINVAL;
34815238:	93e00015 	mvnls	r0, #21
{
	struct usb_config_descriptor		*cp = buf;
	int					len;

	/* config descriptor first */
	if (length < USB_DT_CONFIG_SIZE || !desc)
3481523c:	98bd80f8 	popls	{r3, r4, r5, r6, r7, pc}
		return -EINVAL;
	*cp = *config;
34815240:	e3a06009 	mov	r6, #9
34815244:	e1a00001 	mov	r0, r1
34815248:	e1a02006 	mov	r2, r6
3481524c:	e1a0100c 	mov	r1, ip
34815250:	eb000f0e 	bl	34818e90 <memcpy>

	/* then interface/endpoint/class/vendor/... */
	len = usb_descriptor_fillbuf(USB_DT_CONFIG_SIZE + (u8 *)buf,
34815254:	e0840006 	add	r0, r4, r6
34815258:	e2451009 	sub	r1, r5, #9
3481525c:	e1a02007 	mov	r2, r7
34815260:	ebffffd5 	bl	348151bc <usb_descriptor_fillbuf>
			length - USB_DT_CONFIG_SIZE, desc);
	if (len < 0)
34815264:	e3500000 	cmp	r0, #0
34815268:	b8bd80f8 	poplt	{r3, r4, r5, r6, r7, pc}
		return len;
	len += USB_DT_CONFIG_SIZE;
3481526c:	e0800006 	add	r0, r0, r6
	if (len > 0xffff)
34815270:	e3500801 	cmp	r0, #65536	; 0x10000
34815274:	aa00000b 	bge	348152a8 <usb_gadget_config_buf+0x8c>
		return -EINVAL;

	/* patch up the config descriptor */
	cp->bLength = USB_DT_CONFIG_SIZE;
	cp->bDescriptorType = USB_DT_CONFIG;
34815278:	e3a03002 	mov	r3, #2
3481527c:	e5c43001 	strb	r3, [r4, #1]
	cp->wTotalLength = cpu_to_le16(len);
34815280:	e6ff3070 	uxth	r3, r0
34815284:	e5c43002 	strb	r3, [r4, #2]
34815288:	e1a03423 	lsr	r3, r3, #8
3481528c:	e5c43003 	strb	r3, [r4, #3]
	cp->bmAttributes |= USB_CONFIG_ATT_ONE;
34815290:	e5d43007 	ldrb	r3, [r4, #7]
	len += USB_DT_CONFIG_SIZE;
	if (len > 0xffff)
		return -EINVAL;

	/* patch up the config descriptor */
	cp->bLength = USB_DT_CONFIG_SIZE;
34815294:	e5c46000 	strb	r6, [r4]
	cp->bDescriptorType = USB_DT_CONFIG;
	cp->wTotalLength = cpu_to_le16(len);
	cp->bmAttributes |= USB_CONFIG_ATT_ONE;
34815298:	e1e03c83 	mvn	r3, r3, lsl #25
3481529c:	e1e03ca3 	mvn	r3, r3, lsr #25
348152a0:	e5c43007 	strb	r3, [r4, #7]
	return len;
348152a4:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
			length - USB_DT_CONFIG_SIZE, desc);
	if (len < 0)
		return len;
	len += USB_DT_CONFIG_SIZE;
	if (len > 0xffff)
		return -EINVAL;
348152a8:	e3e00015 	mvn	r0, #21
	cp->bLength = USB_DT_CONFIG_SIZE;
	cp->bDescriptorType = USB_DT_CONFIG;
	cp->wTotalLength = cpu_to_le16(len);
	cp->bmAttributes |= USB_CONFIG_ATT_ONE;
	return len;
}
348152ac:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}

348152b0 <usb_gadget_get_string>:
{
	struct usb_string	*s;
	int			len;

	/* descriptor 0 has the language id */
	if (id == 0) {
348152b0:	e3510000 	cmp	r1, #0
 * the eighth bit set will be multibyte UTF-8 characters, not ISO-8859/1
 * characters (which are also widely used in C strings).
 */
int
usb_gadget_get_string(struct usb_gadget_strings *table, int id, u8 *buf)
{
348152b4:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
348152b8:	e1a04002 	mov	r4, r2
	struct usb_string	*s;
	int			len;

	/* descriptor 0 has the language id */
	if (id == 0) {
348152bc:	1a00000a 	bne	348152ec <usb_gadget_get_string+0x3c>
		buf[0] = 4;
348152c0:	e3a03004 	mov	r3, #4
348152c4:	e5c23000 	strb	r3, [r2]
		buf[1] = USB_DT_STRING;
348152c8:	e3a02003 	mov	r2, #3
348152cc:	e5c42001 	strb	r2, [r4, #1]
		buf[2] = (u8) table->language;
348152d0:	e1d020b0 	ldrh	r2, [r0]
348152d4:	e5c42002 	strb	r2, [r4, #2]
		buf[3] = (u8) (table->language >> 8);
348152d8:	e1d020b0 	ldrh	r2, [r0]
		return 4;
348152dc:	e1a00003 	mov	r0, r3
	/* descriptor 0 has the language id */
	if (id == 0) {
		buf[0] = 4;
		buf[1] = USB_DT_STRING;
		buf[2] = (u8) table->language;
		buf[3] = (u8) (table->language >> 8);
348152e0:	e1a02422 	lsr	r2, r2, #8
348152e4:	e5c42003 	strb	r2, [r4, #3]
		return 4;
348152e8:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
	}
	for (s = table->strings; s && s->s; s++)
348152ec:	e5905004 	ldr	r5, [r0, #4]
348152f0:	ea000003 	b	34815304 <usb_gadget_get_string+0x54>
		if (s->id == id)
348152f4:	e5d53000 	ldrb	r3, [r5]
348152f8:	e1530001 	cmp	r3, r1
348152fc:	0a000006 	beq	3481531c <usb_gadget_get_string+0x6c>
		buf[1] = USB_DT_STRING;
		buf[2] = (u8) table->language;
		buf[3] = (u8) (table->language >> 8);
		return 4;
	}
	for (s = table->strings; s && s->s; s++)
34815300:	e2855008 	add	r5, r5, #8
34815304:	e3550000 	cmp	r5, #0
34815308:	0a000041 	beq	34815414 <usb_gadget_get_string+0x164>
3481530c:	e5950004 	ldr	r0, [r5, #4]
34815310:	e3500000 	cmp	r0, #0
34815314:	1afffff6 	bne	348152f4 <usb_gadget_get_string+0x44>
34815318:	ea00003d 	b	34815414 <usb_gadget_get_string+0x164>
	/* unrecognized: stall. */
	if (!s || !s->s)
		return -EINVAL;

	/* string descriptors have length, tag, then UTF16-LE text */
	len = min((size_t) 126, strlen(s->s));
3481531c:	eb000e17 	bl	34818b80 <strlen>
34815320:	e350007e 	cmp	r0, #126	; 0x7e
34815324:	31a06000 	movcc	r6, r0
34815328:	23a0607e 	movcs	r6, #126	; 0x7e
	memset(buf + 2, 0, 2 * len);	/* zero all the bytes */
3481532c:	e3a01000 	mov	r1, #0
34815330:	e2840002 	add	r0, r4, #2
34815334:	e1a02086 	lsl	r2, r6, #1
34815338:	eb000eb0 	bl	34818e00 <memset>
	len = utf8_to_utf16le(s->s, (__le16 *)&buf[2], len);
3481533c:	e5953004 	ldr	r3, [r5, #4]
34815340:	e1a01004 	mov	r1, r4
#include <asm/unaligned.h>


static int utf8_to_utf16le(const char *s, __le16 *cp, unsigned len)
{
	int	count = 0;
34815344:	e3a00000 	mov	r0, #0
					goto fail;
				c &= 0x3f;
				uchar |= c;

				/* no bogus surrogates */
				if (0xd800 <= uchar && uchar <= 0xdfff)
34815348:	e30057ff 	movw	r5, #2047	; 0x7ff
3481534c:	ea00002a 	b	348153fc <usb_gadget_get_string+0x14c>
	 * this insists on correct encodings, though not minimal ones.
	 * BUT it currently rejects legit 4-byte UTF-8 code points,
	 * which need surrogate pairs.  (Unicode 3.1 can use them.)
	 */
	while (len != 0 && (c = (u8) *s++) != 0) {
		if ((c & 0x80)) {
34815350:	e3120080 	tst	r2, #128	; 0x80
	/*
	 * this insists on correct encodings, though not minimal ones.
	 * BUT it currently rejects legit 4-byte UTF-8 code points,
	 * which need surrogate pairs.  (Unicode 3.1 can use them.)
	 */
	while (len != 0 && (c = (u8) *s++) != 0) {
34815354:	e2833001 	add	r3, r3, #1
		if ((c & 0x80)) {
34815358:	0a000022 	beq	348153e8 <usb_gadget_get_string+0x138>
			/*
			 * 2-byte sequence:
			 * 00000yyyyyxxxxxx = 110yyyyy 10xxxxxx
			 */
			if ((c & 0xe0) == 0xc0) {
3481535c:	e202c0e0 	and	ip, r2, #224	; 0xe0
34815360:	e35c00c0 	cmp	ip, #192	; 0xc0
34815364:	1a000008 	bne	3481538c <usb_gadget_get_string+0xdc>
				uchar = (c & 0x1f) << 6;

				c = (u8) *s++;
34815368:	e5d3c000 	ldrb	ip, [r3]
				if ((c & 0xc0) != 0x80)
3481536c:	e20c70c0 	and	r7, ip, #192	; 0xc0
34815370:	e3570080 	cmp	r7, #128	; 0x80
34815374:	1a000026 	bne	34815414 <usb_gadget_get_string+0x164>
			/*
			 * 2-byte sequence:
			 * 00000yyyyyxxxxxx = 110yyyyy 10xxxxxx
			 */
			if ((c & 0xe0) == 0xc0) {
				uchar = (c & 0x1f) << 6;
34815378:	e202201f 	and	r2, r2, #31

				c = (u8) *s++;
				if ((c & 0xc0) != 0x80)
					goto fail;
				c &= 0x3f;
				uchar |= c;
3481537c:	e20cc03f 	and	ip, ip, #63	; 0x3f
			 * 00000yyyyyxxxxxx = 110yyyyy 10xxxxxx
			 */
			if ((c & 0xe0) == 0xc0) {
				uchar = (c & 0x1f) << 6;

				c = (u8) *s++;
34815380:	e2833001 	add	r3, r3, #1
				if ((c & 0xc0) != 0x80)
					goto fail;
				c &= 0x3f;
				uchar |= c;
34815384:	e18c2302 	orr	r2, ip, r2, lsl #6
34815388:	ea000016 	b	348153e8 <usb_gadget_get_string+0x138>

			/*
			 * 3-byte sequence (most CJKV characters):
			 * zzzzyyyyyyxxxxxx = 1110zzzz 10yyyyyy 10xxxxxx
			 */
			} else if ((c & 0xf0) == 0xe0) {
3481538c:	e202c0f0 	and	ip, r2, #240	; 0xf0
34815390:	e35c00e0 	cmp	ip, #224	; 0xe0
34815394:	1a00001e 	bne	34815414 <usb_gadget_get_string+0x164>
				uchar = (c & 0x0f) << 12;

				c = (u8) *s++;
34815398:	e5d3c000 	ldrb	ip, [r3]
				if ((c & 0xc0) != 0x80)
3481539c:	e20c70c0 	and	r7, ip, #192	; 0xc0
348153a0:	e3570080 	cmp	r7, #128	; 0x80
348153a4:	1a00001a 	bne	34815414 <usb_gadget_get_string+0x164>
			 * zzzzyyyyyyxxxxxx = 1110zzzz 10yyyyyy 10xxxxxx
			 */
			} else if ((c & 0xf0) == 0xe0) {
				uchar = (c & 0x0f) << 12;

				c = (u8) *s++;
348153a8:	e2837001 	add	r7, r3, #1
				if ((c & 0xc0) != 0x80)
					goto fail;
				c &= 0x3f;
				uchar |= c << 6;

				c = (u8) *s++;
348153ac:	e5d33001 	ldrb	r3, [r3, #1]
				if ((c & 0xc0) != 0x80)
348153b0:	e203a0c0 	and	sl, r3, #192	; 0xc0
348153b4:	e35a0080 	cmp	sl, #128	; 0x80
348153b8:	1a000015 	bne	34815414 <usb_gadget_get_string+0x164>

				c = (u8) *s++;
				if ((c & 0xc0) != 0x80)
					goto fail;
				c &= 0x3f;
				uchar |= c << 6;
348153bc:	e20cc03f 	and	ip, ip, #63	; 0x3f
			/*
			 * 3-byte sequence (most CJKV characters):
			 * zzzzyyyyyyxxxxxx = 1110zzzz 10yyyyyy 10xxxxxx
			 */
			} else if ((c & 0xf0) == 0xe0) {
				uchar = (c & 0x0f) << 12;
348153c0:	e1a02602 	lsl	r2, r2, #12

				c = (u8) *s++;
				if ((c & 0xc0) != 0x80)
					goto fail;
				c &= 0x3f;
				uchar |= c << 6;
348153c4:	e182230c 	orr	r2, r2, ip, lsl #6

				c = (u8) *s++;
				if ((c & 0xc0) != 0x80)
					goto fail;
				c &= 0x3f;
				uchar |= c;
348153c8:	e203303f 	and	r3, r3, #63	; 0x3f

				c = (u8) *s++;
				if ((c & 0xc0) != 0x80)
					goto fail;
				c &= 0x3f;
				uchar |= c << 6;
348153cc:	e6ff2072 	uxth	r2, r2

				c = (u8) *s++;
				if ((c & 0xc0) != 0x80)
					goto fail;
				c &= 0x3f;
				uchar |= c;
348153d0:	e1822003 	orr	r2, r2, r3

				/* no bogus surrogates */
				if (0xd800 <= uchar && uchar <= 0xdfff)
348153d4:	e2823b0a 	add	r3, r2, #10240	; 0x2800
348153d8:	e6ff3073 	uxth	r3, r3
348153dc:	e1530005 	cmp	r3, r5
348153e0:	9a00000d 	bls	3481541c <usb_gadget_get_string+0x16c>
				if ((c & 0xc0) != 0x80)
					goto fail;
				c &= 0x3f;
				uchar |= c << 6;

				c = (u8) *s++;
348153e4:	e2873001 	add	r3, r7, #1
	       __get_unaligned_le32(p);
}

static inline void __put_unaligned_le16(u16 val, u8 *p)
{
	*p++ = val;
348153e8:	e5c12002 	strb	r2, [r1, #2]
	*p++ = val >> 8;
348153ec:	e1a02422 	lsr	r2, r2, #8
348153f0:	e5c12003 	strb	r2, [r1, #3]
			} else
				goto fail;
		} else
			uchar = c;
		put_unaligned_le16(uchar, cp++);
		count++;
348153f4:	e2800001 	add	r0, r0, #1
348153f8:	e2811002 	add	r1, r1, #2
	/*
	 * this insists on correct encodings, though not minimal ones.
	 * BUT it currently rejects legit 4-byte UTF-8 code points,
	 * which need surrogate pairs.  (Unicode 3.1 can use them.)
	 */
	while (len != 0 && (c = (u8) *s++) != 0) {
348153fc:	e1560000 	cmp	r6, r0
34815400:	0a000007 	beq	34815424 <usb_gadget_get_string+0x174>
34815404:	e5d32000 	ldrb	r2, [r3]
34815408:	e3520000 	cmp	r2, #0
3481540c:	1affffcf 	bne	34815350 <usb_gadget_get_string+0xa0>
34815410:	ea000003 	b	34815424 <usb_gadget_get_string+0x174>
	/* string descriptors have length, tag, then UTF16-LE text */
	len = min((size_t) 126, strlen(s->s));
	memset(buf + 2, 0, 2 * len);	/* zero all the bytes */
	len = utf8_to_utf16le(s->s, (__le16 *)&buf[2], len);
	if (len < 0)
		return -EINVAL;
34815414:	e3e00015 	mvn	r0, #21
34815418:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
3481541c:	e3e00015 	mvn	r0, #21
	buf[0] = (len + 1) * 2;
	buf[1] = USB_DT_STRING;
	return buf[0];
}
34815420:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
	len = min((size_t) 126, strlen(s->s));
	memset(buf + 2, 0, 2 * len);	/* zero all the bytes */
	len = utf8_to_utf16le(s->s, (__le16 *)&buf[2], len);
	if (len < 0)
		return -EINVAL;
	buf[0] = (len + 1) * 2;
34815424:	e2800001 	add	r0, r0, #1
34815428:	e1a00080 	lsl	r0, r0, #1
	buf[1] = USB_DT_STRING;
3481542c:	e3a03003 	mov	r3, #3
	len = min((size_t) 126, strlen(s->s));
	memset(buf + 2, 0, 2 * len);	/* zero all the bytes */
	len = utf8_to_utf16le(s->s, (__le16 *)&buf[2], len);
	if (len < 0)
		return -EINVAL;
	buf[0] = (len + 1) * 2;
34815430:	e5c40000 	strb	r0, [r4]
	buf[1] = USB_DT_STRING;
34815434:	e5c43001 	strb	r3, [r4, #1]
	return buf[0];
34815438:	e20000fe 	and	r0, r0, #254	; 0xfe
3481543c:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}

34815440 <get_unaligned_le16>:

#include <linux/types.h>

static inline u16 __get_unaligned_le16(const u8 *p)
{
	return p[0] | p[1] << 8;
34815440:	e5d02001 	ldrb	r2, [r0, #1]
34815444:	e5d03000 	ldrb	r3, [r0]
}

static inline u16 get_unaligned_le16(const void *p)
{
	return __get_unaligned_le16((const u8 *)p);
}
34815448:	e1830402 	orr	r0, r3, r2, lsl #8
3481544c:	e12fff1e 	bx	lr

34815450 <set_max_pktsize>:
static void set_max_pktsize(struct s3c_udc *dev, enum usb_device_speed speed)
{
	unsigned int ep_ctrl;
	int i;

	if (speed == USB_SPEED_HIGH) {
34815450:	e3510003 	cmp	r1, #3
34815454:	e59f307c 	ldr	r3, [pc, #124]	; 348154d8 <set_max_pktsize+0x88>
34815458:	1a000007 	bne	3481547c <set_max_pktsize+0x2c>
		ep0_fifo_size = 64;
3481545c:	e3a02040 	mov	r2, #64	; 0x40
34815460:	e5832000 	str	r2, [r3]
		ep_fifo_size = 512;
34815464:	e2822d07 	add	r2, r2, #448	; 0x1c0
34815468:	e5832004 	str	r2, [r3, #4]
		ep_fifo_size2 = 1024;
3481546c:	e2822c02 	add	r2, r2, #512	; 0x200
34815470:	e5832008 	str	r2, [r3, #8]
		dev->gadget.speed = USB_SPEED_HIGH;
34815474:	e5801010 	str	r1, [r0, #16]
34815478:	ea000005 	b	34815494 <set_max_pktsize+0x44>
	} else {
		ep0_fifo_size = 64;
3481547c:	e3a02040 	mov	r2, #64	; 0x40
34815480:	e5832000 	str	r2, [r3]
		ep_fifo_size = 64;
34815484:	e5832004 	str	r2, [r3, #4]
		ep_fifo_size2 = 64;
34815488:	e5832008 	str	r2, [r3, #8]
		dev->gadget.speed = USB_SPEED_FULL;
3481548c:	e3a03002 	mov	r3, #2
34815490:	e5803010 	str	r3, [r0, #16]
	}

	dev->ep[0].ep.maxpacket = ep0_fifo_size;
34815494:	e3a03040 	mov	r3, #64	; 0x40
34815498:	e1c036bc 	strh	r3, [r0, #108]	; 0x6c
	for (i = 1; i < S3C_MAX_ENDPOINTS; i++)
		dev->ep[i].ep.maxpacket = ep_fifo_size;
3481549c:	e59f3034 	ldr	r3, [pc, #52]	; 348154d8 <set_max_pktsize+0x88>
348154a0:	e3a02f4b 	mov	r2, #300	; 0x12c
348154a4:	e1d330b4 	ldrh	r3, [r3, #4]
348154a8:	e18030b2 	strh	r3, [r0, r2]
348154ac:	e1c03abc 	strh	r3, [r0, #172]	; 0xac
348154b0:	e1c03ebc 	strh	r3, [r0, #236]	; 0xec

	/* EP0 - Control IN (64 bytes)*/
	ep_ctrl = readl(&reg->in_endp[EP0_CON].diepctl);
348154b4:	e59f3020 	ldr	r3, [pc, #32]	; 348154dc <set_max_pktsize+0x8c>
348154b8:	e5932000 	ldr	r2, [r3]
348154bc:	e5921900 	ldr	r1, [r2, #2304]	; 0x900
	writel(ep_ctrl|(0<<0), &reg->in_endp[EP0_CON].diepctl);
348154c0:	e5932000 	ldr	r2, [r3]
348154c4:	e5821900 	str	r1, [r2, #2304]	; 0x900

	/* EP0 - Control OUT (64 bytes)*/
	ep_ctrl = readl(&reg->out_endp[EP0_CON].doepctl);
348154c8:	e5922b00 	ldr	r2, [r2, #2816]	; 0xb00
	writel(ep_ctrl|(0<<0), &reg->out_endp[EP0_CON].doepctl);
348154cc:	e5933000 	ldr	r3, [r3]
348154d0:	e5832b00 	str	r2, [r3, #2816]	; 0xb00
}
348154d4:	e12fff1e 	bx	lr
348154d8:	34828a10 	.word	0x34828a10
348154dc:	3482b310 	.word	0x3482b310

348154e0 <s3c_fifo_status>:
{
	int count = 0;
	struct s3c_ep *ep;

	ep = container_of(_ep, struct s3c_ep, ep);
	if (!_ep) {
348154e0:	e3500000 	cmp	r0, #0
348154e4:	0a000004 	beq	348154fc <s3c_fifo_status+0x1c>
	}

	debug("%s: %d\n", __func__, ep_index(ep));

	/* LPD can't report unclaimed bytes from IN fifos */
	if (ep_is_in(ep))
348154e8:	e1d033d5 	ldrsb	r3, [r0, #53]	; 0x35
348154ec:	e3530000 	cmp	r3, #0
		return -EOPNOTSUPP;
348154f0:	a3a00000 	movge	r0, #0
348154f4:	b3e0005e 	mvnlt	r0, #94	; 0x5e
348154f8:	e12fff1e 	bx	lr
	struct s3c_ep *ep;

	ep = container_of(_ep, struct s3c_ep, ep);
	if (!_ep) {
		debug("%s: bad ep\n", __func__);
		return -ENODEV;
348154fc:	e3e00012 	mvn	r0, #18
	/* LPD can't report unclaimed bytes from IN fifos */
	if (ep_is_in(ep))
		return -EOPNOTSUPP;

	return count;
}
34815500:	e12fff1e 	bx	lr

34815504 <s3c_fifo_flush>:
		debug("%s: bad ep\n", __func__);
		return;
	}

	debug("%s: %d\n", __func__, ep_index(ep));
}
34815504:	e12fff1e 	bx	lr

34815508 <reconfig_usbd>:
	/* re-init driver-visible data structures */
	udc_reinit(dev);
}

static void reconfig_usbd(void)
{
34815508:	e92d4038 	push	{r3, r4, r5, lr}
	/* 2. Soft-reset OTG Core and then unreset again. */
	int i;
	unsigned int uTemp = writel(CORE_SOFT_RESET, &reg->grstctl);
3481550c:	e59f4170 	ldr	r4, [pc, #368]	; 34815684 <reconfig_usbd+0x17c>
34815510:	e3a05001 	mov	r5, #1
34815514:	e5943000 	ldr	r3, [r4]
34815518:	e5835010 	str	r5, [r3, #16]

	debug("Reseting OTG controller\n");

	writel(0<<15		/* PHY Low Power Clock sel*/
3481551c:	e5943000 	ldr	r3, [r4]
34815520:	e305240f 	movw	r2, #21519	; 0x540f
34815524:	e583200c 	str	r2, [r3, #12]
		|1<<3		/* phy i/f  0:8bit, 1:16bit*/
		|0x7<<0,	/* HS/FS Timeout**/
		&reg->gusbcfg);

	/* 3. Put the OTG device core in the disconnected state.*/
	uTemp = readl(&reg->dctl);
34815528:	e5932804 	ldr	r2, [r3, #2052]	; 0x804
	uTemp |= SOFT_DISCONNECT;
3481552c:	e3822002 	orr	r2, r2, #2
	writel(uTemp, &reg->dctl);
34815530:	e5943000 	ldr	r3, [r4]

	udelay(20);
34815534:	e3a00014 	mov	r0, #20
		&reg->gusbcfg);

	/* 3. Put the OTG device core in the disconnected state.*/
	uTemp = readl(&reg->dctl);
	uTemp |= SOFT_DISCONNECT;
	writel(uTemp, &reg->dctl);
34815538:	e5832804 	str	r2, [r3, #2052]	; 0x804

	udelay(20);
3481553c:	eb000ede 	bl	348190bc <udelay>

	/* 4. Make the OTG device core exit from the disconnected state.*/
	uTemp = readl(&reg->dctl);
34815540:	e5943000 	ldr	r3, [r4]
34815544:	e5932804 	ldr	r2, [r3, #2052]	; 0x804
	uTemp = uTemp & ~SOFT_DISCONNECT;
34815548:	e3c22002 	bic	r2, r2, #2
	writel(uTemp, &reg->dctl);
3481554c:	e5943000 	ldr	r3, [r4]
34815550:	e5832804 	str	r2, [r3, #2052]	; 0x804

	/* 5. Configure OTG Core to initial settings of device mode.*/
	/* [][1: full speed(30Mhz) 0:high speed]*/
	writel(EP_MISS_CNT(1) | DEV_SPEED_HIGH_SPEED_20, &reg->dcfg);
34815554:	e5943000 	ldr	r3, [r4]
34815558:	e3a02701 	mov	r2, #262144	; 0x40000
3481555c:	e5832800 	str	r2, [r3, #2048]	; 0x800

	mdelay(1);
34815560:	e1a00005 	mov	r0, r5
34815564:	eb000ee0 	bl	348190ec <mdelay>

	/* 6. Unmask the core interrupts*/
	writel(GINTMSK_INIT, &reg->gintmsk);
34815568:	e59f2118 	ldr	r2, [pc, #280]	; 34815688 <reconfig_usbd+0x180>
3481556c:	e5943000 	ldr	r3, [r4]
34815570:	e5832018 	str	r2, [r3, #24]

	/* 7. Set NAK bit of EP0, EP1, EP2*/
	writel(DEPCTL_EPDIS|DEPCTL_SNAK, &reg->out_endp[EP0_CON].doepctl);
34815574:	e5942000 	ldr	r2, [r4]
34815578:	e3a03312 	mov	r3, #1207959552	; 0x48000000
3481557c:	e5823b00 	str	r3, [r2, #2816]	; 0xb00
	writel(DEPCTL_EPDIS|DEPCTL_SNAK, &reg->in_endp[EP0_CON].diepctl);
34815580:	e5942000 	ldr	r2, [r4]
34815584:	e5823900 	str	r3, [r2, #2304]	; 0x900

	for (i = 1; i < S3C_MAX_ENDPOINTS; i++) {
		writel(DEPCTL_EPDIS|DEPCTL_SNAK, &reg->out_endp[i].doepctl);
34815588:	e1a02003 	mov	r2, r3
3481558c:	e5941000 	ldr	r1, [r4]
34815590:	e2850058 	add	r0, r5, #88	; 0x58
34815594:	e7812280 	str	r2, [r1, r0, lsl #5]
34815598:	e59f30e4 	ldr	r3, [pc, #228]	; 34815684 <reconfig_usbd+0x17c>
		writel(DEPCTL_EPDIS|DEPCTL_SNAK, &reg->in_endp[i].diepctl);
3481559c:	e2850048 	add	r0, r5, #72	; 0x48
348155a0:	e5941000 	ldr	r1, [r4]

	/* 7. Set NAK bit of EP0, EP1, EP2*/
	writel(DEPCTL_EPDIS|DEPCTL_SNAK, &reg->out_endp[EP0_CON].doepctl);
	writel(DEPCTL_EPDIS|DEPCTL_SNAK, &reg->in_endp[EP0_CON].diepctl);

	for (i = 1; i < S3C_MAX_ENDPOINTS; i++) {
348155a4:	e2855001 	add	r5, r5, #1
348155a8:	e3550004 	cmp	r5, #4
		writel(DEPCTL_EPDIS|DEPCTL_SNAK, &reg->out_endp[i].doepctl);
		writel(DEPCTL_EPDIS|DEPCTL_SNAK, &reg->in_endp[i].diepctl);
348155ac:	e7812280 	str	r2, [r1, r0, lsl #5]

	/* 7. Set NAK bit of EP0, EP1, EP2*/
	writel(DEPCTL_EPDIS|DEPCTL_SNAK, &reg->out_endp[EP0_CON].doepctl);
	writel(DEPCTL_EPDIS|DEPCTL_SNAK, &reg->in_endp[EP0_CON].diepctl);

	for (i = 1; i < S3C_MAX_ENDPOINTS; i++) {
348155b0:	1afffff5 	bne	3481558c <reconfig_usbd+0x84>
		writel(DEPCTL_EPDIS|DEPCTL_SNAK, &reg->out_endp[i].doepctl);
		writel(DEPCTL_EPDIS|DEPCTL_SNAK, &reg->in_endp[i].diepctl);
	}

	/* 8. Unmask EPO interrupts*/
	writel(((1 << EP0_CON) << DAINT_OUT_BIT)
348155b4:	e59f10d0 	ldr	r1, [pc, #208]	; 3481568c <reconfig_usbd+0x184>
348155b8:	e5932000 	ldr	r2, [r3]
348155bc:	e582181c 	str	r1, [r2, #2076]	; 0x81c
	       | (1 << EP0_CON), &reg->daintmsk);

	/* 9. Unmask device OUT EP common interrupts*/
	writel(DOEPMSK_INIT, &reg->doepmsk);
348155c0:	e5931000 	ldr	r1, [r3]
348155c4:	e3a0200d 	mov	r2, #13
348155c8:	e5812814 	str	r2, [r1, #2068]	; 0x814

	/* 10. Unmask device IN EP common interrupts*/
	writel(DIEPMSK_INIT, &reg->diepmsk);
348155cc:	e5931000 	ldr	r1, [r3]
348155d0:	e5812810 	str	r2, [r1, #2064]	; 0x810

	/* 11. Set Rx FIFO Size (in 32-bit words) */
	writel(RX_FIFO_SIZE >> 2, &reg->grxfsiz);
348155d4:	e5932000 	ldr	r2, [r3]
348155d8:	e3a01b01 	mov	r1, #1024	; 0x400
348155dc:	e5821024 	str	r1, [r2, #36]	; 0x24

	/* 12. Set Non Periodic Tx FIFO Size */
	writel((NPTX_FIFO_SIZE >> 2) << 16 | ((RX_FIFO_SIZE >> 2)) << 0,
348155e0:	e5932000 	ldr	r2, [r3]
348155e4:	e2811301 	add	r1, r1, #67108864	; 0x4000000
348155e8:	e5821028 	str	r1, [r2, #40]	; 0x28
348155ec:	e3a01000 	mov	r1, #0
348155f0:	e3a02a02 	mov	r2, #8192	; 0x2000
	       &reg->gnptxfsiz);

	for (i = 1; i < S3C_MAX_HW_ENDPOINTS; i++)
		writel((PTX_FIFO_SIZE >> 2) << 16 |
348155f4:	e1a04142 	asr	r4, r2, #2
348155f8:	e3844506 	orr	r4, r4, #25165824	; 0x1800000
348155fc:	e593c000 	ldr	ip, [r3]
34815600:	e2822c06 	add	r2, r2, #1536	; 0x600
34815604:	e28ccf41 	add	ip, ip, #260	; 0x104

	/* 12. Set Non Periodic Tx FIFO Size */
	writel((NPTX_FIFO_SIZE >> 2) << 16 | ((RX_FIFO_SIZE >> 2)) << 0,
	       &reg->gnptxfsiz);

	for (i = 1; i < S3C_MAX_HW_ENDPOINTS; i++)
34815608:	e3520c7a 	cmp	r2, #31232	; 0x7a00
		writel((PTX_FIFO_SIZE >> 2) << 16 |
3481560c:	e78c4001 	str	r4, [ip, r1]
34815610:	e59f006c 	ldr	r0, [pc, #108]	; 34815684 <reconfig_usbd+0x17c>
34815614:	e2811004 	add	r1, r1, #4

	/* 12. Set Non Periodic Tx FIFO Size */
	writel((NPTX_FIFO_SIZE >> 2) << 16 | ((RX_FIFO_SIZE >> 2)) << 0,
	       &reg->gnptxfsiz);

	for (i = 1; i < S3C_MAX_HW_ENDPOINTS; i++)
34815618:	1afffff5 	bne	348155f4 <reconfig_usbd+0xec>
		       ((RX_FIFO_SIZE + NPTX_FIFO_SIZE +
			 PTX_FIFO_SIZE*(i-1)) >> 2) << 0,
		       &reg->dieptxf[i-1]);

	/* Flush the RX FIFO */
	writel(RX_FIFO_FLUSH, &reg->grstctl);
3481561c:	e5903000 	ldr	r3, [r0]
34815620:	e3a02010 	mov	r2, #16
34815624:	e5832010 	str	r2, [r3, #16]
	while (readl(&reg->grstctl) & RX_FIFO_FLUSH)
34815628:	e5902000 	ldr	r2, [r0]
3481562c:	e59f3050 	ldr	r3, [pc, #80]	; 34815684 <reconfig_usbd+0x17c>
34815630:	e5922010 	ldr	r2, [r2, #16]
34815634:	e3120010 	tst	r2, #16
34815638:	1afffffa 	bne	34815628 <reconfig_usbd+0x120>
		debug("%s: waiting for S3C_UDC_OTG_GRSTCTL\n", __func__);

	/* Flush all the Tx FIFO's */
	writel(TX_FIFO_FLUSH_ALL, &reg->grstctl);
3481563c:	e5932000 	ldr	r2, [r3]
34815640:	e3a01b01 	mov	r1, #1024	; 0x400
34815644:	e5821010 	str	r1, [r2, #16]
	writel(TX_FIFO_FLUSH_ALL | TX_FIFO_FLUSH, &reg->grstctl);
34815648:	e5932000 	ldr	r2, [r3]
3481564c:	e2811020 	add	r1, r1, #32
34815650:	e5821010 	str	r1, [r2, #16]
	while (readl(&reg->grstctl) & TX_FIFO_FLUSH)
34815654:	e5931000 	ldr	r1, [r3]
34815658:	e59f2024 	ldr	r2, [pc, #36]	; 34815684 <reconfig_usbd+0x17c>
3481565c:	e5911010 	ldr	r1, [r1, #16]
34815660:	e3110020 	tst	r1, #32
34815664:	1afffffa 	bne	34815654 <reconfig_usbd+0x14c>
		debug("%s: waiting for S3C_UDC_OTG_GRSTCTL\n", __func__);

	/* 13. Clear NAK bit of EP0, EP1, EP2*/
	/* For Slave mode*/
	/* EP0: Control OUT */
	writel(DEPCTL_EPDIS | DEPCTL_CNAK,
34815668:	e5923000 	ldr	r3, [r2]
3481566c:	e3a01311 	mov	r1, #1140850688	; 0x44000000
34815670:	e5831b00 	str	r1, [r3, #2816]	; 0xb00
	       &reg->out_endp[EP0_CON].doepctl);

	/* 14. Initialize OTG Link Core.*/
	writel(GAHBCFG_INIT, &reg->gahbcfg);
34815674:	e5923000 	ldr	r3, [r2]
34815678:	e3a02027 	mov	r2, #39	; 0x27
3481567c:	e5832008 	str	r2, [r3, #8]
}
34815680:	e8bd8038 	pop	{r3, r4, r5, pc}
34815684:	3482b310 	.word	0x3482b310
34815688:	800c3800 	.word	0x800c3800
3481568c:	00010001 	.word	0x00010001

34815690 <done>:

/*
 *	done - retire a request; caller blocked irqs
 */
static void done(struct s3c_ep *ep, struct s3c_request *req, int status)
{
34815690:	e92d4038 	push	{r3, r4, r5, lr}
 * list_del_init - deletes entry from list and reinitialize it.
 * @entry: the element to delete from the list.
 */
static inline void list_del_init(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
34815694:	e591c028 	ldr	ip, [r1, #40]	; 0x28
	unsigned int stopped = ep->stopped;
34815698:	e5d05034 	ldrb	r5, [r0, #52]	; 0x34

/*
 *	done - retire a request; caller blocked irqs
 */
static void done(struct s3c_ep *ep, struct s3c_request *req, int status)
{
3481569c:	e1a04000 	mov	r4, r0
348156a0:	e591002c 	ldr	r0, [r1, #44]	; 0x2c
	unsigned int stopped = ep->stopped;

	debug("%s: %s %p, req = %p, stopped = %d\n",
	      __func__, ep->ep.name, ep, &req->req, stopped);

	list_del_init(&req->queue);
348156a4:	e2813028 	add	r3, r1, #40	; 0x28
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head *prev, struct list_head *next)
{
	next->prev = prev;
348156a8:	e58c0004 	str	r0, [ip, #4]
	prev->next = next;
348156ac:	e580c000 	str	ip, [r0]
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
	list->prev = list;
348156b0:	e581302c 	str	r3, [r1, #44]	; 0x2c
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
348156b4:	e5813028 	str	r3, [r1, #40]	; 0x28

	if (likely(req->req.status == -EINPROGRESS))
348156b8:	e5913020 	ldr	r3, [r1, #32]
		}
		printf("\n");
	}
#endif
	spin_unlock(&ep->dev->lock);
	req->req.complete(&ep->ep, &req->req);
348156bc:	e1a00004 	mov	r0, r4
	debug("%s: %s %p, req = %p, stopped = %d\n",
	      __func__, ep->ep.name, ep, &req->req, stopped);

	list_del_init(&req->queue);

	if (likely(req->req.status == -EINPROGRESS))
348156c0:	e3730073 	cmn	r3, #115	; 0x73
		      ep->ep.name, &req->req, status,
		      req->req.actual, req->req.length);
	}

	/* don't modify queue heads during completion callback */
	ep->stopped = 1;
348156c4:	e3a03001 	mov	r3, #1
	      __func__, ep->ep.name, ep, &req->req, stopped);

	list_del_init(&req->queue);

	if (likely(req->req.status == -EINPROGRESS))
		req->req.status = status;
348156c8:	05812020 	streq	r2, [r1, #32]
		      ep->ep.name, &req->req, status,
		      req->req.actual, req->req.length);
	}

	/* don't modify queue heads during completion callback */
	ep->stopped = 1;
348156cc:	e5c43034 	strb	r3, [r4, #52]	; 0x34
		}
		printf("\n");
	}
#endif
	spin_unlock(&ep->dev->lock);
	req->req.complete(&ep->ep, &req->req);
348156d0:	e5913010 	ldr	r3, [r1, #16]
348156d4:	e12fff33 	blx	r3
	spin_lock(&ep->dev->lock);

	debug("callback completed\n");

	ep->stopped = stopped;
348156d8:	e5c45034 	strb	r5, [r4, #52]	; 0x34
}
348156dc:	e8bd8038 	pop	{r3, r4, r5, pc}

348156e0 <s3c_dequeue>:
	unsigned long flags;

	debug("%s: %p\n", __func__, _ep);

	ep = container_of(_ep, struct s3c_ep, ep);
	if (!_ep || ep->ep.name == ep0name)
348156e0:	e3500000 	cmp	r0, #0
	kfree(req);
}

/* dequeue JUST ONE request */
static int s3c_dequeue(struct usb_ep *_ep, struct usb_request *_req)
{
348156e4:	e92d4008 	push	{r3, lr}
348156e8:	e1a03001 	mov	r3, r1
	unsigned long flags;

	debug("%s: %p\n", __func__, _ep);

	ep = container_of(_ep, struct s3c_ep, ep);
	if (!_ep || ep->ep.name == ep0name)
348156ec:	0a000013 	beq	34815740 <s3c_dequeue+0x60>
348156f0:	e59f2058 	ldr	r2, [pc, #88]	; 34815750 <s3c_dequeue+0x70>
348156f4:	e5901004 	ldr	r1, [r0, #4]
348156f8:	e1510002 	cmp	r1, r2
		return -EINVAL;

	spin_lock_irqsave(&ep->dev->lock, flags);

	/* make sure it's actually queued on this endpoint */
	list_for_each_entry(req, &ep->queue, queue) {
348156fc:	11a02000 	movne	r2, r0
34815700:	15b21020 	ldrne	r1, [r2, #32]!
	unsigned long flags;

	debug("%s: %p\n", __func__, _ep);

	ep = container_of(_ep, struct s3c_ep, ep);
	if (!_ep || ep->ep.name == ep0name)
34815704:	0a00000d 	beq	34815740 <s3c_dequeue+0x60>
34815708:	ea000002 	b	34815718 <s3c_dequeue+0x38>

	spin_lock_irqsave(&ep->dev->lock, flags);

	/* make sure it's actually queued on this endpoint */
	list_for_each_entry(req, &ep->queue, queue) {
		if (&req->req == _req)
3481570c:	e1510003 	cmp	r1, r3
34815710:	0a000006 	beq	34815730 <s3c_dequeue+0x50>
		return -EINVAL;

	spin_lock_irqsave(&ep->dev->lock, flags);

	/* make sure it's actually queued on this endpoint */
	list_for_each_entry(req, &ep->queue, queue) {
34815714:	e5911028 	ldr	r1, [r1, #40]	; 0x28
34815718:	e2411028 	sub	r1, r1, #40	; 0x28
3481571c:	e281c028 	add	ip, r1, #40	; 0x28
34815720:	e15c0002 	cmp	ip, r2
34815724:	1afffff8 	bne	3481570c <s3c_dequeue+0x2c>
		if (&req->req == _req)
			break;
	}
	if (&req->req != _req) {
34815728:	e1510003 	cmp	r1, r3
3481572c:	1a000005 	bne	34815748 <s3c_dequeue+0x68>
		spin_unlock_irqrestore(&ep->dev->lock, flags);
		return -EINVAL;
	}

	done(ep, req, -ECONNRESET);
34815730:	e3e02067 	mvn	r2, #103	; 0x67
34815734:	ebffffd5 	bl	34815690 <done>

	spin_unlock_irqrestore(&ep->dev->lock, flags);
	return 0;
34815738:	e3a00000 	mov	r0, #0
3481573c:	e8bd8008 	pop	{r3, pc}

	debug("%s: %p\n", __func__, _ep);

	ep = container_of(_ep, struct s3c_ep, ep);
	if (!_ep || ep->ep.name == ep0name)
		return -EINVAL;
34815740:	e3e00015 	mvn	r0, #21
34815744:	e8bd8008 	pop	{r3, pc}
		if (&req->req == _req)
			break;
	}
	if (&req->req != _req) {
		spin_unlock_irqrestore(&ep->dev->lock, flags);
		return -EINVAL;
34815748:	e3e00015 	mvn	r0, #21

	done(ep, req, -ECONNRESET);

	spin_unlock_irqrestore(&ep->dev->lock, flags);
	return 0;
}
3481574c:	e8bd8008 	pop	{r3, pc}
34815750:	34821894 	.word	0x34821894

34815754 <nuke>:

/*
 *	nuke - dequeue ALL requests
 */
static void nuke(struct s3c_ep *ep, int status)
{
34815754:	e92d4070 	push	{r4, r5, r6, lr}
34815758:	e1a04000 	mov	r4, r0
3481575c:	e1a06001 	mov	r6, r1
	struct s3c_request *req;

	debug("%s: %s %p\n", __func__, ep->ep.name, ep);

	/* called with irqs blocked */
	while (!list_empty(&ep->queue)) {
34815760:	e2805020 	add	r5, r0, #32
34815764:	ea000003 	b	34815778 <nuke+0x24>
		req = list_entry(ep->queue.next, struct s3c_request, queue);
		done(ep, req, status);
34815768:	e1a00004 	mov	r0, r4
3481576c:	e2411028 	sub	r1, r1, #40	; 0x28
34815770:	e1a02006 	mov	r2, r6
34815774:	ebffffc5 	bl	34815690 <done>
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
34815778:	e5941020 	ldr	r1, [r4, #32]
	struct s3c_request *req;

	debug("%s: %s %p\n", __func__, ep->ep.name, ep);

	/* called with irqs blocked */
	while (!list_empty(&ep->queue)) {
3481577c:	e1510005 	cmp	r1, r5
34815780:	1afffff8 	bne	34815768 <nuke+0x14>
		req = list_entry(ep->queue.next, struct s3c_request, queue);
		done(ep, req, status);
	}
}
34815784:	e8bd8070 	pop	{r4, r5, r6, pc}

34815788 <s3c_ep_disable>:

/*
 * Disable EP
 */
static int s3c_ep_disable(struct usb_ep *_ep)
{
34815788:	e92d4010 	push	{r4, lr}
	unsigned long flags;

	debug("%s: %p\n", __func__, _ep);

	ep = container_of(_ep, struct s3c_ep, ep);
	if (!_ep || !ep->desc) {
3481578c:	e2504000 	subs	r4, r0, #0
		debug("%s: %s not enabled\n", __func__,
		      _ep ? ep->ep.name : NULL);
		return -EINVAL;
34815790:	03e00015 	mvneq	r0, #21
	unsigned long flags;

	debug("%s: %p\n", __func__, _ep);

	ep = container_of(_ep, struct s3c_ep, ep);
	if (!_ep || !ep->desc) {
34815794:	08bd8010 	popeq	{r4, pc}
34815798:	e594301c 	ldr	r3, [r4, #28]
3481579c:	e3530000 	cmp	r3, #0
348157a0:	0a000006 	beq	348157c0 <s3c_ep_disable+0x38>
	}

	spin_lock_irqsave(&ep->dev->lock, flags);

	/* Nuke all pending requests */
	nuke(ep, -ESHUTDOWN);
348157a4:	e3e0106b 	mvn	r1, #107	; 0x6b
348157a8:	ebffffe9 	bl	34815754 <nuke>

	ep->desc = 0;
348157ac:	e3a00000 	mov	r0, #0
	ep->stopped = 1;
348157b0:	e3a03001 	mov	r3, #1
	spin_lock_irqsave(&ep->dev->lock, flags);

	/* Nuke all pending requests */
	nuke(ep, -ESHUTDOWN);

	ep->desc = 0;
348157b4:	e584001c 	str	r0, [r4, #28]
	ep->stopped = 1;
348157b8:	e5c43034 	strb	r3, [r4, #52]	; 0x34

	spin_unlock_irqrestore(&ep->dev->lock, flags);

	debug("%s: disabled %s\n", __func__, _ep->name);
	return 0;
348157bc:	e8bd8010 	pop	{r4, pc}

	ep = container_of(_ep, struct s3c_ep, ep);
	if (!_ep || !ep->desc) {
		debug("%s: %s not enabled\n", __func__,
		      _ep ? ep->ep.name : NULL);
		return -EINVAL;
348157c0:	e3e00015 	mvn	r0, #21

	spin_unlock_irqrestore(&ep->dev->lock, flags);

	debug("%s: disabled %s\n", __func__, _ep->name);
	return 0;
}
348157c4:	e8bd8010 	pop	{r4, pc}

348157c8 <s3c_ep0_complete_out>:
		__func__, readl(&reg->out_endp[EP0_CON].doepctl));

}

static inline void s3c_ep0_complete_out(void)
{
348157c8:	e92d4010 	push	{r4, lr}

	debug_cond(DEBUG_IN_EP,
		"%s : Prepare Complete Out packet.\n", __func__);

	invalidate_dcache_range((unsigned long) usb_ctrl_dma_addr,
				(unsigned long) usb_ctrl_dma_addr
348157cc:	e59f4034 	ldr	r4, [pc, #52]	; 34815808 <s3c_ep0_complete_out+0x40>
348157d0:	e5940004 	ldr	r0, [r4, #4]
		__func__, readl(&reg->out_endp[EP0_CON].doepctl));

	debug_cond(DEBUG_IN_EP,
		"%s : Prepare Complete Out packet.\n", __func__);

	invalidate_dcache_range((unsigned long) usb_ctrl_dma_addr,
348157d4:	e2801901 	add	r1, r0, #16384	; 0x4000
348157d8:	ebffadf4 	bl	34800fb0 <invalidate_dcache_range>
				(unsigned long) usb_ctrl_dma_addr
				+ DMA_BUFFER_SIZE);

	writel(DOEPT_SIZ_PKT_CNT(1) | sizeof(struct usb_ctrlrequest),
348157dc:	e59f2028 	ldr	r2, [pc, #40]	; 3481580c <s3c_ep0_complete_out+0x44>
348157e0:	e5943000 	ldr	r3, [r4]
348157e4:	e5832b10 	str	r2, [r3, #2832]	; 0xb10
	       &reg->out_endp[EP0_CON].doeptsiz);
	writel(usb_ctrl_dma_addr, &reg->out_endp[EP0_CON].doepdma);
348157e8:	e5942004 	ldr	r2, [r4, #4]
348157ec:	e5943000 	ldr	r3, [r4]
348157f0:	e5832b14 	str	r2, [r3, #2836]	; 0xb14

	ep_ctrl = readl(&reg->out_endp[EP0_CON].doepctl);
348157f4:	e5932b00 	ldr	r2, [r3, #2816]	; 0xb00
	writel(ep_ctrl|DEPCTL_EPENA|DEPCTL_CNAK,
348157f8:	e3822321 	orr	r2, r2, #-2080374784	; 0x84000000
348157fc:	e5943000 	ldr	r3, [r4]
34815800:	e5832b00 	str	r2, [r3, #2816]	; 0xb00
	debug_cond(DEBUG_EP0 != 0, "%s:EP0 ZLP DIEPCTL0 = 0x%x\n",
		__func__, readl(&reg->in_endp[EP0_CON].diepctl));
	debug_cond(DEBUG_EP0 != 0, "%s:EP0 ZLP DOEPCTL0 = 0x%x\n",
		__func__, readl(&reg->out_endp[EP0_CON].doepctl));

}
34815804:	e8bd8010 	pop	{r4, pc}
34815808:	3482b310 	.word	0x3482b310
3481580c:	00080008 	.word	0x00080008

34815810 <setdma_rx>:


static int setdma_rx(struct s3c_ep *ep, struct s3c_request *req)
{
34815810:	e92d4070 	push	{r4, r5, r6, lr}
	u32 *buf, ctrl;
	u32 length, pktcnt;
	u32 ep_num = ep_index(ep);

	buf = req->req.buf + req->req.actual;
34815814:	e5913024 	ldr	r3, [r1, #36]	; 0x24
34815818:	e5912000 	ldr	r2, [r1]

	length = min(req->req.length - req->req.actual, (int)ep->ep.maxpacket);
3481581c:	e5911004 	ldr	r1, [r1, #4]
34815820:	e1d061b4 	ldrh	r6, [r0, #20]
{
	u32 *buf, ctrl;
	u32 length, pktcnt;
	u32 ep_num = ep_index(ep);

	buf = req->req.buf + req->req.actual;
34815824:	e0822003 	add	r2, r2, r3

static int setdma_rx(struct s3c_ep *ep, struct s3c_request *req)
{
	u32 *buf, ctrl;
	u32 length, pktcnt;
	u32 ep_num = ep_index(ep);
34815828:	e5d05035 	ldrb	r5, [r0, #53]	; 0x35

	buf = req->req.buf + req->req.actual;

	length = min(req->req.length - req->req.actual, (int)ep->ep.maxpacket);
3481582c:	e0633001 	rsb	r3, r3, r1
34815830:	e1560003 	cmp	r6, r3
34815834:	21a06003 	movcs	r6, r3

	ep->len = length;
	ep->dma_buf = buf;

	invalidate_dcache_range((unsigned long) ep->dev->dma_buf[ep_num],
				(unsigned long) ep->dev->dma_buf[ep_num]
34815838:	e5903018 	ldr	r3, [r0, #24]

static int setdma_rx(struct s3c_ep *ep, struct s3c_request *req)
{
	u32 *buf, ctrl;
	u32 length, pktcnt;
	u32 ep_num = ep_index(ep);
3481583c:	e205500f 	and	r5, r5, #15

	ep->len = length;
	ep->dma_buf = buf;

	invalidate_dcache_range((unsigned long) ep->dev->dma_buf[ep_num],
				(unsigned long) ep->dev->dma_buf[ep_num]
34815840:	e0833105 	add	r3, r3, r5, lsl #2
	buf = req->req.buf + req->req.actual;

	length = min(req->req.length - req->req.actual, (int)ep->ep.maxpacket);

	ep->len = length;
	ep->dma_buf = buf;
34815844:	e5802030 	str	r2, [r0, #48]	; 0x30

	buf = req->req.buf + req->req.actual;

	length = min(req->req.length - req->req.actual, (int)ep->ep.maxpacket);

	ep->len = length;
34815848:	e580602c 	str	r6, [r0, #44]	; 0x2c

}


static int setdma_rx(struct s3c_ep *ep, struct s3c_request *req)
{
3481584c:	e1a04000 	mov	r4, r0

	ep->len = length;
	ep->dma_buf = buf;

	invalidate_dcache_range((unsigned long) ep->dev->dma_buf[ep_num],
				(unsigned long) ep->dev->dma_buf[ep_num]
34815850:	e593002c 	ldr	r0, [r3, #44]	; 0x2c
	length = min(req->req.length - req->req.actual, (int)ep->ep.maxpacket);

	ep->len = length;
	ep->dma_buf = buf;

	invalidate_dcache_range((unsigned long) ep->dev->dma_buf[ep_num],
34815854:	e2801901 	add	r1, r0, #16384	; 0x4000
34815858:	ebffadd4 	bl	34800fb0 <invalidate_dcache_range>
		pktcnt = 1;
	else
		pktcnt = (length - 1)/(ep->ep.maxpacket) + 1;

	pktcnt = 1;
	ctrl =  readl(&reg->out_endp[ep_num].doepctl);
3481585c:	e59f3050 	ldr	r3, [pc, #80]	; 348158b4 <setdma_rx+0xa4>
34815860:	e2852058 	add	r2, r5, #88	; 0x58
34815864:	e5931000 	ldr	r1, [r3]
34815868:	e7911282 	ldr	r1, [r1, r2, lsl #5]

	writel(the_controller->dma_addr[ep_index(ep)+1],
3481586c:	e5d4c035 	ldrb	ip, [r4, #53]	; 0x35
34815870:	e5930008 	ldr	r0, [r3, #8]
34815874:	e20cc00f 	and	ip, ip, #15
34815878:	e28cc011 	add	ip, ip, #17
3481587c:	e790c10c 	ldr	ip, [r0, ip, lsl #2]
34815880:	e5930000 	ldr	r0, [r3]
34815884:	e1a05285 	lsl	r5, r5, #5
34815888:	e2855eb1 	add	r5, r5, #2832	; 0xb10
3481588c:	e0800005 	add	r0, r0, r5
34815890:	e580c004 	str	ip, [r0, #4]
	       &reg->out_endp[ep_num].doepdma);
	writel(DOEPT_SIZ_PKT_CNT(pktcnt) | DOEPT_SIZ_XFER_SIZE(length),
34815894:	e3866702 	orr	r6, r6, #524288	; 0x80000
34815898:	e5930000 	ldr	r0, [r3]
	       &reg->out_endp[ep_num].doeptsiz);
	writel(DEPCTL_EPENA|DEPCTL_CNAK|ctrl, &reg->out_endp[ep_num].doepctl);
3481589c:	e3811321 	orr	r1, r1, #-2080374784	; 0x84000000
	pktcnt = 1;
	ctrl =  readl(&reg->out_endp[ep_num].doepctl);

	writel(the_controller->dma_addr[ep_index(ep)+1],
	       &reg->out_endp[ep_num].doepdma);
	writel(DOEPT_SIZ_PKT_CNT(pktcnt) | DOEPT_SIZ_XFER_SIZE(length),
348158a0:	e7806005 	str	r6, [r0, r5]
	       &reg->out_endp[ep_num].doeptsiz);
	writel(DEPCTL_EPENA|DEPCTL_CNAK|ctrl, &reg->out_endp[ep_num].doepctl);
348158a4:	e5933000 	ldr	r3, [r3]
		   readl(&reg->out_endp[ep_num].doeptsiz),
		   readl(&reg->out_endp[ep_num].doepctl),
		   buf, pktcnt, length);
	return 0;

}
348158a8:	e3a00000 	mov	r0, #0

	writel(the_controller->dma_addr[ep_index(ep)+1],
	       &reg->out_endp[ep_num].doepdma);
	writel(DOEPT_SIZ_PKT_CNT(pktcnt) | DOEPT_SIZ_XFER_SIZE(length),
	       &reg->out_endp[ep_num].doeptsiz);
	writel(DEPCTL_EPENA|DEPCTL_CNAK|ctrl, &reg->out_endp[ep_num].doepctl);
348158ac:	e7831282 	str	r1, [r3, r2, lsl #5]
		   readl(&reg->out_endp[ep_num].doeptsiz),
		   readl(&reg->out_endp[ep_num].doepctl),
		   buf, pktcnt, length);
	return 0;

}
348158b0:	e8bd8070 	pop	{r4, r5, r6, pc}
348158b4:	3482b310 	.word	0x3482b310

348158b8 <s3c_free_request>:
	struct s3c_request *req;

	debug("%s: %p\n", __func__, ep);

	req = container_of(_req, struct s3c_request, req);
	WARN_ON(!list_empty(&req->queue));
348158b8:	e5912028 	ldr	r2, [r1, #40]	; 0x28
348158bc:	e2813028 	add	r3, r1, #40	; 0x28
348158c0:	e1520003 	cmp	r2, r3

	return &req->req;
}

static void s3c_free_request(struct usb_ep *ep, struct usb_request *_req)
{
348158c4:	e92d4010 	push	{r4, lr}
348158c8:	e1a04001 	mov	r4, r1
	struct s3c_request *req;

	debug("%s: %p\n", __func__, ep);

	req = container_of(_req, struct s3c_request, req);
	WARN_ON(!list_empty(&req->queue));
348158cc:	0a000003 	beq	348158e0 <s3c_free_request+0x28>
348158d0:	e59f0014 	ldr	r0, [pc, #20]	; 348158ec <s3c_free_request+0x34>
348158d4:	e59f1014 	ldr	r1, [pc, #20]	; 348158f0 <s3c_free_request+0x38>
348158d8:	e3a02faf 	mov	r2, #700	; 0x2bc
348158dc:	ebffcd9a 	bl	34808f4c <printf>
	kfree(req);
348158e0:	e1a00004 	mov	r0, r4
}
348158e4:	e8bd4010 	pop	{r4, lr}

	debug("%s: %p\n", __func__, ep);

	req = container_of(_req, struct s3c_request, req);
	WARN_ON(!list_empty(&req->queue));
	kfree(req);
348158e8:	eaffced5 	b	34809444 <free>
348158ec:	34827646 	.word	0x34827646
348158f0:	3482765d 	.word	0x3482765d

348158f4 <s3c_alloc_request>:
	return 0;
}

static struct usb_request *s3c_alloc_request(struct usb_ep *ep,
					     gfp_t gfp_flags)
{
348158f4:	e92d4010 	push	{r4, lr}
	struct s3c_request *req;

	debug("%s: %s %p\n", __func__, ep->name, ep);

	req = memalign(CONFIG_SYS_CACHELINE_SIZE, sizeof(*req));
348158f8:	e3a00040 	mov	r0, #64	; 0x40
348158fc:	e3a01030 	mov	r1, #48	; 0x30
34815900:	ebffd0fd 	bl	34809cfc <memalign>
	if (!req)
34815904:	e2504000 	subs	r4, r0, #0
34815908:	0a000005 	beq	34815924 <s3c_alloc_request+0x30>
		return 0;

	memset(req, 0, sizeof *req);
3481590c:	e3a01000 	mov	r1, #0
34815910:	e3a02030 	mov	r2, #48	; 0x30
34815914:	eb000d39 	bl	34818e00 <memset>
	INIT_LIST_HEAD(&req->queue);
34815918:	e2843028 	add	r3, r4, #40	; 0x28
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
3481591c:	e5843028 	str	r3, [r4, #40]	; 0x28
	list->prev = list;
34815920:	e584302c 	str	r3, [r4, #44]	; 0x2c

	return &req->req;
}
34815924:	e1a00004 	mov	r0, r4
34815928:	e8bd8010 	pop	{r4, pc}

3481592c <s3c_udc_ep0_zlp.clone.2>:

/* Bulk-Only Mass Storage Reset (class-specific request) */
#define GET_MAX_LUN_REQUEST	0xFE
#define BOT_RESET_REQUEST	0xFF

static inline void s3c_udc_ep0_zlp(struct s3c_udc *dev)
3481592c:	e92d4038 	push	{r3, r4, r5, lr}
{
	u32 ep_ctrl;

	flush_dcache_range((unsigned long) usb_ctrl_dma_addr,
			   (unsigned long) usb_ctrl_dma_addr
34815930:	e59f4040 	ldr	r4, [pc, #64]	; 34815978 <s3c_udc_ep0_zlp.clone.2+0x4c>

/* Bulk-Only Mass Storage Reset (class-specific request) */
#define GET_MAX_LUN_REQUEST	0xFE
#define BOT_RESET_REQUEST	0xFF

static inline void s3c_udc_ep0_zlp(struct s3c_udc *dev)
34815934:	e1a05000 	mov	r5, r0
{
	u32 ep_ctrl;

	flush_dcache_range((unsigned long) usb_ctrl_dma_addr,
			   (unsigned long) usb_ctrl_dma_addr
34815938:	e5940004 	ldr	r0, [r4, #4]

static inline void s3c_udc_ep0_zlp(struct s3c_udc *dev)
{
	u32 ep_ctrl;

	flush_dcache_range((unsigned long) usb_ctrl_dma_addr,
3481593c:	e2801901 	add	r1, r0, #16384	; 0x4000
34815940:	ebffada3 	bl	34800fd4 <flush_dcache_range>
			   (unsigned long) usb_ctrl_dma_addr
			   + DMA_BUFFER_SIZE);

	writel(usb_ctrl_dma_addr, &reg->in_endp[EP0_CON].diepdma);
34815944:	e5942004 	ldr	r2, [r4, #4]
34815948:	e5943000 	ldr	r3, [r4]
3481594c:	e5832914 	str	r2, [r3, #2324]	; 0x914
	writel(DIEPT_SIZ_PKT_CNT(1), &reg->in_endp[EP0_CON].dieptsiz);
34815950:	e5943000 	ldr	r3, [r4]
34815954:	e3a02702 	mov	r2, #524288	; 0x80000
34815958:	e5832910 	str	r2, [r3, #2320]	; 0x910

	ep_ctrl = readl(&reg->in_endp[EP0_CON].diepctl);
3481595c:	e5932900 	ldr	r2, [r3, #2304]	; 0x900
	writel(ep_ctrl|DEPCTL_EPENA|DEPCTL_CNAK,
34815960:	e3822321 	orr	r2, r2, #-2080374784	; 0x84000000
34815964:	e5943000 	ldr	r3, [r4]
34815968:	e5832900 	str	r2, [r3, #2304]	; 0x900
	       &reg->in_endp[EP0_CON].diepctl);

	debug_cond(DEBUG_EP0 != 0, "%s:EP0 ZLP DIEPCTL0 = 0x%x\n",
		__func__, readl(&reg->in_endp[EP0_CON].diepctl));
	dev->ep0state = WAIT_FOR_IN_COMPLETE;
3481596c:	e3a03007 	mov	r3, #7
34815970:	e5853000 	str	r3, [r5]
}
34815974:	e8bd8038 	pop	{r3, r4, r5, pc}
34815978:	3482b310 	.word	0x3482b310

3481597c <complete_rx>:

	return length;
}

static void complete_rx(struct s3c_udc *dev, u8 ep_num)
{
3481597c:	e92d4eff 	push	{r0, r1, r2, r3, r4, r5, r6, r7, r9, sl, fp, lr}
34815980:	e1a05001 	mov	r5, r1
	struct s3c_ep *ep = &dev->ep[ep_num];
	struct s3c_request *req = NULL;
	u32 ep_tsr = 0, xfer_size = 0, is_short = 0;
	u32 *p = the_controller->dma_buf[ep_index(ep)+1];
34815984:	e1a01301 	lsl	r1, r1, #6
34815988:	e0802001 	add	r2, r0, r1
3481598c:	e59f3134 	ldr	r3, [pc, #308]	; 34815ac8 <complete_rx+0x14c>

	return length;
}

static void complete_rx(struct s3c_udc *dev, u8 ep_num)
{
34815990:	e1a04000 	mov	r4, r0
	struct s3c_ep *ep = &dev->ep[ep_num];
	struct s3c_request *req = NULL;
	u32 ep_tsr = 0, xfer_size = 0, is_short = 0;
	u32 *p = the_controller->dma_buf[ep_index(ep)+1];
34815994:	e5d2008d 	ldrb	r0, [r2, #141]	; 0x8d
34815998:	e593c008 	ldr	ip, [r3, #8]

	if (list_empty(&ep->queue)) {
3481599c:	e2811078 	add	r1, r1, #120	; 0x78
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
348159a0:	e5926078 	ldr	r6, [r2, #120]	; 0x78
348159a4:	e0841001 	add	r1, r4, r1
static void complete_rx(struct s3c_udc *dev, u8 ep_num)
{
	struct s3c_ep *ep = &dev->ep[ep_num];
	struct s3c_request *req = NULL;
	u32 ep_tsr = 0, xfer_size = 0, is_short = 0;
	u32 *p = the_controller->dma_buf[ep_index(ep)+1];
348159a8:	e200000f 	and	r0, r0, #15
348159ac:	e08c0100 	add	r0, ip, r0, lsl #2

	if (list_empty(&ep->queue)) {
348159b0:	e1560001 	cmp	r6, r1
static void complete_rx(struct s3c_udc *dev, u8 ep_num)
{
	struct s3c_ep *ep = &dev->ep[ep_num];
	struct s3c_request *req = NULL;
	u32 ep_tsr = 0, xfer_size = 0, is_short = 0;
	u32 *p = the_controller->dma_buf[ep_index(ep)+1];
348159b4:	e5909030 	ldr	r9, [r0, #48]	; 0x30

	if (list_empty(&ep->queue)) {
348159b8:	e58d100c 	str	r1, [sp, #12]
348159bc:	0a00003f 	beq	34815ac0 <complete_rx+0x144>
		return;

	}

	req = list_entry(ep->queue.next, struct s3c_request, queue);
	ep_tsr = readl(&reg->out_endp[ep_num].doeptsiz);
348159c0:	e5933000 	ldr	r3, [r3]
			   __func__, ep_num);
		return;

	}

	req = list_entry(ep->queue.next, struct s3c_request, queue);
348159c4:	e246c028 	sub	ip, r6, #40	; 0x28
	ep_tsr = readl(&reg->out_endp[ep_num].doeptsiz);
348159c8:	e0833285 	add	r3, r3, r5, lsl #5
348159cc:	e5933b10 	ldr	r3, [r3, #2832]	; 0xb10
	if (ep_num == EP0_CON)
		xfer_size = (ep_tsr & DOEPT_SIZ_XFER_SIZE_MAX_EP0);
	else
		xfer_size = (ep_tsr & DOEPT_SIZ_XFER_SIZE_MAX_EP);

	xfer_size = ep->len - xfer_size;
348159d0:	e285b002 	add	fp, r5, #2
	}

	req = list_entry(ep->queue.next, struct s3c_request, queue);
	ep_tsr = readl(&reg->out_endp[ep_num].doeptsiz);

	if (ep_num == EP0_CON)
348159d4:	e3550000 	cmp	r5, #0
		xfer_size = (ep_tsr & DOEPT_SIZ_XFER_SIZE_MAX_EP0);
	else
		xfer_size = (ep_tsr & DOEPT_SIZ_XFER_SIZE_MAX_EP);

	xfer_size = ep->len - xfer_size;
348159d8:	e084b30b 	add	fp, r4, fp, lsl #6
	ep_tsr = readl(&reg->out_endp[ep_num].doeptsiz);

	if (ep_num == EP0_CON)
		xfer_size = (ep_tsr & DOEPT_SIZ_XFER_SIZE_MAX_EP0);
	else
		xfer_size = (ep_tsr & DOEPT_SIZ_XFER_SIZE_MAX_EP);
348159dc:	11a03883 	lslne	r3, r3, #17

	xfer_size = ep->len - xfer_size;
348159e0:	e59b2004 	ldr	r2, [fp, #4]

	req = list_entry(ep->queue.next, struct s3c_request, queue);
	ep_tsr = readl(&reg->out_endp[ep_num].doeptsiz);

	if (ep_num == EP0_CON)
		xfer_size = (ep_tsr & DOEPT_SIZ_XFER_SIZE_MAX_EP0);
348159e4:	0203307f 	andeq	r3, r3, #127	; 0x7f
	else
		xfer_size = (ep_tsr & DOEPT_SIZ_XFER_SIZE_MAX_EP);
348159e8:	11a038a3 	lsrne	r3, r3, #17
	return length;
}

static void complete_rx(struct s3c_udc *dev, u8 ep_num)
{
	struct s3c_ep *ep = &dev->ep[ep_num];
348159ec:	e1a0a305 	lsl	sl, r5, #6
	if (ep_num == EP0_CON)
		xfer_size = (ep_tsr & DOEPT_SIZ_XFER_SIZE_MAX_EP0);
	else
		xfer_size = (ep_tsr & DOEPT_SIZ_XFER_SIZE_MAX_EP);

	xfer_size = ep->len - xfer_size;
348159f0:	e0633002 	rsb	r3, r3, r2
	return length;
}

static void complete_rx(struct s3c_udc *dev, u8 ep_num)
{
	struct s3c_ep *ep = &dev->ep[ep_num];
348159f4:	e28a7058 	add	r7, sl, #88	; 0x58
	else
		xfer_size = (ep_tsr & DOEPT_SIZ_XFER_SIZE_MAX_EP);

	xfer_size = ep->len - xfer_size;

	invalidate_dcache_range((unsigned long) p,
348159f8:	e1a00009 	mov	r0, r9
348159fc:	e2891901 	add	r1, r9, #16384	; 0x4000
				(unsigned long) p + DMA_BUFFER_SIZE);

	memcpy(ep->dma_buf, p, ep->len);
34815a00:	e084a00a 	add	sl, r4, sl
	else
		xfer_size = (ep_tsr & DOEPT_SIZ_XFER_SIZE_MAX_EP);

	xfer_size = ep->len - xfer_size;

	invalidate_dcache_range((unsigned long) p,
34815a04:	e98d1008 	stmib	sp, {r3, ip}
34815a08:	ebffad68 	bl	34800fb0 <invalidate_dcache_range>
				(unsigned long) p + DMA_BUFFER_SIZE);

	memcpy(ep->dma_buf, p, ep->len);
34815a0c:	e1a01009 	mov	r1, r9
34815a10:	e59b2004 	ldr	r2, [fp, #4]
34815a14:	e59a0088 	ldr	r0, [sl, #136]	; 0x88
34815a18:	eb000d1c 	bl	34818e90 <memcpy>

	req->req.actual += min(xfer_size, req->req.length - req->req.actual);
34815a1c:	e5161004 	ldr	r1, [r6, #-4]
34815a20:	e5162024 	ldr	r2, [r6, #-36]	; 0x24
34815a24:	e59d3004 	ldr	r3, [sp, #4]
34815a28:	e0610002 	rsb	r0, r1, r2
34815a2c:	e1530000 	cmp	r3, r0
34815a30:	90811003 	addls	r1, r1, r3
34815a34:	80811000 	addhi	r1, r1, r0
	is_short = (xfer_size < ep->ep.maxpacket);
34815a38:	e1da06bc 	ldrh	r0, [sl, #108]	; 0x6c
	return length;
}

static void complete_rx(struct s3c_udc *dev, u8 ep_num)
{
	struct s3c_ep *ep = &dev->ep[ep_num];
34815a3c:	e0847007 	add	r7, r4, r7
		   "%s: RX DMA done : ep = %d, rx bytes = %d/%d, "
		   "is_short = %d, DOEPTSIZ = 0x%x, remained bytes = %d\n",
		   __func__, ep_num, req->req.actual, req->req.length,
		   is_short, ep_tsr, xfer_size);

	if (is_short || req->req.actual == req->req.length) {
34815a40:	e1530000 	cmp	r3, r0
	invalidate_dcache_range((unsigned long) p,
				(unsigned long) p + DMA_BUFFER_SIZE);

	memcpy(ep->dma_buf, p, ep->len);

	req->req.actual += min(xfer_size, req->req.length - req->req.actual);
34815a44:	e5061004 	str	r1, [r6, #-4]
		   "%s: RX DMA done : ep = %d, rx bytes = %d/%d, "
		   "is_short = %d, DOEPTSIZ = 0x%x, remained bytes = %d\n",
		   __func__, ep_num, req->req.actual, req->req.length,
		   is_short, ep_tsr, xfer_size);

	if (is_short || req->req.actual == req->req.length) {
34815a48:	e59dc008 	ldr	ip, [sp, #8]
34815a4c:	3a000003 	bcc	34815a60 <complete_rx+0xe4>
34815a50:	e1510002 	cmp	r1, r2
					   __func__);
				setdma_rx(ep, req);
			}
		}
	} else
		setdma_rx(ep, req);
34815a54:	11a00007 	movne	r0, r7
34815a58:	11a0100c 	movne	r1, ip
		   "%s: RX DMA done : ep = %d, rx bytes = %d/%d, "
		   "is_short = %d, DOEPTSIZ = 0x%x, remained bytes = %d\n",
		   __func__, ep_num, req->req.actual, req->req.length,
		   is_short, ep_tsr, xfer_size);

	if (is_short || req->req.actual == req->req.length) {
34815a5c:	1a000014 	bne	34815ab4 <complete_rx+0x138>
		if (ep_num == EP0_CON && dev->ep0state == DATA_STATE_RECV) {
34815a60:	e3550000 	cmp	r5, #0
34815a64:	1a000007 	bne	34815a88 <complete_rx+0x10c>
34815a68:	e5943054 	ldr	r3, [r4, #84]	; 0x54
34815a6c:	e3530004 	cmp	r3, #4
34815a70:	1a000004 	bne	34815a88 <complete_rx+0x10c>
			debug_cond(DEBUG_OUT_EP != 0, "	=> Send ZLP\n");
			s3c_udc_ep0_zlp(dev);
34815a74:	e2840054 	add	r0, r4, #84	; 0x54
34815a78:	ebffffab 	bl	3481592c <s3c_udc_ep0_zlp.clone.2>
			/* packet will be completed in complete_tx() */
			dev->ep0state = WAIT_FOR_IN_COMPLETE;
34815a7c:	e3a03007 	mov	r3, #7
34815a80:	e5843054 	str	r3, [r4, #84]	; 0x54
34815a84:	ea00000d 	b	34815ac0 <complete_rx+0x144>
		} else {
			done(ep, req, 0);
34815a88:	e1a00007 	mov	r0, r7
34815a8c:	e1a0100c 	mov	r1, ip
34815a90:	e3a02000 	mov	r2, #0
34815a94:	e0844305 	add	r4, r4, r5, lsl #6
34815a98:	ebfffefc 	bl	34815690 <done>
34815a9c:	e5941078 	ldr	r1, [r4, #120]	; 0x78

			if (!list_empty(&ep->queue)) {
34815aa0:	e59d200c 	ldr	r2, [sp, #12]
34815aa4:	e1510002 	cmp	r1, r2
				req = list_entry(ep->queue.next,
					struct s3c_request, queue);
				debug_cond(DEBUG_OUT_EP != 0,
					   "%s: Next Rx request start...\n",
					   __func__);
				setdma_rx(ep, req);
34815aa8:	11a00007 	movne	r0, r7
34815aac:	12411028 	subne	r1, r1, #40	; 0x28
			/* packet will be completed in complete_tx() */
			dev->ep0state = WAIT_FOR_IN_COMPLETE;
		} else {
			done(ep, req, 0);

			if (!list_empty(&ep->queue)) {
34815ab0:	0a000002 	beq	34815ac0 <complete_rx+0x144>
				setdma_rx(ep, req);
			}
		}
	} else
		setdma_rx(ep, req);
}
34815ab4:	e28dd010 	add	sp, sp, #16
34815ab8:	e8bd4ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, lr}
					   __func__);
				setdma_rx(ep, req);
			}
		}
	} else
		setdma_rx(ep, req);
34815abc:	eaffff53 	b	34815810 <setdma_rx>
}
34815ac0:	e28dd010 	add	sp, sp, #16
34815ac4:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
34815ac8:	3482b310 	.word	0x3482b310

34815acc <udc_set_address>:
 *
 * Called from control endpoint function
 * after it decodes a set address setup packet.
 */
static void udc_set_address(struct s3c_udc *dev, unsigned char address)
{
34815acc:	e92d4038 	push	{r3, r4, r5, lr}
	u32 ctrl = readl(&reg->dcfg);
34815ad0:	e59f3028 	ldr	r3, [pc, #40]	; 34815b00 <udc_set_address+0x34>
 *
 * Called from control endpoint function
 * after it decodes a set address setup packet.
 */
static void udc_set_address(struct s3c_udc *dev, unsigned char address)
{
34815ad4:	e1a04000 	mov	r4, r0
	u32 ctrl = readl(&reg->dcfg);
34815ad8:	e5932000 	ldr	r2, [r3]
 *
 * Called from control endpoint function
 * after it decodes a set address setup packet.
 */
static void udc_set_address(struct s3c_udc *dev, unsigned char address)
{
34815adc:	e1a05001 	mov	r5, r1
	u32 ctrl = readl(&reg->dcfg);
34815ae0:	e5922800 	ldr	r2, [r2, #2048]	; 0x800
	writel(DEVICE_ADDRESS(address) | ctrl, &reg->dcfg);
34815ae4:	e1822201 	orr	r2, r2, r1, lsl #4
34815ae8:	e5933000 	ldr	r3, [r3]

	s3c_udc_ep0_zlp(dev);
34815aec:	e2800054 	add	r0, r0, #84	; 0x54
 * after it decodes a set address setup packet.
 */
static void udc_set_address(struct s3c_udc *dev, unsigned char address)
{
	u32 ctrl = readl(&reg->dcfg);
	writel(DEVICE_ADDRESS(address) | ctrl, &reg->dcfg);
34815af0:	e5832800 	str	r2, [r3, #2048]	; 0x800

	s3c_udc_ep0_zlp(dev);
34815af4:	ebffff8c 	bl	3481592c <s3c_udc_ep0_zlp.clone.2>

	debug_cond(DEBUG_EP0 != 0,
		   "%s: USB OTG 2.0 Device address=%d, DCFG=0x%x\n",
		   __func__, address, readl(&reg->dcfg));

	dev->usb_address = address;
34815af8:	e5c45158 	strb	r5, [r4, #344]	; 0x158
}
34815afc:	e8bd8038 	pop	{r3, r4, r5, pc}
34815b00:	3482b310 	.word	0x3482b310

34815b04 <set_udc_gadget_private_data>:
void set_udc_gadget_private_data(void *p)
{
	debug_cond(DEBUG_SETUP != 0,
		   "%s: the_controller: 0x%p, p: 0x%p\n", __func__,
		   the_controller, p);
	the_controller->gadget.dev.device_data = p;
34815b04:	e59f3008 	ldr	r3, [pc, #8]	; 34815b14 <set_udc_gadget_private_data+0x10>
34815b08:	e5933008 	ldr	r3, [r3, #8]
34815b0c:	e5830020 	str	r0, [r3, #32]
}
34815b10:	e12fff1e 	bx	lr
34815b14:	3482b310 	.word	0x3482b310

34815b18 <get_udc_gadget_private_data>:

void *get_udc_gadget_private_data(struct usb_gadget *gadget)
{
	return gadget->dev.device_data;
}
34815b18:	e5900020 	ldr	r0, [r0, #32]
34815b1c:	e12fff1e 	bx	lr

34815b20 <otg_phy_init>:
struct s3c_usbotg_phy *phy;
static unsigned int usb_phy_ctrl;

void otg_phy_init(struct s3c_udc *dev)
{
	dev->pdata->phy_control(1);
34815b20:	e5903028 	ldr	r3, [r0, #40]	; 0x28
struct s3c_usbotg_reg *reg;
struct s3c_usbotg_phy *phy;
static unsigned int usb_phy_ctrl;

void otg_phy_init(struct s3c_udc *dev)
{
34815b24:	e92d4010 	push	{r4, lr}
	dev->pdata->phy_control(1);
34815b28:	e5933000 	ldr	r3, [r3]
struct s3c_usbotg_reg *reg;
struct s3c_usbotg_phy *phy;
static unsigned int usb_phy_ctrl;

void otg_phy_init(struct s3c_udc *dev)
{
34815b2c:	e1a04000 	mov	r4, r0
	dev->pdata->phy_control(1);
34815b30:	e3a00001 	mov	r0, #1
34815b34:	e12fff33 	blx	r3

	/*USB PHY0 Enable */
	printf("USB PHY0 Enable\n");
34815b38:	e59f00a4 	ldr	r0, [pc, #164]	; 34815be4 <otg_phy_init+0xc4>
34815b3c:	ebffcd02 	bl	34808f4c <printf>

	/* Enable PHY */
	writel(readl(usb_phy_ctrl) | USB_PHY_CTRL_EN0, usb_phy_ctrl);
34815b40:	e59f30a0 	ldr	r3, [pc, #160]	; 34815be8 <otg_phy_init+0xc8>
34815b44:	e593200c 	ldr	r2, [r3, #12]
34815b48:	e5921000 	ldr	r1, [r2]
34815b4c:	e3811001 	orr	r1, r1, #1
34815b50:	e593200c 	ldr	r2, [r3, #12]
34815b54:	e5821000 	str	r1, [r2]

	if (dev->pdata->usb_flags == PHY0_SLEEP) /* C210 Universal */
34815b58:	e5942028 	ldr	r2, [r4, #40]	; 0x28
34815b5c:	e5922010 	ldr	r2, [r2, #16]
34815b60:	e3520020 	cmp	r2, #32
34815b64:	1a000003 	bne	34815b78 <otg_phy_init+0x58>
		writel((readl(&phy->phypwr)
34815b68:	e5932010 	ldr	r2, [r3, #16]
34815b6c:	e5922000 	ldr	r2, [r2]
34815b70:	e3c22039 	bic	r2, r2, #57	; 0x39
34815b74:	ea000002 	b	34815b84 <otg_phy_init+0x64>
			&~(PHY_0_SLEEP | OTG_DISABLE_0 | ANALOG_PWRDOWN)
			&~FORCE_SUSPEND_0), &phy->phypwr);
	else /* C110 GONI */
		writel((readl(&phy->phypwr) &~(OTG_DISABLE_0 | ANALOG_PWRDOWN)
34815b78:	e5932010 	ldr	r2, [r3, #16]
34815b7c:	e5922000 	ldr	r2, [r2]
34815b80:	e3c22019 	bic	r2, r2, #25
34815b84:	e5933010 	ldr	r3, [r3, #16]
			&~FORCE_SUSPEND_0), &phy->phypwr);

	writel((readl(&phy->phyclk) &~(ID_PULLUP0 | COMMON_ON_N0)) |
34815b88:	e59f4058 	ldr	r4, [pc, #88]	; 34815be8 <otg_phy_init+0xc8>
	if (dev->pdata->usb_flags == PHY0_SLEEP) /* C210 Universal */
		writel((readl(&phy->phypwr)
			&~(PHY_0_SLEEP | OTG_DISABLE_0 | ANALOG_PWRDOWN)
			&~FORCE_SUSPEND_0), &phy->phypwr);
	else /* C110 GONI */
		writel((readl(&phy->phypwr) &~(OTG_DISABLE_0 | ANALOG_PWRDOWN)
34815b8c:	e5832000 	str	r2, [r3]
			&~FORCE_SUSPEND_0), &phy->phypwr);

	writel((readl(&phy->phyclk) &~(ID_PULLUP0 | COMMON_ON_N0)) |
34815b90:	e5943010 	ldr	r3, [r4, #16]
34815b94:	e5932004 	ldr	r2, [r3, #4]
34815b98:	e3c22017 	bic	r2, r2, #23
34815b9c:	e3822003 	orr	r2, r2, #3
34815ba0:	e5943010 	ldr	r3, [r4, #16]
34815ba4:	e5832004 	str	r2, [r3, #4]
	       CLK_SEL_24MHZ, &phy->phyclk); /* PLL 24Mhz */

	writel((readl(&phy->rstcon) &~(LINK_SW_RST | PHYLNK_SW_RST))
34815ba8:	e5932008 	ldr	r2, [r3, #8]
34815bac:	e3c22007 	bic	r2, r2, #7
34815bb0:	e3822001 	orr	r2, r2, #1
34815bb4:	e5943010 	ldr	r3, [r4, #16]
	       | PHY_SW_RST0, &phy->rstcon);
	udelay(10);
34815bb8:	e3a0000a 	mov	r0, #10
			&~FORCE_SUSPEND_0), &phy->phypwr);

	writel((readl(&phy->phyclk) &~(ID_PULLUP0 | COMMON_ON_N0)) |
	       CLK_SEL_24MHZ, &phy->phyclk); /* PLL 24Mhz */

	writel((readl(&phy->rstcon) &~(LINK_SW_RST | PHYLNK_SW_RST))
34815bbc:	e5832008 	str	r2, [r3, #8]
	       | PHY_SW_RST0, &phy->rstcon);
	udelay(10);
34815bc0:	eb000d3d 	bl	348190bc <udelay>
	writel(readl(&phy->rstcon)
34815bc4:	e5943010 	ldr	r3, [r4, #16]
34815bc8:	e5932008 	ldr	r2, [r3, #8]
34815bcc:	e3c22007 	bic	r2, r2, #7
34815bd0:	e5943010 	ldr	r3, [r4, #16]
	       &~(PHY_SW_RST0 | LINK_SW_RST | PHYLNK_SW_RST), &phy->rstcon);
	udelay(10);
34815bd4:	e3a0000a 	mov	r0, #10
	       CLK_SEL_24MHZ, &phy->phyclk); /* PLL 24Mhz */

	writel((readl(&phy->rstcon) &~(LINK_SW_RST | PHYLNK_SW_RST))
	       | PHY_SW_RST0, &phy->rstcon);
	udelay(10);
	writel(readl(&phy->rstcon)
34815bd8:	e5832008 	str	r2, [r3, #8]
	       &~(PHY_SW_RST0 | LINK_SW_RST | PHYLNK_SW_RST), &phy->rstcon);
	udelay(10);
}
34815bdc:	e8bd4010 	pop	{r4, lr}
	writel((readl(&phy->rstcon) &~(LINK_SW_RST | PHYLNK_SW_RST))
	       | PHY_SW_RST0, &phy->rstcon);
	udelay(10);
	writel(readl(&phy->rstcon)
	       &~(PHY_SW_RST0 | LINK_SW_RST | PHYLNK_SW_RST), &phy->rstcon);
	udelay(10);
34815be0:	ea000d35 	b	348190bc <udelay>
34815be4:	3482766b 	.word	0x3482766b
34815be8:	3482b310 	.word	0x3482b310

34815bec <otg_phy_off>:
}

void otg_phy_off(struct s3c_udc *dev)
{
34815bec:	e92d4038 	push	{r3, r4, r5, lr}
34815bf0:	e1a05000 	mov	r5, r0
	/* reset controller just in case */
	writel(PHY_SW_RST0, &phy->rstcon);
34815bf4:	e59f4084 	ldr	r4, [pc, #132]	; 34815c80 <otg_phy_off+0x94>
34815bf8:	e3a02001 	mov	r2, #1
34815bfc:	e5943010 	ldr	r3, [r4, #16]
	udelay(20);
34815c00:	e3a00014 	mov	r0, #20
}

void otg_phy_off(struct s3c_udc *dev)
{
	/* reset controller just in case */
	writel(PHY_SW_RST0, &phy->rstcon);
34815c04:	e5832008 	str	r2, [r3, #8]
	udelay(20);
34815c08:	eb000d2b 	bl	348190bc <udelay>
	writel(readl(&phy->phypwr) &~PHY_SW_RST0, &phy->rstcon);
34815c0c:	e5943010 	ldr	r3, [r4, #16]
34815c10:	e5932000 	ldr	r2, [r3]
34815c14:	e3c22001 	bic	r2, r2, #1
34815c18:	e5943010 	ldr	r3, [r4, #16]
	udelay(20);
34815c1c:	e3a00014 	mov	r0, #20
void otg_phy_off(struct s3c_udc *dev)
{
	/* reset controller just in case */
	writel(PHY_SW_RST0, &phy->rstcon);
	udelay(20);
	writel(readl(&phy->phypwr) &~PHY_SW_RST0, &phy->rstcon);
34815c20:	e5832008 	str	r2, [r3, #8]
	udelay(20);
34815c24:	eb000d24 	bl	348190bc <udelay>

	writel(readl(&phy->phypwr) | OTG_DISABLE_0 | ANALOG_PWRDOWN
34815c28:	e5943010 	ldr	r3, [r4, #16]
34815c2c:	e5932000 	ldr	r2, [r3]
34815c30:	e3822019 	orr	r2, r2, #25
34815c34:	e5943010 	ldr	r3, [r4, #16]
34815c38:	e5832000 	str	r2, [r3]
	       | FORCE_SUSPEND_0, &phy->phypwr);

	writel(readl(usb_phy_ctrl) &~USB_PHY_CTRL_EN0, usb_phy_ctrl);
34815c3c:	e594300c 	ldr	r3, [r4, #12]
34815c40:	e5932000 	ldr	r2, [r3]
34815c44:	e3c22001 	bic	r2, r2, #1
34815c48:	e594300c 	ldr	r3, [r4, #12]
34815c4c:	e5832000 	str	r2, [r3]

	writel((readl(&phy->phyclk) & ~(ID_PULLUP0 | COMMON_ON_N0)),
34815c50:	e5943010 	ldr	r3, [r4, #16]
34815c54:	e5932004 	ldr	r2, [r3, #4]
34815c58:	e3c22014 	bic	r2, r2, #20
34815c5c:	e5943010 	ldr	r3, [r4, #16]
	      &phy->phyclk);

	udelay(10000);
34815c60:	e3020710 	movw	r0, #10000	; 0x2710
	writel(readl(&phy->phypwr) | OTG_DISABLE_0 | ANALOG_PWRDOWN
	       | FORCE_SUSPEND_0, &phy->phypwr);

	writel(readl(usb_phy_ctrl) &~USB_PHY_CTRL_EN0, usb_phy_ctrl);

	writel((readl(&phy->phyclk) & ~(ID_PULLUP0 | COMMON_ON_N0)),
34815c64:	e5832004 	str	r2, [r3, #4]
	      &phy->phyclk);

	udelay(10000);
34815c68:	eb000d13 	bl	348190bc <udelay>

	dev->pdata->phy_control(0);
34815c6c:	e5953028 	ldr	r3, [r5, #40]	; 0x28
34815c70:	e3a00000 	mov	r0, #0
34815c74:	e5933000 	ldr	r3, [r3]
34815c78:	e12fff33 	blx	r3
}
34815c7c:	e8bd8038 	pop	{r3, r4, r5, pc}
34815c80:	3482b310 	.word	0x3482b310

34815c84 <s3c_udc_pre_setup>:
		__func__, readl(&reg->in_endp[EP0_CON].diepctl));
	dev->ep0state = WAIT_FOR_IN_COMPLETE;
}

void s3c_udc_pre_setup(void)
{
34815c84:	e92d4010 	push	{r4, lr}

	debug_cond(DEBUG_IN_EP,
		   "%s : Prepare Setup packets.\n", __func__);

	invalidate_dcache_range((unsigned long) usb_ctrl_dma_addr,
				(unsigned long) usb_ctrl_dma_addr
34815c88:	e59f4034 	ldr	r4, [pc, #52]	; 34815cc4 <s3c_udc_pre_setup+0x40>
34815c8c:	e5940004 	ldr	r0, [r4, #4]
	u32 ep_ctrl;

	debug_cond(DEBUG_IN_EP,
		   "%s : Prepare Setup packets.\n", __func__);

	invalidate_dcache_range((unsigned long) usb_ctrl_dma_addr,
34815c90:	e2801901 	add	r1, r0, #16384	; 0x4000
34815c94:	ebffacc5 	bl	34800fb0 <invalidate_dcache_range>
				(unsigned long) usb_ctrl_dma_addr
				+ DMA_BUFFER_SIZE);

	writel(DOEPT_SIZ_PKT_CNT(1) | sizeof(struct usb_ctrlrequest),
34815c98:	e59f2028 	ldr	r2, [pc, #40]	; 34815cc8 <s3c_udc_pre_setup+0x44>
34815c9c:	e5943000 	ldr	r3, [r4]
34815ca0:	e5832b10 	str	r2, [r3, #2832]	; 0xb10
	       &reg->out_endp[EP0_CON].doeptsiz);
	writel(usb_ctrl_dma_addr, &reg->out_endp[EP0_CON].doepdma);
34815ca4:	e5942004 	ldr	r2, [r4, #4]
34815ca8:	e5943000 	ldr	r3, [r4]
34815cac:	e5832b14 	str	r2, [r3, #2836]	; 0xb14

	ep_ctrl = readl(&reg->out_endp[EP0_CON].doepctl);
34815cb0:	e5932b00 	ldr	r2, [r3, #2816]	; 0xb00
	writel(ep_ctrl|DEPCTL_EPENA, &reg->out_endp[EP0_CON].doepctl);
34815cb4:	e3822102 	orr	r2, r2, #-2147483648	; 0x80000000
34815cb8:	e5943000 	ldr	r3, [r4]
34815cbc:	e5832b00 	str	r2, [r3, #2816]	; 0xb00
	debug_cond(DEBUG_EP0 != 0, "%s:EP0 ZLP DIEPCTL0 = 0x%x\n",
		__func__, readl(&reg->in_endp[EP0_CON].diepctl));
	debug_cond(DEBUG_EP0 != 0, "%s:EP0 ZLP DOEPCTL0 = 0x%x\n",
		__func__, readl(&reg->out_endp[EP0_CON].doepctl));

}
34815cc0:	e8bd8010 	pop	{r4, pc}
34815cc4:	3482b310 	.word	0x3482b310
34815cc8:	00080008 	.word	0x00080008

34815ccc <s3c_udc_ep0_set_stall.clone.3>:
{
	struct s3c_udc *dev;
	u32		ep_ctrl = 0;

	dev = ep->dev;
	ep_ctrl = readl(&reg->in_endp[EP0_CON].diepctl);
34815ccc:	e59f3028 	ldr	r3, [pc, #40]	; 34815cfc <s3c_udc_ep0_set_stall.clone.3+0x30>
34815cd0:	e5933000 	ldr	r3, [r3]
34815cd4:	e5933900 	ldr	r3, [r3, #2304]	; 0x900

	/* set the disable and stall bits */
	if (ep_ctrl & DEPCTL_EPENA)
34815cd8:	e3530000 	cmp	r3, #0
		ep_ctrl |= DEPCTL_EPDIS;
34815cdc:	b3833101 	orrlt	r3, r3, #1073741824	; 0x40000000

	ep_ctrl |= DEPCTL_STALL;
34815ce0:	e3833602 	orr	r3, r3, #2097152	; 0x200000

	writel(ep_ctrl, &reg->in_endp[EP0_CON].diepctl);
34815ce4:	e59f2010 	ldr	r2, [pc, #16]	; 34815cfc <s3c_udc_ep0_set_stall.clone.3+0x30>
34815ce8:	e5922000 	ldr	r2, [r2]
34815cec:	e5823900 	str	r3, [r2, #2304]	; 0x900
		   __func__, ep_index(ep), &reg->in_endp[EP0_CON].diepctl);
	/*
	 * The application can only set this bit, and the core clears it,
	 * when a SETUP token is received for this endpoint
	 */
	dev->ep0state = WAIT_FOR_SETUP;
34815cf0:	e3a03000 	mov	r3, #0
34815cf4:	e5803054 	str	r3, [r0, #84]	; 0x54

	s3c_udc_pre_setup();
34815cf8:	eaffffe1 	b	34815c84 <s3c_udc_pre_setup>
34815cfc:	3482b310 	.word	0x3482b310

34815d00 <setdma_tx>:
	return 0;

}

int setdma_tx(struct s3c_ep *ep, struct s3c_request *req)
{
34815d00:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
	u32 *buf, ctrl = 0;
	u32 length, pktcnt;
	u32 ep_num = ep_index(ep);
	u32 *p = the_controller->dma_buf[ep_index(ep)+1];
34815d04:	e59f211c 	ldr	r2, [pc, #284]	; 34815e28 <setdma_tx+0x128>

int setdma_tx(struct s3c_ep *ep, struct s3c_request *req)
{
	u32 *buf, ctrl = 0;
	u32 length, pktcnt;
	u32 ep_num = ep_index(ep);
34815d08:	e5d06035 	ldrb	r6, [r0, #53]	; 0x35
	u32 *p = the_controller->dma_buf[ep_index(ep)+1];
34815d0c:	e5922008 	ldr	r2, [r2, #8]

int setdma_tx(struct s3c_ep *ep, struct s3c_request *req)
{
	u32 *buf, ctrl = 0;
	u32 length, pktcnt;
	u32 ep_num = ep_index(ep);
34815d10:	e206600f 	and	r6, r6, #15
	return 0;

}

int setdma_tx(struct s3c_ep *ep, struct s3c_request *req)
{
34815d14:	e1a03001 	mov	r3, r1
	u32 *buf, ctrl = 0;
	u32 length, pktcnt;
	u32 ep_num = ep_index(ep);
	u32 *p = the_controller->dma_buf[ep_index(ep)+1];
34815d18:	e0822106 	add	r2, r2, r6, lsl #2
34815d1c:	e5927030 	ldr	r7, [r2, #48]	; 0x30

	buf = req->req.buf + req->req.actual;
	length = req->req.length - req->req.actual;
34815d20:	e5935004 	ldr	r5, [r3, #4]
	u32 *buf, ctrl = 0;
	u32 length, pktcnt;
	u32 ep_num = ep_index(ep);
	u32 *p = the_controller->dma_buf[ep_index(ep)+1];

	buf = req->req.buf + req->req.actual;
34815d24:	e5912024 	ldr	r2, [r1, #36]	; 0x24
34815d28:	e5911000 	ldr	r1, [r1]
	length = req->req.length - req->req.actual;

	if (ep_num == EP0_CON)
34815d2c:	e3560000 	cmp	r6, #0
	return 0;

}

int setdma_tx(struct s3c_ep *ep, struct s3c_request *req)
{
34815d30:	e1a04000 	mov	r4, r0
	u32 *buf, ctrl = 0;
	u32 length, pktcnt;
	u32 ep_num = ep_index(ep);
	u32 *p = the_controller->dma_buf[ep_index(ep)+1];

	buf = req->req.buf + req->req.actual;
34815d34:	e0811002 	add	r1, r1, r2
	length = req->req.length - req->req.actual;
34815d38:	e0625005 	rsb	r5, r2, r5

	if (ep_num == EP0_CON)
34815d3c:	1a000002 	bne	34815d4c <setdma_tx+0x4c>
		length = min(length, (u32)ep_maxpacket(ep));
34815d40:	e1d031b4 	ldrh	r3, [r0, #20]
34815d44:	e1550003 	cmp	r5, r3
34815d48:	21a05003 	movcs	r5, r3

	ep->len = length;
	ep->dma_buf = buf;
34815d4c:	e5841030 	str	r1, [r4, #48]	; 0x30
	memcpy(p, ep->dma_buf, length);
34815d50:	e1a02005 	mov	r2, r5
	length = req->req.length - req->req.actual;

	if (ep_num == EP0_CON)
		length = min(length, (u32)ep_maxpacket(ep));

	ep->len = length;
34815d54:	e584502c 	str	r5, [r4, #44]	; 0x2c
	ep->dma_buf = buf;
	memcpy(p, ep->dma_buf, length);
34815d58:	e1a00007 	mov	r0, r7
34815d5c:	eb000c4b 	bl	34818e90 <memcpy>

	flush_dcache_range((unsigned long) p ,
34815d60:	e1a00007 	mov	r0, r7
34815d64:	e2871901 	add	r1, r7, #16384	; 0x4000
34815d68:	ebffac99 	bl	34800fd4 <flush_dcache_range>
			   (unsigned long) p + DMA_BUFFER_SIZE);

	if (length == 0)
34815d6c:	e3550000 	cmp	r5, #0
		pktcnt = 1;
34815d70:	03a00001 	moveq	r0, #1
	memcpy(p, ep->dma_buf, length);

	flush_dcache_range((unsigned long) p ,
			   (unsigned long) p + DMA_BUFFER_SIZE);

	if (length == 0)
34815d74:	0a000003 	beq	34815d88 <setdma_tx+0x88>
		pktcnt = 1;
	else
		pktcnt = (length - 1)/(ep->ep.maxpacket) + 1;
34815d78:	e2450001 	sub	r0, r5, #1
34815d7c:	e1d411b4 	ldrh	r1, [r4, #20]
34815d80:	eb002847 	bl	3481fea4 <__udivsi3>
34815d84:	e2800001 	add	r0, r0, #1

	/* Flush the endpoint's Tx FIFO */
	writel(TX_FIFO_NUMBER(ep->fifo_num), &reg->grstctl);
34815d88:	e594103c 	ldr	r1, [r4, #60]	; 0x3c
34815d8c:	e1a01301 	lsl	r1, r1, #6
34815d90:	e59f3090 	ldr	r3, [pc, #144]	; 34815e28 <setdma_tx+0x128>
34815d94:	e5932000 	ldr	r2, [r3]
34815d98:	e5821010 	str	r1, [r2, #16]
	writel(TX_FIFO_NUMBER(ep->fifo_num) | TX_FIFO_FLUSH, &reg->grstctl);
34815d9c:	e594103c 	ldr	r1, [r4, #60]	; 0x3c
34815da0:	e1a01301 	lsl	r1, r1, #6
34815da4:	e3811020 	orr	r1, r1, #32
34815da8:	e5932000 	ldr	r2, [r3]
34815dac:	e5821010 	str	r1, [r2, #16]
	while (readl(&reg->grstctl) & TX_FIFO_FLUSH)
34815db0:	e1a02003 	mov	r2, r3
34815db4:	e5921000 	ldr	r1, [r2]
34815db8:	e59f3068 	ldr	r3, [pc, #104]	; 34815e28 <setdma_tx+0x128>
34815dbc:	e5911010 	ldr	r1, [r1, #16]
34815dc0:	e3110020 	tst	r1, #32
34815dc4:	1afffffa 	bne	34815db4 <setdma_tx+0xb4>
		;

	writel(the_controller->dma_addr[ep_index(ep)+1],
34815dc8:	e5d41035 	ldrb	r1, [r4, #53]	; 0x35
34815dcc:	e5932008 	ldr	r2, [r3, #8]
34815dd0:	e201100f 	and	r1, r1, #15
34815dd4:	e2811011 	add	r1, r1, #17
34815dd8:	e792c101 	ldr	ip, [r2, r1, lsl #2]
34815ddc:	e5932000 	ldr	r2, [r3]
34815de0:	e1a01286 	lsl	r1, r6, #5
34815de4:	e2811e91 	add	r1, r1, #2320	; 0x910
34815de8:	e0822001 	add	r2, r2, r1
34815dec:	e582c004 	str	ip, [r2, #4]
	       &reg->in_endp[ep_num].diepdma);
	writel(DIEPT_SIZ_PKT_CNT(pktcnt) | DIEPT_SIZ_XFER_SIZE(length),
34815df0:	e1850980 	orr	r0, r5, r0, lsl #19
34815df4:	e5932000 	ldr	r2, [r3]
	       &reg->in_endp[ep_num].dieptsiz);

	ctrl = readl(&reg->in_endp[ep_num].diepctl);
34815df8:	e2866048 	add	r6, r6, #72	; 0x48
	while (readl(&reg->grstctl) & TX_FIFO_FLUSH)
		;

	writel(the_controller->dma_addr[ep_index(ep)+1],
	       &reg->in_endp[ep_num].diepdma);
	writel(DIEPT_SIZ_PKT_CNT(pktcnt) | DIEPT_SIZ_XFER_SIZE(length),
34815dfc:	e7820001 	str	r0, [r2, r1]
	       &reg->in_endp[ep_num].dieptsiz);

	ctrl = readl(&reg->in_endp[ep_num].diepctl);
34815e00:	e7922286 	ldr	r2, [r2, r6, lsl #5]

	/* Write the FIFO number to be used for this endpoint */
	ctrl &= DIEPCTL_TX_FIFO_NUM_MASK;
	ctrl |= DIEPCTL_TX_FIFO_NUM(ep->fifo_num);
34815e04:	e594103c 	ldr	r1, [r4, #60]	; 0x3c
	       &reg->in_endp[ep_num].dieptsiz);

	ctrl = readl(&reg->in_endp[ep_num].diepctl);

	/* Write the FIFO number to be used for this endpoint */
	ctrl &= DIEPCTL_TX_FIFO_NUM_MASK;
34815e08:	e3c2250f 	bic	r2, r2, #62914560	; 0x3c00000
	ctrl |= DIEPCTL_TX_FIFO_NUM(ep->fifo_num);
34815e0c:	e1822b01 	orr	r2, r2, r1, lsl #22

	/* Clear reserved (Next EP) bits */
	ctrl = (ctrl&~(EP_MASK<<DEPCTL_NEXT_EP_BIT));
34815e10:	e3c22b1e 	bic	r2, r2, #30720	; 0x7800

	writel(DEPCTL_EPENA|DEPCTL_CNAK|ctrl, &reg->in_endp[ep_num].diepctl);
34815e14:	e3822321 	orr	r2, r2, #-2080374784	; 0x84000000
34815e18:	e5933000 	ldr	r3, [r3]
		readl(&reg->in_endp[ep_num].dieptsiz),
		readl(&reg->in_endp[ep_num].diepctl),
		buf, pktcnt, length);

	return length;
}
34815e1c:	e1a00005 	mov	r0, r5
	ctrl |= DIEPCTL_TX_FIFO_NUM(ep->fifo_num);

	/* Clear reserved (Next EP) bits */
	ctrl = (ctrl&~(EP_MASK<<DEPCTL_NEXT_EP_BIT));

	writel(DEPCTL_EPENA|DEPCTL_CNAK|ctrl, &reg->in_endp[ep_num].diepctl);
34815e20:	e7832286 	str	r2, [r3, r6, lsl #5]
		readl(&reg->in_endp[ep_num].dieptsiz),
		readl(&reg->in_endp[ep_num].diepctl),
		buf, pktcnt, length);

	return length;
}
34815e24:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
34815e28:	3482b310 	.word	0x3482b310

34815e2c <write_fifo_ep0>:
/* End Point 0 related functions                                */
/****************************************************************/

/* return:  0 = still running, 1 = completed, negative = errno */
static int write_fifo_ep0(struct s3c_ep *ep, struct s3c_request *req)
{
34815e2c:	e92d4070 	push	{r4, r5, r6, lr}
	u32 max;
	unsigned count;
	int is_last;

	max = ep_maxpacket(ep);
34815e30:	e1d061b4 	ldrh	r6, [r0, #20]
/* End Point 0 related functions                                */
/****************************************************************/

/* return:  0 = still running, 1 = completed, negative = errno */
static int write_fifo_ep0(struct s3c_ep *ep, struct s3c_request *req)
{
34815e34:	e1a05000 	mov	r5, r0
34815e38:	e1a04001 	mov	r4, r1

	max = ep_maxpacket(ep);

	debug_cond(DEBUG_EP0 != 0, "%s: max = %d\n", __func__, max);

	count = setdma_tx(ep, req);
34815e3c:	ebffffaf 	bl	34815d00 <setdma_tx>

	/* last packet is usually short (or a zlp) */
	if (likely(count != max))
34815e40:	e1500006 	cmp	r0, r6
34815e44:	1a00000d 	bne	34815e80 <write_fifo_ep0+0x54>
		is_last = 1;
	else {
		if (likely(req->req.length != req->req.actual + count)
34815e48:	e5943024 	ldr	r3, [r4, #36]	; 0x24
34815e4c:	e0800003 	add	r0, r0, r3
34815e50:	e5943004 	ldr	r3, [r4, #4]
34815e54:	e1530000 	cmp	r3, r0
34815e58:	1a000006 	bne	34815e78 <write_fifo_ep0+0x4c>
		    || req->req.zero)
34815e5c:	e5d4300c 	ldrb	r3, [r4, #12]
34815e60:	e2033002 	and	r3, r3, #2
34815e64:	e6ef3073 	uxtb	r3, r3
34815e68:	e3530000 	cmp	r3, #0
	if (is_last) {
		ep->dev->ep0state = WAIT_FOR_SETUP;
		return 1;
	}

	return 0;
34815e6c:	13a00000 	movne	r0, #0
	/* last packet is usually short (or a zlp) */
	if (likely(count != max))
		is_last = 1;
	else {
		if (likely(req->req.length != req->req.actual + count)
		    || req->req.zero)
34815e70:	18bd8070 	popne	{r4, r5, r6, pc}
34815e74:	ea000001 	b	34815e80 <write_fifo_ep0+0x54>
	if (is_last) {
		ep->dev->ep0state = WAIT_FOR_SETUP;
		return 1;
	}

	return 0;
34815e78:	e3a00000 	mov	r0, #0
}
34815e7c:	e8bd8070 	pop	{r4, r5, r6, pc}
		   is_last ? "/L" : "",
		   req->req.length - req->req.actual - count, req);

	/* requests complete when all IN data is in the FIFO */
	if (is_last) {
		ep->dev->ep0state = WAIT_FOR_SETUP;
34815e80:	e5953018 	ldr	r3, [r5, #24]
34815e84:	e3a02000 	mov	r2, #0
34815e88:	e5832054 	str	r2, [r3, #84]	; 0x54
		return 1;
34815e8c:	e3a00001 	mov	r0, #1
34815e90:	e8bd8070 	pop	{r4, r5, r6, pc}

34815e94 <s3c_queue>:
/** Queue one request
 *  Kickstart transfer if needed
 */
static int s3c_queue(struct usb_ep *_ep, struct usb_request *_req,
			 gfp_t gfp_flags)
{
34815e94:	e92d46f8 	push	{r3, r4, r5, r6, r7, r9, sl, lr}
	struct s3c_udc *dev;
	unsigned long flags;
	u32 ep_num, gintsts;

	req = container_of(_req, struct s3c_request, req);
	if (unlikely(!_req || !_req->complete || !_req->buf
34815e98:	e2516000 	subs	r6, r1, #0
/** Queue one request
 *  Kickstart transfer if needed
 */
static int s3c_queue(struct usb_ep *_ep, struct usb_request *_req,
			 gfp_t gfp_flags)
{
34815e9c:	e1a04000 	mov	r4, r0
	struct s3c_udc *dev;
	unsigned long flags;
	u32 ep_num, gintsts;

	req = container_of(_req, struct s3c_request, req);
	if (unlikely(!_req || !_req->complete || !_req->buf
34815ea0:	0a00006a 	beq	34816050 <s3c_queue+0x1bc>
34815ea4:	e5963010 	ldr	r3, [r6, #16]
34815ea8:	e3530000 	cmp	r3, #0
34815eac:	1a00006c 	bne	34816064 <s3c_queue+0x1d0>
34815eb0:	ea000066 	b	34816050 <s3c_queue+0x1bc>
		return -EINVAL;
	}

	ep = container_of(_ep, struct s3c_ep, ep);

	if (unlikely(!_ep || (!ep->desc && ep->ep.name != ep0name))) {
34815eb4:	e3540000 	cmp	r4, #0
34815eb8:	0a000064 	beq	34816050 <s3c_queue+0x1bc>
34815ebc:	e594301c 	ldr	r3, [r4, #28]
34815ec0:	e3530000 	cmp	r3, #0
34815ec4:	1a00006e 	bne	34816084 <s3c_queue+0x1f0>
34815ec8:	e5942004 	ldr	r2, [r4, #4]
34815ecc:	e59f31c8 	ldr	r3, [pc, #456]	; 3481609c <s3c_queue+0x208>
34815ed0:	e1520003 	cmp	r2, r3
34815ed4:	0a00006a 	beq	34816084 <s3c_queue+0x1f0>
34815ed8:	ea00005c 	b	34816050 <s3c_queue+0x1bc>
		return -EINVAL;
	}

	ep_num = ep_index(ep);
	dev = ep->dev;
	if (unlikely(!dev->driver || dev->gadget.speed == USB_SPEED_UNKNOWN)) {
34815edc:	e5953010 	ldr	r3, [r5, #16]
34815ee0:	e3530000 	cmp	r3, #0
34815ee4:	0a00005b 	beq	34816058 <s3c_queue+0x1c4>
34815ee8:	e5942020 	ldr	r2, [r4, #32]
		return -ESHUTDOWN;
	}

	spin_lock_irqsave(&dev->lock, flags);

	_req->status = -EINPROGRESS;
34815eec:	e3e03072 	mvn	r3, #114	; 0x72
		}
		printf("\n");
	}
#endif

	if (list_empty(&ep->queue) && !ep->stopped) {
34815ef0:	e2849020 	add	r9, r4, #32
		return -ESHUTDOWN;
	}

	spin_lock_irqsave(&dev->lock, flags);

	_req->status = -EINPROGRESS;
34815ef4:	e5863020 	str	r3, [r6, #32]
		}
		printf("\n");
	}
#endif

	if (list_empty(&ep->queue) && !ep->stopped) {
34815ef8:	e1520009 	cmp	r2, r9
	}

	spin_lock_irqsave(&dev->lock, flags);

	_req->status = -EINPROGRESS;
	_req->actual = 0;
34815efc:	e2833073 	add	r3, r3, #115	; 0x73
34815f00:	e5863024 	str	r3, [r6, #36]	; 0x24
		}
		printf("\n");
	}
#endif

	if (list_empty(&ep->queue) && !ep->stopped) {
34815f04:	1a000048 	bne	3481602c <s3c_queue+0x198>
34815f08:	e5d43034 	ldrb	r3, [r4, #52]	; 0x34
34815f0c:	e3530000 	cmp	r3, #0
34815f10:	1a000045 	bne	3481602c <s3c_queue+0x198>

		if (ep_num == 0) {
34815f14:	e21aa00f 	ands	sl, sl, #15
34815f18:	1a000039 	bne	34816004 <s3c_queue+0x170>
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
34815f1c:	e5943024 	ldr	r3, [r4, #36]	; 0x24
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
	new->next = next;
34815f20:	e5862028 	str	r2, [r6, #40]	; 0x28
 */
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
34815f24:	e5847024 	str	r7, [r4, #36]	; 0x24
	new->next = next;
	new->prev = prev;
	prev->next = new;
34815f28:	e5837000 	str	r7, [r3]
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
	new->next = next;
	new->prev = prev;
34815f2c:	e586302c 	str	r3, [r6, #44]	; 0x2c

static void s3c_ep0_kick(struct s3c_udc *dev, struct s3c_ep *ep)
{
	debug_cond(DEBUG_EP0 != 0,
		   "%s: ep_is_in = %d\n", __func__, ep_is_in(ep));
	if (ep_is_in(ep)) {
34815f30:	e1d433d5 	ldrsb	r3, [r4, #53]	; 0x35
34815f34:	e1a02005 	mov	r2, r5
34815f38:	e3530000 	cmp	r3, #0
34815f3c:	e5b23078 	ldr	r3, [r2, #120]!	; 0x78
34815f40:	aa000017 	bge	34815fa4 <s3c_queue+0x110>
		dev->ep0state = DATA_STATE_XMIT;
34815f44:	e3a04001 	mov	r4, #1
{
	struct s3c_request *req;
	struct s3c_ep *ep = &dev->ep[0];
	int ret, need_zlp = 0;

	if (list_empty(&ep->queue))
34815f48:	e1530002 	cmp	r3, r2
static void s3c_ep0_kick(struct s3c_udc *dev, struct s3c_ep *ep)
{
	debug_cond(DEBUG_EP0 != 0,
		   "%s: ep_is_in = %d\n", __func__, ep_is_in(ep));
	if (ep_is_in(ep)) {
		dev->ep0state = DATA_STATE_XMIT;
34815f4c:	e5854054 	str	r4, [r5, #84]	; 0x54
{
	struct s3c_request *req;
	struct s3c_ep *ep = &dev->ep[0];
	int ret, need_zlp = 0;

	if (list_empty(&ep->queue))
34815f50:	0a000041 	beq	3481605c <s3c_queue+0x1c8>
		req = 0;
	else
		req = list_entry(ep->queue.next, struct s3c_request, queue);

	if (!req) {
34815f54:	e2531028 	subs	r1, r3, #40	; 0x28
34815f58:	0a00003a 	beq	34816048 <s3c_queue+0x1b4>

	debug_cond(DEBUG_EP0 != 0,
		   "%s: req = %p, req.length = 0x%x, req.actual = 0x%x\n",
		   __func__, req, req->req.length, req->req.actual);

	if (req->req.length - req->req.actual == ep0_fifo_size) {
34815f5c:	e5137024 	ldr	r7, [r3, #-36]	; 0x24
34815f60:	e5133004 	ldr	r3, [r3, #-4]
		/* Next write will end with the packet size, */
		/* so we need Zero-length-packet */
		need_zlp = 1;
	}

	ret = write_fifo_ep0(ep, req);
34815f64:	e2850058 	add	r0, r5, #88	; 0x58

	debug_cond(DEBUG_EP0 != 0,
		   "%s: req = %p, req.length = 0x%x, req.actual = 0x%x\n",
		   __func__, req, req->req.length, req->req.actual);

	if (req->req.length - req->req.actual == ep0_fifo_size) {
34815f68:	e0637007 	rsb	r7, r3, r7
34815f6c:	e59f312c 	ldr	r3, [pc, #300]	; 348160a0 <s3c_queue+0x20c>
34815f70:	e5936000 	ldr	r6, [r3]
		/* Next write will end with the packet size, */
		/* so we need Zero-length-packet */
		need_zlp = 1;
	}

	ret = write_fifo_ep0(ep, req);
34815f74:	ebffffac 	bl	34815e2c <write_fifo_ep0>

	if ((ret == 1) && !need_zlp) {
34815f78:	e1500004 	cmp	r0, r4
34815f7c:	13a01000 	movne	r1, #0
34815f80:	03a01001 	moveq	r1, #1
34815f84:	e1570006 	cmp	r7, r6
34815f88:	03a01000 	moveq	r1, #0
34815f8c:	e3510000 	cmp	r1, #0
		/* Last packet */
		dev->ep0state = WAIT_FOR_COMPLETE;
34815f90:	13a03005 	movne	r3, #5
34815f94:	15853054 	strne	r3, [r5, #84]	; 0x54
		debug_cond(DEBUG_EP0 != 0,
			   "%s: finished, waiting for status\n", __func__);

	} else {
		dev->ep0state = DATA_STATE_XMIT;
34815f98:	05854054 	streq	r4, [r5, #84]	; 0x54
		need_zlp = 1;
	}

	ret = write_fifo_ep0(ep, req);

	if ((ret == 1) && !need_zlp) {
34815f9c:	0a000029 	beq	34816048 <s3c_queue+0x1b4>
34815fa0:	ea00002d 	b	3481605c <s3c_queue+0x1c8>
	if (ep_is_in(ep)) {
		dev->ep0state = DATA_STATE_XMIT;
		s3c_ep0_write(dev);

	} else {
		dev->ep0state = DATA_STATE_RECV;
34815fa4:	e3a01004 	mov	r1, #4
static void s3c_ep0_read(struct s3c_udc *dev)
{
	struct s3c_request *req;
	struct s3c_ep *ep = &dev->ep[0];

	if (!list_empty(&ep->queue)) {
34815fa8:	e1530002 	cmp	r3, r2
	if (ep_is_in(ep)) {
		dev->ep0state = DATA_STATE_XMIT;
		s3c_ep0_write(dev);

	} else {
		dev->ep0state = DATA_STATE_RECV;
34815fac:	e5851054 	str	r1, [r5, #84]	; 0x54
static void s3c_ep0_read(struct s3c_udc *dev)
{
	struct s3c_request *req;
	struct s3c_ep *ep = &dev->ep[0];

	if (!list_empty(&ep->queue)) {
34815fb0:	0a000004 	beq	34815fc8 <s3c_queue+0x134>

	debug_cond(DEBUG_EP0 != 0,
		   "%s: req = %p, req.length = 0x%x, req.actual = 0x%x\n",
		   __func__, req, req->req.length, req->req.actual);

	if (req->req.length == 0) {
34815fb4:	e5134024 	ldr	r4, [r3, #-36]	; 0x24
{
	struct s3c_request *req;
	struct s3c_ep *ep = &dev->ep[0];

	if (!list_empty(&ep->queue)) {
		req = list_entry(ep->queue.next, struct s3c_request, queue);
34815fb8:	e2431028 	sub	r1, r3, #40	; 0x28

	debug_cond(DEBUG_EP0 != 0,
		   "%s: req = %p, req.length = 0x%x, req.actual = 0x%x\n",
		   __func__, req, req->req.length, req->req.actual);

	if (req->req.length == 0) {
34815fbc:	e3540000 	cmp	r4, #0
34815fc0:	1a00000c 	bne	34815ff8 <s3c_queue+0x164>
34815fc4:	ea000006 	b	34815fe4 <s3c_queue+0x150>
	if (!list_empty(&ep->queue)) {
		req = list_entry(ep->queue.next, struct s3c_request, queue);

	} else {
		debug("%s: ---> BUG\n", __func__);
		BUG();
34815fc8:	e59f00d4 	ldr	r0, [pc, #212]	; 348160a4 <s3c_queue+0x210>
34815fcc:	e59f10d4 	ldr	r1, [pc, #212]	; 348160a8 <s3c_queue+0x214>
34815fd0:	e3002332 	movw	r2, #818	; 0x332
34815fd4:	e59f30d0 	ldr	r3, [pc, #208]	; 348160ac <s3c_queue+0x218>
34815fd8:	ebffcbdb 	bl	34808f4c <printf>
34815fdc:	e59f00cc 	ldr	r0, [pc, #204]	; 348160b0 <s3c_queue+0x21c>
34815fe0:	eb000fb3 	bl	34819eb4 <panic>

	if (req->req.length == 0) {
		/* zlp for Set_configuration, Set_interface,
		 * or Bulk-Only mass storge reset */

		ep->len = 0;
34815fe4:	e5854084 	str	r4, [r5, #132]	; 0x84
		s3c_udc_ep0_zlp(dev);
34815fe8:	e2850054 	add	r0, r5, #84	; 0x54
34815fec:	ebfffe4e 	bl	3481592c <s3c_udc_ep0_zlp.clone.2>
	if (likely(req != 0))
		list_add_tail(&req->queue, &ep->queue);

	spin_unlock_irqrestore(&dev->lock, flags);

	return 0;
34815ff0:	e1a0a004 	mov	sl, r4
34815ff4:	ea000018 	b	3481605c <s3c_queue+0x1c8>
			   "%s: req.length = 0, bRequest = %d\n",
			   __func__, usb_ctrl->bRequest);
		return;
	}

	setdma_rx(ep, req);
34815ff8:	e2850058 	add	r0, r5, #88	; 0x58
34815ffc:	ebfffe03 	bl	34815810 <setdma_rx>
34816000:	ea000015 	b	3481605c <s3c_queue+0x1c8>
			/* EP0 */
			list_add_tail(&req->queue, &ep->queue);
			s3c_ep0_kick(dev, ep);
			req = 0;

		} else if (ep_is_in(ep)) {
34816004:	e1d433d5 	ldrsb	r3, [r4, #53]	; 0x35
34816008:	e3530000 	cmp	r3, #0
3481600c:	aa000003 	bge	34816020 <s3c_queue+0x18c>
			gintsts = readl(&reg->gintsts);
			debug_cond(DEBUG_IN_EP,
				   "%s: ep_is_in, S3C_UDC_OTG_GINTSTS=0x%x\n",
				   __func__, gintsts);

			setdma_tx(ep, req);
34816010:	e1a00004 	mov	r0, r4
34816014:	e1a01006 	mov	r1, r6
34816018:	ebffff38 	bl	34815d00 <setdma_tx>
3481601c:	ea000002 	b	3481602c <s3c_queue+0x198>
			gintsts = readl(&reg->gintsts);
			debug_cond(DEBUG_OUT_EP != 0,
				   "%s:ep_is_out, S3C_UDC_OTG_GINTSTS=0x%x\n",
				   __func__, gintsts);

			setdma_rx(ep, req);
34816020:	e1a00004 	mov	r0, r4
34816024:	e1a01006 	mov	r1, r6
34816028:	ebfffdf8 	bl	34815810 <setdma_rx>
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
3481602c:	e5943024 	ldr	r3, [r4, #36]	; 0x24
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
	new->next = next;
34816030:	e5869028 	str	r9, [r6, #40]	; 0x28
 */
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
34816034:	e5847024 	str	r7, [r4, #36]	; 0x24
	new->next = next;
	new->prev = prev;
	prev->next = new;
34816038:	e5837000 	str	r7, [r3]
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
	new->next = next;
	new->prev = prev;
3481603c:	e586302c 	str	r3, [r6, #44]	; 0x2c
	if (likely(req != 0))
		list_add_tail(&req->queue, &ep->queue);

	spin_unlock_irqrestore(&dev->lock, flags);

	return 0;
34816040:	e3a0a000 	mov	sl, #0
34816044:	ea000004 	b	3481605c <s3c_queue+0x1c8>
34816048:	e1a0a001 	mov	sl, r1
3481604c:	ea000002 	b	3481605c <s3c_queue+0x1c8>
	req = container_of(_req, struct s3c_request, req);
	if (unlikely(!_req || !_req->complete || !_req->buf
		     || !list_empty(&req->queue))) {

		debug("%s: bad params\n", __func__);
		return -EINVAL;
34816050:	e3e0a015 	mvn	sl, #21
34816054:	ea000000 	b	3481605c <s3c_queue+0x1c8>
	ep_num = ep_index(ep);
	dev = ep->dev;
	if (unlikely(!dev->driver || dev->gadget.speed == USB_SPEED_UNKNOWN)) {

		debug("%s: bogus device state %p\n", __func__, dev->driver);
		return -ESHUTDOWN;
34816058:	e3e0a06b 	mvn	sl, #107	; 0x6b
		list_add_tail(&req->queue, &ep->queue);

	spin_unlock_irqrestore(&dev->lock, flags);

	return 0;
}
3481605c:	e1a0000a 	mov	r0, sl
34816060:	e8bd86f8 	pop	{r3, r4, r5, r6, r7, r9, sl, pc}
	struct s3c_udc *dev;
	unsigned long flags;
	u32 ep_num, gintsts;

	req = container_of(_req, struct s3c_request, req);
	if (unlikely(!_req || !_req->complete || !_req->buf
34816064:	e5963000 	ldr	r3, [r6]
34816068:	e3530000 	cmp	r3, #0
3481606c:	0afffff7 	beq	34816050 <s3c_queue+0x1bc>
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
34816070:	e1a03006 	mov	r3, r6
34816074:	e5b37028 	ldr	r7, [r3, #40]!	; 0x28
34816078:	e1570003 	cmp	r7, r3
3481607c:	0affff8c 	beq	34815eb4 <s3c_queue+0x20>
34816080:	eafffff2 	b	34816050 <s3c_queue+0x1bc>
		      ep->ep.name, !ep->desc, _ep);
		return -EINVAL;
	}

	ep_num = ep_index(ep);
	dev = ep->dev;
34816084:	e5945018 	ldr	r5, [r4, #24]
		debug("%s: bad ep: %s, %d, %p\n", __func__,
		      ep->ep.name, !ep->desc, _ep);
		return -EINVAL;
	}

	ep_num = ep_index(ep);
34816088:	e5d4a035 	ldrb	sl, [r4, #53]	; 0x35
	dev = ep->dev;
	if (unlikely(!dev->driver || dev->gadget.speed == USB_SPEED_UNKNOWN)) {
3481608c:	e5953024 	ldr	r3, [r5, #36]	; 0x24
34816090:	e3530000 	cmp	r3, #0
34816094:	1affff90 	bne	34815edc <s3c_queue+0x48>
34816098:	eaffffee 	b	34816058 <s3c_queue+0x1c4>
3481609c:	34821894 	.word	0x34821894
348160a0:	34828a10 	.word	0x34828a10
348160a4:	3482729e 	.word	0x3482729e
348160a8:	3482767c 	.word	0x3482767c
348160ac:	348218a0 	.word	0x348218a0
348160b0:	348272c5 	.word	0x348272c5

348160b4 <s3c_fifo_read>:

	return 0;
}

int s3c_fifo_read(struct s3c_ep *ep, u32 *cp, int max)
{
348160b4:	e92d4008 	push	{r3, lr}
	u32 bytes;

	bytes = sizeof(struct usb_ctrlrequest);

	invalidate_dcache_range((unsigned long) ep->dev->dma_buf[ep_index(ep)],
				(unsigned long) ep->dev->dma_buf[ep_index(ep)]
348160b8:	e5d03035 	ldrb	r3, [r0, #53]	; 0x35
348160bc:	e5902018 	ldr	r2, [r0, #24]
348160c0:	e203300f 	and	r3, r3, #15
348160c4:	e0823103 	add	r3, r2, r3, lsl #2
348160c8:	e593002c 	ldr	r0, [r3, #44]	; 0x2c
{
	u32 bytes;

	bytes = sizeof(struct usb_ctrlrequest);

	invalidate_dcache_range((unsigned long) ep->dev->dma_buf[ep_index(ep)],
348160cc:	e2801901 	add	r1, r0, #16384	; 0x4000
348160d0:	ebffabb6 	bl	34800fb0 <invalidate_dcache_range>
	debug_cond(DEBUG_EP0 != 0,
		   "%s: bytes=%d, ep_index=%d %p\n", __func__,
		   bytes, ep_index(ep), ep->dev->dma_buf[ep_index(ep)]);

	return bytes;
}
348160d4:	e3a00008 	mov	r0, #8
348160d8:	e8bd8008 	pop	{r3, pc}

348160dc <s3c_udc_get_status>:

u16	g_status;

int s3c_udc_get_status(struct s3c_udc *dev,
		struct usb_ctrlrequest *crq)
{
348160dc:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
	u8 ep_num = crq->wIndex & 0x7F;
	u32 ep_ctrl;
	u32 *p = the_controller->dma_buf[1];
348160e0:	e59f70e8 	ldr	r7, [pc, #232]	; 348161d0 <s3c_udc_get_status+0xf4>
u16	g_status;

int s3c_udc_get_status(struct s3c_udc *dev,
		struct usb_ctrlrequest *crq)
{
	u8 ep_num = crq->wIndex & 0x7F;
348160e4:	e5d13004 	ldrb	r3, [r1, #4]
348160e8:	e5d1a005 	ldrb	sl, [r1, #5]

u16	g_status;

int s3c_udc_get_status(struct s3c_udc *dev,
		struct usb_ctrlrequest *crq)
{
348160ec:	e1a04001 	mov	r4, r1
	u32 ep_ctrl;
	u32 *p = the_controller->dma_buf[1];

	debug_cond(DEBUG_SETUP != 0,
		   "%s: *** USB_REQ_GET_STATUS\n", __func__);
	printf("crq->brequest:0x%x\n", crq->bRequestType & USB_RECIP_MASK);
348160f0:	e5d11000 	ldrb	r1, [r1]
u16	g_status;

int s3c_udc_get_status(struct s3c_udc *dev,
		struct usb_ctrlrequest *crq)
{
	u8 ep_num = crq->wIndex & 0x7F;
348160f4:	e183a40a 	orr	sl, r3, sl, lsl #8
	u32 ep_ctrl;
	u32 *p = the_controller->dma_buf[1];
348160f8:	e5973008 	ldr	r3, [r7, #8]

u16	g_status;

int s3c_udc_get_status(struct s3c_udc *dev,
		struct usb_ctrlrequest *crq)
{
348160fc:	e1a05000 	mov	r5, r0
	u32 ep_ctrl;
	u32 *p = the_controller->dma_buf[1];

	debug_cond(DEBUG_SETUP != 0,
		   "%s: *** USB_REQ_GET_STATUS\n", __func__);
	printf("crq->brequest:0x%x\n", crq->bRequestType & USB_RECIP_MASK);
34816100:	e201101f 	and	r1, r1, #31
34816104:	e59f00c8 	ldr	r0, [pc, #200]	; 348161d4 <s3c_udc_get_status+0xf8>
int s3c_udc_get_status(struct s3c_udc *dev,
		struct usb_ctrlrequest *crq)
{
	u8 ep_num = crq->wIndex & 0x7F;
	u32 ep_ctrl;
	u32 *p = the_controller->dma_buf[1];
34816108:	e5936030 	ldr	r6, [r3, #48]	; 0x30

	debug_cond(DEBUG_SETUP != 0,
		   "%s: *** USB_REQ_GET_STATUS\n", __func__);
	printf("crq->brequest:0x%x\n", crq->bRequestType & USB_RECIP_MASK);
3481610c:	ebffcb8e 	bl	34808f4c <printf>
	switch (crq->bRequestType & USB_RECIP_MASK) {
34816110:	e5d43000 	ldrb	r3, [r4]
34816114:	e203301f 	and	r3, r3, #31
34816118:	e3530001 	cmp	r3, #1
3481611c:	0a000005 	beq	34816138 <s3c_udc_get_status+0x5c>
34816120:	e3530002 	cmp	r3, #2
34816124:	0a000005 	beq	34816140 <s3c_udc_get_status+0x64>
34816128:	e3530000 	cmp	r3, #0
			   "\tGET_STATUS:USB_RECIP_INTERFACE, g_stauts = %d\n",
			   g_status);
		break;

	case USB_RECIP_DEVICE:
		g_status = 0x1; /* Self powered */
3481612c:	03a03001 	moveq	r3, #1
	u32 *p = the_controller->dma_buf[1];

	debug_cond(DEBUG_SETUP != 0,
		   "%s: *** USB_REQ_GET_STATUS\n", __func__);
	printf("crq->brequest:0x%x\n", crq->bRequestType & USB_RECIP_MASK);
	switch (crq->bRequestType & USB_RECIP_MASK) {
34816130:	0a00000a 	beq	34816160 <s3c_udc_get_status+0x84>
34816134:	ea000021 	b	348161c0 <s3c_udc_get_status+0xe4>
	case USB_RECIP_INTERFACE:
		g_status = 0;
34816138:	e3a03000 	mov	r3, #0
3481613c:	ea000007 	b	34816160 <s3c_udc_get_status+0x84>
			   "\tGET_STATUS: USB_RECIP_DEVICE, g_stauts = %d\n",
			   g_status);
		break;

	case USB_RECIP_ENDPOINT:
		if (crq->wLength > 2) {
34816140:	e5d43006 	ldrb	r3, [r4, #6]
34816144:	e5d42007 	ldrb	r2, [r4, #7]
34816148:	e1833402 	orr	r3, r3, r2, lsl #8
3481614c:	e3530002 	cmp	r3, #2
34816150:	8a00001c 	bhi	348161c8 <s3c_udc_get_status+0xec>
			debug_cond(DEBUG_SETUP != 0,
				   "\tGET_STATUS:Not support EP or wLength\n");
			return 1;
		}

		g_status = dev->ep[ep_num].stopped;
34816154:	e20aa07f 	and	sl, sl, #127	; 0x7f
34816158:	e085a30a 	add	sl, r5, sl, lsl #6
3481615c:	e5da308c 	ldrb	r3, [sl, #140]	; 0x8c

	default:
		return 1;
	}

	memcpy(p, &g_status, sizeof(g_status));
34816160:	e59f4068 	ldr	r4, [pc, #104]	; 348161d0 <s3c_udc_get_status+0xf4>
34816164:	e3a02002 	mov	r2, #2
34816168:	e2841014 	add	r1, r4, #20
3481616c:	e1a00006 	mov	r0, r6
			debug_cond(DEBUG_SETUP != 0,
				   "\tGET_STATUS:Not support EP or wLength\n");
			return 1;
		}

		g_status = dev->ep[ep_num].stopped;
34816170:	e1c731b4 	strh	r3, [r7, #20]

	default:
		return 1;
	}

	memcpy(p, &g_status, sizeof(g_status));
34816174:	eb000b45 	bl	34818e90 <memcpy>

	flush_dcache_range((unsigned long) p,
34816178:	e1a00006 	mov	r0, r6
3481617c:	e2861901 	add	r1, r6, #16384	; 0x4000
34816180:	ebffab93 	bl	34800fd4 <flush_dcache_range>
			   (unsigned long) p + DMA_BUFFER_SIZE);

	writel(the_controller->dma_addr[1], &reg->in_endp[EP0_CON].diepdma);
34816184:	e5943008 	ldr	r3, [r4, #8]
34816188:	e5932044 	ldr	r2, [r3, #68]	; 0x44
3481618c:	e5943000 	ldr	r3, [r4]
34816190:	e5832914 	str	r2, [r3, #2324]	; 0x914
	writel(DIEPT_SIZ_PKT_CNT(1) | DIEPT_SIZ_XFER_SIZE(2),
34816194:	e59f203c 	ldr	r2, [pc, #60]	; 348161d8 <s3c_udc_get_status+0xfc>
34816198:	e5943000 	ldr	r3, [r4]
3481619c:	e5832910 	str	r2, [r3, #2320]	; 0x910
	       &reg->in_endp[EP0_CON].dieptsiz);

	ep_ctrl = readl(&reg->in_endp[EP0_CON].diepctl);
348161a0:	e5932900 	ldr	r2, [r3, #2304]	; 0x900
	writel(ep_ctrl|DEPCTL_EPENA|DEPCTL_CNAK,
348161a4:	e3822321 	orr	r2, r2, #-2080374784	; 0x84000000
348161a8:	e5943000 	ldr	r3, [r4]
	       &reg->in_endp[EP0_CON].diepctl);
	dev->ep0state = WAIT_FOR_NULL_COMPLETE;

	return 0;
348161ac:	e3a00000 	mov	r0, #0
	writel(the_controller->dma_addr[1], &reg->in_endp[EP0_CON].diepdma);
	writel(DIEPT_SIZ_PKT_CNT(1) | DIEPT_SIZ_XFER_SIZE(2),
	       &reg->in_endp[EP0_CON].dieptsiz);

	ep_ctrl = readl(&reg->in_endp[EP0_CON].diepctl);
	writel(ep_ctrl|DEPCTL_EPENA|DEPCTL_CNAK,
348161b0:	e5832900 	str	r2, [r3, #2304]	; 0x900
	       &reg->in_endp[EP0_CON].diepctl);
	dev->ep0state = WAIT_FOR_NULL_COMPLETE;
348161b4:	e3a03008 	mov	r3, #8
348161b8:	e5853054 	str	r3, [r5, #84]	; 0x54

	return 0;
348161bc:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
			   g_status);

		break;

	default:
		return 1;
348161c0:	e3a00001 	mov	r0, #1
348161c4:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}

	case USB_RECIP_ENDPOINT:
		if (crq->wLength > 2) {
			debug_cond(DEBUG_SETUP != 0,
				   "\tGET_STATUS:Not support EP or wLength\n");
			return 1;
348161c8:	e3a00001 	mov	r0, #1
	writel(ep_ctrl|DEPCTL_EPENA|DEPCTL_CNAK,
	       &reg->in_endp[EP0_CON].diepctl);
	dev->ep0state = WAIT_FOR_NULL_COMPLETE;

	return 0;
}
348161cc:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
348161d0:	3482b310 	.word	0x3482b310
348161d4:	34827693 	.word	0x34827693
348161d8:	00080002 	.word	0x00080002

348161dc <s3c_udc_ep_set_stall>:
void s3c_udc_ep_set_stall(struct s3c_ep *ep)
{
	u8		ep_num;
	u32		ep_ctrl = 0;

	ep_num = ep_index(ep);
348161dc:	e5d03035 	ldrb	r3, [r0, #53]	; 0x35
	debug("%s: ep_num = %d, ep_type = %d\n", __func__, ep_num, ep->ep_type);

	if (ep_is_in(ep)) {
348161e0:	e3130080 	tst	r3, #128	; 0x80
void s3c_udc_ep_set_stall(struct s3c_ep *ep)
{
	u8		ep_num;
	u32		ep_ctrl = 0;

	ep_num = ep_index(ep);
348161e4:	e203200f 	and	r2, r3, #15
348161e8:	e59f3048 	ldr	r3, [pc, #72]	; 34816238 <s3c_udc_ep_set_stall+0x5c>
	debug("%s: ep_num = %d, ep_type = %d\n", __func__, ep_num, ep->ep_type);

	if (ep_is_in(ep)) {
348161ec:	0a00000a 	beq	3481621c <s3c_udc_ep_set_stall+0x40>
		ep_ctrl = readl(&reg->in_endp[ep_num].diepctl);
348161f0:	e5933000 	ldr	r3, [r3]
348161f4:	e2821048 	add	r1, r2, #72	; 0x48
348161f8:	e7933281 	ldr	r3, [r3, r1, lsl #5]

		/* set the disable and stall bits */
		if (ep_ctrl & DEPCTL_EPENA)
348161fc:	e3530000 	cmp	r3, #0
			ep_ctrl |= DEPCTL_EPDIS;
34816200:	b3833101 	orrlt	r3, r3, #1073741824	; 0x40000000

		ep_ctrl |= DEPCTL_STALL;
34816204:	e3833602 	orr	r3, r3, #2097152	; 0x200000

		writel(ep_ctrl, &reg->in_endp[ep_num].diepctl);
34816208:	e59f1028 	ldr	r1, [pc, #40]	; 34816238 <s3c_udc_ep_set_stall+0x5c>
3481620c:	e2822048 	add	r2, r2, #72	; 0x48
34816210:	e5911000 	ldr	r1, [r1]
34816214:	e7813282 	str	r3, [r1, r2, lsl #5]
34816218:	e12fff1e 	bx	lr
		debug("%s: set stall, DIEPCTL%d = 0x%x\n",
		      __func__, ep_num, readl(&reg->in_endp[ep_num].diepctl));

	} else {
		ep_ctrl = readl(&reg->out_endp[ep_num].doepctl);
3481621c:	e5931000 	ldr	r1, [r3]
34816220:	e2822058 	add	r2, r2, #88	; 0x58
34816224:	e7911282 	ldr	r1, [r1, r2, lsl #5]

		/* set the stall bit */
		ep_ctrl |= DEPCTL_STALL;
34816228:	e3811602 	orr	r1, r1, #2097152	; 0x200000

		writel(ep_ctrl, &reg->out_endp[ep_num].doepctl);
3481622c:	e5933000 	ldr	r3, [r3]
34816230:	e7831282 	str	r1, [r3, r2, lsl #5]
34816234:	e12fff1e 	bx	lr
34816238:	3482b310 	.word	0x3482b310

3481623c <s3c_udc_ep_clear_stall>:
void s3c_udc_ep_clear_stall(struct s3c_ep *ep)
{
	u8		ep_num;
	u32		ep_ctrl = 0;

	ep_num = ep_index(ep);
3481623c:	e5d02035 	ldrb	r2, [r0, #53]	; 0x35
	debug("%s: ep_num = %d, ep_type = %d\n", __func__, ep_num, ep->ep_type);

	if (ep_is_in(ep)) {
34816240:	e3120080 	tst	r2, #128	; 0x80
void s3c_udc_ep_clear_stall(struct s3c_ep *ep)
{
	u8		ep_num;
	u32		ep_ctrl = 0;

	ep_num = ep_index(ep);
34816244:	e202300f 	and	r3, r2, #15
34816248:	e59f2064 	ldr	r2, [pc, #100]	; 348162b4 <s3c_udc_ep_clear_stall+0x78>
	debug("%s: ep_num = %d, ep_type = %d\n", __func__, ep_num, ep->ep_type);

	if (ep_is_in(ep)) {
3481624c:	0a00000a 	beq	3481627c <s3c_udc_ep_clear_stall+0x40>
		ep_ctrl = readl(&reg->in_endp[ep_num].diepctl);
34816250:	e5922000 	ldr	r2, [r2]
34816254:	e2831048 	add	r1, r3, #72	; 0x48
34816258:	e7922281 	ldr	r2, [r2, r1, lsl #5]
		 * of whether an endpoint has the Halt feature set, a
		 * ClearFeature(ENDPOINT_HALT) request always results in the
		 * data toggle being reinitialized to DATA0.
		 */
		if (ep->bmAttributes == USB_ENDPOINT_XFER_INT
		    || ep->bmAttributes == USB_ENDPOINT_XFER_BULK) {
3481625c:	e5d01036 	ldrb	r1, [r0, #54]	; 0x36

	if (ep_is_in(ep)) {
		ep_ctrl = readl(&reg->in_endp[ep_num].diepctl);

		/* clear stall bit */
		ep_ctrl &= ~DEPCTL_STALL;
34816260:	e3c22602 	bic	r2, r2, #2097152	; 0x200000
		 * of whether an endpoint has the Halt feature set, a
		 * ClearFeature(ENDPOINT_HALT) request always results in the
		 * data toggle being reinitialized to DATA0.
		 */
		if (ep->bmAttributes == USB_ENDPOINT_XFER_INT
		    || ep->bmAttributes == USB_ENDPOINT_XFER_BULK) {
34816264:	e2411002 	sub	r1, r1, #2
		 * USB Spec 9.4.5: For endpoints using data toggle, regardless
		 * of whether an endpoint has the Halt feature set, a
		 * ClearFeature(ENDPOINT_HALT) request always results in the
		 * data toggle being reinitialized to DATA0.
		 */
		if (ep->bmAttributes == USB_ENDPOINT_XFER_INT
34816268:	e6ef1071 	uxtb	r1, r1
3481626c:	e3510001 	cmp	r1, #1
		    || ep->bmAttributes == USB_ENDPOINT_XFER_BULK) {
			ep_ctrl |= DEPCTL_SETD0PID; /* DATA0 */
34816270:	93822201 	orrls	r2, r2, #268435456	; 0x10000000
		}

		writel(ep_ctrl, &reg->in_endp[ep_num].diepctl);
34816274:	e2833048 	add	r3, r3, #72	; 0x48
34816278:	ea000009 	b	348162a4 <s3c_udc_ep_clear_stall+0x68>
		debug("%s: cleared stall, DIEPCTL%d = 0x%x\n",
			__func__, ep_num, readl(&reg->in_endp[ep_num].diepctl));

	} else {
		ep_ctrl = readl(&reg->out_endp[ep_num].doepctl);
3481627c:	e5922000 	ldr	r2, [r2]
34816280:	e2831058 	add	r1, r3, #88	; 0x58
34816284:	e7922281 	ldr	r2, [r2, r1, lsl #5]

		/* clear stall bit */
		ep_ctrl &= ~DEPCTL_STALL;

		if (ep->bmAttributes == USB_ENDPOINT_XFER_INT
		    || ep->bmAttributes == USB_ENDPOINT_XFER_BULK) {
34816288:	e5d01036 	ldrb	r1, [r0, #54]	; 0x36

	} else {
		ep_ctrl = readl(&reg->out_endp[ep_num].doepctl);

		/* clear stall bit */
		ep_ctrl &= ~DEPCTL_STALL;
3481628c:	e3c22602 	bic	r2, r2, #2097152	; 0x200000

		if (ep->bmAttributes == USB_ENDPOINT_XFER_INT
		    || ep->bmAttributes == USB_ENDPOINT_XFER_BULK) {
34816290:	e2411002 	sub	r1, r1, #2
		ep_ctrl = readl(&reg->out_endp[ep_num].doepctl);

		/* clear stall bit */
		ep_ctrl &= ~DEPCTL_STALL;

		if (ep->bmAttributes == USB_ENDPOINT_XFER_INT
34816294:	e6ef1071 	uxtb	r1, r1
34816298:	e3510001 	cmp	r1, #1
		    || ep->bmAttributes == USB_ENDPOINT_XFER_BULK) {
			ep_ctrl |= DEPCTL_SETD0PID; /* DATA0 */
3481629c:	93822201 	orrls	r2, r2, #268435456	; 0x10000000
		}

		writel(ep_ctrl, &reg->out_endp[ep_num].doepctl);
348162a0:	e2833058 	add	r3, r3, #88	; 0x58
348162a4:	e59f1008 	ldr	r1, [pc, #8]	; 348162b4 <s3c_udc_ep_clear_stall+0x78>
348162a8:	e5911000 	ldr	r1, [r1]
348162ac:	e7812283 	str	r2, [r1, r3, lsl #5]
348162b0:	e12fff1e 	bx	lr
348162b4:	3482b310 	.word	0x3482b310

348162b8 <s3c_udc_set_halt>:

	return;
}

static int s3c_udc_set_halt(struct usb_ep *_ep, int value)
{
348162b8:	e92d4010 	push	{r4, lr}
	struct s3c_udc	*dev;
	unsigned long	flags;
	u8		ep_num;

	ep = container_of(_ep, struct s3c_ep, ep);
	ep_num = ep_index(ep);
348162bc:	e5d02035 	ldrb	r2, [r0, #53]	; 0x35

	if (unlikely(!_ep || !ep->desc || ep_num == EP0_CON ||
348162c0:	e590301c 	ldr	r3, [r0, #28]
348162c4:	e312000f 	tst	r2, #15
348162c8:	13a0c000 	movne	ip, #0
348162cc:	03a0c001 	moveq	ip, #1
348162d0:	e3530000 	cmp	r3, #0
348162d4:	038cc001 	orreq	ip, ip, #1
348162d8:	e35c0000 	cmp	ip, #0
348162dc:	0a000019 	beq	34816348 <s3c_udc_set_halt+0x90>
348162e0:	ea000014 	b	34816338 <s3c_udc_set_halt+0x80>
		return -EINVAL;
	}

	/* Attempt to halt IN ep will fail if any transfer requests
	 * are still queue */
	if (value && ep_is_in(ep) && !list_empty(&ep->queue)) {
348162e4:	e3510000 	cmp	r1, #0
348162e8:	0a000008 	beq	34816310 <s3c_udc_set_halt+0x58>
348162ec:	e3120080 	tst	r2, #128	; 0x80
348162f0:	0a000004 	beq	34816308 <s3c_udc_set_halt+0x50>
348162f4:	e5902020 	ldr	r2, [r0, #32]
348162f8:	e2803020 	add	r3, r0, #32
348162fc:	e1520003 	cmp	r2, r3
		debug("%s: %s queue not empty, req = %p\n",
			__func__, ep->ep.name,
			list_entry(ep->queue.next, struct s3c_request, queue));

		return -EAGAIN;
34816300:	13e0000a 	mvnne	r0, #10
		return -EINVAL;
	}

	/* Attempt to halt IN ep will fail if any transfer requests
	 * are still queue */
	if (value && ep_is_in(ep) && !list_empty(&ep->queue)) {
34816304:	18bd8010 	popne	{r4, pc}
	dev = ep->dev;
	debug("%s: ep_num = %d, value = %d\n", __func__, ep_num, value);

	spin_lock_irqsave(&dev->lock, flags);

	if (value == 0) {
34816308:	e3510000 	cmp	r1, #0
3481630c:	1a000004 	bne	34816324 <s3c_udc_set_halt+0x6c>
		ep->stopped = 0;
34816310:	e3a04000 	mov	r4, #0
34816314:	e5c04034 	strb	r4, [r0, #52]	; 0x34
		s3c_udc_ep_clear_stall(ep);
34816318:	ebffffc7 	bl	3481623c <s3c_udc_ep_clear_stall>
		s3c_udc_ep_set_stall(ep);
	}

	spin_unlock_irqrestore(&dev->lock, flags);

	return 0;
3481631c:	e1a00004 	mov	r0, r4
34816320:	e8bd8010 	pop	{r4, pc}
		s3c_udc_ep_clear_stall(ep);
	} else {
		if (ep_num == 0)
			dev->ep0state = WAIT_FOR_SETUP;

		ep->stopped = 1;
34816324:	e3a03001 	mov	r3, #1
34816328:	e5c03034 	strb	r3, [r0, #52]	; 0x34
		s3c_udc_ep_set_stall(ep);
3481632c:	ebffffaa 	bl	348161dc <s3c_udc_ep_set_stall>
	}

	spin_unlock_irqrestore(&dev->lock, flags);

	return 0;
34816330:	e3a00000 	mov	r0, #0
34816334:	e8bd8010 	pop	{r4, pc}
	ep_num = ep_index(ep);

	if (unlikely(!_ep || !ep->desc || ep_num == EP0_CON ||
		     ep->desc->bmAttributes == USB_ENDPOINT_XFER_ISOC)) {
		debug("%s: %s bad ep or descriptor\n", __func__, ep->ep.name);
		return -EINVAL;
34816338:	e3e00015 	mvn	r0, #21
3481633c:	e8bd8010 	pop	{r4, pc}
34816340:	e3e00015 	mvn	r0, #21
	}

	spin_unlock_irqrestore(&dev->lock, flags);

	return 0;
}
34816344:	e8bd8010 	pop	{r4, pc}
	u8		ep_num;

	ep = container_of(_ep, struct s3c_ep, ep);
	ep_num = ep_index(ep);

	if (unlikely(!_ep || !ep->desc || ep_num == EP0_CON ||
34816348:	e5d33003 	ldrb	r3, [r3, #3]
3481634c:	e3530001 	cmp	r3, #1
34816350:	1affffe3 	bne	348162e4 <s3c_udc_set_halt+0x2c>
34816354:	eafffff9 	b	34816340 <s3c_udc_set_halt+0x88>

34816358 <s3c_udc_ep_activate>:
void s3c_udc_ep_activate(struct s3c_ep *ep)
{
	u8 ep_num;
	u32 ep_ctrl = 0, daintmsk = 0;

	ep_num = ep_index(ep);
34816358:	e5d02035 	ldrb	r2, [r0, #53]	; 0x35

	/* Read DEPCTLn register */
	if (ep_is_in(ep)) {
3481635c:	e3120080 	tst	r2, #128	; 0x80
void s3c_udc_ep_activate(struct s3c_ep *ep)
{
	u8 ep_num;
	u32 ep_ctrl = 0, daintmsk = 0;

	ep_num = ep_index(ep);
34816360:	e202300f 	and	r3, r2, #15
34816364:	e59f2094 	ldr	r2, [pc, #148]	; 34816400 <s3c_udc_ep_activate+0xa8>

	/* Read DEPCTLn register */
	if (ep_is_in(ep)) {
34816368:	0a000004 	beq	34816380 <s3c_udc_ep_activate+0x28>
		ep_ctrl = readl(&reg->in_endp[ep_num].diepctl);
3481636c:	e5922000 	ldr	r2, [r2]
34816370:	e2831048 	add	r1, r3, #72	; 0x48
34816374:	e7922281 	ldr	r2, [r2, r1, lsl #5]
		daintmsk = 1 << ep_num;
34816378:	e3a01001 	mov	r1, #1
3481637c:	ea000003 	b	34816390 <s3c_udc_ep_activate+0x38>
	} else {
		ep_ctrl = readl(&reg->out_endp[ep_num].doepctl);
34816380:	e5922000 	ldr	r2, [r2]
34816384:	e2831058 	add	r1, r3, #88	; 0x58
34816388:	e7922281 	ldr	r2, [r2, r1, lsl #5]
		daintmsk = (1 << ep_num) << DAINT_OUT_BIT;
3481638c:	e3a01801 	mov	r1, #65536	; 0x10000
	debug("%s: EPCTRL%d = 0x%x, ep_is_in = %d\n",
		__func__, ep_num, ep_ctrl, ep_is_in(ep));

	/* If the EP is already active don't change the EP Control
	 * register. */
	if (!(ep_ctrl & DEPCTL_USBACTEP)) {
34816390:	e3120902 	tst	r2, #32768	; 0x8000
	if (ep_is_in(ep)) {
		ep_ctrl = readl(&reg->in_endp[ep_num].diepctl);
		daintmsk = 1 << ep_num;
	} else {
		ep_ctrl = readl(&reg->out_endp[ep_num].doepctl);
		daintmsk = (1 << ep_num) << DAINT_OUT_BIT;
34816394:	e1a01311 	lsl	r1, r1, r3
	debug("%s: EPCTRL%d = 0x%x, ep_is_in = %d\n",
		__func__, ep_num, ep_ctrl, ep_is_in(ep));

	/* If the EP is already active don't change the EP Control
	 * register. */
	if (!(ep_ctrl & DEPCTL_USBACTEP)) {
34816398:	1a000011 	bne	348163e4 <s3c_udc_ep_activate+0x8c>
		ep_ctrl = (ep_ctrl & ~DEPCTL_TYPE_MASK) |
			(ep->bmAttributes << DEPCTL_TYPE_BIT);
3481639c:	e5d0c036 	ldrb	ip, [r0, #54]	; 0x36
		__func__, ep_num, ep_ctrl, ep_is_in(ep));

	/* If the EP is already active don't change the EP Control
	 * register. */
	if (!(ep_ctrl & DEPCTL_USBACTEP)) {
		ep_ctrl = (ep_ctrl & ~DEPCTL_TYPE_MASK) |
348163a0:	e3c22703 	bic	r2, r2, #786432	; 0xc0000
348163a4:	e182290c 	orr	r2, r2, ip, lsl #18
			(ep->bmAttributes << DEPCTL_TYPE_BIT);
		ep_ctrl = (ep_ctrl & ~DEPCTL_MPS_MASK) |
348163a8:	e1d0c1b4 	ldrh	ip, [r0, #20]
348163ac:	e3c22e7f 	bic	r2, r2, #2032	; 0x7f0
348163b0:	e38cc306 	orr	ip, ip, #402653184	; 0x18000000
348163b4:	e3c2200f 	bic	r2, r2, #15
348163b8:	e38cc902 	orr	ip, ip, #32768	; 0x8000
			(ep->ep.maxpacket << DEPCTL_MPS_BIT);
		ep_ctrl |= (DEPCTL_SETD0PID | DEPCTL_USBACTEP | DEPCTL_SNAK);
348163bc:	e18cc002 	orr	ip, ip, r2

		if (ep_is_in(ep)) {
348163c0:	e1d023d5 	ldrsb	r2, [r0, #53]	; 0x35
348163c4:	e3520000 	cmp	r2, #0
348163c8:	e59f2030 	ldr	r2, [pc, #48]	; 34816400 <s3c_udc_ep_activate+0xa8>
348163cc:	aa000001 	bge	348163d8 <s3c_udc_ep_activate+0x80>
			writel(ep_ctrl, &reg->in_endp[ep_num].diepctl);
348163d0:	e2833048 	add	r3, r3, #72	; 0x48
348163d4:	ea000000 	b	348163dc <s3c_udc_ep_activate+0x84>
			debug("%s: USB Ative EP%d, DIEPCTRL%d = 0x%x\n",
			      __func__, ep_num, ep_num,
			      readl(&reg->in_endp[ep_num].diepctl));
		} else {
			writel(ep_ctrl, &reg->out_endp[ep_num].doepctl);
348163d8:	e2833058 	add	r3, r3, #88	; 0x58
348163dc:	e5922000 	ldr	r2, [r2]
348163e0:	e782c283 	str	ip, [r2, r3, lsl #5]
			      readl(&reg->out_endp[ep_num].doepctl));
		}
	}

	/* Unmask EP Interrtupt */
	writel(readl(&reg->daintmsk)|daintmsk, &reg->daintmsk);
348163e4:	e59f3014 	ldr	r3, [pc, #20]	; 34816400 <s3c_udc_ep_activate+0xa8>
348163e8:	e5932000 	ldr	r2, [r3]
348163ec:	e592281c 	ldr	r2, [r2, #2076]	; 0x81c
348163f0:	e1811002 	orr	r1, r1, r2
348163f4:	e5933000 	ldr	r3, [r3]
348163f8:	e583181c 	str	r1, [r3, #2076]	; 0x81c
	debug("%s: DAINTMSK = 0x%x\n", __func__, readl(&reg->daintmsk));

}
348163fc:	e12fff1e 	bx	lr
34816400:	3482b310 	.word	0x3482b310

34816404 <s3c_ep_enable>:
	unsigned long flags;

	debug("%s: %p\n", __func__, _ep);

	ep = container_of(_ep, struct s3c_ep, ep);
	if (!_ep || !desc || ep->desc || _ep->name == ep0name
34816404:	e3500000 	cmp	r0, #0
34816408:	13510000 	cmpne	r1, #0
	writel(ep_ctrl|(0<<0), &reg->out_endp[EP0_CON].doepctl);
}

static int s3c_ep_enable(struct usb_ep *_ep,
			 const struct usb_endpoint_descriptor *desc)
{
3481640c:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
	unsigned long flags;

	debug("%s: %p\n", __func__, _ep);

	ep = container_of(_ep, struct s3c_ep, ep);
	if (!_ep || !desc || ep->desc || _ep->name == ep0name
34816410:	e1a05001 	mov	r5, r1
34816414:	e1a04000 	mov	r4, r0
34816418:	0a000047 	beq	3481653c <s3c_ep_enable+0x138>
3481641c:	e590301c 	ldr	r3, [r0, #28]
34816420:	e3530000 	cmp	r3, #0
34816424:	1a000044 	bne	3481653c <s3c_ep_enable+0x138>
34816428:	e5902004 	ldr	r2, [r0, #4]
3481642c:	e59f3120 	ldr	r3, [pc, #288]	; 34816554 <s3c_ep_enable+0x150>
34816430:	e1520003 	cmp	r2, r3
34816434:	0a000040 	beq	3481653c <s3c_ep_enable+0x138>
	    || desc->bDescriptorType != USB_DT_ENDPOINT
34816438:	e5d13001 	ldrb	r3, [r1, #1]
3481643c:	e3530005 	cmp	r3, #5
34816440:	1a00003d 	bne	3481653c <s3c_ep_enable+0x138>
	    || ep->bEndpointAddress != desc->bEndpointAddress
34816444:	e5d06035 	ldrb	r6, [r0, #53]	; 0x35
34816448:	e5d13002 	ldrb	r3, [r1, #2]
3481644c:	e1530006 	cmp	r3, r6
34816450:	1a000039 	bne	3481653c <s3c_ep_enable+0x138>
	    || ep_maxpacket(ep) <
	    le16_to_cpu(get_unaligned(&desc->wMaxPacketSize))) {
34816454:	e2817004 	add	r7, r1, #4

	ep = container_of(_ep, struct s3c_ep, ep);
	if (!_ep || !desc || ep->desc || _ep->name == ep0name
	    || desc->bDescriptorType != USB_DT_ENDPOINT
	    || ep->bEndpointAddress != desc->bEndpointAddress
	    || ep_maxpacket(ep) <
34816458:	e1d0a1b4 	ldrh	sl, [r0, #20]
	    le16_to_cpu(get_unaligned(&desc->wMaxPacketSize))) {
3481645c:	e1a00007 	mov	r0, r7
34816460:	ebfffbf6 	bl	34815440 <get_unaligned_le16>

	ep = container_of(_ep, struct s3c_ep, ep);
	if (!_ep || !desc || ep->desc || _ep->name == ep0name
	    || desc->bDescriptorType != USB_DT_ENDPOINT
	    || ep->bEndpointAddress != desc->bEndpointAddress
	    || ep_maxpacket(ep) <
34816464:	e15a0000 	cmp	sl, r0
34816468:	3a000033 	bcc	3481653c <s3c_ep_enable+0x138>
		debug("%s: bad ep or descriptor\n", __func__);
		return -EINVAL;
	}

	/* xfer types must match, except that interrupt ~= bulk */
	if (ep->bmAttributes != desc->bmAttributes
3481646c:	e5d42036 	ldrb	r2, [r4, #54]	; 0x36
34816470:	e5d53003 	ldrb	r3, [r5, #3]
34816474:	e1520003 	cmp	r2, r3
34816478:	0a000004 	beq	34816490 <s3c_ep_enable+0x8c>
	    && ep->bmAttributes != USB_ENDPOINT_XFER_BULK
3481647c:	e3520002 	cmp	r2, #2
34816480:	0a000002 	beq	34816490 <s3c_ep_enable+0x8c>
	    && desc->bmAttributes != USB_ENDPOINT_XFER_INT) {
34816484:	e3530003 	cmp	r3, #3
34816488:	1a00002b 	bne	3481653c <s3c_ep_enable+0x138>
3481648c:	ea000003 	b	348164a0 <s3c_ep_enable+0x9c>
		debug("%s: %s type mismatch\n", __func__, _ep->name);
		return -EINVAL;
	}

	/* hardware _could_ do smaller, but driver doesn't */
	if ((desc->bmAttributes == USB_ENDPOINT_XFER_BULK
34816490:	e3530002 	cmp	r3, #2
34816494:	1a000001 	bne	348164a0 <s3c_ep_enable+0x9c>
	     && le16_to_cpu(get_unaligned(&desc->wMaxPacketSize)) !=
34816498:	e150000a 	cmp	r0, sl
3481649c:	1a000028 	bne	34816544 <s3c_ep_enable+0x140>
	     ep_maxpacket(ep)) || !get_unaligned(&desc->wMaxPacketSize)) {
348164a0:	e3500000 	cmp	r0, #0
348164a4:	0a000026 	beq	34816544 <s3c_ep_enable+0x140>

		debug("%s: bad %s maxpacket\n", __func__, _ep->name);
		return -ERANGE;
	}

	dev = ep->dev;
348164a8:	e5943018 	ldr	r3, [r4, #24]
	if (!dev->driver || dev->gadget.speed == USB_SPEED_UNKNOWN) {
348164ac:	e5932024 	ldr	r2, [r3, #36]	; 0x24
348164b0:	e3520000 	cmp	r2, #0

		debug("%s: bogus device state\n", __func__);
		return -ESHUTDOWN;
348164b4:	03e0006b 	mvneq	r0, #107	; 0x6b
		debug("%s: bad %s maxpacket\n", __func__, _ep->name);
		return -ERANGE;
	}

	dev = ep->dev;
	if (!dev->driver || dev->gadget.speed == USB_SPEED_UNKNOWN) {
348164b8:	08bd84f0 	popeq	{r4, r5, r6, r7, sl, pc}
348164bc:	e5933010 	ldr	r3, [r3, #16]
348164c0:	e3530000 	cmp	r3, #0
348164c4:	0a000020 	beq	3481654c <s3c_ep_enable+0x148>

		debug("%s: bogus device state\n", __func__);
		return -ESHUTDOWN;
	}

	ep->stopped = 0;
348164c8:	e3a03000 	mov	r3, #0
348164cc:	e5c43034 	strb	r3, [r4, #52]	; 0x34
	ep->desc = desc;
	ep->pio_irqs = 0;
348164d0:	e5843028 	str	r3, [r4, #40]	; 0x28
		debug("%s: bogus device state\n", __func__);
		return -ESHUTDOWN;
	}

	ep->stopped = 0;
	ep->desc = desc;
348164d4:	e584501c 	str	r5, [r4, #28]
	ep->pio_irqs = 0;
	ep->ep.maxpacket = le16_to_cpu(get_unaligned(&desc->wMaxPacketSize));
348164d8:	e1a00007 	mov	r0, r7
348164dc:	ebfffbd7 	bl	34815440 <get_unaligned_le16>
	u32		ep_ctrl = 0;

	ep_num = ep_index(ep);
	debug("%s: ep_num = %d, ep_type = %d\n", __func__, ep_num, ep->ep_type);

	if (ep_is_in(ep)) {
348164e0:	e3160080 	tst	r6, #128	; 0x80
348164e4:	e1c401b4 	strh	r0, [r4, #20]
static void s3c_udc_set_nak(struct s3c_ep *ep)
{
	u8		ep_num;
	u32		ep_ctrl = 0;

	ep_num = ep_index(ep);
348164e8:	e206200f 	and	r2, r6, #15
348164ec:	e59f3064 	ldr	r3, [pc, #100]	; 34816558 <s3c_ep_enable+0x154>
	debug("%s: ep_num = %d, ep_type = %d\n", __func__, ep_num, ep->ep_type);

	if (ep_is_in(ep)) {
348164f0:	0a000004 	beq	34816508 <s3c_ep_enable+0x104>
		ep_ctrl = readl(&reg->in_endp[ep_num].diepctl);
348164f4:	e5931000 	ldr	r1, [r3]
348164f8:	e2822048 	add	r2, r2, #72	; 0x48
348164fc:	e7911282 	ldr	r1, [r1, r2, lsl #5]
		ep_ctrl |= DEPCTL_SNAK;
34816500:	e3811302 	orr	r1, r1, #134217728	; 0x8000000
		writel(ep_ctrl, &reg->in_endp[ep_num].diepctl);
34816504:	ea000003 	b	34816518 <s3c_ep_enable+0x114>
		debug("%s: set NAK, DIEPCTL%d = 0x%x\n",
			__func__, ep_num, readl(&reg->in_endp[ep_num].diepctl));
	} else {
		ep_ctrl = readl(&reg->out_endp[ep_num].doepctl);
34816508:	e5931000 	ldr	r1, [r3]
3481650c:	e2822058 	add	r2, r2, #88	; 0x58
34816510:	e7911282 	ldr	r1, [r1, r2, lsl #5]
		ep_ctrl |= DEPCTL_SNAK;
34816514:	e3811302 	orr	r1, r1, #134217728	; 0x8000000
		writel(ep_ctrl, &reg->out_endp[ep_num].doepctl);
34816518:	e5933000 	ldr	r3, [r3]

	/* Reset halt state */
	s3c_udc_set_nak(ep);
	s3c_udc_set_halt(_ep, 0);
3481651c:	e1a00004 	mov	r0, r4
34816520:	e7831282 	str	r1, [r3, r2, lsl #5]
34816524:	e3a01000 	mov	r1, #0
34816528:	ebffff62 	bl	348162b8 <s3c_udc_set_halt>

	spin_lock_irqsave(&ep->dev->lock, flags);
	s3c_udc_ep_activate(ep);
3481652c:	e1a00004 	mov	r0, r4
34816530:	ebffff88 	bl	34816358 <s3c_udc_ep_activate>
	spin_unlock_irqrestore(&ep->dev->lock, flags);

	debug("%s: enabled %s, stopped = %d, maxpacket = %d\n",
	      __func__, _ep->name, ep->stopped, ep->ep.maxpacket);
	return 0;
34816534:	e3a00000 	mov	r0, #0
34816538:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
	if (ep->bmAttributes != desc->bmAttributes
	    && ep->bmAttributes != USB_ENDPOINT_XFER_BULK
	    && desc->bmAttributes != USB_ENDPOINT_XFER_INT) {

		debug("%s: %s type mismatch\n", __func__, _ep->name);
		return -EINVAL;
3481653c:	e3e00015 	mvn	r0, #21
34816540:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
	if ((desc->bmAttributes == USB_ENDPOINT_XFER_BULK
	     && le16_to_cpu(get_unaligned(&desc->wMaxPacketSize)) !=
	     ep_maxpacket(ep)) || !get_unaligned(&desc->wMaxPacketSize)) {

		debug("%s: bad %s maxpacket\n", __func__, _ep->name);
		return -ERANGE;
34816544:	e3e00021 	mvn	r0, #33	; 0x21
34816548:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}

	dev = ep->dev;
	if (!dev->driver || dev->gadget.speed == USB_SPEED_UNKNOWN) {

		debug("%s: bogus device state\n", __func__);
		return -ESHUTDOWN;
3481654c:	e3e0006b 	mvn	r0, #107	; 0x6b
	spin_unlock_irqrestore(&ep->dev->lock, flags);

	debug("%s: enabled %s, stopped = %d, maxpacket = %d\n",
	      __func__, _ep->name, ep->stopped, ep->ep.maxpacket);
	return 0;
}
34816550:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
34816554:	34821894 	.word	0x34821894
34816558:	3482b310 	.word	0x3482b310

3481655c <s3c_ep0_setup>:

/*
 * WAIT_FOR_SETUP (OUT_PKT_RDY)
 */
void s3c_ep0_setup(struct s3c_udc *dev)
{
3481655c:	e92d4070 	push	{r4, r5, r6, lr}
	struct s3c_ep *ep = &dev->ep[0];
34816560:	e2806058 	add	r6, r0, #88	; 0x58

	/* Nuke all previous transfers */
	nuke(ep, -EPROTO);

	/* read control req from fifo (8 bytes) */
	s3c_fifo_read(ep, (u32 *)usb_ctrl, 8);
34816564:	e59f5298 	ldr	r5, [pc, #664]	; 34816804 <s3c_ep0_setup+0x2a8>
	struct s3c_ep *ep = &dev->ep[0];
	int i;
	u8 ep_num;

	/* Nuke all previous transfers */
	nuke(ep, -EPROTO);
34816568:	e3e01046 	mvn	r1, #70	; 0x46

/*
 * WAIT_FOR_SETUP (OUT_PKT_RDY)
 */
void s3c_ep0_setup(struct s3c_udc *dev)
{
3481656c:	e1a04000 	mov	r4, r0
	struct s3c_ep *ep = &dev->ep[0];
	int i;
	u8 ep_num;

	/* Nuke all previous transfers */
	nuke(ep, -EPROTO);
34816570:	e1a00006 	mov	r0, r6
34816574:	ebfffc76 	bl	34815754 <nuke>

	/* read control req from fifo (8 bytes) */
	s3c_fifo_read(ep, (u32 *)usb_ctrl, 8);
34816578:	e5951018 	ldr	r1, [r5, #24]
3481657c:	e1a00006 	mov	r0, r6
34816580:	e3a02008 	mov	r2, #8
34816584:	ebfffeca 	bl	348160b4 <s3c_fifo_read>
		}
		printf("\n");
	}
#endif

	if (usb_ctrl->bRequest == GET_MAX_LUN_REQUEST &&
34816588:	e5951018 	ldr	r1, [r5, #24]
3481658c:	e5d13001 	ldrb	r3, [r1, #1]
34816590:	e35300fe 	cmp	r3, #254	; 0xfe
34816594:	1a000005 	bne	348165b0 <s3c_ep0_setup+0x54>
	    usb_ctrl->wLength != 1) {
34816598:	e5d13006 	ldrb	r3, [r1, #6]
3481659c:	e5d12007 	ldrb	r2, [r1, #7]
		}
		printf("\n");
	}
#endif

	if (usb_ctrl->bRequest == GET_MAX_LUN_REQUEST &&
348165a0:	e1833402 	orr	r3, r3, r2, lsl #8
348165a4:	e3530001 	cmp	r3, #1
348165a8:	0a000006 	beq	348165c8 <s3c_ep0_setup+0x6c>
348165ac:	ea00008a 	b	348167dc <s3c_ep0_setup+0x280>

		s3c_udc_ep0_set_stall(ep);
		dev->ep0state = WAIT_FOR_SETUP;

		return;
	} else if (usb_ctrl->bRequest == BOT_RESET_REQUEST &&
348165b0:	e35300ff 	cmp	r3, #255	; 0xff
348165b4:	1a000003 	bne	348165c8 <s3c_ep0_setup+0x6c>
		 usb_ctrl->wLength != 0) {
348165b8:	e5d13006 	ldrb	r3, [r1, #6]
348165bc:	e5d12007 	ldrb	r2, [r1, #7]

		s3c_udc_ep0_set_stall(ep);
		dev->ep0state = WAIT_FOR_SETUP;

		return;
	} else if (usb_ctrl->bRequest == BOT_RESET_REQUEST &&
348165c0:	e1932402 	orrs	r2, r3, r2, lsl #8
348165c4:	1a000084 	bne	348167dc <s3c_ep0_setup+0x280>

		return;
	}

	/* Set direction of EP0 */
	if (likely(usb_ctrl->bRequestType & USB_DIR_IN)) {
348165c8:	e1d130d0 	ldrsb	r3, [r1]
348165cc:	e3530000 	cmp	r3, #0
348165d0:	e5d4308d 	ldrb	r3, [r4, #141]	; 0x8d
		ep->bEndpointAddress |= USB_DIR_IN;
348165d4:	b1e03c83 	mvnlt	r3, r3, lsl #25
348165d8:	b1e03ca3 	mvnlt	r3, r3, lsr #25
	} else {
		ep->bEndpointAddress &= ~USB_DIR_IN;
348165dc:	a203307f 	andge	r3, r3, #127	; 0x7f
348165e0:	e5c4308d 	strb	r3, [r4, #141]	; 0x8d
	}
	/* cope with automagic for some standard requests. */
	dev->req_std = (usb_ctrl->bRequestType & USB_TYPE_MASK)
348165e4:	e5d13000 	ldrb	r3, [r1]
		== USB_TYPE_STANDARD;
348165e8:	e3130060 	tst	r3, #96	; 0x60
		ep->bEndpointAddress |= USB_DIR_IN;
	} else {
		ep->bEndpointAddress &= ~USB_DIR_IN;
	}
	/* cope with automagic for some standard requests. */
	dev->req_std = (usb_ctrl->bRequestType & USB_TYPE_MASK)
348165ec:	e5d43159 	ldrb	r3, [r4, #345]	; 0x159
		== USB_TYPE_STANDARD;
348165f0:	13a02000 	movne	r2, #0
348165f4:	03a02001 	moveq	r2, #1
		ep->bEndpointAddress |= USB_DIR_IN;
	} else {
		ep->bEndpointAddress &= ~USB_DIR_IN;
	}
	/* cope with automagic for some standard requests. */
	dev->req_std = (usb_ctrl->bRequestType & USB_TYPE_MASK)
348165f8:	e7c13092 	bfi	r3, r2, #1, #1
		== USB_TYPE_STANDARD;

	dev->req_pending = 1;
348165fc:	e6ef3073 	uxtb	r3, r3
34816600:	e3833001 	orr	r3, r3, #1
34816604:	e5c43159 	strb	r3, [r4, #345]	; 0x159

	/* Handle some SETUP packets ourselves */
	if (dev->req_std) {
34816608:	e2033002 	and	r3, r3, #2
3481660c:	e6ef3073 	uxtb	r3, r3
34816610:	e3530000 	cmp	r3, #0
34816614:	0a000066 	beq	348167b4 <s3c_ep0_setup+0x258>
		switch (usb_ctrl->bRequest) {
34816618:	e5d13001 	ldrb	r3, [r1, #1]
3481661c:	e353000b 	cmp	r3, #11
34816620:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
34816624:	ea000062 	b	348167b4 <s3c_ep0_setup+0x258>
34816628:	348166a0 	.word	0x348166a0
3481662c:	348166b4 	.word	0x348166b4
34816630:	348167b4 	.word	0x348167b4
34816634:	3481673c 	.word	0x3481673c
34816638:	348167b4 	.word	0x348167b4
3481663c:	34816658 	.word	0x34816658
34816640:	348167b4 	.word	0x348167b4
34816644:	348167b4 	.word	0x348167b4
34816648:	348167b4 	.word	0x348167b4
3481664c:	34816674 	.word	0x34816674
34816650:	348167b4 	.word	0x348167b4
34816654:	3481668c 	.word	0x3481668c
		case USB_REQ_SET_ADDRESS:
		debug_cond(DEBUG_SETUP != 0,
			   "%s: *** USB_REQ_SET_ADDRESS (%d)\n",
			   __func__, usb_ctrl->wValue);
			if (usb_ctrl->bRequestType
34816658:	e5d13000 	ldrb	r3, [r1]
3481665c:	e3530000 	cmp	r3, #0
34816660:	1a000053 	bne	348167b4 <s3c_ep0_setup+0x258>
				!= (USB_TYPE_STANDARD | USB_RECIP_DEVICE))
				break;

			udc_set_address(dev, usb_ctrl->wValue);
34816664:	e5d11002 	ldrb	r1, [r1, #2]
34816668:	e1a00004 	mov	r0, r4

		debug_cond(DEBUG_SETUP != 0,
			   "\tep0state = %s\n", state_names[dev->ep0state]);

	}
}
3481666c:	e8bd4070 	pop	{r4, r5, r6, lr}
			   __func__, usb_ctrl->wValue);
			if (usb_ctrl->bRequestType
				!= (USB_TYPE_STANDARD | USB_RECIP_DEVICE))
				break;

			udc_set_address(dev, usb_ctrl->wValue);
34816670:	eafffd15 	b	34815acc <udc_set_address>
				   "=====================================\n");
			debug_cond(DEBUG_SETUP != 0,
				   "%s: USB_REQ_SET_CONFIGURATION (%d)\n",
				   __func__, usb_ctrl->wValue);

			if (usb_ctrl->bRequestType == USB_RECIP_DEVICE)
34816674:	e5d13000 	ldrb	r3, [r1]
34816678:	e3530000 	cmp	r3, #0
				reset_available = 1;
3481667c:	059f3184 	ldreq	r3, [pc, #388]	; 34816808 <s3c_ep0_setup+0x2ac>
34816680:	03a02001 	moveq	r2, #1
34816684:	0583200c 	streq	r2, [r3, #12]
34816688:	ea000049 	b	348167b4 <s3c_ep0_setup+0x258>
		case USB_REQ_SET_INTERFACE:
			debug_cond(DEBUG_SETUP != 0,
				   "%s: *** USB_REQ_SET_INTERFACE (%d)\n",
				   __func__, usb_ctrl->wValue);

			if (usb_ctrl->bRequestType == USB_RECIP_INTERFACE)
3481668c:	e5d13000 	ldrb	r3, [r1]
34816690:	e3530001 	cmp	r3, #1
				reset_available = 1;
34816694:	059f216c 	ldreq	r2, [pc, #364]	; 34816808 <s3c_ep0_setup+0x2ac>
34816698:	0582300c 	streq	r3, [r2, #12]
3481669c:	ea000044 	b	348167b4 <s3c_ep0_setup+0x258>
				   "%s: *** USB_REQ_GET_CONFIGURATION\n",
				   __func__);
			break;

		case USB_REQ_GET_STATUS:
			if (!s3c_udc_get_status(dev, usb_ctrl))
348166a0:	e1a00004 	mov	r0, r4
348166a4:	ebfffe8c 	bl	348160dc <s3c_udc_get_status>
348166a8:	e3500000 	cmp	r0, #0
348166ac:	1a000040 	bne	348167b4 <s3c_ep0_setup+0x258>
348166b0:	e8bd8070 	pop	{r4, r5, r6, pc}
				return;

			break;

		case USB_REQ_CLEAR_FEATURE:
			ep_num = usb_ctrl->wIndex & 0x7f;
348166b4:	e5d15004 	ldrb	r5, [r1, #4]
	dev = ep->dev;
	debug_cond(DEBUG_SETUP != 0,
		   "%s: ep_num = %d, is_in = %d, clear_feature_flag = %d\n",
		   __func__, ep_num, ep_is_in(ep), clear_feature_flag);

	if (usb_ctrl->wLength != 0) {
348166b8:	e5d12006 	ldrb	r2, [r1, #6]
			break;

		case USB_REQ_CLEAR_FEATURE:
			ep_num = usb_ctrl->wIndex & 0x7f;

			if (!s3c_udc_clear_feature(&dev->ep[ep_num].ep))
348166bc:	e205507f 	and	r5, r5, #127	; 0x7f
	dev = ep->dev;
	debug_cond(DEBUG_SETUP != 0,
		   "%s: ep_num = %d, is_in = %d, clear_feature_flag = %d\n",
		   __func__, ep_num, ep_is_in(ep), clear_feature_flag);

	if (usb_ctrl->wLength != 0) {
348166c0:	e5d1c007 	ldrb	ip, [r1, #7]
			break;

		case USB_REQ_CLEAR_FEATURE:
			ep_num = usb_ctrl->wIndex & 0x7f;

			if (!s3c_udc_clear_feature(&dev->ep[ep_num].ep))
348166c4:	e0845305 	add	r5, r4, r5, lsl #6
348166c8:	e2855058 	add	r5, r5, #88	; 0x58
	dev = ep->dev;
	debug_cond(DEBUG_SETUP != 0,
		   "%s: ep_num = %d, is_in = %d, clear_feature_flag = %d\n",
		   __func__, ep_num, ep_is_in(ep), clear_feature_flag);

	if (usb_ctrl->wLength != 0) {
348166cc:	e192c40c 	orrs	ip, r2, ip, lsl #8
	struct s3c_udc	*dev;
	struct s3c_ep	*ep;
	u8		ep_num;

	ep = container_of(_ep, struct s3c_ep, ep);
	ep_num = ep_index(ep);
348166d0:	e5d53035 	ldrb	r3, [r5, #53]	; 0x35

	dev = ep->dev;
348166d4:	e5950018 	ldr	r0, [r5, #24]
	debug_cond(DEBUG_SETUP != 0,
		   "%s: ep_num = %d, is_in = %d, clear_feature_flag = %d\n",
		   __func__, ep_num, ep_is_in(ep), clear_feature_flag);

	if (usb_ctrl->wLength != 0) {
348166d8:	1a000035 	bne	348167b4 <s3c_ep0_setup+0x258>
		debug_cond(DEBUG_SETUP != 0,
			   "\tCLEAR_FEATURE: wLength is not zero.....\n");
		return 1;
	}

	switch (usb_ctrl->bRequestType & USB_RECIP_MASK) {
348166dc:	e5d12000 	ldrb	r2, [r1]
348166e0:	e212201f 	ands	r2, r2, #31
				   "\tCLEAR_FEATURE: USB_DEVICE_TEST_MODE\n");
			/** @todo Add CLEAR_FEATURE for TEST modes. */
			break;
		}

		s3c_udc_ep0_zlp(dev);
348166e4:	02800054 	addeq	r0, r0, #84	; 0x54
		debug_cond(DEBUG_SETUP != 0,
			   "\tCLEAR_FEATURE: wLength is not zero.....\n");
		return 1;
	}

	switch (usb_ctrl->bRequestType & USB_RECIP_MASK) {
348166e8:	0a00002f 	beq	348167ac <s3c_ep0_setup+0x250>
348166ec:	e3520002 	cmp	r2, #2
348166f0:	18bd8070 	popne	{r4, r5, r6, pc}
	case USB_RECIP_ENDPOINT:
		debug_cond(DEBUG_SETUP != 0,
			   "\tCLEAR_FEATURE:USB_RECIP_ENDPOINT, wValue = %d\n",
			   usb_ctrl->wValue);

		if (usb_ctrl->wValue == USB_ENDPOINT_HALT) {
348166f4:	e5d12002 	ldrb	r2, [r1, #2]
348166f8:	e5d16003 	ldrb	r6, [r1, #3]
348166fc:	e1926406 	orrs	r6, r2, r6, lsl #8
34816700:	18bd8070 	popne	{r4, r5, r6, pc}
			if (ep_num == 0) {
34816704:	e213400f 	ands	r4, r3, #15
34816708:	0a000021 	beq	34816794 <s3c_ep0_setup+0x238>
				s3c_udc_ep0_set_stall(ep);
				return 0;
			}

			s3c_udc_ep0_zlp(dev);
3481670c:	e2800054 	add	r0, r0, #84	; 0x54
34816710:	ebfffc85 	bl	3481592c <s3c_udc_ep0_zlp.clone.2>

			s3c_udc_ep_clear_stall(ep);
34816714:	e1a00005 	mov	r0, r5
34816718:	ebfffec7 	bl	3481623c <s3c_udc_ep_clear_stall>
			s3c_udc_ep_activate(ep);
3481671c:	e1a00005 	mov	r0, r5
34816720:	ebffff0c 	bl	34816358 <s3c_udc_ep_activate>
			ep->stopped = 0;

			clear_feature_num = ep_num;
34816724:	e59f30d8 	ldr	r3, [pc, #216]	; 34816804 <s3c_ep0_setup+0x2a8>
			clear_feature_flag = 1;
34816728:	e3a02001 	mov	r2, #1

			s3c_udc_ep0_zlp(dev);

			s3c_udc_ep_clear_stall(ep);
			s3c_udc_ep_activate(ep);
			ep->stopped = 0;
3481672c:	e5c56034 	strb	r6, [r5, #52]	; 0x34

			clear_feature_num = ep_num;
34816730:	e5c3401c 	strb	r4, [r3, #28]
			clear_feature_flag = 1;
34816734:	e5832020 	str	r2, [r3, #32]
34816738:	e8bd8070 	pop	{r4, r5, r6, pc}
				return;

			break;

		case USB_REQ_SET_FEATURE:
			ep_num = usb_ctrl->wIndex & 0x7f;
3481673c:	e5d10004 	ldrb	r0, [r1, #4]

	debug_cond(DEBUG_SETUP != 0,
		   "%s: *** USB_REQ_SET_FEATURE , ep_num = %d\n",
		    __func__, ep_num);

	if (usb_ctrl->wLength != 0) {
34816740:	e5d13006 	ldrb	r3, [r1, #6]
			break;

		case USB_REQ_SET_FEATURE:
			ep_num = usb_ctrl->wIndex & 0x7f;

			if (!s3c_udc_set_feature(&dev->ep[ep_num].ep))
34816744:	e200007f 	and	r0, r0, #127	; 0x7f

	debug_cond(DEBUG_SETUP != 0,
		   "%s: *** USB_REQ_SET_FEATURE , ep_num = %d\n",
		    __func__, ep_num);

	if (usb_ctrl->wLength != 0) {
34816748:	e5d1c007 	ldrb	ip, [r1, #7]
			break;

		case USB_REQ_SET_FEATURE:
			ep_num = usb_ctrl->wIndex & 0x7f;

			if (!s3c_udc_set_feature(&dev->ep[ep_num].ep))
3481674c:	e0840300 	add	r0, r4, r0, lsl #6
34816750:	e2800058 	add	r0, r0, #88	; 0x58

	debug_cond(DEBUG_SETUP != 0,
		   "%s: *** USB_REQ_SET_FEATURE , ep_num = %d\n",
		    __func__, ep_num);

	if (usb_ctrl->wLength != 0) {
34816754:	e193c40c 	orrs	ip, r3, ip, lsl #8
	struct s3c_udc	*dev;
	struct s3c_ep	*ep;
	u8		ep_num;

	ep = container_of(_ep, struct s3c_ep, ep);
	ep_num = ep_index(ep);
34816758:	e5d02035 	ldrb	r2, [r0, #53]	; 0x35
	dev = ep->dev;
3481675c:	e5905018 	ldr	r5, [r0, #24]

	debug_cond(DEBUG_SETUP != 0,
		   "%s: *** USB_REQ_SET_FEATURE , ep_num = %d\n",
		    __func__, ep_num);

	if (usb_ctrl->wLength != 0) {
34816760:	1a000013 	bne	348167b4 <s3c_ep0_setup+0x258>
		debug_cond(DEBUG_SETUP != 0,
			   "\tSET_FEATURE: wLength is not zero.....\n");
		return 1;
	}

	switch (usb_ctrl->bRequestType & USB_RECIP_MASK) {
34816764:	e5d13000 	ldrb	r3, [r1]
34816768:	e213301f 	ands	r3, r3, #31
3481676c:	0a00000d 	beq	348167a8 <s3c_ep0_setup+0x24c>
34816770:	e3530002 	cmp	r3, #2
34816774:	1a00000e 	bne	348167b4 <s3c_ep0_setup+0x258>
		break;

	case USB_RECIP_ENDPOINT:
		debug_cond(DEBUG_SETUP != 0,
			   "\tSET_FEATURE: USB_RECIP_ENDPOINT\n");
		if (usb_ctrl->wValue == USB_ENDPOINT_HALT) {
34816778:	e5d13002 	ldrb	r3, [r1, #2]
3481677c:	e5d11003 	ldrb	r1, [r1, #3]
34816780:	e1931401 	orrs	r1, r3, r1, lsl #8
34816784:	1a000007 	bne	348167a8 <s3c_ep0_setup+0x24c>
			if (ep_num == 0) {
34816788:	e312000f 	tst	r2, #15
3481678c:	1a000002 	bne	3481679c <s3c_ep0_setup+0x240>
				s3c_udc_ep0_set_stall(ep);
34816790:	e1a00005 	mov	r0, r5

		debug_cond(DEBUG_SETUP != 0,
			   "\tep0state = %s\n", state_names[dev->ep0state]);

	}
}
34816794:	e8bd4070 	pop	{r4, r5, r6, lr}
	case USB_RECIP_ENDPOINT:
		debug_cond(DEBUG_SETUP != 0,
			   "\tSET_FEATURE: USB_RECIP_ENDPOINT\n");
		if (usb_ctrl->wValue == USB_ENDPOINT_HALT) {
			if (ep_num == 0) {
				s3c_udc_ep0_set_stall(ep);
34816798:	eafffd4b 	b	34815ccc <s3c_udc_ep0_set_stall.clone.3>
				return 0;
			}
			ep->stopped = 1;
3481679c:	e3a03001 	mov	r3, #1
348167a0:	e5c03034 	strb	r3, [r0, #52]	; 0x34
			s3c_udc_ep_set_stall(ep);
348167a4:	ebfffe8c 	bl	348161dc <s3c_udc_ep_set_stall>
		}

		s3c_udc_ep0_zlp(dev);
348167a8:	e2850054 	add	r0, r5, #84	; 0x54

		debug_cond(DEBUG_SETUP != 0,
			   "\tep0state = %s\n", state_names[dev->ep0state]);

	}
}
348167ac:	e8bd4070 	pop	{r4, r5, r6, lr}
			}
			ep->stopped = 1;
			s3c_udc_ep_set_stall(ep);
		}

		s3c_udc_ep0_zlp(dev);
348167b0:	eafffc5d 	b	3481592c <s3c_udc_ep0_zlp.clone.2>
			break;
		}
	}


	if (likely(dev->driver)) {
348167b4:	e5943024 	ldr	r3, [r4, #36]	; 0x24
348167b8:	e3530000 	cmp	r3, #0
348167bc:	08bd8070 	popeq	{r4, r5, r6, pc}
		debug_cond(DEBUG_SETUP != 0,
			   "%s:usb_ctrlreq will be passed to fsg_setup()\n",
			    __func__);

		spin_unlock(&dev->lock);
		i = dev->driver->setup(&dev->gadget, usb_ctrl);
348167c0:	e59f203c 	ldr	r2, [pc, #60]	; 34816804 <s3c_ep0_setup+0x2a8>
348167c4:	e593300c 	ldr	r3, [r3, #12]
348167c8:	e1a00004 	mov	r0, r4
348167cc:	e5921018 	ldr	r1, [r2, #24]
348167d0:	e12fff33 	blx	r3
		spin_lock(&dev->lock);

		if (i < 0) {
348167d4:	e3500000 	cmp	r0, #0
348167d8:	aa000004 	bge	348167f0 <s3c_ep0_setup+0x294>
			/* setup processing failed, force stall */
			s3c_udc_ep0_set_stall(ep);
348167dc:	e5940070 	ldr	r0, [r4, #112]	; 0x70
348167e0:	ebfffd39 	bl	34815ccc <s3c_udc_ep0_set_stall.clone.3>
			dev->ep0state = WAIT_FOR_SETUP;
348167e4:	e3a03000 	mov	r3, #0
348167e8:	e5843054 	str	r3, [r4, #84]	; 0x54
348167ec:	e8bd8070 	pop	{r4, r5, r6, pc}
				   "\tdev->driver->setup failed (%d),"
				    " bRequest = %d\n",
				i, usb_ctrl->bRequest);


		} else if (dev->req_pending) {
348167f0:	e5d43159 	ldrb	r3, [r4, #345]	; 0x159
348167f4:	e3130001 	tst	r3, #1
			dev->req_pending = 0;
348167f8:	17c0301f 	bfcne	r3, #0, #1
348167fc:	15c43159 	strbne	r3, [r4, #345]	; 0x159
34816800:	e8bd8070 	pop	{r4, r5, r6, pc}
34816804:	3482b310 	.word	0x3482b310
34816808:	34828a10 	.word	0x34828a10

3481680c <usb_gadget_register_driver>:
/*
  Register entry point for the peripheral controller driver.
*/
int usb_gadget_register_driver(struct usb_gadget_driver *driver)
{
	struct s3c_udc *dev = the_controller;
3481680c:	e59f3094 	ldr	r3, [pc, #148]	; 348168a8 <usb_gadget_register_driver+0x9c>
	int retval = 0;
	unsigned long flags;

	debug_cond(DEBUG_SETUP != 0, "%s: %s\n", __func__, "no name");

	if (!driver
34816810:	e3500000 	cmp	r0, #0

/*
  Register entry point for the peripheral controller driver.
*/
int usb_gadget_register_driver(struct usb_gadget_driver *driver)
{
34816814:	e92d4070 	push	{r4, r5, r6, lr}
	struct s3c_udc *dev = the_controller;
34816818:	e5935008 	ldr	r5, [r3, #8]
	int retval = 0;
	unsigned long flags;

	debug_cond(DEBUG_SETUP != 0, "%s: %s\n", __func__, "no name");

	if (!driver
3481681c:	0a00001e 	beq	3481689c <usb_gadget_register_driver+0x90>
	    || (driver->speed != USB_SPEED_FULL
		&& driver->speed != USB_SPEED_HIGH)
34816820:	e5903000 	ldr	r3, [r0]
34816824:	e2433002 	sub	r3, r3, #2
	unsigned long flags;

	debug_cond(DEBUG_SETUP != 0, "%s: %s\n", __func__, "no name");

	if (!driver
	    || (driver->speed != USB_SPEED_FULL
34816828:	e3530001 	cmp	r3, #1
3481682c:	8a00001a 	bhi	3481689c <usb_gadget_register_driver+0x90>
		&& driver->speed != USB_SPEED_HIGH)
	    || !driver->bind || !driver->disconnect || !driver->setup)
34816830:	e5903004 	ldr	r3, [r0, #4]
34816834:	e3530000 	cmp	r3, #0
34816838:	0a000017 	beq	3481689c <usb_gadget_register_driver+0x90>
3481683c:	e5902010 	ldr	r2, [r0, #16]
34816840:	e3520000 	cmp	r2, #0
34816844:	0a000014 	beq	3481689c <usb_gadget_register_driver+0x90>
34816848:	e590200c 	ldr	r2, [r0, #12]
3481684c:	e3520000 	cmp	r2, #0
34816850:	0a000011 	beq	3481689c <usb_gadget_register_driver+0x90>
		return -EINVAL;
	if (!dev)
34816854:	e3550000 	cmp	r5, #0
		return -ENODEV;
34816858:	03e04012 	mvneq	r4, #18
	if (!driver
	    || (driver->speed != USB_SPEED_FULL
		&& driver->speed != USB_SPEED_HIGH)
	    || !driver->bind || !driver->disconnect || !driver->setup)
		return -EINVAL;
	if (!dev)
3481685c:	0a00000f 	beq	348168a0 <usb_gadget_register_driver+0x94>
		return -ENODEV;
	if (dev->driver)
34816860:	e5956024 	ldr	r6, [r5, #36]	; 0x24
34816864:	e3560000 	cmp	r6, #0
		return -EBUSY;
34816868:	13e0400f 	mvnne	r4, #15
		&& driver->speed != USB_SPEED_HIGH)
	    || !driver->bind || !driver->disconnect || !driver->setup)
		return -EINVAL;
	if (!dev)
		return -ENODEV;
	if (dev->driver)
3481686c:	1a00000b 	bne	348168a0 <usb_gadget_register_driver+0x94>
		return -EBUSY;

	spin_lock_irqsave(&dev->lock, flags);
	/* first hook up the driver ... */
	dev->driver = driver;
34816870:	e5850024 	str	r0, [r5, #36]	; 0x24
	if (retval) { /* TODO */
		printf("target device_add failed, error %d\n", retval);
		return retval;
	}

	retval = driver->bind(&dev->gadget);
34816874:	e1a00005 	mov	r0, r5
34816878:	e12fff33 	blx	r3
	if (retval) {
3481687c:	e2504000 	subs	r4, r0, #0
		debug_cond(DEBUG_SETUP != 0,
			   "%s: bind to driver --> error %d\n",
			    dev->gadget.name, retval);
		dev->driver = 0;
34816880:	15856024 	strne	r6, [r5, #36]	; 0x24
		printf("target device_add failed, error %d\n", retval);
		return retval;
	}

	retval = driver->bind(&dev->gadget);
	if (retval) {
34816884:	1a000005 	bne	348168a0 <usb_gadget_register_driver+0x94>
 */
static int udc_enable(struct s3c_udc *dev)
{
	debug_cond(DEBUG_SETUP != 0, "%s: %p\n", __func__, dev);

	otg_phy_init(dev);
34816888:	e1a00005 	mov	r0, r5
3481688c:	ebfffca3 	bl	34815b20 <otg_phy_init>
	reconfig_usbd();
34816890:	ebfffb1c 	bl	34815508 <reconfig_usbd>

	debug_cond(DEBUG_SETUP != 0,
		   "S3C USB 2.0 OTG Controller Core Initialized : 0x%x\n",
		    readl(&reg->gintmsk));

	dev->gadget.speed = USB_SPEED_UNKNOWN;
34816894:	e5854010 	str	r4, [r5, #16]

	debug_cond(DEBUG_SETUP != 0,
		   "Registered gadget driver %s\n", dev->gadget.name);
	udc_enable(dev);

	return 0;
34816898:	ea000000 	b	348168a0 <usb_gadget_register_driver+0x94>

	if (!driver
	    || (driver->speed != USB_SPEED_FULL
		&& driver->speed != USB_SPEED_HIGH)
	    || !driver->bind || !driver->disconnect || !driver->setup)
		return -EINVAL;
3481689c:	e3e04015 	mvn	r4, #21
	debug_cond(DEBUG_SETUP != 0,
		   "Registered gadget driver %s\n", dev->gadget.name);
	udc_enable(dev);

	return 0;
}
348168a0:	e1a00004 	mov	r0, r4
348168a4:	e8bd8070 	pop	{r4, r5, r6, pc}
348168a8:	3482b310 	.word	0x3482b310

348168ac <usb_gadget_unregister_driver>:
/*
 * Unregister entry point for the peripheral controller driver.
 */
int usb_gadget_unregister_driver(struct usb_gadget_driver *driver)
{
	struct s3c_udc *dev = the_controller;
348168ac:	e59f3144 	ldr	r3, [pc, #324]	; 348169f8 <usb_gadget_unregister_driver+0x14c>

/*
 * Unregister entry point for the peripheral controller driver.
 */
int usb_gadget_unregister_driver(struct usb_gadget_driver *driver)
{
348168b0:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	struct s3c_udc *dev = the_controller;
348168b4:	e5934008 	ldr	r4, [r3, #8]

/*
 * Unregister entry point for the peripheral controller driver.
 */
int usb_gadget_unregister_driver(struct usb_gadget_driver *driver)
{
348168b8:	e1a07000 	mov	r7, r0
	struct s3c_udc *dev = the_controller;
	unsigned long flags;

	if (!dev)
348168bc:	e3540000 	cmp	r4, #0
		return -ENODEV;
348168c0:	03e00012 	mvneq	r0, #18
int usb_gadget_unregister_driver(struct usb_gadget_driver *driver)
{
	struct s3c_udc *dev = the_controller;
	unsigned long flags;

	if (!dev)
348168c4:	08bd8ef0 	popeq	{r4, r5, r6, r7, r9, sl, fp, pc}
		return -ENODEV;
	if (!driver || driver != dev->driver)
348168c8:	e3570000 	cmp	r7, #0
		return -EINVAL;
348168cc:	03e00015 	mvneq	r0, #21
	struct s3c_udc *dev = the_controller;
	unsigned long flags;

	if (!dev)
		return -ENODEV;
	if (!driver || driver != dev->driver)
348168d0:	08bd8ef0 	popeq	{r4, r5, r6, r7, r9, sl, fp, pc}
348168d4:	e5943024 	ldr	r3, [r4, #36]	; 0x24
348168d8:	e1570003 	cmp	r7, r3
348168dc:	1a000043 	bne	348169f0 <usb_gadget_unregister_driver+0x144>
			  struct usb_gadget_driver *driver)
{
	int i;

	/* don't disconnect drivers more than once */
	if (dev->gadget.speed == USB_SPEED_UNKNOWN)
348168e0:	e5949010 	ldr	r9, [r4, #16]
		return -ENODEV;
	if (!driver || driver != dev->driver)
		return -EINVAL;

	spin_lock_irqsave(&dev->lock, flags);
	dev->driver = 0;
348168e4:	e3a06000 	mov	r6, #0
			  struct usb_gadget_driver *driver)
{
	int i;

	/* don't disconnect drivers more than once */
	if (dev->gadget.speed == USB_SPEED_UNKNOWN)
348168e8:	e1590006 	cmp	r9, r6
		return -ENODEV;
	if (!driver || driver != dev->driver)
		return -EINVAL;

	spin_lock_irqsave(&dev->lock, flags);
	dev->driver = 0;
348168ec:	e5846024 	str	r6, [r4, #36]	; 0x24
			  struct usb_gadget_driver *driver)
{
	int i;

	/* don't disconnect drivers more than once */
	if (dev->gadget.speed == USB_SPEED_UNKNOWN)
348168f0:	11a09007 	movne	r9, r7
348168f4:	01a09006 	moveq	r9, r6
		driver = 0;
	dev->gadget.speed = USB_SPEED_UNKNOWN;
348168f8:	e5846010 	str	r6, [r4, #16]
348168fc:	e1a05004 	mov	r5, r4
34816900:	e1a0a004 	mov	sl, r4

	/* prevent new request submissions, kill any outstanding requests  */
	for (i = 0; i < S3C_MAX_ENDPOINTS; i++) {
		struct s3c_ep *ep = &dev->ep[i];
		ep->stopped = 1;
34816904:	e3a0b001 	mov	fp, #1
		driver = 0;
	dev->gadget.speed = USB_SPEED_UNKNOWN;

	/* prevent new request submissions, kill any outstanding requests  */
	for (i = 0; i < S3C_MAX_ENDPOINTS; i++) {
		struct s3c_ep *ep = &dev->ep[i];
34816908:	e0840306 	add	r0, r4, r6, lsl #6
		ep->stopped = 1;
3481690c:	e5cab08c 	strb	fp, [sl, #140]	; 0x8c
		nuke(ep, -ESHUTDOWN);
34816910:	e2800058 	add	r0, r0, #88	; 0x58
34816914:	e3e0106b 	mvn	r1, #107	; 0x6b
	if (dev->gadget.speed == USB_SPEED_UNKNOWN)
		driver = 0;
	dev->gadget.speed = USB_SPEED_UNKNOWN;

	/* prevent new request submissions, kill any outstanding requests  */
	for (i = 0; i < S3C_MAX_ENDPOINTS; i++) {
34816918:	e2866001 	add	r6, r6, #1
		struct s3c_ep *ep = &dev->ep[i];
		ep->stopped = 1;
		nuke(ep, -ESHUTDOWN);
3481691c:	ebfffb8c 	bl	34815754 <nuke>
	if (dev->gadget.speed == USB_SPEED_UNKNOWN)
		driver = 0;
	dev->gadget.speed = USB_SPEED_UNKNOWN;

	/* prevent new request submissions, kill any outstanding requests  */
	for (i = 0; i < S3C_MAX_ENDPOINTS; i++) {
34816920:	e3560004 	cmp	r6, #4
34816924:	e28aa040 	add	sl, sl, #64	; 0x40
34816928:	1afffff6 	bne	34816908 <usb_gadget_unregister_driver+0x5c>
		ep->stopped = 1;
		nuke(ep, -ESHUTDOWN);
	}

	/* report disconnect; the driver is already quiesced */
	if (driver) {
3481692c:	e3590000 	cmp	r9, #0
34816930:	0a000002 	beq	34816940 <usb_gadget_unregister_driver+0x94>
		spin_unlock(&dev->lock);
		driver->disconnect(&dev->gadget);
34816934:	e5993010 	ldr	r3, [r9, #16]
34816938:	e1a00004 	mov	r0, r4
3481693c:	e12fff33 	blx	r3

	debug_cond(DEBUG_SETUP != 0, "%s: %p\n", __func__, dev);

	/* device/ep0 records init */
	INIT_LIST_HEAD(&dev->gadget.ep_list);
	INIT_LIST_HEAD(&dev->gadget.ep0->ep_list);
34816940:	e5943004 	ldr	r3, [r4, #4]
	unsigned int i;

	debug_cond(DEBUG_SETUP != 0, "%s: %p\n", __func__, dev);

	/* device/ep0 records init */
	INIT_LIST_HEAD(&dev->gadget.ep_list);
34816944:	e2842008 	add	r2, r4, #8
	INIT_LIST_HEAD(&dev->gadget.ep0->ep_list);
34816948:	e283100c 	add	r1, r3, #12
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
3481694c:	e5842008 	str	r2, [r4, #8]
	list->prev = list;
34816950:	e584200c 	str	r2, [r4, #12]
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
34816954:	e583100c 	str	r1, [r3, #12]
	list->prev = list;
34816958:	e5831010 	str	r1, [r3, #16]
	dev->ep0state = WAIT_FOR_SETUP;
3481695c:	e3a03000 	mov	r3, #0
34816960:	e5843054 	str	r3, [r4, #84]	; 0x54
		struct s3c_ep *ep = &dev->ep[i];

		if (i != 0)
			list_add_tail(&ep->ep.ep_list, &dev->gadget.ep_list);

		ep->desc = 0;
34816964:	e1a06003 	mov	r6, r3
34816968:	ea000009 	b	34816994 <usb_gadget_unregister_driver+0xe8>

	/* basic endpoint records init */
	for (i = 0; i < S3C_MAX_ENDPOINTS; i++) {
		struct s3c_ep *ep = &dev->ep[i];

		if (i != 0)
3481696c:	e3530000 	cmp	r3, #0
34816970:	0a000006 	beq	34816990 <usb_gadget_unregister_driver+0xe4>
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
34816974:	e594100c 	ldr	r1, [r4, #12]
			list_add_tail(&ep->ep.ep_list, &dev->gadget.ep_list);
34816978:	e0840303 	add	r0, r4, r3, lsl #6
3481697c:	e2800064 	add	r0, r0, #100	; 0x64
 */
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
34816980:	e584000c 	str	r0, [r4, #12]
	new->next = next;
34816984:	e58520a4 	str	r2, [r5, #164]	; 0xa4
	new->prev = prev;
34816988:	e58510a8 	str	r1, [r5, #168]	; 0xa8
	prev->next = new;
3481698c:	e5810000 	str	r0, [r1]
34816990:	e2855040 	add	r5, r5, #64	; 0x40

		ep->desc = 0;
		ep->stopped = 0;
		INIT_LIST_HEAD(&ep->queue);
34816994:	e0841303 	add	r1, r4, r3, lsl #6
	INIT_LIST_HEAD(&dev->gadget.ep_list);
	INIT_LIST_HEAD(&dev->gadget.ep0->ep_list);
	dev->ep0state = WAIT_FOR_SETUP;

	/* basic endpoint records init */
	for (i = 0; i < S3C_MAX_ENDPOINTS; i++) {
34816998:	e2833001 	add	r3, r3, #1
		if (i != 0)
			list_add_tail(&ep->ep.ep_list, &dev->gadget.ep_list);

		ep->desc = 0;
		ep->stopped = 0;
		INIT_LIST_HEAD(&ep->queue);
3481699c:	e2811078 	add	r1, r1, #120	; 0x78
	INIT_LIST_HEAD(&dev->gadget.ep_list);
	INIT_LIST_HEAD(&dev->gadget.ep0->ep_list);
	dev->ep0state = WAIT_FOR_SETUP;

	/* basic endpoint records init */
	for (i = 0; i < S3C_MAX_ENDPOINTS; i++) {
348169a0:	e3530004 	cmp	r3, #4
		struct s3c_ep *ep = &dev->ep[i];

		if (i != 0)
			list_add_tail(&ep->ep.ep_list, &dev->gadget.ep_list);

		ep->desc = 0;
348169a4:	e5856074 	str	r6, [r5, #116]	; 0x74
		ep->stopped = 0;
348169a8:	e5c5608c 	strb	r6, [r5, #140]	; 0x8c
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
348169ac:	e5851078 	str	r1, [r5, #120]	; 0x78
	list->prev = list;
348169b0:	e585107c 	str	r1, [r5, #124]	; 0x7c
		INIT_LIST_HEAD(&ep->queue);
		ep->pio_irqs = 0;
348169b4:	e5856080 	str	r6, [r5, #128]	; 0x80
	INIT_LIST_HEAD(&dev->gadget.ep_list);
	INIT_LIST_HEAD(&dev->gadget.ep0->ep_list);
	dev->ep0state = WAIT_FOR_SETUP;

	/* basic endpoint records init */
	for (i = 0; i < S3C_MAX_ENDPOINTS; i++) {
348169b8:	1affffeb 	bne	3481696c <usb_gadget_unregister_driver+0xc0>
	spin_lock_irqsave(&dev->lock, flags);
	dev->driver = 0;
	stop_activity(dev, driver);
	spin_unlock_irqrestore(&dev->lock, flags);

	driver->unbind(&dev->gadget);
348169bc:	e5973008 	ldr	r3, [r7, #8]
348169c0:	e1a00004 	mov	r0, r4
348169c4:	e12fff33 	blx	r3
 */
static void udc_disable(struct s3c_udc *dev)
{
	debug_cond(DEBUG_SETUP != 0, "%s: %p\n", __func__, dev);

	udc_set_address(dev, 0);
348169c8:	e1a00004 	mov	r0, r4
348169cc:	e1a01006 	mov	r1, r6
348169d0:	ebfffc3d 	bl	34815acc <udc_set_address>

	dev->ep0state = WAIT_FOR_SETUP;
	dev->gadget.speed = USB_SPEED_UNKNOWN;
	dev->usb_address = 0;

	otg_phy_off(dev);
348169d4:	e1a00004 	mov	r0, r4
{
	debug_cond(DEBUG_SETUP != 0, "%s: %p\n", __func__, dev);

	udc_set_address(dev, 0);

	dev->ep0state = WAIT_FOR_SETUP;
348169d8:	e5846054 	str	r6, [r4, #84]	; 0x54
	dev->gadget.speed = USB_SPEED_UNKNOWN;
348169dc:	e5846010 	str	r6, [r4, #16]
	dev->usb_address = 0;
348169e0:	e5c46158 	strb	r6, [r4, #344]	; 0x158

	otg_phy_off(dev);
348169e4:	ebfffc80 	bl	34815bec <otg_phy_off>
	driver->unbind(&dev->gadget);

	disable_irq(IRQ_OTG);

	udc_disable(dev);
	return 0;
348169e8:	e1a00006 	mov	r0, r6
348169ec:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
	unsigned long flags;

	if (!dev)
		return -ENODEV;
	if (!driver || driver != dev->driver)
		return -EINVAL;
348169f0:	e3e00015 	mvn	r0, #21

	disable_irq(IRQ_OTG);

	udc_disable(dev);
	return 0;
}
348169f4:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
348169f8:	3482b310 	.word	0x3482b310

348169fc <s3c_udc_probe>:

	debug("%s: %p\n", __func__, pdata);

	dev->pdata = pdata;

	phy = (struct s3c_usbotg_phy *)pdata->regs_phy;
348169fc:	e59f3108 	ldr	r3, [pc, #264]	; 34816b0c <s3c_udc_probe+0x110>
34816a00:	e5902004 	ldr	r2, [r0, #4]
/*
 *	probe - binds to the platform device
 */

int s3c_udc_probe(struct s3c_plat_otg_data *pdata)
{
34816a04:	e92d4070 	push	{r4, r5, r6, lr}

	debug("%s: %p\n", __func__, pdata);

	dev->pdata = pdata;

	phy = (struct s3c_usbotg_phy *)pdata->regs_phy;
34816a08:	e5832010 	str	r2, [r3, #16]
	reg = (struct s3c_usbotg_reg *)pdata->regs_otg;
34816a0c:	e5902008 	ldr	r2, [r0, #8]
	struct s3c_udc *dev = &memory;
	int retval = 0, i;

	debug("%s: %p\n", __func__, pdata);

	dev->pdata = pdata;
34816a10:	e59f60f8 	ldr	r6, [pc, #248]	; 34816b10 <s3c_udc_probe+0x114>

	phy = (struct s3c_usbotg_phy *)pdata->regs_phy;
	reg = (struct s3c_usbotg_reg *)pdata->regs_otg;
34816a14:	e5832000 	str	r2, [r3]
	usb_phy_ctrl = pdata->usb_phy_ctrl;
34816a18:	e590200c 	ldr	r2, [r0, #12]
	dev->gadget.is_a_peripheral = 0;
	dev->gadget.b_hnp_enable = 0;
	dev->gadget.a_hnp_support = 0;
	dev->gadget.a_alt_hnp_support = 0;

	the_controller = dev;
34816a1c:	e2864010 	add	r4, r6, #16

	dev->pdata = pdata;

	phy = (struct s3c_usbotg_phy *)pdata->regs_phy;
	reg = (struct s3c_usbotg_reg *)pdata->regs_otg;
	usb_phy_ctrl = pdata->usb_phy_ctrl;
34816a20:	e583200c 	str	r2, [r3, #12]

	/* regs_otg = (void *)pdata->regs_otg; */

	dev->gadget.is_dualspeed = 1;	/* Hack only*/
34816a24:	e5d62024 	ldrb	r2, [r6, #36]	; 0x24
	struct s3c_udc *dev = &memory;
	int retval = 0, i;

	debug("%s: %p\n", __func__, pdata);

	dev->pdata = pdata;
34816a28:	e5860038 	str	r0, [r6, #56]	; 0x38
	usb_phy_ctrl = pdata->usb_phy_ctrl;

	/* regs_otg = (void *)pdata->regs_otg; */

	dev->gadget.is_dualspeed = 1;	/* Hack only*/
	dev->gadget.is_otg = 0;
34816a2c:	e3822001 	orr	r2, r2, #1
	dev->gadget.is_a_peripheral = 0;
	dev->gadget.b_hnp_enable = 0;
	dev->gadget.a_hnp_support = 0;
	dev->gadget.a_alt_hnp_support = 0;
34816a30:	e20220e1 	and	r2, r2, #225	; 0xe1
34816a34:	e7c5229f 	bfc	r2, #5, #1
34816a38:	e5c62024 	strb	r2, [r6, #36]	; 0x24

	the_controller = dev;
34816a3c:	e2865038 	add	r5, r6, #56	; 0x38
34816a40:	e5834008 	str	r4, [r3, #8]

/*
 *	probe - binds to the platform device
 */

int s3c_udc_probe(struct s3c_plat_otg_data *pdata)
34816a44:	e286604c 	add	r6, r6, #76	; 0x4c
	dev->gadget.a_alt_hnp_support = 0;

	the_controller = dev;

	for (i = 0; i < S3C_MAX_ENDPOINTS+1; i++) {
		dev->dma_buf[i] = memalign(CONFIG_SYS_CACHELINE_SIZE,
34816a48:	e3a01901 	mov	r1, #16384	; 0x4000
34816a4c:	e3a00040 	mov	r0, #64	; 0x40
34816a50:	ebffcca9 	bl	34809cfc <memalign>
34816a54:	e5a50004 	str	r0, [r5, #4]!
					   DMA_BUFFER_SIZE);
		dev->dma_addr[i] = (dma_addr_t) dev->dma_buf[i];
34816a58:	e5850014 	str	r0, [r5, #20]
		invalidate_dcache_range((unsigned long) dev->dma_buf[i],
34816a5c:	e2801901 	add	r1, r0, #16384	; 0x4000
34816a60:	ebffa952 	bl	34800fb0 <invalidate_dcache_range>
	dev->gadget.a_hnp_support = 0;
	dev->gadget.a_alt_hnp_support = 0;

	the_controller = dev;

	for (i = 0; i < S3C_MAX_ENDPOINTS+1; i++) {
34816a64:	e1550006 	cmp	r5, r6
34816a68:	1afffff6 	bne	34816a48 <s3c_udc_probe+0x4c>
		dev->dma_addr[i] = (dma_addr_t) dev->dma_buf[i];
		invalidate_dcache_range((unsigned long) dev->dma_buf[i],
					(unsigned long) (dev->dma_buf[i]
							 + DMA_BUFFER_SIZE));
	}
	usb_ctrl = dev->dma_buf[0];
34816a6c:	e59f309c 	ldr	r3, [pc, #156]	; 34816b10 <s3c_udc_probe+0x114>
34816a70:	e59f2094 	ldr	r2, [pc, #148]	; 34816b0c <s3c_udc_probe+0x110>
34816a74:	e593103c 	ldr	r1, [r3, #60]	; 0x3c
34816a78:	e5821018 	str	r1, [r2, #24]
	usb_ctrl_dma_addr = dev->dma_addr[0];
34816a7c:	e5931050 	ldr	r1, [r3, #80]	; 0x50
34816a80:	e5821004 	str	r1, [r2, #4]

	debug_cond(DEBUG_SETUP != 0, "%s: %p\n", __func__, dev);

	/* device/ep0 records init */
	INIT_LIST_HEAD(&dev->gadget.ep_list);
	INIT_LIST_HEAD(&dev->gadget.ep0->ep_list);
34816a84:	e5932014 	ldr	r2, [r3, #20]
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
34816a88:	e2831018 	add	r1, r3, #24
34816a8c:	e282000c 	add	r0, r2, #12
34816a90:	e582000c 	str	r0, [r2, #12]
	list->prev = list;
34816a94:	e5820010 	str	r0, [r2, #16]
	dev->ep0state = WAIT_FOR_SETUP;
34816a98:	e3a02000 	mov	r2, #0
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
34816a9c:	e5831018 	str	r1, [r3, #24]
34816aa0:	e5832064 	str	r2, [r3, #100]	; 0x64
		struct s3c_ep *ep = &dev->ep[i];

		if (i != 0)
			list_add_tail(&ep->ep.ep_list, &dev->gadget.ep_list);

		ep->desc = 0;
34816aa4:	e1a00002 	mov	r0, r2
		ep->stopped = 0;
		INIT_LIST_HEAD(&ep->queue);
34816aa8:	e2833010 	add	r3, r3, #16
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
	new->next = next;
34816aac:	e1a05001 	mov	r5, r1
34816ab0:	ea000008 	b	34816ad8 <s3c_udc_probe+0xdc>

	/* basic endpoint records init */
	for (i = 0; i < S3C_MAX_ENDPOINTS; i++) {
		struct s3c_ep *ep = &dev->ep[i];

		if (i != 0)
34816ab4:	e3520000 	cmp	r2, #0
34816ab8:	0a000005 	beq	34816ad4 <s3c_udc_probe+0xd8>
			list_add_tail(&ep->ep.ep_list, &dev->gadget.ep_list);
34816abc:	e083c302 	add	ip, r3, r2, lsl #6
34816ac0:	e28cc064 	add	ip, ip, #100	; 0x64
34816ac4:	e58450a4 	str	r5, [r4, #164]	; 0xa4
	new->prev = prev;
34816ac8:	e58410a8 	str	r1, [r4, #168]	; 0xa8
	prev->next = new;
34816acc:	e581c000 	str	ip, [r1]
 */
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
34816ad0:	e1a0100c 	mov	r1, ip
	new->next = next;
	new->prev = prev;
	prev->next = new;
34816ad4:	e2844040 	add	r4, r4, #64	; 0x40

		ep->desc = 0;
		ep->stopped = 0;
		INIT_LIST_HEAD(&ep->queue);
34816ad8:	e083c302 	add	ip, r3, r2, lsl #6
	INIT_LIST_HEAD(&dev->gadget.ep_list);
	INIT_LIST_HEAD(&dev->gadget.ep0->ep_list);
	dev->ep0state = WAIT_FOR_SETUP;

	/* basic endpoint records init */
	for (i = 0; i < S3C_MAX_ENDPOINTS; i++) {
34816adc:	e2822001 	add	r2, r2, #1
		if (i != 0)
			list_add_tail(&ep->ep.ep_list, &dev->gadget.ep_list);

		ep->desc = 0;
		ep->stopped = 0;
		INIT_LIST_HEAD(&ep->queue);
34816ae0:	e28cc078 	add	ip, ip, #120	; 0x78
	INIT_LIST_HEAD(&dev->gadget.ep_list);
	INIT_LIST_HEAD(&dev->gadget.ep0->ep_list);
	dev->ep0state = WAIT_FOR_SETUP;

	/* basic endpoint records init */
	for (i = 0; i < S3C_MAX_ENDPOINTS; i++) {
34816ae4:	e3520004 	cmp	r2, #4
		struct s3c_ep *ep = &dev->ep[i];

		if (i != 0)
			list_add_tail(&ep->ep.ep_list, &dev->gadget.ep_list);

		ep->desc = 0;
34816ae8:	e5840074 	str	r0, [r4, #116]	; 0x74
		ep->stopped = 0;
34816aec:	e5c4008c 	strb	r0, [r4, #140]	; 0x8c
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
34816af0:	e584c078 	str	ip, [r4, #120]	; 0x78
	list->prev = list;
34816af4:	e584c07c 	str	ip, [r4, #124]	; 0x7c
		INIT_LIST_HEAD(&ep->queue);
		ep->pio_irqs = 0;
34816af8:	e5840080 	str	r0, [r4, #128]	; 0x80
	INIT_LIST_HEAD(&dev->gadget.ep_list);
	INIT_LIST_HEAD(&dev->gadget.ep0->ep_list);
	dev->ep0state = WAIT_FOR_SETUP;

	/* basic endpoint records init */
	for (i = 0; i < S3C_MAX_ENDPOINTS; i++) {
34816afc:	1affffec 	bne	34816ab4 <s3c_udc_probe+0xb8>
34816b00:	e59f3008 	ldr	r3, [pc, #8]	; 34816b10 <s3c_udc_probe+0x114>
34816b04:	e583101c 	str	r1, [r3, #28]
	usb_ctrl_dma_addr = dev->dma_addr[0];

	udc_reinit(dev);

	return retval;
}
34816b08:	e8bd8070 	pop	{r4, r5, r6, pc}
34816b0c:	3482b310 	.word	0x3482b310
34816b10:	34828a10 	.word	0x34828a10

34816b14 <usb_gadget_handle_interrupts>:

int usb_gadget_handle_interrupts()
{
34816b14:	e92d4eff 	push	{r0, r1, r2, r3, r4, r5, r6, r7, r9, sl, fp, lr}
	u32 intr_status = readl(&reg->gintsts);
34816b18:	e59f3434 	ldr	r3, [pc, #1076]	; 34816f54 <usb_gadget_handle_interrupts+0x440>
34816b1c:	e5932000 	ldr	r2, [r3]
34816b20:	e5922014 	ldr	r2, [r2, #20]
	u32 gintmsk = readl(&reg->gintmsk);
34816b24:	e5931000 	ldr	r1, [r3]
34816b28:	e5910018 	ldr	r0, [r1, #24]

	if (intr_status & gintmsk)
34816b2c:	e0100002 	ands	r0, r0, r2
34816b30:	0a000105 	beq	34816f4c <usb_gadget_handle_interrupts+0x438>
	u32 usb_status, gintmsk;
	unsigned long flags;

	spin_lock_irqsave(&dev->lock, flags);

	intr_status = readl(&reg->gintsts);
34816b34:	e5932000 	ldr	r2, [r3]
		return s3c_udc_irq(1, (void *)the_controller);
34816b38:	e5934008 	ldr	r4, [r3, #8]
34816b3c:	e5926014 	ldr	r6, [r2, #20]
		  "\n*** %s : GINTSTS=0x%x(on state %s), GINTMSK : 0x%x,"
		  "DAINT : 0x%x, DAINTMSK : 0x%x\n",
		  __func__, intr_status, state_names[dev->ep0state], gintmsk,
		  readl(&reg->daint), readl(&reg->daintmsk));

	if (!intr_status) {
34816b40:	e3560000 	cmp	r6, #0
34816b44:	0a0000ff 	beq	34816f48 <usb_gadget_handle_interrupts+0x434>
		spin_unlock_irqrestore(&dev->lock, flags);
		return IRQ_HANDLED;
	}

	if (intr_status & INT_ENUMDONE) {
34816b48:	e3160a02 	tst	r6, #8192	; 0x2000
34816b4c:	0a000009 	beq	34816b78 <usb_gadget_handle_interrupts+0x64>
		debug_cond(DEBUG_ISR, "\tSpeed Detection interrupt\n");

		writel(INT_ENUMDONE, &reg->gintsts);
34816b50:	e5933000 	ldr	r3, [r3]
34816b54:	e3a02a02 	mov	r2, #8192	; 0x2000
34816b58:	e5832014 	str	r2, [r3, #20]
		usb_status = (readl(&reg->dsts) & 0x6);
34816b5c:	e5933808 	ldr	r3, [r3, #2056]	; 0x808

		if (usb_status & (USB_FULL_30_60MHZ | USB_FULL_48MHZ)) {
34816b60:	e3130006 	tst	r3, #6
			debug_cond(DEBUG_ISR,
				   "\t\tFull Speed Detection\n");
			set_max_pktsize(dev, USB_SPEED_FULL);
34816b64:	11a00004 	movne	r0, r4
34816b68:	13a01002 	movne	r1, #2

		} else {
			debug_cond(DEBUG_ISR,
				"\t\tHigh Speed Detection : 0x%x\n",
				usb_status);
			set_max_pktsize(dev, USB_SPEED_HIGH);
34816b6c:	01a00004 	moveq	r0, r4
34816b70:	03a01003 	moveq	r1, #3
34816b74:	ebfffa35 	bl	34815450 <set_max_pktsize>
		}
	}

	if (intr_status & INT_EARLY_SUSPEND) {
34816b78:	e3160b01 	tst	r6, #1024	; 0x400
34816b7c:	0a000003 	beq	34816b90 <usb_gadget_handle_interrupts+0x7c>
		debug_cond(DEBUG_ISR, "\tEarly suspend interrupt\n");
		writel(INT_EARLY_SUSPEND, &reg->gintsts);
34816b80:	e59f33cc 	ldr	r3, [pc, #972]	; 34816f54 <usb_gadget_handle_interrupts+0x440>
34816b84:	e3a02b01 	mov	r2, #1024	; 0x400
34816b88:	e5933000 	ldr	r3, [r3]
34816b8c:	e5832014 	str	r2, [r3, #20]
	}

	if (intr_status & INT_SUSPEND) {
34816b90:	e3160b02 	tst	r6, #2048	; 0x800
34816b94:	0a000014 	beq	34816bec <usb_gadget_handle_interrupts+0xd8>
		usb_status = readl(&reg->dsts);
		debug_cond(DEBUG_ISR,
			"\tSuspend interrupt :(DSTS):0x%x\n", usb_status);
		writel(INT_SUSPEND, &reg->gintsts);
34816b98:	e59f33b4 	ldr	r3, [pc, #948]	; 34816f54 <usb_gadget_handle_interrupts+0x440>
34816b9c:	e3a02b02 	mov	r2, #2048	; 0x800
34816ba0:	e5933000 	ldr	r3, [r3]
34816ba4:	e5832014 	str	r2, [r3, #20]

		if (dev->gadget.speed != USB_SPEED_UNKNOWN
34816ba8:	e5943010 	ldr	r3, [r4, #16]
34816bac:	e3530000 	cmp	r3, #0
34816bb0:	0a00000d 	beq	34816bec <usb_gadget_handle_interrupts+0xd8>
		    && dev->driver) {
34816bb4:	e5943024 	ldr	r3, [r4, #36]	; 0x24
34816bb8:	e3530000 	cmp	r3, #0
34816bbc:	0a00000a 	beq	34816bec <usb_gadget_handle_interrupts+0xd8>
			if (dev->driver->suspend)
34816bc0:	e5933014 	ldr	r3, [r3, #20]
34816bc4:	e3530000 	cmp	r3, #0
34816bc8:	0a000001 	beq	34816bd4 <usb_gadget_handle_interrupts+0xc0>
				dev->driver->suspend(&dev->gadget);
34816bcc:	e1a00004 	mov	r0, r4
34816bd0:	e12fff33 	blx	r3

			/* HACK to let gadget detect disconnected state */
			if (dev->driver->disconnect) {
34816bd4:	e5943024 	ldr	r3, [r4, #36]	; 0x24
34816bd8:	e5933010 	ldr	r3, [r3, #16]
34816bdc:	e3530000 	cmp	r3, #0
34816be0:	0a000001 	beq	34816bec <usb_gadget_handle_interrupts+0xd8>
				spin_unlock_irqrestore(&dev->lock, flags);
				dev->driver->disconnect(&dev->gadget);
34816be4:	e1a00004 	mov	r0, r4
34816be8:	e12fff33 	blx	r3
				spin_lock_irqsave(&dev->lock, flags);
			}
		}
	}

	if (intr_status & INT_RESUME) {
34816bec:	e3560000 	cmp	r6, #0
34816bf0:	aa00000e 	bge	34816c30 <usb_gadget_handle_interrupts+0x11c>
		debug_cond(DEBUG_ISR, "\tResume interrupt\n");
		writel(INT_RESUME, &reg->gintsts);
34816bf4:	e59f3358 	ldr	r3, [pc, #856]	; 34816f54 <usb_gadget_handle_interrupts+0x440>
34816bf8:	e3a02102 	mov	r2, #-2147483648	; 0x80000000
34816bfc:	e5933000 	ldr	r3, [r3]
34816c00:	e5832014 	str	r2, [r3, #20]

		if (dev->gadget.speed != USB_SPEED_UNKNOWN
34816c04:	e5943010 	ldr	r3, [r4, #16]
34816c08:	e3530000 	cmp	r3, #0
34816c0c:	0a000007 	beq	34816c30 <usb_gadget_handle_interrupts+0x11c>
		    && dev->driver
34816c10:	e5943024 	ldr	r3, [r4, #36]	; 0x24
34816c14:	e3530000 	cmp	r3, #0
34816c18:	0a000004 	beq	34816c30 <usb_gadget_handle_interrupts+0x11c>
		    && dev->driver->resume) {
34816c1c:	e5933018 	ldr	r3, [r3, #24]
34816c20:	e3530000 	cmp	r3, #0
34816c24:	0a000001 	beq	34816c30 <usb_gadget_handle_interrupts+0x11c>

			dev->driver->resume(&dev->gadget);
34816c28:	e1a00004 	mov	r0, r4
34816c2c:	e12fff33 	blx	r3
		}
	}

	if (intr_status & INT_RESET) {
34816c30:	e3160a01 	tst	r6, #4096	; 0x1000
34816c34:	0a000014 	beq	34816c8c <usb_gadget_handle_interrupts+0x178>
		usb_status = readl(&reg->gotgctl);
34816c38:	e59f3314 	ldr	r3, [pc, #788]	; 34816f54 <usb_gadget_handle_interrupts+0x440>
34816c3c:	e5932000 	ldr	r2, [r3]
34816c40:	e5922000 	ldr	r2, [r2]
		debug_cond(DEBUG_ISR,
			"\tReset interrupt - (GOTGCTL):0x%x\n", usb_status);
		writel(INT_RESET, &reg->gintsts);
34816c44:	e5933000 	ldr	r3, [r3]
34816c48:	e3a01a01 	mov	r1, #4096	; 0x1000
34816c4c:	e5831014 	str	r1, [r3, #20]

		if ((usb_status & 0xc0000) == (0x3 << 18)) {
34816c50:	e2023703 	and	r3, r2, #786432	; 0xc0000
34816c54:	e3530703 	cmp	r3, #786432	; 0xc0000
34816c58:	e59f52f8 	ldr	r5, [pc, #760]	; 34816f58 <usb_gadget_handle_interrupts+0x444>
34816c5c:	1a000008 	bne	34816c84 <usb_gadget_handle_interrupts+0x170>
			if (reset_available) {
34816c60:	e595300c 	ldr	r3, [r5, #12]
34816c64:	e3530000 	cmp	r3, #0
34816c68:	0a000005 	beq	34816c84 <usb_gadget_handle_interrupts+0x170>
				debug_cond(DEBUG_ISR,
					"\t\tOTG core got reset (%d)!!\n",
					reset_available);
				reconfig_usbd();
34816c6c:	ebfffa25 	bl	34815508 <reconfig_usbd>
				dev->ep0state = WAIT_FOR_SETUP;
34816c70:	e3a03000 	mov	r3, #0
34816c74:	e5843054 	str	r3, [r4, #84]	; 0x54
				reset_available = 0;
34816c78:	e585300c 	str	r3, [r5, #12]
				s3c_udc_pre_setup();
34816c7c:	ebfffc00 	bl	34815c84 <s3c_udc_pre_setup>
34816c80:	ea000001 	b	34816c8c <usb_gadget_handle_interrupts+0x178>
			} else
				reset_available = 1;

		} else {
			reset_available = 1;
34816c84:	e3a03001 	mov	r3, #1
34816c88:	e585300c 	str	r3, [r5, #12]
			debug_cond(DEBUG_ISR,
				   "\t\tRESET handling skipped\n");
		}
	}

	if (intr_status & INT_IN_EP)
34816c8c:	e3160701 	tst	r6, #262144	; 0x40000
34816c90:	0a00007a 	beq	34816e80 <usb_gadget_handle_interrupts+0x36c>
static void process_ep_in_intr(struct s3c_udc *dev)
{
	u32 ep_intr, ep_intr_status;
	u8 ep_num = 0;

	ep_intr = readl(&reg->daint);
34816c94:	e59f72b8 	ldr	r7, [pc, #696]	; 34816f54 <usb_gadget_handle_interrupts+0x440>
34816c98:	e5973000 	ldr	r3, [r7]
34816c9c:	e5939818 	ldr	r9, [r3, #2072]	; 0x818
}

static void process_ep_in_intr(struct s3c_udc *dev)
{
	u32 ep_intr, ep_intr_status;
	u8 ep_num = 0;
34816ca0:	e3a05000 	mov	r5, #0

	ep_intr = readl(&reg->daint);
	debug_cond(DEBUG_IN_EP,
		"*** %s: EP In interrupt : DAINT = 0x%x\n", __func__, ep_intr);

	ep_intr &= DAINT_MASK;
34816ca4:	e6ff9079 	uxth	r9, r9
34816ca8:	e58d6004 	str	r6, [sp, #4]
34816cac:	ea000070 	b	34816e74 <usb_gadget_handle_interrupts+0x360>

	while (ep_intr) {
		if (ep_intr & DAINT_IN_EP_INT(1)) {
34816cb0:	e3190001 	tst	r9, #1
34816cb4:	0a00006b 	beq	34816e68 <usb_gadget_handle_interrupts+0x354>
			ep_intr_status = readl(&reg->in_endp[ep_num].diepint);
34816cb8:	e5973000 	ldr	r3, [r7]
34816cbc:	e1a02285 	lsl	r2, r5, #5
34816cc0:	e0833002 	add	r3, r3, r2
34816cc4:	e5933908 	ldr	r3, [r3, #2312]	; 0x908
			debug_cond(DEBUG_IN_EP,
				   "\tEP%d-IN : DIEPINT = 0x%x\n",
				   ep_num, ep_intr_status);

			/* Interrupt Clear */
			writel(ep_intr_status, &reg->in_endp[ep_num].diepint);
34816cc8:	e2822c09 	add	r2, r2, #2304	; 0x900
34816ccc:	e5971000 	ldr	r1, [r7]
34816cd0:	e2822008 	add	r2, r2, #8

			if (ep_intr_status & TRANSFER_DONE) {
34816cd4:	e3130001 	tst	r3, #1
			debug_cond(DEBUG_IN_EP,
				   "\tEP%d-IN : DIEPINT = 0x%x\n",
				   ep_num, ep_intr_status);

			/* Interrupt Clear */
			writel(ep_intr_status, &reg->in_endp[ep_num].diepint);
34816cd8:	e7813002 	str	r3, [r1, r2]

			if (ep_intr_status & TRANSFER_DONE) {
34816cdc:	0a000061 	beq	34816e68 <usb_gadget_handle_interrupts+0x354>
	struct s3c_ep *ep = &dev->ep[ep_num];
	struct s3c_request *req;
	u32 ep_tsr = 0, xfer_size = 0, is_short = 0;
	u32 last;

	if (dev->ep0state == WAIT_FOR_NULL_COMPLETE) {
34816ce0:	e5943054 	ldr	r3, [r4, #84]	; 0x54
34816ce4:	e3530008 	cmp	r3, #8
34816ce8:	1a000003 	bne	34816cfc <usb_gadget_handle_interrupts+0x1e8>
		dev->ep0state = WAIT_FOR_OUT_COMPLETE;
34816cec:	e3a00006 	mov	r0, #6
34816cf0:	e5840054 	str	r0, [r4, #84]	; 0x54
		s3c_ep0_complete_out();
34816cf4:	ebfffab3 	bl	348157c8 <s3c_ep0_complete_out>
34816cf8:	ea00003a 	b	34816de8 <usb_gadget_handle_interrupts+0x2d4>
		return;
	}

	if (list_empty(&ep->queue)) {
34816cfc:	e1a06305 	lsl	r6, r5, #6
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
34816d00:	e0843006 	add	r3, r4, r6
34816d04:	e286b078 	add	fp, r6, #120	; 0x78
34816d08:	e5933078 	ldr	r3, [r3, #120]	; 0x78
34816d0c:	e084b00b 	add	fp, r4, fp
34816d10:	e153000b 	cmp	r3, fp
34816d14:	0a000033 	beq	34816de8 <usb_gadget_handle_interrupts+0x2d4>
		setdma_rx(ep, req);
}

static void complete_tx(struct s3c_udc *dev, u8 ep_num)
{
	struct s3c_ep *ep = &dev->ep[ep_num];
34816d18:	e2866058 	add	r6, r6, #88	; 0x58
34816d1c:	e0846006 	add	r6, r4, r6
			__func__, ep_num);
		return;

	}

	req = list_entry(ep->queue.next, struct s3c_request, queue);
34816d20:	e2431028 	sub	r1, r3, #40	; 0x28

	ep_tsr = readl(&reg->in_endp[ep_num].dieptsiz);

	xfer_size = ep->len;
	is_short = (xfer_size < ep->ep.maxpacket);
	req->req.actual += min(xfer_size, req->req.length - req->req.actual);
34816d24:	e513a004 	ldr	sl, [r3, #-4]
34816d28:	e5132024 	ldr	r2, [r3, #-36]	; 0x24

	req = list_entry(ep->queue.next, struct s3c_request, queue);

	ep_tsr = readl(&reg->in_endp[ep_num].dieptsiz);

	xfer_size = ep->len;
34816d2c:	e0840305 	add	r0, r4, r5, lsl #6
	is_short = (xfer_size < ep->ep.maxpacket);
	req->req.actual += min(xfer_size, req->req.length - req->req.actual);
34816d30:	e5900084 	ldr	r0, [r0, #132]	; 0x84
34816d34:	e06ac002 	rsb	ip, sl, r2
34816d38:	e15c0000 	cmp	ip, r0
34816d3c:	908aa00c 	addls	sl, sl, ip
34816d40:	808aa000 	addhi	sl, sl, r0
		"%s: TX DMA done : ep = %d, tx bytes = %d/%d, "
		"is_short = %d, DIEPTSIZ = 0x%x, remained bytes = %d\n",
		__func__, ep_num, req->req.actual, req->req.length,
		is_short, ep_tsr, xfer_size);

	if (ep_num == 0) {
34816d44:	e3550000 	cmp	r5, #0

	ep_tsr = readl(&reg->in_endp[ep_num].dieptsiz);

	xfer_size = ep->len;
	is_short = (xfer_size < ep->ep.maxpacket);
	req->req.actual += min(xfer_size, req->req.length - req->req.actual);
34816d48:	e503a004 	str	sl, [r3, #-4]
		"%s: TX DMA done : ep = %d, tx bytes = %d/%d, "
		"is_short = %d, DIEPTSIZ = 0x%x, remained bytes = %d\n",
		__func__, ep_num, req->req.actual, req->req.length,
		is_short, ep_tsr, xfer_size);

	if (ep_num == 0) {
34816d4c:	1a000018 	bne	34816db4 <usb_gadget_handle_interrupts+0x2a0>
		if (dev->ep0state == DATA_STATE_XMIT) {
34816d50:	e5943054 	ldr	r3, [r4, #84]	; 0x54
34816d54:	e3530001 	cmp	r3, #1
34816d58:	1a000005 	bne	34816d74 <usb_gadget_handle_interrupts+0x260>
			debug_cond(DEBUG_IN_EP,
				"%s: ep_num = %d, ep0stat =="
				"DATA_STATE_XMIT\n",
				__func__, ep_num);
			last = write_fifo_ep0(ep, req);
34816d5c:	e1a00006 	mov	r0, r6
34816d60:	ebfffc31 	bl	34815e2c <write_fifo_ep0>
			if (last)
34816d64:	e3500000 	cmp	r0, #0
				dev->ep0state = WAIT_FOR_COMPLETE;
34816d68:	13a00005 	movne	r0, #5
34816d6c:	15840054 	strne	r0, [r4, #84]	; 0x54
34816d70:	ea00001e 	b	34816df0 <usb_gadget_handle_interrupts+0x2dc>
		} else if (dev->ep0state == WAIT_FOR_IN_COMPLETE) {
34816d74:	e3530007 	cmp	r3, #7
34816d78:	1a000004 	bne	34816d90 <usb_gadget_handle_interrupts+0x27c>
			debug_cond(DEBUG_IN_EP,
				"%s: ep_num = %d, completing request\n",
				__func__, ep_num);
			done(ep, req, 0);
34816d7c:	e1a00006 	mov	r0, r6
34816d80:	e1a02005 	mov	r2, r5
34816d84:	ebfffa41 	bl	34815690 <done>
			dev->ep0state = WAIT_FOR_SETUP;
34816d88:	e5845054 	str	r5, [r4, #84]	; 0x54
34816d8c:	ea000017 	b	34816df0 <usb_gadget_handle_interrupts+0x2dc>
		} else if (dev->ep0state == WAIT_FOR_COMPLETE) {
34816d90:	e3530005 	cmp	r3, #5
34816d94:	1a000015 	bne	34816df0 <usb_gadget_handle_interrupts+0x2dc>
			debug_cond(DEBUG_IN_EP,
				"%s: ep_num = %d, completing request\n",
				__func__, ep_num);
			done(ep, req, 0);
34816d98:	e1a00006 	mov	r0, r6
34816d9c:	e1a02005 	mov	r2, r5
34816da0:	ebfffa3a 	bl	34815690 <done>
			dev->ep0state = WAIT_FOR_OUT_COMPLETE;
34816da4:	e3a03006 	mov	r3, #6
34816da8:	e5843054 	str	r3, [r4, #84]	; 0x54
			s3c_ep0_complete_out();
34816dac:	ebfffa85 	bl	348157c8 <s3c_ep0_complete_out>
34816db0:	ea00000e 	b	34816df0 <usb_gadget_handle_interrupts+0x2dc>
				__func__, ep_num);
		}
		return;
	}

	if (req->req.actual == req->req.length)
34816db4:	e15a0002 	cmp	sl, r2
34816db8:	1a000002 	bne	34816dc8 <usb_gadget_handle_interrupts+0x2b4>
		done(ep, req, 0);
34816dbc:	e1a00006 	mov	r0, r6
34816dc0:	e3a02000 	mov	r2, #0
34816dc4:	ebfffa31 	bl	34815690 <done>
34816dc8:	e0843305 	add	r3, r4, r5, lsl #6
34816dcc:	e5931078 	ldr	r1, [r3, #120]	; 0x78

	if (!list_empty(&ep->queue)) {
34816dd0:	e151000b 	cmp	r1, fp
34816dd4:	0a000023 	beq	34816e68 <usb_gadget_handle_interrupts+0x354>
		req = list_entry(ep->queue.next, struct s3c_request, queue);
		debug_cond(DEBUG_IN_EP,
			"%s: Next Tx request start...\n", __func__);
		setdma_tx(ep, req);
34816dd8:	e1a00006 	mov	r0, r6
34816ddc:	e2411028 	sub	r1, r1, #40	; 0x28
34816de0:	ebfffbc6 	bl	34815d00 <setdma_tx>
34816de4:	ea00001f 	b	34816e68 <usb_gadget_handle_interrupts+0x354>
			writel(ep_intr_status, &reg->in_endp[ep_num].diepint);

			if (ep_intr_status & TRANSFER_DONE) {
				complete_tx(dev, ep_num);

				if (ep_num == 0) {
34816de8:	e3550000 	cmp	r5, #0
34816dec:	1a00001d 	bne	34816e68 <usb_gadget_handle_interrupts+0x354>
					if (dev->ep0state ==
34816df0:	e5943054 	ldr	r3, [r4, #84]	; 0x54
34816df4:	e3530007 	cmp	r3, #7
					    WAIT_FOR_IN_COMPLETE)
						dev->ep0state = WAIT_FOR_SETUP;
34816df8:	03a0a000 	moveq	sl, #0
34816dfc:	0584a054 	streq	sl, [r4, #84]	; 0x54

					if (dev->ep0state == WAIT_FOR_SETUP)
34816e00:	e5943054 	ldr	r3, [r4, #84]	; 0x54
34816e04:	e3530000 	cmp	r3, #0
34816e08:	1a000000 	bne	34816e10 <usb_gadget_handle_interrupts+0x2fc>
						s3c_udc_pre_setup();
34816e0c:	ebfffb9c 	bl	34815c84 <s3c_udc_pre_setup>

					/* continue transfer after
					   set_clear_halt for DMA mode */
					if (clear_feature_flag == 1) {
34816e10:	e5973020 	ldr	r3, [r7, #32]
34816e14:	e3530001 	cmp	r3, #1
34816e18:	1a000012 	bne	34816e68 <usb_gadget_handle_interrupts+0x354>
	}
}

static inline void s3c_udc_check_tx_queue(struct s3c_udc *dev, u8 ep_num)
{
	struct s3c_ep *ep = &dev->ep[ep_num];
34816e1c:	e5d7001c 	ldrb	r0, [r7, #28]
34816e20:	e1a00300 	lsl	r0, r0, #6
34816e24:	e0843000 	add	r3, r4, r0
34816e28:	e5931078 	ldr	r1, [r3, #120]	; 0x78
	struct s3c_request *req;

	debug_cond(DEBUG_IN_EP,
		"%s: Check queue, ep_num = %d\n", __func__, ep_num);

	if (!list_empty(&ep->queue)) {
34816e2c:	e2802078 	add	r2, r0, #120	; 0x78
34816e30:	e0842002 	add	r2, r4, r2
34816e34:	e1510002 	cmp	r1, r2
34816e38:	0a000008 	beq	34816e60 <usb_gadget_handle_interrupts+0x34c>
		req = list_entry(ep->queue.next, struct s3c_request, queue);
		debug_cond(DEBUG_IN_EP,
			"%s: Next Tx request(0x%p) start...\n",
			__func__, req);

		if (ep_is_in(ep))
34816e3c:	e1d338dd 	ldrsb	r3, [r3, #141]	; 0x8d
	}
}

static inline void s3c_udc_check_tx_queue(struct s3c_udc *dev, u8 ep_num)
{
	struct s3c_ep *ep = &dev->ep[ep_num];
34816e40:	e2800058 	add	r0, r0, #88	; 0x58
		req = list_entry(ep->queue.next, struct s3c_request, queue);
		debug_cond(DEBUG_IN_EP,
			"%s: Next Tx request(0x%p) start...\n",
			__func__, req);

		if (ep_is_in(ep))
34816e44:	e3530000 	cmp	r3, #0
	}
}

static inline void s3c_udc_check_tx_queue(struct s3c_udc *dev, u8 ep_num)
{
	struct s3c_ep *ep = &dev->ep[ep_num];
34816e48:	e0840000 	add	r0, r4, r0

	debug_cond(DEBUG_IN_EP,
		"%s: Check queue, ep_num = %d\n", __func__, ep_num);

	if (!list_empty(&ep->queue)) {
		req = list_entry(ep->queue.next, struct s3c_request, queue);
34816e4c:	e2411028 	sub	r1, r1, #40	; 0x28
		debug_cond(DEBUG_IN_EP,
			"%s: Next Tx request(0x%p) start...\n",
			__func__, req);

		if (ep_is_in(ep))
34816e50:	aa000001 	bge	34816e5c <usb_gadget_handle_interrupts+0x348>
			setdma_tx(ep, req);
34816e54:	ebfffba9 	bl	34815d00 <setdma_tx>
34816e58:	ea000000 	b	34816e60 <usb_gadget_handle_interrupts+0x34c>
		else
			setdma_rx(ep, req);
34816e5c:	ebfffa6b 	bl	34815810 <setdma_rx>
					/* continue transfer after
					   set_clear_halt for DMA mode */
					if (clear_feature_flag == 1) {
						s3c_udc_check_tx_queue(dev,
							clear_feature_num);
						clear_feature_flag = 0;
34816e60:	e3a00000 	mov	r0, #0
34816e64:	e5870020 	str	r0, [r7, #32]
					}
				}
			}
		}
		ep_num++;
34816e68:	e2855001 	add	r5, r5, #1
34816e6c:	e6ef5075 	uxtb	r5, r5
		ep_intr >>= 1;
34816e70:	e1a090a9 	lsr	r9, r9, #1
	debug_cond(DEBUG_IN_EP,
		"*** %s: EP In interrupt : DAINT = 0x%x\n", __func__, ep_intr);

	ep_intr &= DAINT_MASK;

	while (ep_intr) {
34816e74:	e3590000 	cmp	r9, #0
34816e78:	1affff8c 	bne	34816cb0 <usb_gadget_handle_interrupts+0x19c>
34816e7c:	e59d6004 	ldr	r6, [sp, #4]
	}

	if (intr_status & INT_IN_EP)
		process_ep_in_intr(dev);

	if (intr_status & INT_OUT_EP)
34816e80:	e3160702 	tst	r6, #524288	; 0x80000
34816e84:	0a00002f 	beq	34816f48 <usb_gadget_handle_interrupts+0x434>
static void process_ep_out_intr(struct s3c_udc *dev)
{
	u32 ep_intr, ep_intr_status;
	u8 ep_num = 0;

	ep_intr = readl(&reg->daint);
34816e88:	e59fa0c4 	ldr	sl, [pc, #196]	; 34816f54 <usb_gadget_handle_interrupts+0x440>
34816e8c:	e59a3000 	ldr	r3, [sl]
34816e90:	e5936818 	ldr	r6, [r3, #2072]	; 0x818
}

static void process_ep_out_intr(struct s3c_udc *dev)
{
	u32 ep_intr, ep_intr_status;
	u8 ep_num = 0;
34816e94:	e3a05000 	mov	r5, #0
	ep_intr = readl(&reg->daint);
	debug_cond(DEBUG_OUT_EP != 0,
		   "*** %s: EP OUT interrupt : DAINT = 0x%x\n",
		   __func__, ep_intr);

	ep_intr = (ep_intr >> DAINT_OUT_BIT) & DAINT_MASK;
34816e98:	e1a06826 	lsr	r6, r6, #16
34816e9c:	ea000027 	b	34816f40 <usb_gadget_handle_interrupts+0x42c>

	while (ep_intr) {
		if (ep_intr & 0x1) {
34816ea0:	e3160001 	tst	r6, #1
34816ea4:	0a000022 	beq	34816f34 <usb_gadget_handle_interrupts+0x420>
			ep_intr_status = readl(&reg->out_endp[ep_num].doepint);
34816ea8:	e59a2000 	ldr	r2, [sl]
34816eac:	e1a03285 	lsl	r3, r5, #5
34816eb0:	e0822003 	add	r2, r2, r3
34816eb4:	e5927b08 	ldr	r7, [r2, #2824]	; 0xb08
			debug_cond(DEBUG_OUT_EP != 0,
				   "\tEP%d-OUT : DOEPINT = 0x%x\n",
				   ep_num, ep_intr_status);

			/* Interrupt Clear */
			writel(ep_intr_status, &reg->out_endp[ep_num].doepint);
34816eb8:	e2833c0b 	add	r3, r3, #2816	; 0xb00
34816ebc:	e59a2000 	ldr	r2, [sl]
34816ec0:	e2833008 	add	r3, r3, #8

			if (ep_num == 0) {
34816ec4:	e3550000 	cmp	r5, #0
			debug_cond(DEBUG_OUT_EP != 0,
				   "\tEP%d-OUT : DOEPINT = 0x%x\n",
				   ep_num, ep_intr_status);

			/* Interrupt Clear */
			writel(ep_intr_status, &reg->out_endp[ep_num].doepint);
34816ec8:	e7827003 	str	r7, [r2, r3]
34816ecc:	e2073001 	and	r3, r7, #1

			if (ep_num == 0) {
34816ed0:	1a000012 	bne	34816f20 <usb_gadget_handle_interrupts+0x40c>
				if (ep_intr_status & TRANSFER_DONE) {
34816ed4:	e3530000 	cmp	r3, #0
34816ed8:	0a000008 	beq	34816f00 <usb_gadget_handle_interrupts+0x3ec>
					if (dev->ep0state !=
34816edc:	e5943054 	ldr	r3, [r4, #84]	; 0x54
34816ee0:	e3530006 	cmp	r3, #6
34816ee4:	0a000003 	beq	34816ef8 <usb_gadget_handle_interrupts+0x3e4>
					    WAIT_FOR_OUT_COMPLETE)
						complete_rx(dev, ep_num);
34816ee8:	e1a00004 	mov	r0, r4
34816eec:	e1a01005 	mov	r1, r5
34816ef0:	ebfffaa1 	bl	3481597c <complete_rx>
34816ef4:	ea000001 	b	34816f00 <usb_gadget_handle_interrupts+0x3ec>
					else {
						dev->ep0state = WAIT_FOR_SETUP;
34816ef8:	e5845054 	str	r5, [r4, #84]	; 0x54
						s3c_udc_pre_setup();
34816efc:	ebfffb60 	bl	34815c84 <s3c_udc_pre_setup>
					}
				}

				if (ep_intr_status &
34816f00:	e3170008 	tst	r7, #8
34816f04:	0a00000a 	beq	34816f34 <usb_gadget_handle_interrupts+0x420>
/*
 * handle ep0 interrupt
 */
static void s3c_handle_ep0(struct s3c_udc *dev)
{
	if (dev->ep0state == WAIT_FOR_SETUP) {
34816f08:	e5943054 	ldr	r3, [r4, #84]	; 0x54
34816f0c:	e3530000 	cmp	r3, #0
34816f10:	1a000007 	bne	34816f34 <usb_gadget_handle_interrupts+0x420>
		debug_cond(DEBUG_OUT_EP != 0,
			   "%s: WAIT_FOR_SETUP\n", __func__);
		s3c_ep0_setup(dev);
34816f14:	e1a00004 	mov	r0, r4
34816f18:	ebfffd8f 	bl	3481655c <s3c_ep0_setup>
34816f1c:	ea000004 	b	34816f34 <usb_gadget_handle_interrupts+0x420>
					debug_cond(DEBUG_OUT_EP != 0,
						   "SETUP packet arrived\n");
					s3c_handle_ep0(dev);
				}
			} else {
				if (ep_intr_status & TRANSFER_DONE)
34816f20:	e3530000 	cmp	r3, #0
34816f24:	0a000002 	beq	34816f34 <usb_gadget_handle_interrupts+0x420>
					complete_rx(dev, ep_num);
34816f28:	e1a00004 	mov	r0, r4
34816f2c:	e1a01005 	mov	r1, r5
34816f30:	ebfffa91 	bl	3481597c <complete_rx>
			}
		}
		ep_num++;
34816f34:	e2855001 	add	r5, r5, #1
34816f38:	e6ef5075 	uxtb	r5, r5
		ep_intr >>= 1;
34816f3c:	e1a060a6 	lsr	r6, r6, #1
		   "*** %s: EP OUT interrupt : DAINT = 0x%x\n",
		   __func__, ep_intr);

	ep_intr = (ep_intr >> DAINT_OUT_BIT) & DAINT_MASK;

	while (ep_intr) {
34816f40:	e3560000 	cmp	r6, #0
34816f44:	1affffd5 	bne	34816ea0 <usb_gadget_handle_interrupts+0x38c>
34816f48:	e3a00001 	mov	r0, #1
	return 0;
}
34816f4c:	e28dd010 	add	sp, sp, #16
34816f50:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
34816f54:	3482b310 	.word	0x3482b310
34816f58:	34828a10 	.word	0x34828a10

34816f5c <cyg_crc16>:
    0x6e17, 0x7e36, 0x4e55, 0x5e74, 0x2e93, 0x3eb2, 0x0ed1, 0x1ef0,
};

uint16_t
cyg_crc16(unsigned char *buf, int len)
{
34816f5c:	e1a03000 	mov	r3, r0
    int i;
    uint16_t cksum;

    cksum = 0;
34816f60:	e3a00000 	mov	r0, #0
    0x6e17, 0x7e36, 0x4e55, 0x5e74, 0x2e93, 0x3eb2, 0x0ed1, 0x1ef0,
};

uint16_t
cyg_crc16(unsigned char *buf, int len)
{
34816f64:	e92d4010 	push	{r4, lr}
    int i;
    uint16_t cksum;

    cksum = 0;
    for (i = 0;  i < len;  i++) {
34816f68:	e1a02000 	mov	r2, r0
	cksum = crc16_tab[((cksum>>8) ^ *buf++) & 0xFF] ^ (cksum << 8);
34816f6c:	e59fc028 	ldr	ip, [pc, #40]	; 34816f9c <cyg_crc16+0x40>
{
    int i;
    uint16_t cksum;

    cksum = 0;
    for (i = 0;  i < len;  i++) {
34816f70:	ea000006 	b	34816f90 <cyg_crc16+0x34>
	cksum = crc16_tab[((cksum>>8) ^ *buf++) & 0xFF] ^ (cksum << 8);
34816f74:	e7d34002 	ldrb	r4, [r3, r2]
{
    int i;
    uint16_t cksum;

    cksum = 0;
    for (i = 0;  i < len;  i++) {
34816f78:	e2822001 	add	r2, r2, #1
	cksum = crc16_tab[((cksum>>8) ^ *buf++) & 0xFF] ^ (cksum << 8);
34816f7c:	e0244420 	eor	r4, r4, r0, lsr #8
34816f80:	e1a04084 	lsl	r4, r4, #1
34816f84:	e19c40b4 	ldrh	r4, [ip, r4]
34816f88:	e0240400 	eor	r0, r4, r0, lsl #8
34816f8c:	e6ff0070 	uxth	r0, r0
{
    int i;
    uint16_t cksum;

    cksum = 0;
    for (i = 0;  i < len;  i++) {
34816f90:	e1520001 	cmp	r2, r1
34816f94:	bafffff6 	blt	34816f74 <cyg_crc16+0x18>
	cksum = crc16_tab[((cksum>>8) ^ *buf++) & 0xFF] ^ (cksum << 8);
    }
    return cksum;
}
34816f98:	e8bd8010 	pop	{r4, pc}
34816f9c:	348218d4 	.word	0x348218d4

34816fa0 <crc32_no_comp>:
    if (crc_table_empty)
      make_crc_table();
#endif
    crc = cpu_to_le32(crc);
    /* Align it */
    if (((long)b) & 3 && len) {
34816fa0:	e211c003 	ands	ip, r1, #3
34816fa4:	13a0c001 	movne	ip, #1
34816fa8:	e3520000 	cmp	r2, #0
34816fac:	03a0c000 	moveq	ip, #0
34816fb0:	120cc001 	andne	ip, ip, #1
34816fb4:	e35c0000 	cmp	ip, #0

/* No ones complement version. JFFS2 (and other things ?)
 * don't use ones compliment in their CRC calculations.
 */
uint32_t ZEXPORT crc32_no_comp(uint32_t crc, const Bytef *buf, uInt len)
{
34816fb8:	e92d4070 	push	{r4, r5, r6, lr}
    const uint32_t *tab = crc_table;
    const uint32_t *b =(const uint32_t *)buf;
34816fbc:	e1a03001 	mov	r3, r1
    if (crc_table_empty)
      make_crc_table();
#endif
    crc = cpu_to_le32(crc);
    /* Align it */
    if (((long)b) & 3 && len) {
34816fc0:	0a00000a 	beq	34816ff0 <crc32_no_comp+0x50>
	 uint8_t *p = (uint8_t *)b;
	 do {
	      DO_CRC(*p++);
34816fc4:	e59f30b8 	ldr	r3, [pc, #184]	; 34817084 <crc32_no_comp+0xe4>
34816fc8:	e4d1c001 	ldrb	ip, [r1], #1
	 } while ((--len) && ((long)p)&3);
34816fcc:	e2522001 	subs	r2, r2, #1
    crc = cpu_to_le32(crc);
    /* Align it */
    if (((long)b) & 3 && len) {
	 uint8_t *p = (uint8_t *)b;
	 do {
	      DO_CRC(*p++);
34816fd0:	e020c00c 	eor	ip, r0, ip
34816fd4:	e20cc0ff 	and	ip, ip, #255	; 0xff
34816fd8:	e793c10c 	ldr	ip, [r3, ip, lsl #2]
34816fdc:	e02c0420 	eor	r0, ip, r0, lsr #8
	 } while ((--len) && ((long)p)&3);
34816fe0:	0a000001 	beq	34816fec <crc32_no_comp+0x4c>
34816fe4:	e3110003 	tst	r1, #3
34816fe8:	1afffff6 	bne	34816fc8 <crc32_no_comp+0x28>
	 b = (uint32_t *)p;
34816fec:	e1a03001 	mov	r3, r1
    }

    rem_len = len & 3;
34816ff0:	e2025003 	and	r5, r2, #3
    len = len >> 2;
34816ff4:	e1a02122 	lsr	r2, r2, #2
    for (--b; len; --len) {
34816ff8:	e2431004 	sub	r1, r3, #4
	 } while ((--len) && ((long)p)&3);
	 b = (uint32_t *)p;
    }

    rem_len = len & 3;
    len = len >> 2;
34816ffc:	e1a04002 	mov	r4, r2
    for (--b; len; --len) {
	 /* load data 32 bits wide, xor data 32 bits wide. */
	 crc ^= *++b; /* use pre increment for speed */
	 DO_CRC(0);
34817000:	e59fc07c 	ldr	ip, [pc, #124]	; 34817084 <crc32_no_comp+0xe4>
	 b = (uint32_t *)p;
    }

    rem_len = len & 3;
    len = len >> 2;
    for (--b; len; --len) {
34817004:	ea00000e 	b	34817044 <crc32_no_comp+0xa4>
	 /* load data 32 bits wide, xor data 32 bits wide. */
	 crc ^= *++b; /* use pre increment for speed */
34817008:	e4936004 	ldr	r6, [r3], #4
	 b = (uint32_t *)p;
    }

    rem_len = len & 3;
    len = len >> 2;
    for (--b; len; --len) {
3481700c:	e2444001 	sub	r4, r4, #1
	 /* load data 32 bits wide, xor data 32 bits wide. */
	 crc ^= *++b; /* use pre increment for speed */
34817010:	e0200006 	eor	r0, r0, r6
	 DO_CRC(0);
34817014:	e20060ff 	and	r6, r0, #255	; 0xff
34817018:	e79c6106 	ldr	r6, [ip, r6, lsl #2]
3481701c:	e0260420 	eor	r0, r6, r0, lsr #8
	 DO_CRC(0);
34817020:	e20060ff 	and	r6, r0, #255	; 0xff
34817024:	e79c6106 	ldr	r6, [ip, r6, lsl #2]
34817028:	e0260420 	eor	r0, r6, r0, lsr #8
	 DO_CRC(0);
3481702c:	e20060ff 	and	r6, r0, #255	; 0xff
34817030:	e79c6106 	ldr	r6, [ip, r6, lsl #2]
34817034:	e0260420 	eor	r0, r6, r0, lsr #8
	 DO_CRC(0);
34817038:	e20060ff 	and	r6, r0, #255	; 0xff
3481703c:	e79c6106 	ldr	r6, [ip, r6, lsl #2]
34817040:	e0260420 	eor	r0, r6, r0, lsr #8
	 b = (uint32_t *)p;
    }

    rem_len = len & 3;
    len = len >> 2;
    for (--b; len; --len) {
34817044:	e3540000 	cmp	r4, #0
34817048:	1affffee 	bne	34817008 <crc32_no_comp+0x68>
	 DO_CRC(0);
	 DO_CRC(0);
    }
    len = rem_len;
    /* And the last few bytes */
    if (len) {
3481704c:	e3550000 	cmp	r5, #0
	 b = (uint32_t *)p;
    }

    rem_len = len & 3;
    len = len >> 2;
    for (--b; len; --len) {
34817050:	e0812102 	add	r2, r1, r2, lsl #2
	 DO_CRC(0);
	 DO_CRC(0);
    }
    len = rem_len;
    /* And the last few bytes */
    if (len) {
34817054:	08bd8070 	popeq	{r4, r5, r6, pc}
	 uint8_t *p = (uint8_t *)(b + 1) - 1;
	 do {
	      DO_CRC(*++p); /* use pre increment for speed */
34817058:	e59f1024 	ldr	r1, [pc, #36]	; 34817084 <crc32_no_comp+0xe4>
	 DO_CRC(0);
    }
    len = rem_len;
    /* And the last few bytes */
    if (len) {
	 uint8_t *p = (uint8_t *)(b + 1) - 1;
3481705c:	e2822003 	add	r2, r2, #3
34817060:	e1a03005 	mov	r3, r5
	 do {
	      DO_CRC(*++p); /* use pre increment for speed */
34817064:	e5f2c001 	ldrb	ip, [r2, #1]!
	 } while (--len);
34817068:	e2533001 	subs	r3, r3, #1
    len = rem_len;
    /* And the last few bytes */
    if (len) {
	 uint8_t *p = (uint8_t *)(b + 1) - 1;
	 do {
	      DO_CRC(*++p); /* use pre increment for speed */
3481706c:	e020c00c 	eor	ip, r0, ip
34817070:	e20cc0ff 	and	ip, ip, #255	; 0xff
34817074:	e791c10c 	ldr	ip, [r1, ip, lsl #2]
34817078:	e02c0420 	eor	r0, ip, r0, lsr #8
	 } while (--len);
3481707c:	1afffff8 	bne	34817064 <crc32_no_comp+0xc4>
    }

    return le32_to_cpu(crc);
}
34817080:	e8bd8070 	pop	{r4, r5, r6, pc}
34817084:	34821ad4 	.word	0x34821ad4

34817088 <crc32>:
#undef DO_CRC

uint32_t ZEXPORT crc32 (uint32_t crc, const Bytef *p, uInt len)
{
34817088:	e92d4008 	push	{r3, lr}
     return crc32_no_comp(crc ^ 0xffffffffL, p, len) ^ 0xffffffffL;
3481708c:	e1e00000 	mvn	r0, r0
34817090:	ebffffc2 	bl	34816fa0 <crc32_no_comp>
}
34817094:	e1e00000 	mvn	r0, r0
34817098:	e8bd8008 	pop	{r3, pc}

3481709c <crc32_wd>:
		crc = crc32 (crc, curr, chunk);
		curr += chunk;
		WATCHDOG_RESET ();
	}
#else
	crc = crc32 (crc, buf, len);
3481709c:	eafffff9 	b	34817088 <crc32>

348170a0 <crc7>:

extern const u8 crc7_syndrome_table[256];

static inline u8 crc7_byte(u8 crc, u8 data)
{
	return crc7_syndrome_table[(crc << 1) ^ data];
348170a0:	e59f301c 	ldr	r3, [pc, #28]	; 348170c4 <crc7+0x24>
 *
 * Returns the updated CRC7 value.
 */
u8 crc7(u8 crc, const u8 *buffer, size_t len)
{
	while (len--)
348170a4:	ea000003 	b	348170b8 <crc7+0x18>
		crc = crc7_byte(crc, *buffer++);
348170a8:	e4d1c001 	ldrb	ip, [r1], #1
348170ac:	e2422001 	sub	r2, r2, #1
348170b0:	e02c0080 	eor	r0, ip, r0, lsl #1
348170b4:	e7d30000 	ldrb	r0, [r3, r0]
 *
 * Returns the updated CRC7 value.
 */
u8 crc7(u8 crc, const u8 *buffer, size_t len)
{
	while (len--)
348170b8:	e3520000 	cmp	r2, #0
348170bc:	1afffff9 	bne	348170a8 <crc7+0x8>
		crc = crc7_byte(crc, *buffer++);
	return crc;
}
348170c0:	e12fff1e 	bx	lr
348170c4:	34821ed4 	.word	0x34821ed4

348170c8 <display_options>:
#include <version.h>
#include <linux/ctype.h>
#include <asm/io.h>

int display_options (void)
{
348170c8:	e92d4008 	push	{r3, lr}
#if defined(BUILD_TAG)
	printf ("\n\n%s, Build: %s\n\n", version_string, BUILD_TAG);
#else
	printf ("\n\n%s\n\n", version_string);
348170cc:	e59f100c 	ldr	r1, [pc, #12]	; 348170e0 <display_options+0x18>
348170d0:	e59f000c 	ldr	r0, [pc, #12]	; 348170e4 <display_options+0x1c>
348170d4:	ebffc79c 	bl	34808f4c <printf>
#endif
	return 0;
}
348170d8:	e3a00000 	mov	r0, #0
348170dc:	e8bd8008 	pop	{r3, pc}
348170e0:	3482053c 	.word	0x3482053c
348170e4:	34822bb4 	.word	0x34822bb4

348170e8 <print_size>:
 * print sizes as "xxx KiB", "xxx.y KiB", "xxx MiB", "xxx.y MiB",
 * xxx GiB, xxx.y GiB, etc as needed; allow for optional trailing string
 * (like "\n")
 */
void print_size(unsigned long long size, const char *s)
{
348170e8:	e92d46f7 	push	{r0, r1, r2, r4, r5, r6, r7, r9, sl, lr}
348170ec:	e1a04000 	mov	r4, r0
348170f0:	e1a05001 	mov	r5, r1
348170f4:	e1a09002 	mov	r9, r2
	static const char names[] = {'E', 'P', 'T', 'G', 'M', 'K'};
	unsigned long d = 10 * ARRAY_SIZE(names);
	char c = 0;
	unsigned int i;

	for (i = 0; i < ARRAY_SIZE(names); i++, d -= 10) {
348170f8:	e3a0a000 	mov	sl, #0
void print_size(unsigned long long size, const char *s)
{
	unsigned long m = 0, n;
	unsigned long long f;
	static const char names[] = {'E', 'P', 'T', 'G', 'M', 'K'};
	unsigned long d = 10 * ARRAY_SIZE(names);
348170fc:	e3a0603c 	mov	r6, #60	; 0x3c
	char c = 0;
	unsigned int i;

	for (i = 0; i < ARRAY_SIZE(names); i++, d -= 10) {
		if (size >> d) {
34817100:	e1a00004 	mov	r0, r4
34817104:	e1a01005 	mov	r1, r5
34817108:	e1a02006 	mov	r2, r6
3481710c:	eb002477 	bl	348202f0 <__lshrdi3>
34817110:	e1901001 	orrs	r1, r0, r1
34817114:	0a000004 	beq	3481712c <print_size+0x44>
			c = names[i];
34817118:	e59f30e0 	ldr	r3, [pc, #224]	; 34817200 <print_size+0x118>
3481711c:	e7d3a00a 	ldrb	sl, [r3, sl]
			break;
		}
	}

	if (!c) {
34817120:	e35a0000 	cmp	sl, #0
34817124:	1a00000b 	bne	34817158 <print_size+0x70>
34817128:	ea000003 	b	3481713c <print_size+0x54>
	static const char names[] = {'E', 'P', 'T', 'G', 'M', 'K'};
	unsigned long d = 10 * ARRAY_SIZE(names);
	char c = 0;
	unsigned int i;

	for (i = 0; i < ARRAY_SIZE(names); i++, d -= 10) {
3481712c:	e28aa001 	add	sl, sl, #1
34817130:	e35a0006 	cmp	sl, #6
34817134:	1246600a 	subne	r6, r6, #10
34817138:	1afffff0 	bne	34817100 <print_size+0x18>
			break;
		}
	}

	if (!c) {
		printf("%llu Bytes%s", size, s);
3481713c:	e1a02004 	mov	r2, r4
34817140:	e1a03005 	mov	r3, r5
34817144:	e59f00b8 	ldr	r0, [pc, #184]	; 34817204 <print_size+0x11c>
34817148:	e58d9000 	str	r9, [sp]
3481714c:	ebffc77e 	bl	34808f4c <printf>
	printf ("%lu", n);
	if (m) {
		printf (".%ld", m);
	}
	printf (" %ciB%s", c, s);
}
34817150:	e28dd00c 	add	sp, sp, #12
34817154:	e8bd86f0 	pop	{r4, r5, r6, r7, r9, sl, pc}
		printf("%llu Bytes%s", size, s);
		return;
	}

	n = size >> d;
	f = size & ((1ULL << d) - 1);
34817158:	e1a02006 	mov	r2, r6
	if (!c) {
		printf("%llu Bytes%s", size, s);
		return;
	}

	n = size >> d;
3481715c:	e1a07000 	mov	r7, r0
	f = size & ((1ULL << d) - 1);
34817160:	e3a01000 	mov	r1, #0
34817164:	e3a00001 	mov	r0, #1
34817168:	eb00246e 	bl	34820328 <__ashldi3>
3481716c:	e3e02000 	mvn	r2, #0
34817170:	e0922000 	adds	r2, r2, r0
34817174:	e3e03000 	mvn	r3, #0
34817178:	e0a33001 	adc	r3, r3, r1
3481717c:	e0022004 	and	r2, r2, r4
34817180:	e0033005 	and	r3, r3, r5

	/* If there's a remainder, deal with it */
	if (f) {
34817184:	e1924003 	orrs	r4, r2, r3
34817188:	0a00000e 	beq	348171c8 <print_size+0xe0>
		m = (10ULL * f + (1ULL << (d - 1))) >> d;
3481718c:	e3a0100a 	mov	r1, #10
34817190:	e0854192 	umull	r4, r5, r2, r1
34817194:	e3a00001 	mov	r0, #1
34817198:	e0255391 	mla	r5, r1, r3, r5
3481719c:	e2462001 	sub	r2, r6, #1
348171a0:	e3a01000 	mov	r1, #0
348171a4:	eb00245f 	bl	34820328 <__ashldi3>
348171a8:	e0900004 	adds	r0, r0, r4
348171ac:	e0a11005 	adc	r1, r1, r5
348171b0:	e1a02006 	mov	r2, r6
348171b4:	eb00244d 	bl	348202f0 <__lshrdi3>

		if (m >= 10) {
348171b8:	e3500009 	cmp	r0, #9
	n = size >> d;
	f = size & ((1ULL << d) - 1);

	/* If there's a remainder, deal with it */
	if (f) {
		m = (10ULL * f + (1ULL << (d - 1))) >> d;
348171bc:	e1a04000 	mov	r4, r0

		if (m >= 10) {
			m -= 10;
			n += 1;
348171c0:	82877001 	addhi	r7, r7, #1
	/* If there's a remainder, deal with it */
	if (f) {
		m = (10ULL * f + (1ULL << (d - 1))) >> d;

		if (m >= 10) {
			m -= 10;
348171c4:	8240400a 	subhi	r4, r0, #10
			n += 1;
		}
	}

	printf ("%lu", n);
348171c8:	e59f0038 	ldr	r0, [pc, #56]	; 34817208 <print_size+0x120>
348171cc:	e1a01007 	mov	r1, r7
348171d0:	ebffc75d 	bl	34808f4c <printf>
	if (m) {
348171d4:	e3540000 	cmp	r4, #0
348171d8:	0a000002 	beq	348171e8 <print_size+0x100>
		printf (".%ld", m);
348171dc:	e59f0028 	ldr	r0, [pc, #40]	; 3481720c <print_size+0x124>
348171e0:	e1a01004 	mov	r1, r4
348171e4:	ebffc758 	bl	34808f4c <printf>
	}
	printf (" %ciB%s", c, s);
348171e8:	e59f0020 	ldr	r0, [pc, #32]	; 34817210 <print_size+0x128>
348171ec:	e1a0100a 	mov	r1, sl
348171f0:	e1a02009 	mov	r2, r9
}
348171f4:	e28dd00c 	add	sp, sp, #12
348171f8:	e8bd46f0 	pop	{r4, r5, r6, r7, r9, sl, lr}

	printf ("%lu", n);
	if (m) {
		printf (".%ld", m);
	}
	printf (" %ciB%s", c, s);
348171fc:	eaffc752 	b	34808f4c <printf>
34817200:	348220d4 	.word	0x348220d4
34817204:	348276c8 	.word	0x348276c8
34817208:	348276d5 	.word	0x348276d5
3481720c:	348276d9 	.word	0x348276d9
34817210:	348276de 	.word	0x348276de

34817214 <print_buffer>:
 *    linelen: Number of values to print per line; specify 0 for default length
 */
#define MAX_LINE_LENGTH_BYTES (64)
#define DEFAULT_LINE_LENGTH_BYTES (16)
int print_buffer (ulong addr, void* data, uint width, uint count, uint linelen)
{
34817214:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
34817218:	e24dd050 	sub	sp, sp, #80	; 0x50
3481721c:	e59d5070 	ldr	r5, [sp, #112]	; 0x70
34817220:	e1a07003 	mov	r7, r3
		uint16_t us[MAX_LINE_LENGTH_BYTES/sizeof(uint16_t) + 1];
		uint8_t  uc[MAX_LINE_LENGTH_BYTES/sizeof(uint8_t) + 1];
	} lb;
	int i;

	if (linelen*width > MAX_LINE_LENGTH_BYTES)
34817224:	e0030592 	mul	r3, r2, r5
34817228:	e3530040 	cmp	r3, #64	; 0x40
 *    linelen: Number of values to print per line; specify 0 for default length
 */
#define MAX_LINE_LENGTH_BYTES (64)
#define DEFAULT_LINE_LENGTH_BYTES (16)
int print_buffer (ulong addr, void* data, uint width, uint count, uint linelen)
{
3481722c:	e1a0b000 	mov	fp, r0
34817230:	e1a09001 	mov	r9, r1
34817234:	e1a04002 	mov	r4, r2
		uint16_t us[MAX_LINE_LENGTH_BYTES/sizeof(uint16_t) + 1];
		uint8_t  uc[MAX_LINE_LENGTH_BYTES/sizeof(uint8_t) + 1];
	} lb;
	int i;

	if (linelen*width > MAX_LINE_LENGTH_BYTES)
34817238:	9a000003 	bls	3481724c <print_buffer+0x38>
		linelen = MAX_LINE_LENGTH_BYTES / width;
3481723c:	e3a00040 	mov	r0, #64	; 0x40
34817240:	e1a01002 	mov	r1, r2
34817244:	eb002316 	bl	3481fea4 <__udivsi3>
34817248:	e1a05000 	mov	r5, r0
	if (linelen < 1)
3481724c:	e3550000 	cmp	r5, #0
34817250:	1a00003c 	bne	34817348 <print_buffer+0x134>
		linelen = DEFAULT_LINE_LENGTH_BYTES / width;
34817254:	e3a00010 	mov	r0, #16
34817258:	e1a01004 	mov	r1, r4
3481725c:	eb002310 	bl	3481fea4 <__udivsi3>
34817260:	e1a05000 	mov	r5, r0
34817264:	ea000037 	b	34817348 <print_buffer+0x134>

	while (count) {
		printf("%08lx:", addr);
34817268:	e59f00fc 	ldr	r0, [pc, #252]	; 3481736c <print_buffer+0x158>
3481726c:	e1a0100b 	mov	r1, fp
34817270:	ebffc735 	bl	34808f4c <printf>
34817274:	e1550007 	cmp	r5, r7
34817278:	21a05007 	movcs	r5, r7
		/* check for overflow condition */
		if (count < linelen)
			linelen = count;

		/* Copy from memory into linebuf and print hex values */
		for (i = 0; i < linelen; i++) {
3481727c:	e1a0a009 	mov	sl, r9
34817280:	e3a06000 	mov	r6, #0
34817284:	ea000010 	b	348172cc <print_buffer+0xb8>
			uint32_t x;
			if (width == 4)
34817288:	e3540004 	cmp	r4, #4
				x = lb.ui[i] = *(volatile uint32_t *)data;
3481728c:	059a2000 	ldreq	r2, [sl]
34817290:	028d300c 	addeq	r3, sp, #12
34817294:	07832106 	streq	r2, [r3, r6, lsl #2]
			linelen = count;

		/* Copy from memory into linebuf and print hex values */
		for (i = 0; i < linelen; i++) {
			uint32_t x;
			if (width == 4)
34817298:	0a000006 	beq	348172b8 <print_buffer+0xa4>
				x = lb.ui[i] = *(volatile uint32_t *)data;
			else if (width == 2)
3481729c:	e3540002 	cmp	r4, #2
				x = lb.us[i] = *(volatile uint16_t *)data;
348172a0:	01da20b0 	ldrheq	r2, [sl]
			else
				x = lb.uc[i] = *(volatile uint8_t *)data;
348172a4:	15da2000 	ldrbne	r2, [sl]
348172a8:	e28d300c 	add	r3, sp, #12
 *    count: number of values to display
 *    linelen: Number of values to print per line; specify 0 for default length
 */
#define MAX_LINE_LENGTH_BYTES (64)
#define DEFAULT_LINE_LENGTH_BYTES (16)
int print_buffer (ulong addr, void* data, uint width, uint count, uint linelen)
348172ac:	01a01086 	lsleq	r1, r6, #1
		for (i = 0; i < linelen; i++) {
			uint32_t x;
			if (width == 4)
				x = lb.ui[i] = *(volatile uint32_t *)data;
			else if (width == 2)
				x = lb.us[i] = *(volatile uint16_t *)data;
348172b0:	018320b1 	strheq	r2, [r3, r1]
			else
				x = lb.uc[i] = *(volatile uint8_t *)data;
348172b4:	17c32006 	strbne	r2, [r3, r6]
			printf(" %0*x", width * 2, x);
348172b8:	e59f00b0 	ldr	r0, [pc, #176]	; 34817370 <print_buffer+0x15c>
348172bc:	e59d1004 	ldr	r1, [sp, #4]
348172c0:	ebffc721 	bl	34808f4c <printf>
			data += width;
348172c4:	e08aa004 	add	sl, sl, r4
		/* check for overflow condition */
		if (count < linelen)
			linelen = count;

		/* Copy from memory into linebuf and print hex values */
		for (i = 0; i < linelen; i++) {
348172c8:	e2866001 	add	r6, r6, #1
348172cc:	e1560005 	cmp	r6, r5
348172d0:	3affffec 	bcc	34817288 <print_buffer+0x74>
 *    count: number of values to display
 *    linelen: Number of values to print per line; specify 0 for default length
 */
#define MAX_LINE_LENGTH_BYTES (64)
#define DEFAULT_LINE_LENGTH_BYTES (16)
int print_buffer (ulong addr, void* data, uint width, uint count, uint linelen)
348172d4:	e0060594 	mul	r6, r4, r5
348172d8:	e28d300c 	add	r3, sp, #12
348172dc:	e0899006 	add	r9, r9, r6
348172e0:	e0861003 	add	r1, r6, r3
348172e4:	ea000008 	b	3481730c <print_buffer+0xf8>
			data += width;
		}

		/* Print data in ASCII characters */
		for (i = 0; i < linelen * width; i++) {
			if (!isprint(lb.uc[i]) || lb.uc[i] >= 0x80)
348172e8:	e4d32001 	ldrb	r2, [r3], #1
348172ec:	e59fc080 	ldr	ip, [pc, #128]	; 34817374 <print_buffer+0x160>
348172f0:	e7dc0002 	ldrb	r0, [ip, r2]
348172f4:	e3100097 	tst	r0, #151	; 0x97
348172f8:	0a000001 	beq	34817304 <print_buffer+0xf0>
348172fc:	e3120080 	tst	r2, #128	; 0x80
34817300:	0a000001 	beq	3481730c <print_buffer+0xf8>
				lb.uc[i] = '.';
34817304:	e3a0202e 	mov	r2, #46	; 0x2e
34817308:	e5432001 	strb	r2, [r3, #-1]
			printf(" %0*x", width * 2, x);
			data += width;
		}

		/* Print data in ASCII characters */
		for (i = 0; i < linelen * width; i++) {
3481730c:	e1530001 	cmp	r3, r1
34817310:	1afffff4 	bne	348172e8 <print_buffer+0xd4>
			if (!isprint(lb.uc[i]) || lb.uc[i] >= 0x80)
				lb.uc[i] = '.';
		}
		lb.uc[i] = '\0';
34817314:	e28dc050 	add	ip, sp, #80	; 0x50
34817318:	e08c3006 	add	r3, ip, r6
3481731c:	e3a02000 	mov	r2, #0
34817320:	e5432044 	strb	r2, [r3, #-68]	; 0x44
		printf("    %s\n", lb.uc);
34817324:	e28d100c 	add	r1, sp, #12
34817328:	e59f0048 	ldr	r0, [pc, #72]	; 34817378 <print_buffer+0x164>
3481732c:	ebffc706 	bl	34808f4c <printf>

		/* update references */
		addr += linelen * width;
		count -= linelen;

		if (ctrlc())
34817330:	ebffc72a 	bl	34808fe0 <ctrlc>
34817334:	e3500000 	cmp	r0, #0
34817338:	1a000008 	bne	34817360 <print_buffer+0x14c>
		}
		lb.uc[i] = '\0';
		printf("    %s\n", lb.uc);

		/* update references */
		addr += linelen * width;
3481733c:	e08bb006 	add	fp, fp, r6
		count -= linelen;
34817340:	e0657007 	rsb	r7, r5, r7
34817344:	ea000001 	b	34817350 <print_buffer+0x13c>
				x = lb.ui[i] = *(volatile uint32_t *)data;
			else if (width == 2)
				x = lb.us[i] = *(volatile uint16_t *)data;
			else
				x = lb.uc[i] = *(volatile uint8_t *)data;
			printf(" %0*x", width * 2, x);
34817348:	e1a03084 	lsl	r3, r4, #1
3481734c:	e58d3004 	str	r3, [sp, #4]
	if (linelen*width > MAX_LINE_LENGTH_BYTES)
		linelen = MAX_LINE_LENGTH_BYTES / width;
	if (linelen < 1)
		linelen = DEFAULT_LINE_LENGTH_BYTES / width;

	while (count) {
34817350:	e3570000 	cmp	r7, #0
34817354:	1affffc3 	bne	34817268 <print_buffer+0x54>

		if (ctrlc())
			return -1;
	}

	return 0;
34817358:	e1a00007 	mov	r0, r7
3481735c:	ea000000 	b	34817364 <print_buffer+0x150>
		/* update references */
		addr += linelen * width;
		count -= linelen;

		if (ctrlc())
			return -1;
34817360:	e3e00000 	mvn	r0, #0
	}

	return 0;
}
34817364:	e28dd050 	add	sp, sp, #80	; 0x50
34817368:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
3481736c:	34824105 	.word	0x34824105
34817370:	348276e6 	.word	0x348276e6
34817374:	34821fd4 	.word	0x34821fd4
34817378:	348276ec 	.word	0x348276ec

3481737c <__div64_32>:
 */

#include <linux/types.h>

uint32_t __div64_32(uint64_t *n, uint32_t base)
{
3481737c:	e92d4eff 	push	{r0, r1, r2, r3, r4, r5, r6, r7, r9, sl, fp, lr}
	uint64_t rem = *n;
34817380:	e1c060d0 	ldrd	r6, [r0]
	uint64_t res, d = 1;
	uint32_t high = rem >> 32;

	/* Reduce the thing a bit first */
	res = 0;
	if (high >= base) {
34817384:	e1510007 	cmp	r1, r7
 */

#include <linux/types.h>

uint32_t __div64_32(uint64_t *n, uint32_t base)
{
34817388:	e1a09000 	mov	r9, r0
3481738c:	e1a0a001 	mov	sl, r1
	uint64_t rem = *n;
	uint64_t b = base;
34817390:	e1a04001 	mov	r4, r1
34817394:	e3a05000 	mov	r5, #0
	uint64_t res, d = 1;
	uint32_t high = rem >> 32;

	/* Reduce the thing a bit first */
	res = 0;
	if (high >= base) {
34817398:	8a000009 	bhi	348173c4 <__div64_32+0x48>
		high /= base;
3481739c:	e1a00007 	mov	r0, r7
348173a0:	eb0022bf 	bl	3481fea4 <__udivsi3>
		res = (uint64_t) high << 32;
		rem -= (uint64_t) (high*base) << 32;
348173a4:	e003009a 	mul	r3, sl, r0

	/* Reduce the thing a bit first */
	res = 0;
	if (high >= base) {
		high /= base;
		res = (uint64_t) high << 32;
348173a8:	e3a0c000 	mov	ip, #0
		rem -= (uint64_t) (high*base) << 32;
348173ac:	e1a0200c 	mov	r2, ip

	/* Reduce the thing a bit first */
	res = 0;
	if (high >= base) {
		high /= base;
		res = (uint64_t) high << 32;
348173b0:	e58d0004 	str	r0, [sp, #4]
348173b4:	e58dc000 	str	ip, [sp]
		rem -= (uint64_t) (high*base) << 32;
348173b8:	e0566002 	subs	r6, r6, r2
348173bc:	e0c77003 	sbc	r7, r7, r3
348173c0:	ea000002 	b	348173d0 <__div64_32+0x54>
	uint64_t b = base;
	uint64_t res, d = 1;
	uint32_t high = rem >> 32;

	/* Reduce the thing a bit first */
	res = 0;
348173c4:	e3a02000 	mov	r2, #0
348173c8:	e3a03000 	mov	r3, #0
348173cc:	e1cd20f0 	strd	r2, [sp]
348173d0:	e3a00001 	mov	r0, #1
348173d4:	e3a01000 	mov	r1, #0
348173d8:	ea000003 	b	348173ec <__div64_32+0x70>
		res = (uint64_t) high << 32;
		rem -= (uint64_t) (high*base) << 32;
	}

	while ((int64_t)b > 0 && b < rem) {
		b = b+b;
348173dc:	e0944004 	adds	r4, r4, r4
348173e0:	e0a55005 	adc	r5, r5, r5
		d = d+d;
348173e4:	e0900000 	adds	r0, r0, r0
348173e8:	e0a11001 	adc	r1, r1, r1
		high /= base;
		res = (uint64_t) high << 32;
		rem -= (uint64_t) (high*base) << 32;
	}

	while ((int64_t)b > 0 && b < rem) {
348173ec:	e1a0afc5 	asr	sl, r5, #31
348173f0:	e1a0200a 	mov	r2, sl
348173f4:	e1a0300a 	mov	r3, sl
348173f8:	e0522004 	subs	r2, r2, r4
348173fc:	e0c33005 	sbc	r3, r3, r5
34817400:	e1570005 	cmp	r7, r5
34817404:	e1a02fa3 	lsr	r2, r3, #31
34817408:	e1a0b00a 	mov	fp, sl
3481740c:	e3a03001 	mov	r3, #1
34817410:	8a000003 	bhi	34817424 <__div64_32+0xa8>
34817414:	1a000001 	bne	34817420 <__div64_32+0xa4>
34817418:	e1560004 	cmp	r6, r4
3481741c:	8a000000 	bhi	34817424 <__div64_32+0xa8>
34817420:	e3a03000 	mov	r3, #0
34817424:	e1120003 	tst	r2, r3
34817428:	1affffeb 	bne	348173dc <__div64_32+0x60>
3481742c:	e1cd20d0 	ldrd	r2, [sp]
		b = b+b;
		d = d+d;
	}

	do {
		if (rem >= b) {
34817430:	e1550007 	cmp	r5, r7
34817434:	8a000006 	bhi	34817454 <__div64_32+0xd8>
34817438:	1a000001 	bne	34817444 <__div64_32+0xc8>
3481743c:	e1540006 	cmp	r4, r6
34817440:	8a000003 	bhi	34817454 <__div64_32+0xd8>
			rem -= b;
34817444:	e0566004 	subs	r6, r6, r4
34817448:	e0c77005 	sbc	r7, r7, r5
			res += d;
3481744c:	e0922000 	adds	r2, r2, r0
34817450:	e0a33001 	adc	r3, r3, r1
		}
		b >>= 1;
		d >>= 1;
34817454:	e1b010a1 	lsrs	r1, r1, #1
34817458:	e1a00060 	rrx	r0, r0
	} while (d);
3481745c:	e190c001 	orrs	ip, r0, r1
34817460:	0a000002 	beq	34817470 <__div64_32+0xf4>
	do {
		if (rem >= b) {
			rem -= b;
			res += d;
		}
		b >>= 1;
34817464:	e1b050a5 	lsrs	r5, r5, #1
34817468:	e1a04064 	rrx	r4, r4
3481746c:	eaffffef 	b	34817430 <__div64_32+0xb4>
		d >>= 1;
	} while (d);

	*n = res;
34817470:	e1c920f0 	strd	r2, [r9]
	return rem;
}
34817474:	e1a00006 	mov	r0, r6
34817478:	e28dd010 	add	sp, sp, #16
3481747c:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}

34817480 <gzfree>:
	return (p);
}

void gzfree(void *x, void *addr, unsigned nb)
{
	free (addr);
34817480:	e1a00001 	mov	r0, r1
34817484:	eaffc7ee 	b	34809444 <free>

34817488 <gzalloc>:

void *gzalloc(void *x, unsigned items, unsigned size)
{
	void *p;

	size *= items;
34817488:	e0020291 	mul	r2, r1, r2
	size = (size + ZALLOC_ALIGNMENT - 1) & ~(ZALLOC_ALIGNMENT - 1);
3481748c:	e282000f 	add	r0, r2, #15

	p = malloc (size);
34817490:	e3c0000f 	bic	r0, r0, #15
34817494:	eaffc873 	b	34809668 <malloc>

34817498 <zunzip>:
/*
 * Uncompress blocks compressed with zlib without headers
 */
int zunzip(void *dst, int dstlen, unsigned char *src, unsigned long *lenp,
						int stoponerr, int offset)
{
34817498:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
3481749c:	e1a04003 	mov	r4, r3
	z_stream s;
	int r;

	s.zalloc = gzalloc;
348174a0:	e59f30e4 	ldr	r3, [pc, #228]	; 3481758c <zunzip+0xf4>
/*
 * Uncompress blocks compressed with zlib without headers
 */
int zunzip(void *dst, int dstlen, unsigned char *src, unsigned long *lenp,
						int stoponerr, int offset)
{
348174a4:	e24dd040 	sub	sp, sp, #64	; 0x40
	z_stream s;
	int r;

	s.zalloc = gzalloc;
348174a8:	e58d3024 	str	r3, [sp, #36]	; 0x24
	s.zfree = gzfree;
348174ac:	e59f30dc 	ldr	r3, [pc, #220]	; 34817590 <zunzip+0xf8>

	r = inflateInit2(&s, -MAX_WBITS);
348174b0:	e28da004 	add	sl, sp, #4
{
	z_stream s;
	int r;

	s.zalloc = gzalloc;
	s.zfree = gzfree;
348174b4:	e58d3028 	str	r3, [sp, #40]	; 0x28
/*
 * Uncompress blocks compressed with zlib without headers
 */
int zunzip(void *dst, int dstlen, unsigned char *src, unsigned long *lenp,
						int stoponerr, int offset)
{
348174b8:	e1a05000 	mov	r5, r0
348174bc:	e1a07001 	mov	r7, r1
348174c0:	e1a09002 	mov	r9, r2
	int r;

	s.zalloc = gzalloc;
	s.zfree = gzfree;

	r = inflateInit2(&s, -MAX_WBITS);
348174c4:	e3e0100e 	mvn	r1, #14
348174c8:	e1a0000a 	mov	r0, sl
348174cc:	e59f20c0 	ldr	r2, [pc, #192]	; 34817594 <zunzip+0xfc>
348174d0:	e3a0303c 	mov	r3, #60	; 0x3c
/*
 * Uncompress blocks compressed with zlib without headers
 */
int zunzip(void *dst, int dstlen, unsigned char *src, unsigned long *lenp,
						int stoponerr, int offset)
{
348174d4:	e59db060 	ldr	fp, [sp, #96]	; 0x60
348174d8:	e59d6064 	ldr	r6, [sp, #100]	; 0x64
	int r;

	s.zalloc = gzalloc;
	s.zfree = gzfree;

	r = inflateInit2(&s, -MAX_WBITS);
348174dc:	eb000d7c 	bl	3481aad4 <inflateInit2_>
	if (r != Z_OK) {
348174e0:	e2501000 	subs	r1, r0, #0
348174e4:	0a000002 	beq	348174f4 <zunzip+0x5c>
		printf ("Error: inflateInit2() returned %d\n", r);
348174e8:	e59f00a8 	ldr	r0, [pc, #168]	; 34817598 <zunzip+0x100>
348174ec:	ebffc696 	bl	34808f4c <printf>
348174f0:	ea000013 	b	34817544 <zunzip+0xac>
		return -1;
	}
	s.next_in = src + offset;
	s.avail_in = *lenp - offset;
348174f4:	e5943000 	ldr	r3, [r4]
	r = inflateInit2(&s, -MAX_WBITS);
	if (r != Z_OK) {
		printf ("Error: inflateInit2() returned %d\n", r);
		return -1;
	}
	s.next_in = src + offset;
348174f8:	e0899006 	add	r9, r9, r6
	s.avail_in = *lenp - offset;
348174fc:	e0663003 	rsb	r3, r6, r3
	r = inflateInit2(&s, -MAX_WBITS);
	if (r != Z_OK) {
		printf ("Error: inflateInit2() returned %d\n", r);
		return -1;
	}
	s.next_in = src + offset;
34817500:	e58d9004 	str	r9, [sp, #4]
	s.avail_in = *lenp - offset;
34817504:	e58d3008 	str	r3, [sp, #8]
	s.next_out = dst;
34817508:	e58d5010 	str	r5, [sp, #16]
	s.avail_out = dstlen;
3481750c:	e58d7014 	str	r7, [sp, #20]
	do {
		r = inflate(&s, Z_FINISH);
34817510:	e3a01004 	mov	r1, #4
34817514:	e1a0000a 	mov	r0, sl
34817518:	eb000e88 	bl	3481af40 <inflate>
		if (r != Z_STREAM_END && r != Z_BUF_ERROR && stoponerr == 1) {
3481751c:	e3500001 	cmp	r0, #1
34817520:	13700005 	cmnne	r0, #5
	s.next_in = src + offset;
	s.avail_in = *lenp - offset;
	s.next_out = dst;
	s.avail_out = dstlen;
	do {
		r = inflate(&s, Z_FINISH);
34817524:	e1a01000 	mov	r1, r0
		if (r != Z_STREAM_END && r != Z_BUF_ERROR && stoponerr == 1) {
34817528:	0a000007 	beq	3481754c <zunzip+0xb4>
3481752c:	e35b0001 	cmp	fp, #1
34817530:	1a000005 	bne	3481754c <zunzip+0xb4>
			printf("Error: inflate() returned %d\n", r);
34817534:	e59f0060 	ldr	r0, [pc, #96]	; 3481759c <zunzip+0x104>
34817538:	ebffc683 	bl	34808f4c <printf>
			inflateEnd(&s);
3481753c:	e1a0000a 	mov	r0, sl
34817540:	eb000da9 	bl	3481abec <inflateEnd>
			return -1;
34817544:	e3e00000 	mvn	r0, #0
34817548:	ea00000d 	b	34817584 <zunzip+0xec>
		}
		s.avail_in = *lenp - offset - (int)(s.next_out - (unsigned char*)dst);
3481754c:	e59d3010 	ldr	r3, [sp, #16]
34817550:	e5942000 	ldr	r2, [r4]
34817554:	e0630005 	rsb	r0, r3, r5
34817558:	e0802002 	add	r2, r0, r2
3481755c:	e0662002 	rsb	r2, r6, r2
		s.avail_out = dstlen;
	} while (r == Z_BUF_ERROR);
34817560:	e3710005 	cmn	r1, #5
		if (r != Z_STREAM_END && r != Z_BUF_ERROR && stoponerr == 1) {
			printf("Error: inflate() returned %d\n", r);
			inflateEnd(&s);
			return -1;
		}
		s.avail_in = *lenp - offset - (int)(s.next_out - (unsigned char*)dst);
34817564:	e58d2008 	str	r2, [sp, #8]
		s.avail_out = dstlen;
34817568:	e58d7014 	str	r7, [sp, #20]
	} while (r == Z_BUF_ERROR);
3481756c:	0affffe7 	beq	34817510 <zunzip+0x78>
	*lenp = s.next_out - (unsigned char *) dst;
34817570:	e0655003 	rsb	r5, r5, r3
34817574:	e5845000 	str	r5, [r4]
	inflateEnd(&s);
34817578:	e28d0004 	add	r0, sp, #4
3481757c:	eb000d9a 	bl	3481abec <inflateEnd>

	return 0;
34817580:	e3a00000 	mov	r0, #0
}
34817584:	e28dd040 	add	sp, sp, #64	; 0x40
34817588:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
3481758c:	34817488 	.word	0x34817488
34817590:	34817480 	.word	0x34817480
34817594:	348276f4 	.word	0x348276f4
34817598:	348276fa 	.word	0x348276fa
3481759c:	3482771d 	.word	0x3482771d

348175a0 <gunzip>:
	int i, flags;

	/* skip header */
	i = 10;
	flags = src[3];
	if (src[2] != DEFLATED || (flags & RESERVED) != 0) {
348175a0:	e5d2c002 	ldrb	ip, [r2, #2]
{
	free (addr);
}

int gunzip(void *dst, int dstlen, unsigned char *src, unsigned long *lenp)
{
348175a4:	e92d4013 	push	{r0, r1, r4, lr}
	int i, flags;

	/* skip header */
	i = 10;
	flags = src[3];
	if (src[2] != DEFLATED || (flags & RESERVED) != 0) {
348175a8:	e35c0008 	cmp	ip, #8
{
	int i, flags;

	/* skip header */
	i = 10;
	flags = src[3];
348175ac:	e5d2e003 	ldrb	lr, [r2, #3]
	if (src[2] != DEFLATED || (flags & RESERVED) != 0) {
348175b0:	1a000001 	bne	348175bc <gunzip+0x1c>
348175b4:	e31e00e0 	tst	lr, #224	; 0xe0
348175b8:	0a000001 	beq	348175c4 <gunzip+0x24>
		puts ("Error: Bad gzipped data\n");
348175bc:	e59f0080 	ldr	r0, [pc, #128]	; 34817644 <gunzip+0xa4>
348175c0:	ea000017 	b	34817624 <gunzip+0x84>
		return (-1);
	}
	if ((flags & EXTRA_FIELD) != 0)
348175c4:	e31e0004 	tst	lr, #4
		i = 12 + src[10] + (src[11] << 8);
348175c8:	15d2c00a 	ldrbne	ip, [r2, #10]
348175cc:	15d2400b 	ldrbne	r4, [r2, #11]
348175d0:	128cc00c 	addne	ip, ip, #12
348175d4:	108cc404 	addne	ip, ip, r4, lsl #8
int gunzip(void *dst, int dstlen, unsigned char *src, unsigned long *lenp)
{
	int i, flags;

	/* skip header */
	i = 10;
348175d8:	03a0c00a 	moveq	ip, #10
		puts ("Error: Bad gzipped data\n");
		return (-1);
	}
	if ((flags & EXTRA_FIELD) != 0)
		i = 12 + src[10] + (src[11] << 8);
	if ((flags & ORIG_NAME) != 0)
348175dc:	e31e0008 	tst	lr, #8
348175e0:	0a000003 	beq	348175f4 <gunzip+0x54>
		while (src[i++] != 0)
348175e4:	e7d2400c 	ldrb	r4, [r2, ip]
348175e8:	e28cc001 	add	ip, ip, #1
348175ec:	e3540000 	cmp	r4, #0
348175f0:	1afffffb 	bne	348175e4 <gunzip+0x44>
			;
	if ((flags & COMMENT) != 0)
348175f4:	e31e0010 	tst	lr, #16
348175f8:	0a000003 	beq	3481760c <gunzip+0x6c>
		while (src[i++] != 0)
348175fc:	e7d2400c 	ldrb	r4, [r2, ip]
34817600:	e28cc001 	add	ip, ip, #1
34817604:	e3540000 	cmp	r4, #0
34817608:	1afffffb 	bne	348175fc <gunzip+0x5c>
			;
	if ((flags & HEAD_CRC) != 0)
3481760c:	e31e0002 	tst	lr, #2
		i += 2;
	if (i >= *lenp) {
34817610:	e593e000 	ldr	lr, [r3]
			;
	if ((flags & COMMENT) != 0)
		while (src[i++] != 0)
			;
	if ((flags & HEAD_CRC) != 0)
		i += 2;
34817614:	128cc002 	addne	ip, ip, #2
	if (i >= *lenp) {
34817618:	e15c000e 	cmp	ip, lr
3481761c:	3a000003 	bcc	34817630 <gunzip+0x90>
		puts ("Error: gunzip out of data in header\n");
34817620:	e59f0020 	ldr	r0, [pc, #32]	; 34817648 <gunzip+0xa8>
34817624:	ebffc63e 	bl	34808f24 <puts>
		return (-1);
34817628:	e3e00000 	mvn	r0, #0
3481762c:	ea000003 	b	34817640 <gunzip+0xa0>
	}

	return zunzip(dst, dstlen, src, lenp, 1, i);
34817630:	e3a0e001 	mov	lr, #1
34817634:	e58de000 	str	lr, [sp]
34817638:	e58dc004 	str	ip, [sp, #4]
3481763c:	ebffff95 	bl	34817498 <zunzip>
}
34817640:	e8bd801c 	pop	{r2, r3, r4, pc}
34817644:	3482773b 	.word	0x3482773b
34817648:	34827754 	.word	0x34827754

3481764c <drop_var_from_set>:
/*
 * Check whether variable 'name' is amongst vars[],
 * and remove all instances by setting the pointer to NULL
 */
static int drop_var_from_set(const char *name, int nvars, char * vars[])
{
3481764c:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
	int i = 0;
	int res = 0;

	/* No variables specified means process all of them */
	if (nvars == 0)
34817650:	e251a000 	subs	sl, r1, #0
34817654:	13a05000 	movne	r5, #0
/*
 * Check whether variable 'name' is amongst vars[],
 * and remove all instances by setting the pointer to NULL
 */
static int drop_var_from_set(const char *name, int nvars, char * vars[])
{
34817658:	e1a04000 	mov	r4, r0
	int i = 0;
	int res = 0;

	/* No variables specified means process all of them */
	if (nvars == 0)
3481765c:	11a07002 	movne	r7, r2
34817660:	11a06005 	movne	r6, r5
34817664:	1a000009 	bne	34817690 <drop_var_from_set+0x44>
34817668:	ea00000b 	b	3481769c <drop_var_from_set+0x50>
		return 1;

	for (i = 0; i < nvars; i++) {
		if (vars[i] == NULL)
3481766c:	e4971004 	ldr	r1, [r7], #4
34817670:	e3510000 	cmp	r1, #0
34817674:	0a000004 	beq	3481768c <drop_var_from_set+0x40>
			continue;
		/* If we found it, delete all of them */
		if (!strcmp(name, vars[i])) {
34817678:	e1a00004 	mov	r0, r4
3481767c:	eb00050b 	bl	34818ab0 <strcmp>
34817680:	e3500000 	cmp	r0, #0
			vars[i] = NULL;
34817684:	05070004 	streq	r0, [r7, #-4]
			res = 1;
34817688:	03a05001 	moveq	r5, #1

	/* No variables specified means process all of them */
	if (nvars == 0)
		return 1;

	for (i = 0; i < nvars; i++) {
3481768c:	e2866001 	add	r6, r6, #1
34817690:	e156000a 	cmp	r6, sl
34817694:	bafffff4 	blt	3481766c <drop_var_from_set+0x20>
34817698:	ea000000 	b	348176a0 <drop_var_from_set+0x54>
	int i = 0;
	int res = 0;

	/* No variables specified means process all of them */
	if (nvars == 0)
		return 1;
3481769c:	e3a05001 	mov	r5, #1
	}
	if (!res)
		debug("Skipping non-listed variable %s\n", name);

	return res;
}
348176a0:	e1a00005 	mov	r0, r5
348176a4:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}

348176a8 <cmpkey>:
static int cmpkey(const void *p1, const void *p2)
{
	ENTRY *e1 = *(ENTRY **) p1;
	ENTRY *e2 = *(ENTRY **) p2;

	return (strcmp(e1->key, e2->key));
348176a8:	e5902000 	ldr	r2, [r0]
348176ac:	e5913000 	ldr	r3, [r1]
348176b0:	e5920000 	ldr	r0, [r2]
348176b4:	e5931000 	ldr	r1, [r3]
348176b8:	ea0004fc 	b	34818ab0 <strcmp>

348176bc <hcreate_r>:
 * The contents of the table is zeroed, especially the field used
 * becomes zero.
 */

int hcreate_r(size_t nel, struct hsearch_data *htab)
{
348176bc:	e92d4070 	push	{r4, r5, r6, lr}
	/* Test for correct arguments.  */
	if (htab == NULL) {
348176c0:	e2516000 	subs	r6, r1, #0
348176c4:	1a000004 	bne	348176dc <hcreate_r+0x20>
		__set_errno(EINVAL);
348176c8:	e59f3094 	ldr	r3, [pc, #148]	; 34817764 <hcreate_r+0xa8>
348176cc:	e3a02016 	mov	r2, #22
348176d0:	e5832000 	str	r2, [r3]
		return 0;
348176d4:	e1a00006 	mov	r0, r6
348176d8:	e8bd8070 	pop	{r4, r5, r6, pc}
	}

	/* There is still another table active. Return with error. */
	if (htab->table != NULL)
348176dc:	e5963000 	ldr	r3, [r6]
348176e0:	e3530000 	cmp	r3, #0
		return 0;

	/* Change nel to the first prime number not smaller as nel. */
	nel |= 1;		/* make odd */
348176e4:	03804001 	orreq	r4, r0, #1
		__set_errno(EINVAL);
		return 0;
	}

	/* There is still another table active. Return with error. */
	if (htab->table != NULL)
348176e8:	1a00001b 	bne	3481775c <hcreate_r+0xa0>
348176ec:	ea000000 	b	348176f4 <hcreate_r+0x38>
		return 0;

	/* Change nel to the first prime number not smaller as nel. */
	nel |= 1;		/* make odd */
	while (!isprime(nel))
		nel += 2;
348176f0:	e2844002 	add	r4, r4, #2
 * b)  the number is small because the table must fit in the core
 * */
static int isprime(unsigned int number)
{
	/* no even number will be passed */
	unsigned int div = 3;
348176f4:	e3a05003 	mov	r5, #3
348176f8:	ea000000 	b	34817700 <hcreate_r+0x44>

	while (div * div < number && number % div != 0)
		div += 2;
348176fc:	e2855002 	add	r5, r5, #2
static int isprime(unsigned int number)
{
	/* no even number will be passed */
	unsigned int div = 3;

	while (div * div < number && number % div != 0)
34817700:	e0030595 	mul	r3, r5, r5
34817704:	e1530004 	cmp	r3, r4
34817708:	2a000004 	bcs	34817720 <hcreate_r+0x64>
3481770c:	e1a00004 	mov	r0, r4
34817710:	e1a01005 	mov	r1, r5
34817714:	eb00225d 	bl	34820090 <__aeabi_uidivmod>
34817718:	e3510000 	cmp	r1, #0
3481771c:	1afffff6 	bne	348176fc <hcreate_r+0x40>
		div += 2;

	return number % div != 0;
34817720:	e1a00004 	mov	r0, r4
34817724:	e1a01005 	mov	r1, r5
34817728:	eb002258 	bl	34820090 <__aeabi_uidivmod>
	if (htab->table != NULL)
		return 0;

	/* Change nel to the first prime number not smaller as nel. */
	nel |= 1;		/* make odd */
	while (!isprime(nel))
3481772c:	e3510000 	cmp	r1, #0
34817730:	0affffee 	beq	348176f0 <hcreate_r+0x34>
		nel += 2;

	htab->size = nel;
	htab->filled = 0;
34817734:	e3a03000 	mov	r3, #0
	/* Change nel to the first prime number not smaller as nel. */
	nel |= 1;		/* make odd */
	while (!isprime(nel))
		nel += 2;

	htab->size = nel;
34817738:	e5864004 	str	r4, [r6, #4]
	htab->filled = 0;
3481773c:	e5863008 	str	r3, [r6, #8]

	/* allocate memory and zero out */
	htab->table = (_ENTRY *) calloc(htab->size + 1, sizeof(_ENTRY));
34817740:	e2840001 	add	r0, r4, #1
34817744:	e3a0100c 	mov	r1, #12
34817748:	ebffc933 	bl	34809c1c <calloc>
3481774c:	e5860000 	str	r0, [r6]
int hcreate_r(size_t nel, struct hsearch_data *htab)
{
	/* Test for correct arguments.  */
	if (htab == NULL) {
		__set_errno(EINVAL);
		return 0;
34817750:	e2500000 	subs	r0, r0, #0
34817754:	13a00001 	movne	r0, #1
34817758:	e8bd8070 	pop	{r4, r5, r6, pc}
	}

	/* There is still another table active. Return with error. */
	if (htab->table != NULL)
		return 0;
3481775c:	e3a00000 	mov	r0, #0
	if (htab->table == NULL)
		return 0;

	/* everything went alright */
	return 1;
}
34817760:	e8bd8070 	pop	{r4, r5, r6, pc}
34817764:	3482b338 	.word	0x3482b338

34817768 <hdestroy_r>:
 * After using the hash table it has to be destroyed. The used memory can
 * be freed and the local static variable can be marked as not used.
 */

void hdestroy_r(struct hsearch_data *htab, int do_apply)
{
34817768:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
	int i;

	/* Test for correct arguments.  */
	if (htab == NULL) {
3481776c:	e2504000 	subs	r4, r0, #0
 * After using the hash table it has to be destroyed. The used memory can
 * be freed and the local static variable can be marked as not used.
 */

void hdestroy_r(struct hsearch_data *htab, int do_apply)
{
34817770:	e1a0a001 	mov	sl, r1
	int i;

	/* Test for correct arguments.  */
	if (htab == NULL) {
34817774:	13a0600c 	movne	r6, #12
34817778:	13a07001 	movne	r7, #1
3481777c:	1a000017 	bne	348177e0 <hdestroy_r+0x78>
		__set_errno(EINVAL);
34817780:	e59f3078 	ldr	r3, [pc, #120]	; 34817800 <hdestroy_r+0x98>
34817784:	e3a02016 	mov	r2, #22
34817788:	e5832000 	str	r2, [r3]
		return;
3481778c:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
	}

	/* free used memory */
	for (i = 1; i <= htab->size; ++i) {
		if (htab->table[i].used > 0) {
34817790:	e5943000 	ldr	r3, [r4]
34817794:	e0835006 	add	r5, r3, r6
34817798:	e7933006 	ldr	r3, [r3, r6]
3481779c:	e3530000 	cmp	r3, #0
348177a0:	da00000c 	ble	348177d8 <hdestroy_r+0x70>
			ENTRY *ep = &htab->table[i].entry;
			if (do_apply && htab->apply != NULL) {
348177a4:	e35a0000 	cmp	sl, #0
348177a8:	0a000006 	beq	348177c8 <hdestroy_r+0x60>
348177ac:	e594c00c 	ldr	ip, [r4, #12]
348177b0:	e35c0000 	cmp	ip, #0
348177b4:	0a000003 	beq	348177c8 <hdestroy_r+0x60>
				/* deletion is always forced */
				htab->apply(ep->key, ep->data, NULL, H_FORCE);
348177b8:	e9950003 	ldmib	r5, {r0, r1}
348177bc:	e3a02000 	mov	r2, #0
348177c0:	e3a03002 	mov	r3, #2
348177c4:	e12fff3c 	blx	ip
			}
			free((void *)ep->key);
348177c8:	e5950004 	ldr	r0, [r5, #4]
348177cc:	ebffc71c 	bl	34809444 <free>
			free(ep->data);
348177d0:	e5950008 	ldr	r0, [r5, #8]
348177d4:	ebffc71a 	bl	34809444 <free>
		__set_errno(EINVAL);
		return;
	}

	/* free used memory */
	for (i = 1; i <= htab->size; ++i) {
348177d8:	e2877001 	add	r7, r7, #1
348177dc:	e286600c 	add	r6, r6, #12
348177e0:	e5943004 	ldr	r3, [r4, #4]
348177e4:	e1570003 	cmp	r7, r3
348177e8:	9affffe8 	bls	34817790 <hdestroy_r+0x28>
			}
			free((void *)ep->key);
			free(ep->data);
		}
	}
	free(htab->table);
348177ec:	e5940000 	ldr	r0, [r4]
348177f0:	ebffc713 	bl	34809444 <free>

	/* the sign for an existing table is an value != NULL in htable */
	htab->table = NULL;
348177f4:	e3a03000 	mov	r3, #0
348177f8:	e5843000 	str	r3, [r4]
348177fc:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
34817800:	3482b338 	.word	0x3482b338

34817804 <hstrstr_r>:
/*
 * hstrstr_r - return index to entry whose key and/or data contains match
 */
int hstrstr_r(const char *match, int last_idx, ENTRY ** retval,
	      struct hsearch_data *htab)
{
34817804:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
	unsigned int idx;

	for (idx = last_idx + 1; idx < htab->size; ++idx) {
34817808:	e2817001 	add	r7, r1, #1
3481780c:	e3a0600c 	mov	r6, #12
/*
 * hstrstr_r - return index to entry whose key and/or data contains match
 */
int hstrstr_r(const char *match, int last_idx, ENTRY ** retval,
	      struct hsearch_data *htab)
{
34817810:	e1a04000 	mov	r4, r0
34817814:	e1a05002 	mov	r5, r2
34817818:	e1a0a003 	mov	sl, r3
	unsigned int idx;

	for (idx = last_idx + 1; idx < htab->size; ++idx) {
3481781c:	e0060796 	mul	r6, r6, r7
34817820:	ea000018 	b	34817888 <hstrstr_r+0x84>
		if (htab->table[idx].used <= 0)
34817824:	e59a3000 	ldr	r3, [sl]
34817828:	e0832006 	add	r2, r3, r6
3481782c:	e7933006 	ldr	r3, [r3, r6]
34817830:	e3530000 	cmp	r3, #0
34817834:	da000011 	ble	34817880 <hstrstr_r+0x7c>
			continue;
		if (strstr(htab->table[idx].entry.key, match) ||
34817838:	e5920004 	ldr	r0, [r2, #4]
3481783c:	e1a01004 	mov	r1, r4
34817840:	eb0005dd 	bl	34818fbc <strstr>
34817844:	e3500000 	cmp	r0, #0
34817848:	1a000006 	bne	34817868 <hstrstr_r+0x64>
		    strstr(htab->table[idx].entry.data, match)) {
3481784c:	e59a3000 	ldr	r3, [sl]
34817850:	e1a01004 	mov	r1, r4
34817854:	e0833006 	add	r3, r3, r6
34817858:	e5930008 	ldr	r0, [r3, #8]
3481785c:	eb0005d6 	bl	34818fbc <strstr>
	unsigned int idx;

	for (idx = last_idx + 1; idx < htab->size; ++idx) {
		if (htab->table[idx].used <= 0)
			continue;
		if (strstr(htab->table[idx].entry.key, match) ||
34817860:	e3500000 	cmp	r0, #0
34817864:	0a000005 	beq	34817880 <hstrstr_r+0x7c>
		    strstr(htab->table[idx].entry.data, match)) {
			*retval = &htab->table[idx].entry;
34817868:	e59a3000 	ldr	r3, [sl]
			return idx;
3481786c:	e1a00007 	mov	r0, r7
	for (idx = last_idx + 1; idx < htab->size; ++idx) {
		if (htab->table[idx].used <= 0)
			continue;
		if (strstr(htab->table[idx].entry.key, match) ||
		    strstr(htab->table[idx].entry.data, match)) {
			*retval = &htab->table[idx].entry;
34817870:	e0836006 	add	r6, r3, r6
34817874:	e2866004 	add	r6, r6, #4
34817878:	e5856000 	str	r6, [r5]
			return idx;
3481787c:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
int hstrstr_r(const char *match, int last_idx, ENTRY ** retval,
	      struct hsearch_data *htab)
{
	unsigned int idx;

	for (idx = last_idx + 1; idx < htab->size; ++idx) {
34817880:	e2877001 	add	r7, r7, #1
34817884:	e286600c 	add	r6, r6, #12
34817888:	e59a3004 	ldr	r3, [sl, #4]
3481788c:	e1570003 	cmp	r7, r3
34817890:	3affffe3 	bcc	34817824 <hstrstr_r+0x20>
			*retval = &htab->table[idx].entry;
			return idx;
		}
	}

	__set_errno(ESRCH);
34817894:	e59f3010 	ldr	r3, [pc, #16]	; 348178ac <hstrstr_r+0xa8>
34817898:	e3a02003 	mov	r2, #3
	*retval = NULL;
3481789c:	e3a00000 	mov	r0, #0
			*retval = &htab->table[idx].entry;
			return idx;
		}
	}

	__set_errno(ESRCH);
348178a0:	e5832000 	str	r2, [r3]
	*retval = NULL;
348178a4:	e5850000 	str	r0, [r5]
	return 0;
}
348178a8:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
348178ac:	3482b338 	.word	0x3482b338

348178b0 <hmatch_r>:

int hmatch_r(const char *match, int last_idx, ENTRY ** retval,
	     struct hsearch_data *htab)
{
348178b0:	e92d46f8 	push	{r3, r4, r5, r6, r7, r9, sl, lr}
348178b4:	e1a05001 	mov	r5, r1
348178b8:	e1a09000 	mov	r9, r0
348178bc:	e1a04002 	mov	r4, r2
348178c0:	e1a07003 	mov	r7, r3
	unsigned int idx;
	size_t key_len = strlen(match);
348178c4:	eb0004ad 	bl	34818b80 <strlen>

	for (idx = last_idx + 1; idx < htab->size; ++idx) {
348178c8:	e2855001 	add	r5, r5, #1
348178cc:	e3a0600c 	mov	r6, #12

int hmatch_r(const char *match, int last_idx, ENTRY ** retval,
	     struct hsearch_data *htab)
{
	unsigned int idx;
	size_t key_len = strlen(match);
348178d0:	e1a0a000 	mov	sl, r0

	for (idx = last_idx + 1; idx < htab->size; ++idx) {
348178d4:	e0060596 	mul	r6, r6, r5
348178d8:	ea000012 	b	34817928 <hmatch_r+0x78>
		if (htab->table[idx].used <= 0)
348178dc:	e5972000 	ldr	r2, [r7]
348178e0:	e0823006 	add	r3, r2, r6
348178e4:	e7922006 	ldr	r2, [r2, r6]
348178e8:	e3520000 	cmp	r2, #0
348178ec:	da00000b 	ble	34817920 <hmatch_r+0x70>
			continue;
		if (!strncmp(match, htab->table[idx].entry.key, key_len)) {
348178f0:	e1a00009 	mov	r0, r9
348178f4:	e5931004 	ldr	r1, [r3, #4]
348178f8:	e1a0200a 	mov	r2, sl
348178fc:	eb000477 	bl	34818ae0 <strncmp>
34817900:	e3500000 	cmp	r0, #0
34817904:	1a000005 	bne	34817920 <hmatch_r+0x70>
			*retval = &htab->table[idx].entry;
34817908:	e5973000 	ldr	r3, [r7]
			return idx;
3481790c:	e1a00005 	mov	r0, r5

	for (idx = last_idx + 1; idx < htab->size; ++idx) {
		if (htab->table[idx].used <= 0)
			continue;
		if (!strncmp(match, htab->table[idx].entry.key, key_len)) {
			*retval = &htab->table[idx].entry;
34817910:	e0836006 	add	r6, r3, r6
34817914:	e2866004 	add	r6, r6, #4
34817918:	e5846000 	str	r6, [r4]
			return idx;
3481791c:	e8bd86f8 	pop	{r3, r4, r5, r6, r7, r9, sl, pc}
	     struct hsearch_data *htab)
{
	unsigned int idx;
	size_t key_len = strlen(match);

	for (idx = last_idx + 1; idx < htab->size; ++idx) {
34817920:	e2855001 	add	r5, r5, #1
34817924:	e286600c 	add	r6, r6, #12
34817928:	e5973004 	ldr	r3, [r7, #4]
3481792c:	e1550003 	cmp	r5, r3
34817930:	3affffe9 	bcc	348178dc <hmatch_r+0x2c>
			*retval = &htab->table[idx].entry;
			return idx;
		}
	}

	__set_errno(ESRCH);
34817934:	e59f3010 	ldr	r3, [pc, #16]	; 3481794c <hmatch_r+0x9c>
34817938:	e3a02003 	mov	r2, #3
	*retval = NULL;
3481793c:	e3a00000 	mov	r0, #0
			*retval = &htab->table[idx].entry;
			return idx;
		}
	}

	__set_errno(ESRCH);
34817940:	e5832000 	str	r2, [r3]
	*retval = NULL;
34817944:	e5840000 	str	r0, [r4]
	return 0;
}
34817948:	e8bd86f8 	pop	{r3, r4, r5, r6, r7, r9, sl, pc}
3481794c:	3482b338 	.word	0x3482b338

34817950 <hsearch_r>:

int hsearch_r(ENTRY item, ACTION action, ENTRY ** retval,
	      struct hsearch_data *htab)
{
34817950:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
34817954:	e24dd018 	sub	sp, sp, #24
34817958:	e28dc010 	add	ip, sp, #16
3481795c:	e88c0003 	stm	ip, {r0, r1}
34817960:	e58d2008 	str	r2, [sp, #8]
		return 1;
	}

	__set_errno(ESRCH);
	*retval = NULL;
	return 0;
34817964:	e59d2014 	ldr	r2, [sp, #20]
	return 0;
}

int hsearch_r(ENTRY item, ACTION action, ENTRY ** retval,
	      struct hsearch_data *htab)
{
34817968:	e1a07003 	mov	r7, r3
3481796c:	e59d4038 	ldr	r4, [sp, #56]	; 0x38
		return 1;
	}

	__set_errno(ESRCH);
	*retval = NULL;
	return 0;
34817970:	e1a0b000 	mov	fp, r0
34817974:	e58d2004 	str	r2, [sp, #4]
int hsearch_r(ENTRY item, ACTION action, ENTRY ** retval,
	      struct hsearch_data *htab)
{
	unsigned int hval;
	unsigned int count;
	unsigned int len = strlen(item.key);
34817978:	eb000480 	bl	34818b80 <strlen>
3481797c:	e1a0a000 	mov	sl, r0
	unsigned int first_deleted = 0;

	/* Compute an value for the given string. Perhaps use a better method. */
	hval = len;
	count = len;
	while (count-- > 0) {
34817980:	ea000002 	b	34817990 <hsearch_r+0x40>
34817984:	e24aa001 	sub	sl, sl, #1
		hval <<= 4;
		hval += item.key[count];
34817988:	e7db300a 	ldrb	r3, [fp, sl]
3481798c:	e0830200 	add	r0, r3, r0, lsl #4
	unsigned int first_deleted = 0;

	/* Compute an value for the given string. Perhaps use a better method. */
	hval = len;
	count = len;
	while (count-- > 0) {
34817990:	e35a0000 	cmp	sl, #0
34817994:	1afffffa 	bne	34817984 <hsearch_r+0x34>

	/*
	 * First hash function:
	 * simply take the modul but prevent zero.
	 */
	hval %= htab->size;
34817998:	e5941004 	ldr	r1, [r4, #4]
3481799c:	eb0021bb 	bl	34820090 <__aeabi_uidivmod>
	if (hval == 0)
		++hval;
348179a0:	e3510000 	cmp	r1, #0
348179a4:	11a06001 	movne	r6, r1
348179a8:	03a06001 	moveq	r6, #1

	/* The first index tried. */
	idx = hval;

	if (htab->table[idx].used) {
348179ac:	e3a0300c 	mov	r3, #12
348179b0:	e0090693 	mul	r9, r3, r6
348179b4:	e5942000 	ldr	r2, [r4]
348179b8:	e7925009 	ldr	r5, [r2, r9]
348179bc:	e0823009 	add	r3, r2, r9
348179c0:	e3550000 	cmp	r5, #0
348179c4:	01a05006 	moveq	r5, r6
{
	unsigned int hval;
	unsigned int count;
	unsigned int len = strlen(item.key);
	unsigned int idx;
	unsigned int first_deleted = 0;
348179c8:	058da00c 	streq	sl, [sp, #12]
		++hval;

	/* The first index tried. */
	idx = hval;

	if (htab->table[idx].used) {
348179cc:	0a000067 	beq	34817b70 <hsearch_r+0x220>
{
	unsigned int hval;
	unsigned int count;
	unsigned int len = strlen(item.key);
	unsigned int idx;
	unsigned int first_deleted = 0;
348179d0:	e3750001 	cmn	r5, #1
348179d4:	01a02006 	moveq	r2, r6
348179d8:	13a02000 	movne	r2, #0

		if (htab->table[idx].used == -1
		    && !first_deleted)
			first_deleted = idx;

		if (htab->table[idx].used == hval
348179dc:	e1550006 	cmp	r5, r6
{
	unsigned int hval;
	unsigned int count;
	unsigned int len = strlen(item.key);
	unsigned int idx;
	unsigned int first_deleted = 0;
348179e0:	e58d200c 	str	r2, [sp, #12]

		if (htab->table[idx].used == -1
		    && !first_deleted)
			first_deleted = idx;

		if (htab->table[idx].used == hval
348179e4:	1a000023 	bne	34817a78 <hsearch_r+0x128>
		    && strcmp(item.key, htab->table[idx].entry.key) == 0) {
348179e8:	e1a0000b 	mov	r0, fp
348179ec:	e5931004 	ldr	r1, [r3, #4]
348179f0:	eb00042e 	bl	34818ab0 <strcmp>
348179f4:	e3500000 	cmp	r0, #0
348179f8:	1a00001e 	bne	34817a78 <hsearch_r+0x128>
			/* Overwrite existing value? */
			if ((action == ENTER) && (item.data != NULL)) {
348179fc:	e59d3008 	ldr	r3, [sp, #8]
34817a00:	e3530001 	cmp	r3, #1
34817a04:	1a000016 	bne	34817a64 <hsearch_r+0x114>
34817a08:	e59d2004 	ldr	r2, [sp, #4]
34817a0c:	e3520000 	cmp	r2, #0
34817a10:	0a000013 	beq	34817a64 <hsearch_r+0x114>
				free(htab->table[idx].entry.data);
34817a14:	e5943000 	ldr	r3, [r4]
34817a18:	e0833009 	add	r3, r3, r9
34817a1c:	e5930008 	ldr	r0, [r3, #8]
34817a20:	ebffc687 	bl	34809444 <free>
				htab->table[idx].entry.data =
					strdup(item.data);
34817a24:	e59d0004 	ldr	r0, [sp, #4]
		if (htab->table[idx].used == hval
		    && strcmp(item.key, htab->table[idx].entry.key) == 0) {
			/* Overwrite existing value? */
			if ((action == ENTER) && (item.data != NULL)) {
				free(htab->table[idx].entry.data);
				htab->table[idx].entry.data =
34817a28:	e5946000 	ldr	r6, [r4]
					strdup(item.data);
34817a2c:	eb000488 	bl	34818c54 <strdup>
				if (!htab->table[idx].entry.data) {
34817a30:	e5943000 	ldr	r3, [r4]
		if (htab->table[idx].used == hval
		    && strcmp(item.key, htab->table[idx].entry.key) == 0) {
			/* Overwrite existing value? */
			if ((action == ENTER) && (item.data != NULL)) {
				free(htab->table[idx].entry.data);
				htab->table[idx].entry.data =
34817a34:	e0866009 	add	r6, r6, r9
34817a38:	e5860008 	str	r0, [r6, #8]
					strdup(item.data);
				if (!htab->table[idx].entry.data) {
34817a3c:	e0833009 	add	r3, r3, r9
34817a40:	e5933008 	ldr	r3, [r3, #8]
34817a44:	e3530000 	cmp	r3, #0
34817a48:	1a000005 	bne	34817a64 <hsearch_r+0x114>
					__set_errno(ENOMEM);
34817a4c:	e59f31dc 	ldr	r3, [pc, #476]	; 34817c30 <hsearch_r+0x2e0>
34817a50:	e3a0200c 	mov	r2, #12
34817a54:	e5832000 	str	r2, [r3]
					*retval = NULL;
					return 0;
34817a58:	e1a0500a 	mov	r5, sl
				free(htab->table[idx].entry.data);
				htab->table[idx].entry.data =
					strdup(item.data);
				if (!htab->table[idx].entry.data) {
					__set_errno(ENOMEM);
					*retval = NULL;
34817a5c:	e587a000 	str	sl, [r7]
					return 0;
34817a60:	ea00006f 	b	34817c24 <hsearch_r+0x2d4>
				}
			}
			/* return found entry */
			*retval = &htab->table[idx].entry;
34817a64:	e5943000 	ldr	r3, [r4]
34817a68:	e0839009 	add	r9, r3, r9
34817a6c:	e2899004 	add	r9, r9, #4
34817a70:	e5879000 	str	r9, [r7]
			return idx;
34817a74:	ea00006a 	b	34817c24 <hsearch_r+0x2d4>

		/*
		 * Second hash function:
		 * as suggested in [Knuth]
		 */
		hval2 = 1 + hval % (htab->size - 2);
34817a78:	e5941004 	ldr	r1, [r4, #4]
34817a7c:	e1a00006 	mov	r0, r6
34817a80:	e2411002 	sub	r1, r1, #2
34817a84:	eb002181 	bl	34820090 <__aeabi_uidivmod>
34817a88:	e1a05006 	mov	r5, r6
34817a8c:	e2819001 	add	r9, r1, #1
			 */
			if (idx == hval)
				break;

			/* If entry is found use it. */
			if ((htab->table[idx].used == hval)
34817a90:	e3a0c00c 	mov	ip, #12
		do {
			/*
			 * Because SIZE is prime this guarantees to
			 * step through all available indices.
			 */
			if (idx <= hval2)
34817a94:	e1550009 	cmp	r5, r9
				idx = htab->size + idx - hval2;
34817a98:	95943004 	ldrls	r3, [r4, #4]
			else
				idx -= hval2;
34817a9c:	80695005 	rsbhi	r5, r9, r5
			/*
			 * Because SIZE is prime this guarantees to
			 * step through all available indices.
			 */
			if (idx <= hval2)
				idx = htab->size + idx - hval2;
34817aa0:	90693003 	rsbls	r3, r9, r3
34817aa4:	90855003 	addls	r5, r5, r3

			/*
			 * If we visited all entries leave the loop
			 * unsuccessfully.
			 */
			if (idx == hval)
34817aa8:	e1550006 	cmp	r5, r6
34817aac:	0a00002f 	beq	34817b70 <hsearch_r+0x220>
				break;

			/* If entry is found use it. */
			if ((htab->table[idx].used == hval)
34817ab0:	e00a059c 	mul	sl, ip, r5
34817ab4:	e5942000 	ldr	r2, [r4]
34817ab8:	e082300a 	add	r3, r2, sl
34817abc:	e792200a 	ldr	r2, [r2, sl]
34817ac0:	e1520006 	cmp	r2, r6
34817ac4:	1a000025 	bne	34817b60 <hsearch_r+0x210>
			    && strcmp(item.key, htab->table[idx].entry.key) == 0) {
34817ac8:	e5931004 	ldr	r1, [r3, #4]
34817acc:	e1a0000b 	mov	r0, fp
34817ad0:	e58dc000 	str	ip, [sp]
34817ad4:	eb0003f5 	bl	34818ab0 <strcmp>
34817ad8:	e3500000 	cmp	r0, #0
34817adc:	e59dc000 	ldr	ip, [sp]
34817ae0:	1a00001e 	bne	34817b60 <hsearch_r+0x210>
				/* Overwrite existing value? */
				if ((action == ENTER) && (item.data != NULL)) {
34817ae4:	e59d3008 	ldr	r3, [sp, #8]
34817ae8:	e3530001 	cmp	r3, #1
34817aec:	1a000016 	bne	34817b4c <hsearch_r+0x1fc>
34817af0:	e59d2004 	ldr	r2, [sp, #4]
34817af4:	e3520000 	cmp	r2, #0
34817af8:	0a000013 	beq	34817b4c <hsearch_r+0x1fc>
					free(htab->table[idx].entry.data);
34817afc:	e5943000 	ldr	r3, [r4]
34817b00:	e083300a 	add	r3, r3, sl
34817b04:	e5930008 	ldr	r0, [r3, #8]
34817b08:	ebffc64d 	bl	34809444 <free>
					htab->table[idx].entry.data =
						strdup(item.data);
34817b0c:	e59d0004 	ldr	r0, [sp, #4]
			if ((htab->table[idx].used == hval)
			    && strcmp(item.key, htab->table[idx].entry.key) == 0) {
				/* Overwrite existing value? */
				if ((action == ENTER) && (item.data != NULL)) {
					free(htab->table[idx].entry.data);
					htab->table[idx].entry.data =
34817b10:	e5946000 	ldr	r6, [r4]
						strdup(item.data);
34817b14:	eb00044e 	bl	34818c54 <strdup>
					if (!htab->table[idx].entry.data) {
34817b18:	e5943000 	ldr	r3, [r4]
			if ((htab->table[idx].used == hval)
			    && strcmp(item.key, htab->table[idx].entry.key) == 0) {
				/* Overwrite existing value? */
				if ((action == ENTER) && (item.data != NULL)) {
					free(htab->table[idx].entry.data);
					htab->table[idx].entry.data =
34817b1c:	e086600a 	add	r6, r6, sl
34817b20:	e5860008 	str	r0, [r6, #8]
						strdup(item.data);
					if (!htab->table[idx].entry.data) {
34817b24:	e083300a 	add	r3, r3, sl
34817b28:	e5933008 	ldr	r3, [r3, #8]
34817b2c:	e3530000 	cmp	r3, #0
34817b30:	1a000005 	bne	34817b4c <hsearch_r+0x1fc>
						__set_errno(ENOMEM);
34817b34:	e59f20f4 	ldr	r2, [pc, #244]	; 34817c30 <hsearch_r+0x2e0>
34817b38:	e3a0100c 	mov	r1, #12
34817b3c:	e5821000 	str	r1, [r2]
						*retval = NULL;
						return 0;
34817b40:	e1a05003 	mov	r5, r3
					free(htab->table[idx].entry.data);
					htab->table[idx].entry.data =
						strdup(item.data);
					if (!htab->table[idx].entry.data) {
						__set_errno(ENOMEM);
						*retval = NULL;
34817b44:	e5873000 	str	r3, [r7]
						return 0;
34817b48:	ea000035 	b	34817c24 <hsearch_r+0x2d4>
					}
				}
				/* return found entry */
				*retval = &htab->table[idx].entry;
34817b4c:	e5943000 	ldr	r3, [r4]
34817b50:	e083a00a 	add	sl, r3, sl
34817b54:	e28aa004 	add	sl, sl, #4
34817b58:	e587a000 	str	sl, [r7]
				return idx;
34817b5c:	ea000030 	b	34817c24 <hsearch_r+0x2d4>
			}
		}
		while (htab->table[idx].used);
34817b60:	e5943000 	ldr	r3, [r4]
34817b64:	e793300a 	ldr	r3, [r3, sl]
34817b68:	e3530000 	cmp	r3, #0
34817b6c:	1affffc8 	bne	34817a94 <hsearch_r+0x144>
	}

	/* An empty bucket has been found. */
	if (action == ENTER) {
34817b70:	e59d3008 	ldr	r3, [sp, #8]
34817b74:	e3530001 	cmp	r3, #1
		/* return new entry */
		*retval = &htab->table[idx].entry;
		return 1;
	}

	__set_errno(ESRCH);
34817b78:	13a02003 	movne	r2, #3
		}
		while (htab->table[idx].used);
	}

	/* An empty bucket has been found. */
	if (action == ENTER) {
34817b7c:	1a000024 	bne	34817c14 <hsearch_r+0x2c4>
		/*
		 * If table is full and another entry should be
		 * entered return with error.
		 */
		if (htab->filled == htab->size) {
34817b80:	e5942008 	ldr	r2, [r4, #8]
34817b84:	e5943004 	ldr	r3, [r4, #4]
34817b88:	e1520003 	cmp	r2, r3
34817b8c:	0a000017 	beq	34817bf0 <hsearch_r+0x2a0>

		/*
		 * Create new entry;
		 * create copies of item.key and item.data
		 */
		if (first_deleted)
34817b90:	e59d200c 	ldr	r2, [sp, #12]
			idx = first_deleted;

		htab->table[idx].used = hval;
34817b94:	e3a0300c 	mov	r3, #12

		/*
		 * Create new entry;
		 * create copies of item.key and item.data
		 */
		if (first_deleted)
34817b98:	e3520000 	cmp	r2, #0
34817b9c:	11a05002 	movne	r5, r2
			idx = first_deleted;

		htab->table[idx].used = hval;
34817ba0:	e0050593 	mul	r5, r3, r5
34817ba4:	e5943000 	ldr	r3, [r4]
		htab->table[idx].entry.key = strdup(item.key);
34817ba8:	e1a0000b 	mov	r0, fp
		 * create copies of item.key and item.data
		 */
		if (first_deleted)
			idx = first_deleted;

		htab->table[idx].used = hval;
34817bac:	e7836005 	str	r6, [r3, r5]
34817bb0:	e083a005 	add	sl, r3, r5
		htab->table[idx].entry.key = strdup(item.key);
34817bb4:	eb000426 	bl	34818c54 <strdup>
34817bb8:	e58a0004 	str	r0, [sl, #4]
		htab->table[idx].entry.data = strdup(item.data);
34817bbc:	e59d0004 	ldr	r0, [sp, #4]
34817bc0:	e5946000 	ldr	r6, [r4]
34817bc4:	eb000422 	bl	34818c54 <strdup>
		if (!htab->table[idx].entry.key ||
34817bc8:	e5943000 	ldr	r3, [r4]
		if (first_deleted)
			idx = first_deleted;

		htab->table[idx].used = hval;
		htab->table[idx].entry.key = strdup(item.key);
		htab->table[idx].entry.data = strdup(item.data);
34817bcc:	e0866005 	add	r6, r6, r5
		if (!htab->table[idx].entry.key ||
34817bd0:	e0835005 	add	r5, r3, r5
34817bd4:	e5953004 	ldr	r3, [r5, #4]
		if (first_deleted)
			idx = first_deleted;

		htab->table[idx].used = hval;
		htab->table[idx].entry.key = strdup(item.key);
		htab->table[idx].entry.data = strdup(item.data);
34817bd8:	e5860008 	str	r0, [r6, #8]
		if (!htab->table[idx].entry.key ||
34817bdc:	e3530000 	cmp	r3, #0
34817be0:	0a000002 	beq	34817bf0 <hsearch_r+0x2a0>
34817be4:	e5953008 	ldr	r3, [r5, #8]
34817be8:	e3530000 	cmp	r3, #0
34817bec:	1a000001 	bne	34817bf8 <hsearch_r+0x2a8>
		    !htab->table[idx].entry.data) {
			__set_errno(ENOMEM);
34817bf0:	e3a0200c 	mov	r2, #12
34817bf4:	ea000006 	b	34817c14 <hsearch_r+0x2c4>
			*retval = NULL;
			return 0;
		}

		++htab->filled;
34817bf8:	e5943008 	ldr	r3, [r4, #8]

		/* return new entry */
		*retval = &htab->table[idx].entry;
34817bfc:	e2855004 	add	r5, r5, #4
			__set_errno(ENOMEM);
			*retval = NULL;
			return 0;
		}

		++htab->filled;
34817c00:	e2833001 	add	r3, r3, #1
34817c04:	e5843008 	str	r3, [r4, #8]

		/* return new entry */
		*retval = &htab->table[idx].entry;
34817c08:	e5875000 	str	r5, [r7]
		return 1;
34817c0c:	e59d5008 	ldr	r5, [sp, #8]
34817c10:	ea000003 	b	34817c24 <hsearch_r+0x2d4>
	}

	__set_errno(ESRCH);
34817c14:	e59f3014 	ldr	r3, [pc, #20]	; 34817c30 <hsearch_r+0x2e0>
	*retval = NULL;
34817c18:	e3a05000 	mov	r5, #0
		/* return new entry */
		*retval = &htab->table[idx].entry;
		return 1;
	}

	__set_errno(ESRCH);
34817c1c:	e5832000 	str	r2, [r3]
	*retval = NULL;
34817c20:	e5875000 	str	r5, [r7]
	return 0;
}
34817c24:	e1a00005 	mov	r0, r5
34817c28:	e28dd018 	add	sp, sp, #24
34817c2c:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
34817c30:	3482b338 	.word	0x3482b338

34817c34 <hdelete_r>:
 * to delete any entries from the hash table.  We extend the code to
 * do that.
 */

int hdelete_r(const char *key, struct hsearch_data *htab, int do_apply)
{
34817c34:	e92d4070 	push	{r4, r5, r6, lr}
34817c38:	e24dd018 	sub	sp, sp, #24
	ENTRY e, *ep;
	int idx;

	debug("hdelete: DELETE key \"%s\"\n", key);

	e.key = (char *)key;
34817c3c:	e58d000c 	str	r0, [sp, #12]

	if ((idx = hsearch_r(e, FIND, &ep, htab)) == 0) {
34817c40:	e58d1000 	str	r1, [sp]
34817c44:	e28d300c 	add	r3, sp, #12
 * to delete any entries from the hash table.  We extend the code to
 * do that.
 */

int hdelete_r(const char *key, struct hsearch_data *htab, int do_apply)
{
34817c48:	e1a04001 	mov	r4, r1
34817c4c:	e1a06002 	mov	r6, r2

	debug("hdelete: DELETE key \"%s\"\n", key);

	e.key = (char *)key;

	if ((idx = hsearch_r(e, FIND, &ep, htab)) == 0) {
34817c50:	e8930003 	ldm	r3, {r0, r1}
34817c54:	e3a02000 	mov	r2, #0
34817c58:	e28d3014 	add	r3, sp, #20
34817c5c:	ebffff3b 	bl	34817950 <hsearch_r>
34817c60:	e2505000 	subs	r5, r0, #0
		__set_errno(ESRCH);
34817c64:	059f3078 	ldreq	r3, [pc, #120]	; 34817ce4 <hdelete_r+0xb0>
34817c68:	03a02003 	moveq	r2, #3
34817c6c:	05832000 	streq	r2, [r3]
		return 0;	/* not found */
34817c70:	01a00005 	moveq	r0, r5
34817c74:	0a000018 	beq	34817cdc <hdelete_r+0xa8>
	}

	/* free used ENTRY */
	debug("hdelete: DELETING key \"%s\"\n", key);
	if (do_apply && htab->apply != NULL)
34817c78:	e3560000 	cmp	r6, #0
34817c7c:	0a000007 	beq	34817ca0 <hdelete_r+0x6c>
34817c80:	e594c00c 	ldr	ip, [r4, #12]
34817c84:	e35c0000 	cmp	ip, #0
34817c88:	0a000004 	beq	34817ca0 <hdelete_r+0x6c>
		htab->apply(ep->key, ep->data, NULL, H_FORCE);
34817c8c:	e59d3014 	ldr	r3, [sp, #20]
34817c90:	e3a02000 	mov	r2, #0
34817c94:	e8930003 	ldm	r3, {r0, r1}
34817c98:	e3a03002 	mov	r3, #2
34817c9c:	e12fff3c 	blx	ip
	free((void *)ep->key);
34817ca0:	e59d3014 	ldr	r3, [sp, #20]
34817ca4:	e5930000 	ldr	r0, [r3]
34817ca8:	ebffc5e5 	bl	34809444 <free>
	free(ep->data);
34817cac:	e59d3014 	ldr	r3, [sp, #20]
34817cb0:	e5930004 	ldr	r0, [r3, #4]
34817cb4:	ebffc5e2 	bl	34809444 <free>
	htab->table[idx].used = -1;
34817cb8:	e3a0200c 	mov	r2, #12
34817cbc:	e0050592 	mul	r5, r2, r5
34817cc0:	e5943000 	ldr	r3, [r4]
34817cc4:	e3e02000 	mvn	r2, #0
34817cc8:	e7832005 	str	r2, [r3, r5]

	--htab->filled;
34817ccc:	e5943008 	ldr	r3, [r4, #8]

	return 1;
34817cd0:	e3a00001 	mov	r0, #1
		htab->apply(ep->key, ep->data, NULL, H_FORCE);
	free((void *)ep->key);
	free(ep->data);
	htab->table[idx].used = -1;

	--htab->filled;
34817cd4:	e0833002 	add	r3, r3, r2
34817cd8:	e5843008 	str	r3, [r4, #8]

	return 1;
}
34817cdc:	e28dd018 	add	sp, sp, #24
34817ce0:	e8bd8070 	pop	{r4, r5, r6, pc}
34817ce4:	3482b338 	.word	0x3482b338

34817ce8 <hexport_r>:
}

ssize_t hexport_r(struct hsearch_data *htab, const char sep,
		 char **resp, size_t size,
		 int argc, char * const argv[])
{
34817ce8:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
34817cec:	e28db01c 	add	fp, sp, #28
34817cf0:	e24dd018 	sub	sp, sp, #24
34817cf4:	e1a04003 	mov	r4, r3
	ENTRY *list[htab->size];
34817cf8:	e5903004 	ldr	r3, [r0, #4]
	char *res, *p;
	size_t totlen;
	int i, n;

	/* Test for correct arguments.  */
	if ((resp == NULL) || (htab == NULL)) {
34817cfc:	e3520000 	cmp	r2, #0

ssize_t hexport_r(struct hsearch_data *htab, const char sep,
		 char **resp, size_t size,
		 int argc, char * const argv[])
{
	ENTRY *list[htab->size];
34817d00:	e1a03103 	lsl	r3, r3, #2
34817d04:	e283300e 	add	r3, r3, #14
34817d08:	e3c33007 	bic	r3, r3, #7
34817d0c:	e04dd003 	sub	sp, sp, r3
}

ssize_t hexport_r(struct hsearch_data *htab, const char sep,
		 char **resp, size_t size,
		 int argc, char * const argv[])
{
34817d10:	e1a05000 	mov	r5, r0
34817d14:	e1a07001 	mov	r7, r1
	ENTRY *list[htab->size];
34817d18:	e50bd028 	str	sp, [fp, #-40]	; 0x28
	char *res, *p;
	size_t totlen;
	int i, n;

	/* Test for correct arguments.  */
	if ((resp == NULL) || (htab == NULL)) {
34817d1c:	e50b202c 	str	r2, [fp, #-44]	; 0x2c
34817d20:	0a000006 	beq	34817d40 <hexport_r+0x58>
34817d24:	e3a06000 	mov	r6, #0
34817d28:	e3a02001 	mov	r2, #1
34817d2c:	e3a0900c 	mov	r9, #12
34817d30:	e50b2024 	str	r2, [fp, #-36]	; 0x24
34817d34:	e50b6020 	str	r6, [fp, #-32]
34817d38:	e50b4030 	str	r4, [fp, #-48]	; 0x30
34817d3c:	ea000041 	b	34817e48 <hexport_r+0x160>
		__set_errno(EINVAL);
34817d40:	e3a02016 	mov	r2, #22
34817d44:	ea000054 	b	34817e9c <hexport_r+0x1b4>
	 * search used entries,
	 * save addresses and compute total length
	 */
	for (i = 1, n = 0, totlen = 0; i <= htab->size; ++i) {

		if (htab->table[i].used > 0) {
34817d48:	e5953000 	ldr	r3, [r5]
34817d4c:	e0834009 	add	r4, r3, r9
34817d50:	e7933009 	ldr	r3, [r3, r9]
34817d54:	e3530000 	cmp	r3, #0
34817d58:	da000036 	ble	34817e38 <hexport_r+0x150>
34817d5c:	e59b3008 	ldr	r3, [fp, #8]
34817d60:	e1a02006 	mov	r2, r6
			ENTRY *ep = &htab->table[i].entry;
			int arg, found = 0;

			for (arg = 0; arg < argc; ++arg) {
34817d64:	e3a0a000 	mov	sl, #0
34817d68:	e1a06003 	mov	r6, r3
34817d6c:	ea000007 	b	34817d90 <hexport_r+0xa8>
				if (strcmp(argv[arg], ep->key) == 0) {
34817d70:	e4960004 	ldr	r0, [r6], #4
34817d74:	e5941004 	ldr	r1, [r4, #4]
34817d78:	e50b2034 	str	r2, [fp, #-52]	; 0x34
34817d7c:	eb00034b 	bl	34818ab0 <strcmp>
34817d80:	e3500000 	cmp	r0, #0
34817d84:	e51b2034 	ldr	r2, [fp, #-52]	; 0x34
34817d88:	0a000006 	beq	34817da8 <hexport_r+0xc0>

		if (htab->table[i].used > 0) {
			ENTRY *ep = &htab->table[i].entry;
			int arg, found = 0;

			for (arg = 0; arg < argc; ++arg) {
34817d8c:	e28aa001 	add	sl, sl, #1
34817d90:	e59b3004 	ldr	r3, [fp, #4]
34817d94:	e15a0003 	cmp	sl, r3
34817d98:	bafffff4 	blt	34817d70 <hexport_r+0x88>
34817d9c:	e1a06002 	mov	r6, r2
	 */
	for (i = 1, n = 0, totlen = 0; i <= htab->size; ++i) {

		if (htab->table[i].used > 0) {
			ENTRY *ep = &htab->table[i].entry;
			int arg, found = 0;
34817da0:	e3a03000 	mov	r3, #0
34817da4:	ea000001 	b	34817db0 <hexport_r+0xc8>
34817da8:	e1a06002 	mov	r6, r2

			for (arg = 0; arg < argc; ++arg) {
				if (strcmp(argv[arg], ep->key) == 0) {
					found = 1;
34817dac:	e3a03001 	mov	r3, #1
					break;
				}
			}
			if ((argc > 0) && (found == 0))
34817db0:	e59b2004 	ldr	r2, [fp, #4]
34817db4:	e2233001 	eor	r3, r3, #1
34817db8:	e3520000 	cmp	r2, #0
34817dbc:	d3a03000 	movle	r3, #0
34817dc0:	c2033001 	andgt	r3, r3, #1
34817dc4:	e3530000 	cmp	r3, #0
34817dc8:	1a00001a 	bne	34817e38 <hexport_r+0x150>
				continue;

			list[n++] = ep;
34817dcc:	e51b2028 	ldr	r2, [fp, #-40]	; 0x28
	 * save addresses and compute total length
	 */
	for (i = 1, n = 0, totlen = 0; i <= htab->size; ++i) {

		if (htab->table[i].used > 0) {
			ENTRY *ep = &htab->table[i].entry;
34817dd0:	e2843004 	add	r3, r4, #4
				}
			}
			if ((argc > 0) && (found == 0))
				continue;

			list[n++] = ep;
34817dd4:	e7823106 	str	r3, [r2, r6, lsl #2]

			totlen += strlen(ep->key) + 2;
34817dd8:	e5940004 	ldr	r0, [r4, #4]
34817ddc:	eb000367 	bl	34818b80 <strlen>
34817de0:	e51b3020 	ldr	r3, [fp, #-32]

			if (sep == '\0') {
34817de4:	e3570000 	cmp	r7, #0
			if ((argc > 0) && (found == 0))
				continue;

			list[n++] = ep;

			totlen += strlen(ep->key) + 2;
34817de8:	e283a002 	add	sl, r3, #2
				}
			}
			if ((argc > 0) && (found == 0))
				continue;

			list[n++] = ep;
34817dec:	e2866001 	add	r6, r6, #1

			totlen += strlen(ep->key) + 2;
34817df0:	e08aa000 	add	sl, sl, r0

			if (sep == '\0') {
				totlen += strlen(ep->data);
34817df4:	15942008 	ldrne	r2, [r4, #8]

			list[n++] = ep;

			totlen += strlen(ep->key) + 2;

			if (sep == '\0') {
34817df8:	1a000009 	bne	34817e24 <hexport_r+0x13c>
				totlen += strlen(ep->data);
34817dfc:	e5940008 	ldr	r0, [r4, #8]
34817e00:	eb00035e 	bl	34818b80 <strlen>
34817e04:	e08aa000 	add	sl, sl, r0
34817e08:	ea000008 	b	34817e30 <hexport_r+0x148>
				char *s = ep->data;

				while (*s) {
					++totlen;
					/* add room for needed escape chars */
					if ((*s == sep) || (*s == '\\'))
34817e0c:	e1530007 	cmp	r3, r7
				totlen += strlen(ep->data);
			} else {	/* check if escapes are needed */
				char *s = ep->data;

				while (*s) {
					++totlen;
34817e10:	e28aa001 	add	sl, sl, #1
					/* add room for needed escape chars */
					if ((*s == sep) || (*s == '\\'))
34817e14:	0a000001 	beq	34817e20 <hexport_r+0x138>
34817e18:	e353005c 	cmp	r3, #92	; 0x5c
34817e1c:	1a000000 	bne	34817e24 <hexport_r+0x13c>
						++totlen;
34817e20:	e28aa001 	add	sl, sl, #1
			if (sep == '\0') {
				totlen += strlen(ep->data);
			} else {	/* check if escapes are needed */
				char *s = ep->data;

				while (*s) {
34817e24:	e4d23001 	ldrb	r3, [r2], #1
34817e28:	e3530000 	cmp	r3, #0
34817e2c:	1afffff6 	bne	34817e0c <hexport_r+0x124>
					if ((*s == sep) || (*s == '\\'))
						++totlen;
					++s;
				}
			}
			totlen += 2;	/* for '=' and 'sep' char */
34817e30:	e28aa002 	add	sl, sl, #2
34817e34:	e50ba020 	str	sl, [fp, #-32]
	/*
	 * Pass 1:
	 * search used entries,
	 * save addresses and compute total length
	 */
	for (i = 1, n = 0, totlen = 0; i <= htab->size; ++i) {
34817e38:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
34817e3c:	e289900c 	add	r9, r9, #12
34817e40:	e2822001 	add	r2, r2, #1
34817e44:	e50b2024 	str	r2, [fp, #-36]	; 0x24
34817e48:	e5953004 	ldr	r3, [r5, #4]
34817e4c:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
34817e50:	e1520003 	cmp	r2, r3
34817e54:	9affffbb 	bls	34817d48 <hexport_r+0x60>
		       i, list[i], list[i]->key, list[i]->data);
	}
#endif

	/* Sort list by keys */
	qsort(list, n, sizeof(ENTRY *), cmpkey);
34817e58:	e3a02004 	mov	r2, #4
34817e5c:	e59f3124 	ldr	r3, [pc, #292]	; 34817f88 <hexport_r+0x2a0>
34817e60:	e51b0028 	ldr	r0, [fp, #-40]	; 0x28
34817e64:	e1a01006 	mov	r1, r6
34817e68:	e51b4030 	ldr	r4, [fp, #-48]	; 0x30
34817e6c:	eb0002a0 	bl	348188f4 <qsort>
34817e70:	e51b3020 	ldr	r3, [fp, #-32]

	/* Check if the user supplied buffer size is sufficient */
	if (size) {
34817e74:	e3540000 	cmp	r4, #0
34817e78:	e2832001 	add	r2, r3, #1
				"but need %zu\n", size, totlen + 1);
			__set_errno(ENOMEM);
			return (-1);
		}
	} else {
		size = totlen + 1;
34817e7c:	01a04002 	moveq	r4, r2

	/* Sort list by keys */
	qsort(list, n, sizeof(ENTRY *), cmpkey);

	/* Check if the user supplied buffer size is sufficient */
	if (size) {
34817e80:	0a000009 	beq	34817eac <hexport_r+0x1c4>
		if (size < totlen + 1) {	/* provided buffer too small */
34817e84:	e1540002 	cmp	r4, r2
34817e88:	2a000007 	bcs	34817eac <hexport_r+0x1c4>
			printf("Env export buffer too small: %zu, "
34817e8c:	e59f00f8 	ldr	r0, [pc, #248]	; 34817f8c <hexport_r+0x2a4>
34817e90:	e1a01004 	mov	r1, r4
34817e94:	ebffc42c 	bl	34808f4c <printf>
				"but need %zu\n", size, totlen + 1);
			__set_errno(ENOMEM);
34817e98:	e3a0200c 	mov	r2, #12
34817e9c:	e59f30ec 	ldr	r3, [pc, #236]	; 34817f90 <hexport_r+0x2a8>
			return (-1);
34817ea0:	e3e00000 	mvn	r0, #0
	/* Check if the user supplied buffer size is sufficient */
	if (size) {
		if (size < totlen + 1) {	/* provided buffer too small */
			printf("Env export buffer too small: %zu, "
				"but need %zu\n", size, totlen + 1);
			__set_errno(ENOMEM);
34817ea4:	e5832000 	str	r2, [r3]
34817ea8:	ea000034 	b	34817f80 <hexport_r+0x298>
	} else {
		size = totlen + 1;
	}

	/* Check if the user provided a buffer */
	if (*resp) {
34817eac:	e51b202c 	ldr	r2, [fp, #-44]	; 0x2c
34817eb0:	e5925000 	ldr	r5, [r2]
34817eb4:	e3550000 	cmp	r5, #0
34817eb8:	0a000008 	beq	34817ee0 <hexport_r+0x1f8>
		/* yes; clear it */
		res = *resp;
		memset(res, '\0', size);
34817ebc:	e1a00005 	mov	r0, r5
34817ec0:	e3a01000 	mov	r1, #0
34817ec4:	e1a02004 	mov	r2, r4
34817ec8:	eb0003cc 	bl	34818e00 <memset>
34817ecc:	e51b2028 	ldr	r2, [fp, #-40]	; 0x28
	} else {
		/* no, allocate and clear one */
		*resp = res = calloc(1, size);
		if (res == NULL) {
34817ed0:	e3a03000 	mov	r3, #0
		const char *s;

		s = list[i]->key;
		while (*s)
			*p++ = *s++;
		*p++ = '=';
34817ed4:	e3a0a03d 	mov	sl, #61	; 0x3d

		s = list[i]->data;

		while (*s) {
			if ((*s == sep) || (*s == '\\'))
				*p++ = '\\';	/* escape */
34817ed8:	e3a0905c 	mov	r9, #92	; 0x5c
34817edc:	ea000022 	b	34817f6c <hexport_r+0x284>
		/* yes; clear it */
		res = *resp;
		memset(res, '\0', size);
	} else {
		/* no, allocate and clear one */
		*resp = res = calloc(1, size);
34817ee0:	e3a00001 	mov	r0, #1
34817ee4:	e1a01004 	mov	r1, r4
34817ee8:	ebffc74b 	bl	34809c1c <calloc>
34817eec:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
		if (res == NULL) {
34817ef0:	e3500000 	cmp	r0, #0
		/* yes; clear it */
		res = *resp;
		memset(res, '\0', size);
	} else {
		/* no, allocate and clear one */
		*resp = res = calloc(1, size);
34817ef4:	e5830000 	str	r0, [r3]
		if (res == NULL) {
34817ef8:	11a05000 	movne	r5, r0
34817efc:	1afffff2 	bne	34817ecc <hexport_r+0x1e4>
34817f00:	eaffffe4 	b	34817e98 <hexport_r+0x1b0>
	 * export sorted list of result data
	 */
	for (i = 0, p = res; i < n; ++i) {
		const char *s;

		s = list[i]->key;
34817f04:	e4921004 	ldr	r1, [r2], #4
34817f08:	e5911000 	ldr	r1, [r1]
		while (*s)
34817f0c:	ea000001 	b	34817f18 <hexport_r+0x230>
			*p++ = *s++;
34817f10:	e5c50000 	strb	r0, [r5]
34817f14:	e1a0500c 	mov	r5, ip
	 */
	for (i = 0, p = res; i < n; ++i) {
		const char *s;

		s = list[i]->key;
		while (*s)
34817f18:	e4d10001 	ldrb	r0, [r1], #1
34817f1c:	e285c001 	add	ip, r5, #1
34817f20:	e3500000 	cmp	r0, #0
34817f24:	1afffff9 	bne	34817f10 <hexport_r+0x228>
			*p++ = *s++;
		*p++ = '=';
34817f28:	e5c5a000 	strb	sl, [r5]

		s = list[i]->data;
34817f2c:	e5121004 	ldr	r1, [r2, #-4]
		const char *s;

		s = list[i]->key;
		while (*s)
			*p++ = *s++;
		*p++ = '=';
34817f30:	e1a0500c 	mov	r5, ip
34817f34:	e5911004 	ldr	r1, [r1, #4]

		s = list[i]->data;

		while (*s) {
34817f38:	ea000006 	b	34817f58 <hexport_r+0x270>
			if ((*s == sep) || (*s == '\\'))
34817f3c:	e1500007 	cmp	r0, r7
34817f40:	0a000001 	beq	34817f4c <hexport_r+0x264>
34817f44:	e350005c 	cmp	r0, #92	; 0x5c
34817f48:	1a000000 	bne	34817f50 <hexport_r+0x268>
				*p++ = '\\';	/* escape */
34817f4c:	e4c59001 	strb	r9, [r5], #1
			*p++ = *s++;
34817f50:	e5510001 	ldrb	r0, [r1, #-1]
34817f54:	e4c50001 	strb	r0, [r5], #1
			*p++ = *s++;
		*p++ = '=';

		s = list[i]->data;

		while (*s) {
34817f58:	e4d10001 	ldrb	r0, [r1], #1
34817f5c:	e3500000 	cmp	r0, #0
34817f60:	1afffff5 	bne	34817f3c <hexport_r+0x254>
			if ((*s == sep) || (*s == '\\'))
				*p++ = '\\';	/* escape */
			*p++ = *s++;
		}
		*p++ = sep;
34817f64:	e4c57001 	strb	r7, [r5], #1
	}
	/*
	 * Pass 2:
	 * export sorted list of result data
	 */
	for (i = 0, p = res; i < n; ++i) {
34817f68:	e2833001 	add	r3, r3, #1
34817f6c:	e1530006 	cmp	r3, r6
34817f70:	baffffe3 	blt	34817f04 <hexport_r+0x21c>
				*p++ = '\\';	/* escape */
			*p++ = *s++;
		}
		*p++ = sep;
	}
	*p = '\0';		/* terminate result */
34817f74:	e3a03000 	mov	r3, #0
34817f78:	e5c53000 	strb	r3, [r5]

	return size;
34817f7c:	e1a00004 	mov	r0, r4
}
34817f80:	e24bd01c 	sub	sp, fp, #28
34817f84:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
34817f88:	348176a8 	.word	0x348176a8
34817f8c:	34827779 	.word	0x34827779
34817f90:	3482b338 	.word	0x3482b338

34817f94 <himport_r>:
 */

int himport_r(struct hsearch_data *htab,
		const char *env, size_t size, const char sep, int flag,
		int nvars, char * const vars[], int do_apply)
{
34817f94:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
34817f98:	e28db01c 	add	fp, sp, #28
34817f9c:	e24dd028 	sub	sp, sp, #40	; 0x28
34817fa0:	e1a06002 	mov	r6, r2
	char *data, *sp, *dp, *name, *value;
	char *localvars[nvars];
34817fa4:	e59b2008 	ldr	r2, [fp, #8]
 */

int himport_r(struct hsearch_data *htab,
		const char *env, size_t size, const char sep, int flag,
		int nvars, char * const vars[], int do_apply)
{
34817fa8:	e1a0a003 	mov	sl, r3
	char *data, *sp, *dp, *name, *value;
	char *localvars[nvars];
34817fac:	e1a05102 	lsl	r5, r2, #2
34817fb0:	e285300e 	add	r3, r5, #14
34817fb4:	e3c33007 	bic	r3, r3, #7
34817fb8:	e04dd003 	sub	sp, sp, r3
34817fbc:	e28d3008 	add	r3, sp, #8
	int i;

	/* Test for correct arguments.  */
	if (htab == NULL) {
34817fc0:	e2504000 	subs	r4, r0, #0
 */

int himport_r(struct hsearch_data *htab,
		const char *env, size_t size, const char sep, int flag,
		int nvars, char * const vars[], int do_apply)
{
34817fc4:	e1a07001 	mov	r7, r1
	char *data, *sp, *dp, *name, *value;
	char *localvars[nvars];
34817fc8:	e50b3030 	str	r3, [fp, #-48]	; 0x30
	int i;

	/* Test for correct arguments.  */
	if (htab == NULL) {
		__set_errno(EINVAL);
34817fcc:	059f3318 	ldreq	r3, [pc, #792]	; 348182ec <himport_r+0x358>
34817fd0:	03a02016 	moveq	r2, #22
34817fd4:	05832000 	streq	r2, [r3]
		return 0;
34817fd8:	01a00004 	moveq	r0, r4
34817fdc:	0a0000c0 	beq	348182e4 <himport_r+0x350>
	}

	/* we allocate new space to make sure we can write to the array */
	if ((data = malloc(size)) == NULL) {
34817fe0:	e1a00006 	mov	r0, r6
34817fe4:	ebffc59f 	bl	34809668 <malloc>
34817fe8:	e2509000 	subs	r9, r0, #0
		debug("himport_r: can't malloc %zu bytes\n", size);
		__set_errno(ENOMEM);
34817fec:	059f32f8 	ldreq	r3, [pc, #760]	; 348182ec <himport_r+0x358>
34817ff0:	03a0200c 	moveq	r2, #12
34817ff4:	05832000 	streq	r2, [r3]
		return 0;
34817ff8:	01a00009 	moveq	r0, r9
34817ffc:	0a0000b8 	beq	348182e4 <himport_r+0x350>
	}
	memcpy(data, env, size);
34818000:	e1a02006 	mov	r2, r6
34818004:	e1a01007 	mov	r1, r7
34818008:	eb0003a0 	bl	34818e90 <memcpy>
	dp = data;

	/* make a local copy of the list of variables */
	if (nvars)
3481800c:	e59b2008 	ldr	r2, [fp, #8]
34818010:	e3520000 	cmp	r2, #0
34818014:	0a000003 	beq	34818028 <himport_r+0x94>
		memcpy(localvars, vars, sizeof(vars[0]) * nvars);
34818018:	e51b0030 	ldr	r0, [fp, #-48]	; 0x30
3481801c:	e59b100c 	ldr	r1, [fp, #12]
34818020:	e1a02005 	mov	r2, r5
34818024:	eb000399 	bl	34818e90 <memcpy>

	if ((flag & H_NOCLEAR) == 0) {
34818028:	e59b3004 	ldr	r3, [fp, #4]
3481802c:	e3130001 	tst	r3, #1
34818030:	1a000005 	bne	3481804c <himport_r+0xb8>
		/* Destroy old hash table if one exists */
		debug("Destroy Hash Table: %p table = %p\n", htab,
		       htab->table);
		if (htab->table)
34818034:	e5943000 	ldr	r3, [r4]
34818038:	e3530000 	cmp	r3, #0
3481803c:	0a000002 	beq	3481804c <himport_r+0xb8>
			hdestroy_r(htab, do_apply);
34818040:	e1a00004 	mov	r0, r4
34818044:	e59b1010 	ldr	r1, [fp, #16]
34818048:	ebfffdc6 	bl	34817768 <hdestroy_r>
	 * On the other hand we need to add some more entries for free
	 * space when importing very small buffers. Both boundaries can
	 * be overwritten in the board config file if needed.
	 */

	if (!htab->table) {
3481804c:	e5943000 	ldr	r3, [r4]
34818050:	e3530000 	cmp	r3, #0
34818054:	0a000003 	beq	34818068 <himport_r+0xd4>
		}

		debug("INSERT: table %p, filled %d/%d rv %p ==> name=\"%s\" value=\"%s\"\n",
			htab, htab->filled, htab->size,
			rv, name, value);
	} while ((dp < data + size) && *dp);	/* size check needed for text */
34818058:	e0896006 	add	r6, r9, r6
 */

int himport_r(struct hsearch_data *htab,
		const char *env, size_t size, const char sep, int flag,
		int nvars, char * const vars[], int do_apply)
{
3481805c:	e1a05009 	mov	r5, r9
		}

		debug("INSERT: table %p, filled %d/%d rv %p ==> name=\"%s\" value=\"%s\"\n",
			htab, htab->filled, htab->size,
			rv, name, value);
	} while ((dp < data + size) && *dp);	/* size check needed for text */
34818060:	e50b6034 	str	r6, [fp, #-52]	; 0x34
34818064:	ea00000c 	b	3481809c <himport_r+0x108>
	 * space when importing very small buffers. Both boundaries can
	 * be overwritten in the board config file if needed.
	 */

	if (!htab->table) {
		int nent = CONFIG_ENV_MIN_ENTRIES + size / 8;
34818068:	e1a001a6 	lsr	r0, r6, #3
3481806c:	e2800040 	add	r0, r0, #64	; 0x40
		if (nent > CONFIG_ENV_MAX_ENTRIES)
			nent = CONFIG_ENV_MAX_ENTRIES;

		debug("Create Hash Table: N=%d\n", nent);

		if (hcreate_r(nent, htab) == 0) {
34818070:	e3500c02 	cmp	r0, #512	; 0x200
34818074:	a3a00c02 	movge	r0, #512	; 0x200
34818078:	e1a01004 	mov	r1, r4
3481807c:	ebfffd8e 	bl	348176bc <hcreate_r>
34818080:	e2505000 	subs	r5, r0, #0
34818084:	1afffff3 	bne	34818058 <himport_r+0xc4>
			free(data);
34818088:	e1a00009 	mov	r0, r9
3481808c:	ebffc4ec 	bl	34809444 <free>
			return 0;
34818090:	e1a00005 	mov	r0, r5
34818094:	ea000092 	b	348182e4 <himport_r+0x350>
 */

int himport_r(struct hsearch_data *htab,
		const char *env, size_t size, const char sep, int flag,
		int nvars, char * const vars[], int do_apply)
{
34818098:	e1a05006 	mov	r5, r6
	/* Parse environment; allow for '\0' and 'sep' as separators */
	do {
		ENTRY e, *rv;

		/* skip leading white space */
		while (isblank(*dp))
3481809c:	e5d53000 	ldrb	r3, [r5]
348180a0:	e3530020 	cmp	r3, #32
348180a4:	13530009 	cmpne	r3, #9
			++dp;
348180a8:	02856001 	addeq	r6, r5, #1
	/* Parse environment; allow for '\0' and 'sep' as separators */
	do {
		ENTRY e, *rv;

		/* skip leading white space */
		while (isblank(*dp))
348180ac:	0afffff9 	beq	34818098 <himport_r+0x104>
			++dp;

		/* skip comment lines */
		if (*dp == '#') {
348180b0:	e3530023 	cmp	r3, #35	; 0x23
348180b4:	11a02005 	movne	r2, r5
348180b8:	1a000007 	bne	348180dc <himport_r+0x148>
348180bc:	e1a06005 	mov	r6, r5
			while (*dp && (*dp != sep))
348180c0:	e4d53001 	ldrb	r3, [r5], #1
348180c4:	e3530000 	cmp	r3, #0
348180c8:	0a000001 	beq	348180d4 <himport_r+0x140>
348180cc:	e153000a 	cmp	r3, sl
348180d0:	1afffff9 	bne	348180bc <himport_r+0x128>
				++dp;
			++dp;
348180d4:	e2866001 	add	r6, r6, #1
			continue;
348180d8:	ea000066 	b	34818278 <himport_r+0x2e4>
		}

		/* parse name */
		for (name = dp; *dp != '=' && *dp && *dp != sep; ++dp)
348180dc:	e5d23000 	ldrb	r3, [r2]
		/* skip comment lines */
		if (*dp == '#') {
			while (*dp && (*dp != sep))
				++dp;
			++dp;
			continue;
348180e0:	e1a06002 	mov	r6, r2
		}

		/* parse name */
		for (name = dp; *dp != '=' && *dp && *dp != sep; ++dp)
348180e4:	e3530000 	cmp	r3, #0
348180e8:	1353003d 	cmpne	r3, #61	; 0x3d
348180ec:	e2822001 	add	r2, r2, #1
348180f0:	1a000002 	bne	34818100 <himport_r+0x16c>
			;

		/* deal with "name" and "name=" entries (delete var) */
		if (*dp == '\0' || *(dp + 1) == '\0' ||
348180f4:	e3530000 	cmp	r3, #0
348180f8:	0a00000e 	beq	34818138 <himport_r+0x1a4>
348180fc:	ea000001 	b	34818108 <himport_r+0x174>
			++dp;
			continue;
		}

		/* parse name */
		for (name = dp; *dp != '=' && *dp && *dp != sep; ++dp)
34818100:	e153000a 	cmp	r3, sl
34818104:	1afffff4 	bne	348180dc <himport_r+0x148>
			;

		/* deal with "name" and "name=" entries (delete var) */
		if (*dp == '\0' || *(dp + 1) == '\0' ||
34818108:	e5d62001 	ldrb	r2, [r6, #1]
3481810c:	e2867001 	add	r7, r6, #1
34818110:	e3520000 	cmp	r2, #0
34818114:	0a000003 	beq	34818128 <himport_r+0x194>
34818118:	e153000a 	cmp	r3, sl
3481811c:	0a000001 	beq	34818128 <himport_r+0x194>
		    *dp == sep || *(dp + 1) == sep) {
34818120:	e152000a 	cmp	r2, sl
34818124:	1a000010 	bne	3481816c <himport_r+0x1d8>
			if (*dp == '=')
34818128:	e353003d 	cmp	r3, #61	; 0x3d
				*dp++ = '\0';
3481812c:	03a02000 	moveq	r2, #0
34818130:	05c62000 	strbeq	r2, [r6]
34818134:	01a06007 	moveq	r6, r7
			*dp++ = '\0';	/* terminate name */
34818138:	e3a03000 	mov	r3, #0
3481813c:	e4c63001 	strb	r3, [r6], #1

			debug("DELETE CANDIDATE: \"%s\"\n", name);
			if (!drop_var_from_set(name, nvars, localvars))
34818140:	e1a00005 	mov	r0, r5
34818144:	e59b1008 	ldr	r1, [fp, #8]
34818148:	e51b2030 	ldr	r2, [fp, #-48]	; 0x30
3481814c:	ebfffd3e 	bl	3481764c <drop_var_from_set>
34818150:	e3500000 	cmp	r0, #0
34818154:	0a000047 	beq	34818278 <himport_r+0x2e4>
				continue;

			if (hdelete_r(name, htab, do_apply) == 0)
34818158:	e1a00005 	mov	r0, r5
3481815c:	e1a01004 	mov	r1, r4
34818160:	e59b2010 	ldr	r2, [fp, #16]
34818164:	ebfffeb2 	bl	34817c34 <hdelete_r>
				debug("DELETE ERROR ##############################\n");

			continue;
34818168:	ea000042 	b	34818278 <himport_r+0x2e4>
		}
		*dp++ = '\0';	/* terminate name */
3481816c:	e3a02000 	mov	r2, #0
34818170:	e5c62000 	strb	r2, [r6]

		/* parse value; deal with escapes */
		for (value = sp = dp; *dp && (*dp != sep); ++dp) {
34818174:	e1a03007 	mov	r3, r7
34818178:	e1a06007 	mov	r6, r7
3481817c:	ea000006 	b	3481819c <himport_r+0x208>
			if ((*dp == '\\') && *(dp + 1))
34818180:	e352005c 	cmp	r2, #92	; 0x5c
34818184:	1a000002 	bne	34818194 <himport_r+0x200>
34818188:	e5d62001 	ldrb	r2, [r6, #1]
3481818c:	e3520000 	cmp	r2, #0
34818190:	12866001 	addne	r6, r6, #1
				++dp;
			*sp++ = *dp;
34818194:	e4d62001 	ldrb	r2, [r6], #1
34818198:	e4c32001 	strb	r2, [r3], #1
			continue;
		}
		*dp++ = '\0';	/* terminate name */

		/* parse value; deal with escapes */
		for (value = sp = dp; *dp && (*dp != sep); ++dp) {
3481819c:	e5d62000 	ldrb	r2, [r6]
348181a0:	e3520000 	cmp	r2, #0
348181a4:	0a000001 	beq	348181b0 <himport_r+0x21c>
348181a8:	e152000a 	cmp	r2, sl
348181ac:	1afffff3 	bne	34818180 <himport_r+0x1ec>
			if ((*dp == '\\') && *(dp + 1))
				++dp;
			*sp++ = *dp;
		}
		*sp++ = '\0';	/* terminate value */
348181b0:	e3a02000 	mov	r2, #0
348181b4:	e5c32000 	strb	r2, [r3]
		++dp;

		/* Skip variables which are not supposed to be processed */
		if (!drop_var_from_set(name, nvars, localvars))
348181b8:	e1a00005 	mov	r0, r5
348181bc:	e59b1008 	ldr	r1, [fp, #8]
348181c0:	e51b2030 	ldr	r2, [fp, #-48]	; 0x30
348181c4:	ebfffd20 	bl	3481764c <drop_var_from_set>
348181c8:	e3500000 	cmp	r0, #0
			if ((*dp == '\\') && *(dp + 1))
				++dp;
			*sp++ = *dp;
		}
		*sp++ = '\0';	/* terminate value */
		++dp;
348181cc:	e2866001 	add	r6, r6, #1

		/* Skip variables which are not supposed to be processed */
		if (!drop_var_from_set(name, nvars, localvars))
348181d0:	0a000028 	beq	34818278 <himport_r+0x2e4>
		/* enter into hash table */
		e.key = name;
		e.data = value;

		/* if there is an apply function, check what it has to say */
		if (do_apply && htab->apply != NULL) {
348181d4:	e59b3010 	ldr	r3, [fp, #16]
		/* Skip variables which are not supposed to be processed */
		if (!drop_var_from_set(name, nvars, localvars))
			continue;

		/* enter into hash table */
		e.key = name;
348181d8:	e50b5028 	str	r5, [fp, #-40]	; 0x28
		e.data = value;

		/* if there is an apply function, check what it has to say */
		if (do_apply && htab->apply != NULL) {
348181dc:	e3530000 	cmp	r3, #0
		if (!drop_var_from_set(name, nvars, localvars))
			continue;

		/* enter into hash table */
		e.key = name;
		e.data = value;
348181e0:	e50b7024 	str	r7, [fp, #-36]	; 0x24

		/* if there is an apply function, check what it has to say */
		if (do_apply && htab->apply != NULL) {
348181e4:	0a000012 	beq	34818234 <himport_r+0x2a0>
348181e8:	e594300c 	ldr	r3, [r4, #12]
348181ec:	e3530000 	cmp	r3, #0
348181f0:	0a00000f 	beq	34818234 <himport_r+0x2a0>
				" for  %s\n", name);
			/*
			 * Search for variable in existing env, so to pass
			 * its previous value to the apply callback
			 */
			hsearch_r(e, FIND, &rv, htab);
348181f4:	e58d4000 	str	r4, [sp]
348181f8:	e24b3028 	sub	r3, fp, #40	; 0x28
348181fc:	e8930003 	ldm	r3, {r0, r1}
34818200:	e3a02000 	mov	r2, #0
34818204:	e24b3020 	sub	r3, fp, #32
34818208:	ebfffdd0 	bl	34817950 <hsearch_r>
			debug("previous value was %s\n", rv ? rv->data : "");
			if (htab->apply(name, rv ? rv->data : NULL,
3481820c:	e51b1020 	ldr	r1, [fp, #-32]
34818210:	e594c00c 	ldr	ip, [r4, #12]
34818214:	e3510000 	cmp	r1, #0
34818218:	15911004 	ldrne	r1, [r1, #4]
3481821c:	e1a00005 	mov	r0, r5
34818220:	e1a02007 	mov	r2, r7
34818224:	e59b3004 	ldr	r3, [fp, #4]
34818228:	e12fff3c 	blx	ip
3481822c:	e3500000 	cmp	r0, #0
34818230:	1a000010 	bne	34818278 <himport_r+0x2e4>
					" variable %s, skipping it!\n", name);
				continue;
			}
		}

		hsearch_r(e, ENTER, &rv, htab);
34818234:	e58d4000 	str	r4, [sp]
34818238:	e24b3028 	sub	r3, fp, #40	; 0x28
3481823c:	e8930003 	ldm	r3, {r0, r1}
34818240:	e3a02001 	mov	r2, #1
34818244:	e24b3020 	sub	r3, fp, #32
34818248:	ebfffdc0 	bl	34817950 <hsearch_r>
		if (rv == NULL) {
3481824c:	e51b3020 	ldr	r3, [fp, #-32]
34818250:	e3530000 	cmp	r3, #0
34818254:	1a000007 	bne	34818278 <himport_r+0x2e4>
			printf("himport_r: can't insert \"%s=%s\" into hash table\n",
34818258:	e59f0090 	ldr	r0, [pc, #144]	; 348182f0 <himport_r+0x35c>
3481825c:	e1a01005 	mov	r1, r5
34818260:	e1a02007 	mov	r2, r7
34818264:	e50b3038 	str	r3, [fp, #-56]	; 0x38
34818268:	ebffc337 	bl	34808f4c <printf>
				name, value);
			return 0;
3481826c:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
34818270:	e1a00003 	mov	r0, r3
34818274:	ea00001a 	b	348182e4 <himport_r+0x350>
		}

		debug("INSERT: table %p, filled %d/%d rv %p ==> name=\"%s\" value=\"%s\"\n",
			htab, htab->filled, htab->size,
			rv, name, value);
	} while ((dp < data + size) && *dp);	/* size check needed for text */
34818278:	e51b2034 	ldr	r2, [fp, #-52]	; 0x34
3481827c:	e1560002 	cmp	r6, r2
34818280:	2a000002 	bcs	34818290 <himport_r+0x2fc>
34818284:	e5d63000 	ldrb	r3, [r6]
34818288:	e3530000 	cmp	r3, #0
3481828c:	1affff81 	bne	34818098 <himport_r+0x104>
						/* without '\0' termination */
	debug("INSERT: free(data = %p)\n", data);
	free(data);
34818290:	e1a00009 	mov	r0, r9
34818294:	ebffc46a 	bl	34809444 <free>

	/* process variables which were not considered */
	for (i = 0; i < nvars; i++) {
34818298:	e3a06000 	mov	r6, #0
			htab, htab->filled, htab->size,
			rv, name, value);
	} while ((dp < data + size) && *dp);	/* size check needed for text */
						/* without '\0' termination */
	debug("INSERT: free(data = %p)\n", data);
	free(data);
3481829c:	e51b5030 	ldr	r5, [fp, #-48]	; 0x30

	/* process variables which were not considered */
	for (i = 0; i < nvars; i++) {
348182a0:	ea00000b 	b	348182d4 <himport_r+0x340>
		if (localvars[i] == NULL)
348182a4:	e4950004 	ldr	r0, [r5], #4
348182a8:	e3500000 	cmp	r0, #0
348182ac:	0a000007 	beq	348182d0 <himport_r+0x33c>
		 * This could mean two things:
		 * a) if the variable was present in current env, we delete it
		 * b) if the variable was not present in current env, we notify
		 *    it might be a typo
		 */
		if (hdelete_r(localvars[i], htab, do_apply) == 0)
348182b0:	e1a01004 	mov	r1, r4
348182b4:	e59b2010 	ldr	r2, [fp, #16]
348182b8:	ebfffe5d 	bl	34817c34 <hdelete_r>
348182bc:	e3500000 	cmp	r0, #0
			printf("WARNING: '%s' neither in running nor in imported env!\n", localvars[i]);
348182c0:	059f002c 	ldreq	r0, [pc, #44]	; 348182f4 <himport_r+0x360>
		else
			printf("WARNING: '%s' not in imported env, deleting it!\n", localvars[i]);
348182c4:	159f002c 	ldrne	r0, [pc, #44]	; 348182f8 <himport_r+0x364>
348182c8:	e5151004 	ldr	r1, [r5, #-4]
348182cc:	ebffc31e 	bl	34808f4c <printf>
						/* without '\0' termination */
	debug("INSERT: free(data = %p)\n", data);
	free(data);

	/* process variables which were not considered */
	for (i = 0; i < nvars; i++) {
348182d0:	e2866001 	add	r6, r6, #1
348182d4:	e59b3008 	ldr	r3, [fp, #8]
348182d8:	e1560003 	cmp	r6, r3
348182dc:	bafffff0 	blt	348182a4 <himport_r+0x310>
		else
			printf("WARNING: '%s' not in imported env, deleting it!\n", localvars[i]);
	}

	debug("INSERT: done\n");
	return 1;		/* everything OK */
348182e0:	e3a00001 	mov	r0, #1
}
348182e4:	e24bd01c 	sub	sp, fp, #28
348182e8:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
348182ec:	3482b338 	.word	0x3482b338
348182f0:	348277a9 	.word	0x348277a9
348182f4:	348277da 	.word	0x348277da
348182f8:	34827811 	.word	0x34827811

348182fc <ldiv>:
	long    rem;
} ldiv_t;
/* Return the `ldiv_t' representation of NUMER over DENOM.  */
ldiv_t
ldiv (long int numer, long int denom)
{
348182fc:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
34818300:	e1a05001 	mov	r5, r1
34818304:	e1a04000 	mov	r4, r0
  ldiv_t result;

  result.quot = numer / denom;
34818308:	e1a00001 	mov	r0, r1
3481830c:	e1a01002 	mov	r1, r2
	long    rem;
} ldiv_t;
/* Return the `ldiv_t' representation of NUMER over DENOM.  */
ldiv_t
ldiv (long int numer, long int denom)
{
34818310:	e1a07002 	mov	r7, r2
  ldiv_t result;

  result.quot = numer / denom;
34818314:	eb001f65 	bl	348200b0 <__divsi3>
  result.rem = numer % denom;
34818318:	e1a01007 	mov	r1, r7
ldiv_t
ldiv (long int numer, long int denom)
{
  ldiv_t result;

  result.quot = numer / denom;
3481831c:	e1a06000 	mov	r6, r0
  result.rem = numer % denom;
34818320:	e1a00005 	mov	r0, r5
34818324:	eb001fe9 	bl	348202d0 <__aeabi_idivmod>
     RESULT will always be positive.  This all boils down to: if
     NUMER >= 0, but REM < 0, we got the wrong answer.  In that
     case, to get the right answer, add 1 to QUOT and subtract
     DENOM from REM.  */

  if (numer >= 0 && result.rem < 0)
34818328:	e3550000 	cmp	r5, #0
3481832c:	ba000002 	blt	3481833c <ldiv+0x40>
34818330:	e3510000 	cmp	r1, #0
    {
      ++result.quot;
34818334:	b2866001 	addlt	r6, r6, #1
      result.rem -= denom;
34818338:	b0671001 	rsblt	r1, r7, r1
3481833c:	e5846000 	str	r6, [r4]
34818340:	e5841004 	str	r1, [r4, #4]
    }

  return result;
}
34818344:	e1a00004 	mov	r0, r4
34818348:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}

3481834c <lmb_add_region>:
static long lmb_add_region(struct lmb_region *rgn, phys_addr_t base, phys_size_t size)
{
	unsigned long coalesced = 0;
	long adjacent, i;

	if ((rgn->cnt == 1) && (rgn->region[0].size == 0)) {
3481834c:	e590c000 	ldr	ip, [r0]
	lmb->reserved.size = 0;
}

/* This routine called with relocation disabled. */
static long lmb_add_region(struct lmb_region *rgn, phys_addr_t base, phys_size_t size)
{
34818350:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	unsigned long coalesced = 0;
	long adjacent, i;

	if ((rgn->cnt == 1) && (rgn->region[0].size == 0)) {
34818354:	e35c0001 	cmp	ip, #1
34818358:	1a000005 	bne	34818374 <lmb_add_region+0x28>
3481835c:	e590500c 	ldr	r5, [r0, #12]
34818360:	e3550000 	cmp	r5, #0
		rgn->region[0].base = base;
34818364:	05801008 	streq	r1, [r0, #8]
		rgn->region[0].size = size;
34818368:	0580200c 	streq	r2, [r0, #12]
		return 0;
3481836c:	01a00005 	moveq	r0, r5
static long lmb_add_region(struct lmb_region *rgn, phys_addr_t base, phys_size_t size)
{
	unsigned long coalesced = 0;
	long adjacent, i;

	if ((rgn->cnt == 1) && (rgn->region[0].size == 0)) {
34818370:	08bd8ef0 	popeq	{r4, r5, r6, r7, r9, sl, fp, pc}
34818374:	e1a04000 	mov	r4, r0
static long lmb_addrs_adjacent(phys_addr_t base1, phys_size_t size1,
		phys_addr_t base2, phys_size_t size2)
{
	if (base2 == base1 + size1)
		return 1;
	else if (base1 == base2 + size2)
34818378:	e3a03000 	mov	r3, #0
}

static long lmb_addrs_adjacent(phys_addr_t base1, phys_size_t size1,
		phys_addr_t base2, phys_size_t size2)
{
	if (base2 == base1 + size1)
3481837c:	e0827001 	add	r7, r2, r1
34818380:	ea000019 	b	348183ec <lmb_add_region+0xa0>
		return 0;
	}

	/* First try and coalesce this LMB with another. */
	for (i=0; i < rgn->cnt; i++) {
		phys_addr_t rgnbase = rgn->region[i].base;
34818384:	e5946008 	ldr	r6, [r4, #8]
		phys_size_t rgnsize = rgn->region[i].size;
34818388:	e594500c 	ldr	r5, [r4, #12]

		if ((rgnbase == base) && (rgnsize == size))
3481838c:	e1550002 	cmp	r5, r2
34818390:	01560001 	cmpeq	r6, r1
34818394:	0a000054 	beq	348184ec <lmb_add_region+0x1a0>
}

static long lmb_addrs_adjacent(phys_addr_t base1, phys_size_t size1,
		phys_addr_t base2, phys_size_t size2)
{
	if (base2 == base1 + size1)
34818398:	e1560007 	cmp	r6, r7
3481839c:	0a000005 	beq	348183b8 <lmb_add_region+0x6c>
		return 1;
	else if (base1 == base2 + size2)
348183a0:	e0856006 	add	r6, r5, r6
348183a4:	e1510006 	cmp	r1, r6
}

static long lmb_addrs_adjacent(phys_addr_t base1, phys_size_t size1,
		phys_addr_t base2, phys_size_t size2)
{
	if (base2 == base1 + size1)
348183a8:	e2844008 	add	r4, r4, #8
348183ac:	e2836001 	add	r6, r3, #1
		return 1;
	else if (base1 == base2 + size2)
348183b0:	1a000051 	bne	348184fc <lmb_add_region+0x1b0>
348183b4:	ea000007 	b	348183d8 <lmb_add_region+0x8c>
			/* Already have this region, so we're done */
			return 0;

		adjacent = lmb_addrs_adjacent(base,size,rgnbase,rgnsize);
		if ( adjacent > 0 ) {
			rgn->region[i].base -= size;
348183b8:	e2834001 	add	r4, r3, #1
348183bc:	e0627007 	rsb	r7, r2, r7
348183c0:	e7807184 	str	r7, [r0, r4, lsl #3]
			rgn->region[i].size += size;
348183c4:	e0804184 	add	r4, r0, r4, lsl #3
348183c8:	e5945004 	ldr	r5, [r4, #4]
348183cc:	e0825005 	add	r5, r2, r5
348183d0:	e5845004 	str	r5, [r4, #4]
348183d4:	ea000002 	b	348183e4 <lmb_add_region+0x98>
			coalesced++;
			break;
		}
		else if ( adjacent < 0 ) {
			rgn->region[i].size += size;
348183d8:	e0806186 	add	r6, r0, r6, lsl #3
348183dc:	e0855002 	add	r5, r5, r2
348183e0:	e5865004 	str	r5, [r6, #4]
			coalesced++;
348183e4:	e3a05001 	mov	r5, #1
			break;
348183e8:	ea000002 	b	348183f8 <lmb_add_region+0xac>
		rgn->region[0].size = size;
		return 0;
	}

	/* First try and coalesce this LMB with another. */
	for (i=0; i < rgn->cnt; i++) {
348183ec:	e153000c 	cmp	r3, ip
348183f0:	3affffe3 	bcc	34818384 <lmb_add_region+0x38>
}

/* This routine called with relocation disabled. */
static long lmb_add_region(struct lmb_region *rgn, phys_addr_t base, phys_size_t size)
{
	unsigned long coalesced = 0;
348183f4:	e3a05000 	mov	r5, #0
			coalesced++;
			break;
		}
	}

	if ((i < rgn->cnt-1) && lmb_regions_adjacent(rgn, i, i+1) ) {
348183f8:	e24c4001 	sub	r4, ip, #1
348183fc:	e1530004 	cmp	r3, r4
34818400:	2a00001e 	bcs	34818480 <lmb_add_region+0x134>
34818404:	e2836001 	add	r6, r3, #1

static long lmb_regions_adjacent(struct lmb_region *rgn,
		unsigned long r1, unsigned long r2)
{
	phys_addr_t base1 = rgn->region[r1].base;
	phys_size_t size1 = rgn->region[r1].size;
34818408:	e080a186 	add	sl, r0, r6, lsl #3
}

static long lmb_regions_adjacent(struct lmb_region *rgn,
		unsigned long r1, unsigned long r2)
{
	phys_addr_t base1 = rgn->region[r1].base;
3481840c:	e7907186 	ldr	r7, [r0, r6, lsl #3]
	phys_size_t size1 = rgn->region[r1].size;
34818410:	e59ab004 	ldr	fp, [sl, #4]
	phys_addr_t base2 = rgn->region[r2].base;
34818414:	e2866001 	add	r6, r6, #1
34818418:	e790a186 	ldr	sl, [r0, r6, lsl #3]
}

static long lmb_addrs_adjacent(phys_addr_t base1, phys_size_t size1,
		phys_addr_t base2, phys_size_t size2)
{
	if (base2 == base1 + size1)
3481841c:	e08b9007 	add	r9, fp, r7
		unsigned long r1, unsigned long r2)
{
	phys_addr_t base1 = rgn->region[r1].base;
	phys_size_t size1 = rgn->region[r1].size;
	phys_addr_t base2 = rgn->region[r2].base;
	phys_size_t size2 = rgn->region[r2].size;
34818420:	e0806186 	add	r6, r0, r6, lsl #3
}

static long lmb_addrs_adjacent(phys_addr_t base1, phys_size_t size1,
		phys_addr_t base2, phys_size_t size2)
{
	if (base2 == base1 + size1)
34818424:	e15a0009 	cmp	sl, r9
		unsigned long r1, unsigned long r2)
{
	phys_addr_t base1 = rgn->region[r1].base;
	phys_size_t size1 = rgn->region[r1].size;
	phys_addr_t base2 = rgn->region[r2].base;
	phys_size_t size2 = rgn->region[r2].size;
34818428:	e5966004 	ldr	r6, [r6, #4]
}

static long lmb_addrs_adjacent(phys_addr_t base1, phys_size_t size1,
		phys_addr_t base2, phys_size_t size2)
{
	if (base2 == base1 + size1)
3481842c:	0a000002 	beq	3481843c <lmb_add_region+0xf0>
		return 1;
	else if (base1 == base2 + size2)
34818430:	e086a00a 	add	sl, r6, sl
34818434:	e157000a 	cmp	r7, sl
34818438:	1a000010 	bne	34818480 <lmb_add_region+0x134>

/* Assumption: base addr of region 1 < base addr of region 2 */
static void lmb_coalesce_regions(struct lmb_region *rgn,
		unsigned long r1, unsigned long r2)
{
	rgn->region[r1].size += rgn->region[r2].size;
3481843c:	e0802183 	add	r2, r0, r3, lsl #3
34818440:	e086600b 	add	r6, r6, fp
34818444:	e582600c 	str	r6, [r2, #12]
	lmb->reserved.cnt = 1;
	lmb->reserved.size = 0;
}

/* This routine called with relocation disabled. */
static long lmb_add_region(struct lmb_region *rgn, phys_addr_t base, phys_size_t size)
34818448:	e2832003 	add	r2, r3, #3
3481844c:	e0802182 	add	r2, r0, r2, lsl #3
34818450:	ea000003 	b	34818464 <lmb_add_region+0x118>
static void lmb_remove_region(struct lmb_region *rgn, unsigned long r)
{
	unsigned long i;

	for (i = r; i < rgn->cnt - 1; i++) {
		rgn->region[i].base = rgn->region[i + 1].base;
34818454:	e5121008 	ldr	r1, [r2, #-8]
34818458:	e5021010 	str	r1, [r2, #-16]
		rgn->region[i].size = rgn->region[i + 1].size;
3481845c:	e5121004 	ldr	r1, [r2, #-4]
34818460:	e502100c 	str	r1, [r2, #-12]
34818464:	e2833001 	add	r3, r3, #1

static void lmb_remove_region(struct lmb_region *rgn, unsigned long r)
{
	unsigned long i;

	for (i = r; i < rgn->cnt - 1; i++) {
34818468:	e1530004 	cmp	r3, r4
		rgn->region[i].base = rgn->region[i + 1].base;
		rgn->region[i].size = rgn->region[i + 1].size;
3481846c:	e2822008 	add	r2, r2, #8

static void lmb_remove_region(struct lmb_region *rgn, unsigned long r)
{
	unsigned long i;

	for (i = r; i < rgn->cnt - 1; i++) {
34818470:	3afffff7 	bcc	34818454 <lmb_add_region+0x108>
		rgn->region[i].base = rgn->region[i + 1].base;
		rgn->region[i].size = rgn->region[i + 1].size;
	}
	rgn->cnt--;
34818474:	e5804000 	str	r4, [r0]
		}
	}

	if ((i < rgn->cnt-1) && lmb_regions_adjacent(rgn, i, i+1) ) {
		lmb_coalesce_regions(rgn, i, i+1);
		coalesced++;
34818478:	e2850001 	add	r0, r5, #1
3481847c:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
	}

	if (coalesced)
34818480:	e3550000 	cmp	r5, #0
34818484:	13a00001 	movne	r0, #1
34818488:	18bd8ef0 	popne	{r4, r5, r6, r7, r9, sl, fp, pc}
		return coalesced;
	if (rgn->cnt >= MAX_LMB_REGIONS)
3481848c:	e35c0007 	cmp	ip, #7
	lmb->reserved.cnt = 1;
	lmb->reserved.size = 0;
}

/* This routine called with relocation disabled. */
static long lmb_add_region(struct lmb_region *rgn, phys_addr_t base, phys_size_t size)
34818490:	928c3001 	addls	r3, ip, #1
34818494:	90803183 	addls	r3, r0, r3, lsl #3
		coalesced++;
	}

	if (coalesced)
		return coalesced;
	if (rgn->cnt >= MAX_LMB_REGIONS)
34818498:	9a00000b 	bls	348184cc <lmb_add_region+0x180>
3481849c:	ea000014 	b	348184f4 <lmb_add_region+0x1a8>
		return -1;

	/* Couldn't coalesce the LMB, so add it to the sorted table. */
	for (i = rgn->cnt-1; i >= 0; i--) {
		if (base < rgn->region[i].base) {
348184a0:	e5335008 	ldr	r5, [r3, #-8]!
348184a4:	e1510005 	cmp	r1, r5
			rgn->region[i+1].base = rgn->region[i].base;
348184a8:	35835008 	strcc	r5, [r3, #8]
			rgn->region[i+1].size = rgn->region[i].size;
348184ac:	35935004 	ldrcc	r5, [r3, #4]
		return coalesced;
	if (rgn->cnt >= MAX_LMB_REGIONS)
		return -1;

	/* Couldn't coalesce the LMB, so add it to the sorted table. */
	for (i = rgn->cnt-1; i >= 0; i--) {
348184b0:	32444001 	subcc	r4, r4, #1
		if (base < rgn->region[i].base) {
			rgn->region[i+1].base = rgn->region[i].base;
			rgn->region[i+1].size = rgn->region[i].size;
348184b4:	3583500c 	strcc	r5, [r3, #12]
		} else {
			rgn->region[i+1].base = base;
348184b8:	22844002 	addcs	r4, r4, #2
348184bc:	27801184 	strcs	r1, [r0, r4, lsl #3]
			rgn->region[i+1].size = size;
348184c0:	20804184 	addcs	r4, r0, r4, lsl #3
348184c4:	25842004 	strcs	r2, [r4, #4]
			break;
348184c8:	2a000001 	bcs	348184d4 <lmb_add_region+0x188>
		return coalesced;
	if (rgn->cnt >= MAX_LMB_REGIONS)
		return -1;

	/* Couldn't coalesce the LMB, so add it to the sorted table. */
	for (i = rgn->cnt-1; i >= 0; i--) {
348184cc:	e3540000 	cmp	r4, #0
348184d0:	aafffff2 	bge	348184a0 <lmb_add_region+0x154>
			rgn->region[i+1].size = size;
			break;
		}
	}

	if (base < rgn->region[0].base) {
348184d4:	e5903008 	ldr	r3, [r0, #8]
		rgn->region[0].base = base;
		rgn->region[0].size = size;
	}

	rgn->cnt++;
348184d8:	e28cc001 	add	ip, ip, #1
			rgn->region[i+1].size = size;
			break;
		}
	}

	if (base < rgn->region[0].base) {
348184dc:	e1510003 	cmp	r1, r3
		rgn->region[0].base = base;
348184e0:	35801008 	strcc	r1, [r0, #8]
		rgn->region[0].size = size;
348184e4:	3580200c 	strcc	r2, [r0, #12]
	}

	rgn->cnt++;
348184e8:	e580c000 	str	ip, [r0]
		phys_addr_t rgnbase = rgn->region[i].base;
		phys_size_t rgnsize = rgn->region[i].size;

		if ((rgnbase == base) && (rgnsize == size))
			/* Already have this region, so we're done */
			return 0;
348184ec:	e3a00000 	mov	r0, #0
348184f0:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
	}

	if (coalesced)
		return coalesced;
	if (rgn->cnt >= MAX_LMB_REGIONS)
		return -1;
348184f4:	e3e00000 	mvn	r0, #0
	}

	rgn->cnt++;

	return 0;
}
348184f8:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
		rgn->region[0].size = size;
		return 0;
	}

	/* First try and coalesce this LMB with another. */
	for (i=0; i < rgn->cnt; i++) {
348184fc:	e1a03006 	mov	r3, r6
34818500:	eaffffb9 	b	348183ec <lmb_add_region+0xa0>

34818504 <lmb_dump_all>:
			(long long unsigned)lmb->reserved.region[i].base);
		debug("		     .size = 0x%llx\n",
			(long long unsigned)lmb->reserved.region[i].size);
	}
#endif /* DEBUG */
}
34818504:	e12fff1e 	bx	lr

34818508 <lmb_init>:
void lmb_init(struct lmb *lmb)
{
	/* Create a dummy zero size LMB which will get coalesced away later.
	 * This simplifies the lmb_add() code below...
	 */
	lmb->memory.region[0].base = 0;
34818508:	e3a03000 	mov	r3, #0
	lmb->memory.region[0].size = 0;
	lmb->memory.cnt = 1;
3481850c:	e3a02001 	mov	r2, #1
void lmb_init(struct lmb *lmb)
{
	/* Create a dummy zero size LMB which will get coalesced away later.
	 * This simplifies the lmb_add() code below...
	 */
	lmb->memory.region[0].base = 0;
34818510:	e5803008 	str	r3, [r0, #8]
	lmb->memory.region[0].size = 0;
34818514:	e580300c 	str	r3, [r0, #12]
	lmb->memory.cnt = 1;
34818518:	e880000c 	stm	r0, {r2, r3}
	lmb->memory.size = 0;

	/* Ditto. */
	lmb->reserved.region[0].base = 0;
3481851c:	e5803058 	str	r3, [r0, #88]	; 0x58
	lmb->reserved.region[0].size = 0;
34818520:	e580305c 	str	r3, [r0, #92]	; 0x5c
	lmb->reserved.cnt = 1;
34818524:	e5802050 	str	r2, [r0, #80]	; 0x50
	lmb->reserved.size = 0;
34818528:	e5803054 	str	r3, [r0, #84]	; 0x54
}
3481852c:	e12fff1e 	bx	lr

34818530 <lmb_add>:
/* This routine may be called with relocation disabled. */
long lmb_add(struct lmb *lmb, phys_addr_t base, phys_size_t size)
{
	struct lmb_region *_rgn = &(lmb->memory);

	return lmb_add_region(_rgn, base, size);
34818530:	eaffff85 	b	3481834c <lmb_add_region>

34818534 <lmb_free>:
}

long lmb_free(struct lmb *lmb, phys_addr_t base, phys_size_t size)
{
34818534:	e92d46f0 	push	{r4, r5, r6, r7, r9, sl, lr}
	int i;

	rgnbegin = rgnend = 0; /* supress gcc warnings */

	/* Find the region where (base, size) belongs to */
	for (i=0; i < rgn->cnt; i++) {
34818538:	e3a04000 	mov	r4, #0

long lmb_free(struct lmb *lmb, phys_addr_t base, phys_size_t size)
{
	struct lmb_region *rgn = &(lmb->reserved);
	phys_addr_t rgnbegin, rgnend;
	phys_addr_t end = base + size;
3481853c:	e082c001 	add	ip, r2, r1
	int i;

	rgnbegin = rgnend = 0; /* supress gcc warnings */

	/* Find the region where (base, size) belongs to */
	for (i=0; i < rgn->cnt; i++) {
34818540:	e5907050 	ldr	r7, [r0, #80]	; 0x50
34818544:	e1a06000 	mov	r6, r0
	struct lmb_region *rgn = &(lmb->reserved);
	phys_addr_t rgnbegin, rgnend;
	phys_addr_t end = base + size;
	int i;

	rgnbegin = rgnend = 0; /* supress gcc warnings */
34818548:	e1a03004 	mov	r3, r4
3481854c:	e1a05004 	mov	r5, r4

	/* Find the region where (base, size) belongs to */
	for (i=0; i < rgn->cnt; i++) {
34818550:	ea000007 	b	34818574 <lmb_free+0x40>
		rgnbegin = rgn->region[i].base;
34818554:	e5965058 	ldr	r5, [r6, #88]	; 0x58
		rgnend = rgnbegin + rgn->region[i].size;
34818558:	e596305c 	ldr	r3, [r6, #92]	; 0x5c
3481855c:	e2866008 	add	r6, r6, #8
34818560:	e0853003 	add	r3, r5, r3

		if ((rgnbegin <= base) && (end <= rgnend))
34818564:	e15c0003 	cmp	ip, r3
34818568:	91550001 	cmpls	r5, r1
3481856c:	9a000003 	bls	34818580 <lmb_free+0x4c>
	int i;

	rgnbegin = rgnend = 0; /* supress gcc warnings */

	/* Find the region where (base, size) belongs to */
	for (i=0; i < rgn->cnt; i++) {
34818570:	e2844001 	add	r4, r4, #1
34818574:	e1540007 	cmp	r4, r7
34818578:	e1a0a004 	mov	sl, r4
3481857c:	3afffff4 	bcc	34818554 <lmb_free+0x20>
		if ((rgnbegin <= base) && (end <= rgnend))
			break;
	}

	/* Didn't find the region */
	if (i == rgn->cnt)
34818580:	e1540007 	cmp	r4, r7
34818584:	0a000032 	beq	34818654 <lmb_free+0x120>
		return -1;

	/* Check to see if we are removing entire region */
	if ((rgnbegin == base) && (rgnend == end)) {
34818588:	e1550001 	cmp	r5, r1
3481858c:	13a05000 	movne	r5, #0
34818590:	03a05001 	moveq	r5, #1
34818594:	e153000c 	cmp	r3, ip
34818598:	13a06000 	movne	r6, #0
3481859c:	03a06001 	moveq	r6, #1
348185a0:	e0169005 	ands	r9, r6, r5
348185a4:	0a00000e 	beq	348185e4 <lmb_free+0xb0>
	struct lmb_region *_rgn = &(lmb->memory);

	return lmb_add_region(_rgn, base, size);
}

long lmb_free(struct lmb *lmb, phys_addr_t base, phys_size_t size)
348185a8:	e284400c 	add	r4, r4, #12
348185ac:	e0804184 	add	r4, r0, r4, lsl #3

static void lmb_remove_region(struct lmb_region *rgn, unsigned long r)
{
	unsigned long i;

	for (i = r; i < rgn->cnt - 1; i++) {
348185b0:	e2477001 	sub	r7, r7, #1
348185b4:	ea000004 	b	348185cc <lmb_free+0x98>
		rgn->region[i].base = rgn->region[i + 1].base;
348185b8:	e5143008 	ldr	r3, [r4, #-8]
348185bc:	e28aa001 	add	sl, sl, #1
348185c0:	e5043010 	str	r3, [r4, #-16]
		rgn->region[i].size = rgn->region[i + 1].size;
348185c4:	e5143004 	ldr	r3, [r4, #-4]
348185c8:	e504300c 	str	r3, [r4, #-12]

static void lmb_remove_region(struct lmb_region *rgn, unsigned long r)
{
	unsigned long i;

	for (i = r; i < rgn->cnt - 1; i++) {
348185cc:	e15a0007 	cmp	sl, r7
348185d0:	e2844008 	add	r4, r4, #8
348185d4:	3afffff7 	bcc	348185b8 <lmb_free+0x84>
		rgn->region[i].base = rgn->region[i + 1].base;
		rgn->region[i].size = rgn->region[i + 1].size;
	}
	rgn->cnt--;
348185d8:	e5807050 	str	r7, [r0, #80]	; 0x50
		return -1;

	/* Check to see if we are removing entire region */
	if ((rgnbegin == base) && (rgnend == end)) {
		lmb_remove_region(rgn, i);
		return 0;
348185dc:	e3a00000 	mov	r0, #0
348185e0:	e8bd86f0 	pop	{r4, r5, r6, r7, r9, sl, pc}
	}

	/* Check to see if region is matching at the front */
	if (rgnbegin == base) {
348185e4:	e3550000 	cmp	r5, #0
348185e8:	0a000007 	beq	3481860c <lmb_free+0xd8>
		rgn->region[i].base = end;
348185ec:	e284400b 	add	r4, r4, #11
348185f0:	e780c184 	str	ip, [r0, r4, lsl #3]
		rgn->region[i].size -= size;
348185f4:	e0800184 	add	r0, r0, r4, lsl #3
348185f8:	e5903004 	ldr	r3, [r0, #4]
348185fc:	e0622003 	rsb	r2, r2, r3
34818600:	e5802004 	str	r2, [r0, #4]
		return 0;
34818604:	e1a00009 	mov	r0, r9
34818608:	e8bd86f0 	pop	{r4, r5, r6, r7, r9, sl, pc}
	}

	/* Check to see if the region is matching at the end */
	if (rgnend == end) {
3481860c:	e3560000 	cmp	r6, #0
34818610:	e284400b 	add	r4, r4, #11
34818614:	0a000005 	beq	34818630 <lmb_free+0xfc>
		rgn->region[i].size -= size;
34818618:	e0804184 	add	r4, r0, r4, lsl #3
3481861c:	e5943004 	ldr	r3, [r4, #4]
		return 0;
34818620:	e1a00005 	mov	r0, r5
		return 0;
	}

	/* Check to see if the region is matching at the end */
	if (rgnend == end) {
		rgn->region[i].size -= size;
34818624:	e0622003 	rsb	r2, r2, r3
34818628:	e5842004 	str	r2, [r4, #4]
		return 0;
3481862c:	e8bd86f0 	pop	{r4, r5, r6, r7, r9, sl, pc}

	/*
	 * We need to split the entry -  adjust the current one to the
	 * beginging of the hole and add the region after hole.
	 */
	rgn->region[i].size = base - rgn->region[i].base;
34818630:	e0802184 	add	r2, r0, r4, lsl #3
34818634:	e7904184 	ldr	r4, [r0, r4, lsl #3]
	return lmb_add_region(rgn, end, rgnend - end);
34818638:	e2800050 	add	r0, r0, #80	; 0x50

	/*
	 * We need to split the entry -  adjust the current one to the
	 * beginging of the hole and add the region after hole.
	 */
	rgn->region[i].size = base - rgn->region[i].base;
3481863c:	e0641001 	rsb	r1, r4, r1
34818640:	e5821004 	str	r1, [r2, #4]
	return lmb_add_region(rgn, end, rgnend - end);
34818644:	e1a0100c 	mov	r1, ip
34818648:	e06c2003 	rsb	r2, ip, r3
}
3481864c:	e8bd46f0 	pop	{r4, r5, r6, r7, r9, sl, lr}
	/*
	 * We need to split the entry -  adjust the current one to the
	 * beginging of the hole and add the region after hole.
	 */
	rgn->region[i].size = base - rgn->region[i].base;
	return lmb_add_region(rgn, end, rgnend - end);
34818650:	eaffff3d 	b	3481834c <lmb_add_region>
			break;
	}

	/* Didn't find the region */
	if (i == rgn->cnt)
		return -1;
34818654:	e3e00000 	mvn	r0, #0
	 * We need to split the entry -  adjust the current one to the
	 * beginging of the hole and add the region after hole.
	 */
	rgn->region[i].size = base - rgn->region[i].base;
	return lmb_add_region(rgn, end, rgnend - end);
}
34818658:	e8bd86f0 	pop	{r4, r5, r6, r7, r9, sl, pc}

3481865c <lmb_reserve>:

long lmb_reserve(struct lmb *lmb, phys_addr_t base, phys_size_t size)
{
	struct lmb_region *_rgn = &(lmb->reserved);

	return lmb_add_region(_rgn, base, size);
3481865c:	e2800050 	add	r0, r0, #80	; 0x50
34818660:	eaffff39 	b	3481834c <lmb_add_region>

34818664 <lmb_overlaps_region>:
}

long lmb_overlaps_region(struct lmb_region *rgn, phys_addr_t base,
				phys_size_t size)
{
34818664:	e92d4030 	push	{r4, r5, lr}
	unsigned long i;

	for (i=0; i < rgn->cnt; i++) {
34818668:	e590c000 	ldr	ip, [r0]
3481866c:	e3a03000 	mov	r3, #0
}

static long lmb_addrs_overlap(phys_addr_t base1,
		phys_size_t size1, phys_addr_t base2, phys_size_t size2)
{
	return ((base1 < (base2+size2)) && (base2 < (base1+size1)));
34818670:	e0822001 	add	r2, r2, r1
long lmb_overlaps_region(struct lmb_region *rgn, phys_addr_t base,
				phys_size_t size)
{
	unsigned long i;

	for (i=0; i < rgn->cnt; i++) {
34818674:	ea000008 	b	3481869c <lmb_overlaps_region+0x38>
		phys_addr_t rgnbase = rgn->region[i].base;
34818678:	e5904008 	ldr	r4, [r0, #8]
}

static long lmb_addrs_overlap(phys_addr_t base1,
		phys_size_t size1, phys_addr_t base2, phys_size_t size2)
{
	return ((base1 < (base2+size2)) && (base2 < (base1+size1)));
3481867c:	e590500c 	ldr	r5, [r0, #12]
34818680:	e0845005 	add	r5, r4, r5
34818684:	e1510005 	cmp	r1, r5
34818688:	2a000007 	bcs	348186ac <lmb_overlaps_region+0x48>
3481868c:	e1540002 	cmp	r4, r2
34818690:	2a000005 	bcs	348186ac <lmb_overlaps_region+0x48>
		if ( lmb_addrs_overlap(base,size,rgnbase,rgnsize) ) {
			break;
		}
	}

	return (i < rgn->cnt) ? i : -1;
34818694:	e1a00003 	mov	r0, r3
34818698:	e8bd8030 	pop	{r4, r5, pc}
long lmb_overlaps_region(struct lmb_region *rgn, phys_addr_t base,
				phys_size_t size)
{
	unsigned long i;

	for (i=0; i < rgn->cnt; i++) {
3481869c:	e153000c 	cmp	r3, ip
348186a0:	3afffff4 	bcc	34818678 <lmb_overlaps_region+0x14>
		if ( lmb_addrs_overlap(base,size,rgnbase,rgnsize) ) {
			break;
		}
	}

	return (i < rgn->cnt) ? i : -1;
348186a4:	e3e00000 	mvn	r0, #0
}
348186a8:	e8bd8030 	pop	{r4, r5, pc}
long lmb_overlaps_region(struct lmb_region *rgn, phys_addr_t base,
				phys_size_t size)
{
	unsigned long i;

	for (i=0; i < rgn->cnt; i++) {
348186ac:	e2833001 	add	r3, r3, #1
348186b0:	e2800008 	add	r0, r0, #8
348186b4:	eafffff8 	b	3481869c <lmb_overlaps_region+0x38>

348186b8 <__lmb_alloc_base>:
{
	return (addr + (size - 1)) & ~(size - 1);
}

phys_addr_t __lmb_alloc_base(struct lmb *lmb, phys_size_t size, ulong align, phys_addr_t max_addr)
{
348186b8:	e92d4eff 	push	{r0, r1, r2, r3, r4, r5, r6, r7, r9, sl, fp, lr}
	long i, j;
	phys_addr_t base = 0;
	phys_addr_t res_base;

	for (i = lmb->memory.cnt-1; i >= 0; i--) {
348186bc:	e5907000 	ldr	r7, [r0]
{
	return (addr + (size - 1)) & ~(size - 1);
}

phys_addr_t __lmb_alloc_base(struct lmb *lmb, phys_size_t size, ulong align, phys_addr_t max_addr)
{
348186c0:	e1a09003 	mov	r9, r3
			base = lmb_align_down(base - size, align);
		} else
			continue;

		while (base && lmbbase <= base) {
			j = lmb_overlaps_region(&lmb->reserved, base, size);
348186c4:	e2803050 	add	r3, r0, #80	; 0x50
348186c8:	e58d300c 	str	r3, [sp, #12]
	return alloc;
}

static phys_addr_t lmb_align_down(phys_addr_t addr, phys_size_t size)
{
	return addr & ~(size - 1);
348186cc:	e2623000 	rsb	r3, r2, #0
{
	return (addr + (size - 1)) & ~(size - 1);
}

phys_addr_t __lmb_alloc_base(struct lmb *lmb, phys_size_t size, ulong align, phys_addr_t max_addr)
{
348186d0:	e1a0c002 	mov	ip, r2
	long i, j;
	phys_addr_t base = 0;
	phys_addr_t res_base;

	for (i = lmb->memory.cnt-1; i >= 0; i--) {
348186d4:	e247b001 	sub	fp, r7, #1
348186d8:	e1a02003 	mov	r2, r3
static phys_addr_t lmb_align_up(phys_addr_t addr, ulong size)
{
	return (addr + (size - 1)) & ~(size - 1);
}

phys_addr_t __lmb_alloc_base(struct lmb *lmb, phys_size_t size, ulong align, phys_addr_t max_addr)
348186dc:	e2877001 	add	r7, r7, #1
{
348186e0:	e1a04001 	mov	r4, r1
static phys_addr_t lmb_align_up(phys_addr_t addr, ulong size)
{
	return (addr + (size - 1)) & ~(size - 1);
}

phys_addr_t __lmb_alloc_base(struct lmb *lmb, phys_size_t size, ulong align, phys_addr_t max_addr)
348186e4:	e0807187 	add	r7, r0, r7, lsl #3
348186e8:	e1a03000 	mov	r3, r0
348186ec:	e1a05002 	mov	r5, r2
{
	long i, j;
	phys_addr_t base = 0;
	phys_addr_t res_base;

	for (i = lmb->memory.cnt-1; i >= 0; i--) {
348186f0:	ea000036 	b	348187d0 <__lmb_alloc_base+0x118>
		phys_addr_t lmbbase = lmb->memory.region[i].base;
		phys_size_t lmbsize = lmb->memory.region[i].size;
348186f4:	e5176004 	ldr	r6, [r7, #-4]
	long i, j;
	phys_addr_t base = 0;
	phys_addr_t res_base;

	for (i = lmb->memory.cnt-1; i >= 0; i--) {
		phys_addr_t lmbbase = lmb->memory.region[i].base;
348186f8:	e517a008 	ldr	sl, [r7, #-8]
		phys_size_t lmbsize = lmb->memory.region[i].size;

		if (lmbsize < size)
348186fc:	e1560004 	cmp	r6, r4
34818700:	3a000030 	bcc	348187c8 <__lmb_alloc_base+0x110>
			continue;
		if (max_addr == LMB_ALLOC_ANYWHERE)
34818704:	e3590000 	cmp	r9, #0
			base = lmb_align_down(lmbbase + lmbsize - size, align);
34818708:	0086600a 	addeq	r6, r6, sl
3481870c:	00646006 	rsbeq	r6, r4, r6
		phys_addr_t lmbbase = lmb->memory.region[i].base;
		phys_size_t lmbsize = lmb->memory.region[i].size;

		if (lmbsize < size)
			continue;
		if (max_addr == LMB_ALLOC_ANYWHERE)
34818710:	0a000005 	beq	3481872c <__lmb_alloc_base+0x74>
			base = lmb_align_down(lmbbase + lmbsize - size, align);
		else if (lmbbase < max_addr) {
34818714:	e15a0009 	cmp	sl, r9
34818718:	2a00002a 	bcs	348187c8 <__lmb_alloc_base+0x110>
			base = min(lmbbase + lmbsize, max_addr);
3481871c:	e086600a 	add	r6, r6, sl
			base = lmb_align_down(base - size, align);
34818720:	e1590006 	cmp	r9, r6
34818724:	90646009 	rsbls	r6, r4, r9
34818728:	80646006 	rsbhi	r6, r4, r6
3481872c:	e58db008 	str	fp, [sp, #8]
	return alloc;
}

static phys_addr_t lmb_align_down(phys_addr_t addr, phys_size_t size)
{
	return addr & ~(size - 1);
34818730:	e0066005 	and	r6, r6, r5
34818734:	e1a0b007 	mov	fp, r7
34818738:	e1a07003 	mov	r7, r3
3481873c:	ea000017 	b	348187a0 <__lmb_alloc_base+0xe8>
			base = lmb_align_down(base - size, align);
		} else
			continue;

		while (base && lmbbase <= base) {
			j = lmb_overlaps_region(&lmb->reserved, base, size);
34818740:	e59d000c 	ldr	r0, [sp, #12]
34818744:	e1a01006 	mov	r1, r6
34818748:	e1a02004 	mov	r2, r4
3481874c:	e58dc004 	str	ip, [sp, #4]
34818750:	ebffffc3 	bl	34818664 <lmb_overlaps_region>
			if (j < 0) {
34818754:	e3500000 	cmp	r0, #0
34818758:	e59dc004 	ldr	ip, [sp, #4]
3481875c:	aa000009 	bge	34818788 <__lmb_alloc_base+0xd0>
	return addr & ~(size - 1);
}

static phys_addr_t lmb_align_up(phys_addr_t addr, ulong size)
{
	return (addr + (size - 1)) & ~(size - 1);
34818760:	e2444001 	sub	r4, r4, #1
34818764:	e26c2000 	rsb	r2, ip, #0
34818768:	e084c00c 	add	ip, r4, ip

		while (base && lmbbase <= base) {
			j = lmb_overlaps_region(&lmb->reserved, base, size);
			if (j < 0) {
				/* This area isn't reserved, take it */
				if (lmb_add_region(&lmb->reserved, base,
3481876c:	e1a01006 	mov	r1, r6
34818770:	e59d000c 	ldr	r0, [sp, #12]
34818774:	e002200c 	and	r2, r2, ip
34818778:	ebfffef3 	bl	3481834c <lmb_add_region>
							lmb_align_up(size,
								align)) < 0)
					return 0;
3481877c:	e3500000 	cmp	r0, #0
34818780:	b3a06000 	movlt	r6, #0
34818784:	ea000014 	b	348187dc <__lmb_alloc_base+0x124>
				return base;
			}
			res_base = lmb->reserved.region[j].base;
34818788:	e280000b 	add	r0, r0, #11
3481878c:	e7976180 	ldr	r6, [r7, r0, lsl #3]
			if (res_base < size)
34818790:	e1560004 	cmp	r6, r4
34818794:	3a000008 	bcc	348187bc <__lmb_alloc_base+0x104>
				break;
			base = lmb_align_down(res_base - size, align);
34818798:	e0646006 	rsb	r6, r4, r6
	return alloc;
}

static phys_addr_t lmb_align_down(phys_addr_t addr, phys_size_t size)
{
	return addr & ~(size - 1);
3481879c:	e0056006 	and	r6, r5, r6
			base = min(lmbbase + lmbsize, max_addr);
			base = lmb_align_down(base - size, align);
		} else
			continue;

		while (base && lmbbase <= base) {
348187a0:	e15a0006 	cmp	sl, r6
348187a4:	83a02000 	movhi	r2, #0
348187a8:	93a02001 	movls	r2, #1
348187ac:	e3560000 	cmp	r6, #0
348187b0:	03a02000 	moveq	r2, #0
348187b4:	e3520000 	cmp	r2, #0
348187b8:	1affffe0 	bne	34818740 <__lmb_alloc_base+0x88>
348187bc:	e1a03007 	mov	r3, r7
348187c0:	e1a0700b 	mov	r7, fp
348187c4:	e59db008 	ldr	fp, [sp, #8]
{
	long i, j;
	phys_addr_t base = 0;
	phys_addr_t res_base;

	for (i = lmb->memory.cnt-1; i >= 0; i--) {
348187c8:	e24bb001 	sub	fp, fp, #1
348187cc:	e2477008 	sub	r7, r7, #8
348187d0:	e35b0000 	cmp	fp, #0
348187d4:	aaffffc6 	bge	348186f4 <__lmb_alloc_base+0x3c>
			if (res_base < size)
				break;
			base = lmb_align_down(res_base - size, align);
		}
	}
	return 0;
348187d8:	e3a06000 	mov	r6, #0
}
348187dc:	e1a00006 	mov	r0, r6
348187e0:	e28dd010 	add	sp, sp, #16
348187e4:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}

348187e8 <lmb_alloc_base>:
{
	return lmb_alloc_base(lmb, size, align, LMB_ALLOC_ANYWHERE);
}

phys_addr_t lmb_alloc_base(struct lmb *lmb, phys_size_t size, ulong align, phys_addr_t max_addr)
{
348187e8:	e92d4070 	push	{r4, r5, r6, lr}
348187ec:	e1a05001 	mov	r5, r1
348187f0:	e1a04003 	mov	r4, r3
	phys_addr_t alloc;

	alloc = __lmb_alloc_base(lmb, size, align, max_addr);
348187f4:	ebffffaf 	bl	348186b8 <__lmb_alloc_base>

	if (alloc == 0)
348187f8:	e2506000 	subs	r6, r0, #0
348187fc:	1a000003 	bne	34818810 <lmb_alloc_base+0x28>
		printf("ERROR: Failed to allocate 0x%lx bytes below 0x%lx.\n",
34818800:	e59f0010 	ldr	r0, [pc, #16]	; 34818818 <lmb_alloc_base+0x30>
34818804:	e1a01005 	mov	r1, r5
34818808:	e1a02004 	mov	r2, r4
3481880c:	ebffc1ce 	bl	34808f4c <printf>
		      (ulong)size, (ulong)max_addr);

	return alloc;
}
34818810:	e1a00006 	mov	r0, r6
34818814:	e8bd8070 	pop	{r4, r5, r6, pc}
34818818:	34827842 	.word	0x34827842

3481881c <lmb_alloc>:
	return (i < rgn->cnt) ? i : -1;
}

phys_addr_t lmb_alloc(struct lmb *lmb, phys_size_t size, ulong align)
{
	return lmb_alloc_base(lmb, size, align, LMB_ALLOC_ANYWHERE);
3481881c:	e3a03000 	mov	r3, #0
34818820:	eafffff0 	b	348187e8 <lmb_alloc_base>

34818824 <lmb_is_reserved>:
	}
	return 0;
}

int lmb_is_reserved(struct lmb *lmb, phys_addr_t addr)
{
34818824:	e92d4010 	push	{r4, lr}
	int i;

	for (i = 0; i < lmb->reserved.cnt; i++) {
34818828:	e590c050 	ldr	ip, [r0, #80]	; 0x50
3481882c:	e3a03000 	mov	r3, #0
34818830:	ea00000d 	b	3481886c <lmb_is_reserved+0x48>
		}
	}
	return 0;
}

int lmb_is_reserved(struct lmb *lmb, phys_addr_t addr)
34818834:	e1a04000 	mov	r4, r0
{
	int i;

	for (i = 0; i < lmb->reserved.cnt; i++) {
		phys_addr_t upper = lmb->reserved.region[i].base +
34818838:	e5902058 	ldr	r2, [r0, #88]	; 0x58
3481883c:	e594405c 	ldr	r4, [r4, #92]	; 0x5c
34818840:	e2800008 	add	r0, r0, #8
34818844:	e0824004 	add	r4, r2, r4
34818848:	e2444001 	sub	r4, r4, #1
			lmb->reserved.region[i].size - 1;
		if ((addr >= lmb->reserved.region[i].base) && (addr <= upper))
3481884c:	e1510004 	cmp	r1, r4
34818850:	83a04000 	movhi	r4, #0
34818854:	93a04001 	movls	r4, #1
34818858:	e1510002 	cmp	r1, r2
3481885c:	33a04000 	movcc	r4, #0
34818860:	e3540000 	cmp	r4, #0
34818864:	1a000004 	bne	3481887c <lmb_is_reserved+0x58>

int lmb_is_reserved(struct lmb *lmb, phys_addr_t addr)
{
	int i;

	for (i = 0; i < lmb->reserved.cnt; i++) {
34818868:	e2833001 	add	r3, r3, #1
3481886c:	e153000c 	cmp	r3, ip
34818870:	3affffef 	bcc	34818834 <lmb_is_reserved+0x10>
		phys_addr_t upper = lmb->reserved.region[i].base +
			lmb->reserved.region[i].size - 1;
		if ((addr >= lmb->reserved.region[i].base) && (addr <= upper))
			return 1;
	}
	return 0;
34818874:	e3a00000 	mov	r0, #0
34818878:	e8bd8010 	pop	{r4, pc}

	for (i = 0; i < lmb->reserved.cnt; i++) {
		phys_addr_t upper = lmb->reserved.region[i].base +
			lmb->reserved.region[i].size - 1;
		if ((addr >= lmb->reserved.region[i].base) && (addr <= upper))
			return 1;
3481887c:	e3a00001 	mov	r0, #1
	}
	return 0;
}
34818880:	e8bd8010 	pop	{r4, pc}

34818884 <__board_lmb_reserve>:

void __board_lmb_reserve(struct lmb *lmb)
{
	/* please define platform specific board_lmb_reserve() */
}
34818884:	e12fff1e 	bx	lr

34818888 <__arch_lmb_reserve>:
void board_lmb_reserve(struct lmb *lmb) __attribute__((weak, alias("__board_lmb_reserve")));

void __arch_lmb_reserve(struct lmb *lmb)
{
	/* please define platform specific arch_lmb_reserve() */
}
34818888:	e12fff1e 	bx	lr

3481888c <string_to_ip>:
 */

#include <common.h>

IPaddr_t string_to_ip(const char *s)
{
3481888c:	e92d40f7 	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	IPaddr_t addr;
	char *e;
	int i;

	if (s == NULL)
34818890:	e2504000 	subs	r4, r0, #0
		return(0);
34818894:	01a00004 	moveq	r0, r4
{
	IPaddr_t addr;
	char *e;
	int i;

	if (s == NULL)
34818898:	0a000014 	beq	348188f0 <string_to_ip+0x64>
3481889c:	e3a06004 	mov	r6, #4
348188a0:	e3a05000 	mov	r5, #0
		return(0);

	for (addr=0, i=0; i<4; ++i) {
		ulong val = s ? simple_strtoul(s, &e, 10) : 0;
348188a4:	e08d7006 	add	r7, sp, r6
348188a8:	e3540000 	cmp	r4, #0
348188ac:	01a00004 	moveq	r0, r4
348188b0:	0a000003 	beq	348188c4 <string_to_ip+0x38>
348188b4:	e1a00004 	mov	r0, r4
348188b8:	e1a01007 	mov	r1, r7
348188bc:	e3a0200a 	mov	r2, #10
348188c0:	eb0004cc 	bl	34819bf8 <simple_strtoul>
		addr <<= 8;
		addr |= (val & 0xFF);
348188c4:	e20000ff 	and	r0, r0, #255	; 0xff
		if (s) {
348188c8:	e3540000 	cmp	r4, #0
		return(0);

	for (addr=0, i=0; i<4; ++i) {
		ulong val = s ? simple_strtoul(s, &e, 10) : 0;
		addr <<= 8;
		addr |= (val & 0xFF);
348188cc:	e1805405 	orr	r5, r0, r5, lsl #8
		if (s) {
348188d0:	0a000003 	beq	348188e4 <string_to_ip+0x58>
			s = (*e) ? e+1 : e;
348188d4:	e59d4004 	ldr	r4, [sp, #4]
348188d8:	e5d43000 	ldrb	r3, [r4]
348188dc:	e3530000 	cmp	r3, #0
348188e0:	12844001 	addne	r4, r4, #1
	int i;

	if (s == NULL)
		return(0);

	for (addr=0, i=0; i<4; ++i) {
348188e4:	e2566001 	subs	r6, r6, #1
348188e8:	1affffee 	bne	348188a8 <string_to_ip+0x1c>
348188ec:	e6bf0f35 	rev	r0, r5
			s = (*e) ? e+1 : e;
		}
	}

	return (htonl(addr));
}
348188f0:	e8bd80fe 	pop	{r1, r2, r3, r4, r5, r6, r7, pc}

348188f4 <qsort>:

void qsort(void  *base,
	   size_t nel,
	   size_t width,
	   int (*comp)(const void *, const void *))
{
348188f4:	e92d4eff 	push	{r0, r1, r2, r3, r4, r5, r6, r7, r9, sl, fp, lr}
	size_t wgap, i, j, k;
	char tmp;

	if ((nel > 1) && (width > 0)) {
348188f8:	e3520000 	cmp	r2, #0
348188fc:	13510001 	cmpne	r1, #1

void qsort(void  *base,
	   size_t nel,
	   size_t width,
	   int (*comp)(const void *, const void *))
{
34818900:	e58d0008 	str	r0, [sp, #8]
34818904:	e1a06001 	mov	r6, r1
34818908:	e58d300c 	str	r3, [sp, #12]
	size_t wgap, i, j, k;
	char tmp;

	if ((nel > 1) && (width > 0)) {
3481890c:	e1a04002 	mov	r4, r2
34818910:	9a000031 	bls	348189dc <qsort+0xe8>
		assert(nel <= ((size_t)(-1)) / width); /* check for overflow */
		wgap = 0;
		do {
			wgap = 3 * wgap + 1;
		} while (wgap < (nel-1)/3);
34818914:	e2410001 	sub	r0, r1, #1
34818918:	e3a01003 	mov	r1, #3
3481891c:	eb001d60 	bl	3481fea4 <__udivsi3>
34818920:	e3a05000 	mov	r5, #0

	if ((nel > 1) && (width > 0)) {
		assert(nel <= ((size_t)(-1)) / width); /* check for overflow */
		wgap = 0;
		do {
			wgap = 3 * wgap + 1;
34818924:	e0855085 	add	r5, r5, r5, lsl #1
34818928:	e2855001 	add	r5, r5, #1
		} while (wgap < (nel-1)/3);
3481892c:	e1550000 	cmp	r5, r0
34818930:	3afffffb 	bcc	34818924 <qsort+0x30>
		/* From the above, we know that either wgap == 1 < nel or */
		/* ((wgap-1)/3 < (int) ((nel-1)/3) <= (nel-1)/3 ==> wgap <  nel. */
		wgap *= width;			/* So this can not overflow if wnel doesn't. */
		nel *= width;			/* Convert nel to 'wnel' */
34818934:	e0060496 	mul	r6, r6, r4
		do {
			wgap = 3 * wgap + 1;
		} while (wgap < (nel-1)/3);
		/* From the above, we know that either wgap == 1 < nel or */
		/* ((wgap-1)/3 < (int) ((nel-1)/3) <= (nel-1)/3 ==> wgap <  nel. */
		wgap *= width;			/* So this can not overflow if wnel doesn't. */
34818938:	e0050594 	mul	r5, r4, r5
		nel *= width;			/* Convert nel to 'wnel' */
3481893c:	e58d6004 	str	r6, [sp, #4]

#include <linux/types.h>
#include <common.h>
#include <exports.h>

void qsort(void  *base,
34818940:	e2653000 	rsb	r3, r5, #0
			wgap = 3 * wgap + 1;
		} while (wgap < (nel-1)/3);
		/* From the above, we know that either wgap == 1 < nel or */
		/* ((wgap-1)/3 < (int) ((nel-1)/3) <= (nel-1)/3 ==> wgap <  nel. */
		wgap *= width;			/* So this can not overflow if wnel doesn't. */
		nel *= width;			/* Convert nel to 'wnel' */
34818944:	e0859004 	add	r9, r5, r4
	if ((nel > 1) && (width > 0)) {
		assert(nel <= ((size_t)(-1)) / width); /* check for overflow */
		wgap = 0;
		do {
			wgap = 3 * wgap + 1;
		} while (wgap < (nel-1)/3);
34818948:	e3a07000 	mov	r7, #0

#include <linux/types.h>
#include <common.h>
#include <exports.h>

void qsort(void  *base,
3481894c:	e1a0b003 	mov	fp, r3
34818950:	e59d2008 	ldr	r2, [sp, #8]
34818954:	e1a03007 	mov	r3, r7
34818958:	e0826007 	add	r6, r2, r7
3481895c:	e086a005 	add	sl, r6, r5
					register char *b;

					j -= wgap;
					a = j + ((char *)base);
					b = a + wgap;
					if ((*comp)(a, b) <= 0) {
34818960:	e58d3000 	str	r3, [sp]
34818964:	e1a00006 	mov	r0, r6
34818968:	e1a0100a 	mov	r1, sl
3481896c:	e59d200c 	ldr	r2, [sp, #12]
34818970:	e12fff32 	blx	r2
34818974:	e3500000 	cmp	r0, #0
34818978:	e59d3000 	ldr	r3, [sp]
3481897c:	da00000b 	ble	348189b0 <qsort+0xbc>
34818980:	e3a02000 	mov	r2, #0
						break;
					}
					k = width;
					do {
						tmp = *a;
34818984:	e7d61002 	ldrb	r1, [r6, r2]
						*a++ = *b;
34818988:	e7da0002 	ldrb	r0, [sl, r2]
3481898c:	e7c60002 	strb	r0, [r6, r2]
						*b++ = tmp;
34818990:	e7ca1002 	strb	r1, [sl, r2]
34818994:	e2822001 	add	r2, r2, #1
					} while (--k);
34818998:	e1540002 	cmp	r4, r2
3481899c:	1afffff8 	bne	34818984 <qsort+0x90>
348189a0:	e087700b 	add	r7, r7, fp
				} while (j >= wgap);
348189a4:	e1770005 	cmn	r7, r5
					k = width;
					do {
						tmp = *a;
						*a++ = *b;
						*b++ = tmp;
					} while (--k);
348189a8:	e086600b 	add	r6, r6, fp
				} while (j >= wgap);
348189ac:	3affffea 	bcc	3481895c <qsort+0x68>
348189b0:	e0899004 	add	r9, r9, r4
				i += width;
			} while (i < nel);
348189b4:	e59d2004 	ldr	r2, [sp, #4]
					do {
						tmp = *a;
						*a++ = *b;
						*b++ = tmp;
					} while (--k);
				} while (j >= wgap);
348189b8:	e0837004 	add	r7, r3, r4
				i += width;
			} while (i < nel);
348189bc:	e0643009 	rsb	r3, r4, r9
348189c0:	e1530002 	cmp	r3, r2
348189c4:	3affffe1 	bcc	34818950 <qsort+0x5c>
			wgap = (wgap - width)/3;
348189c8:	e0640005 	rsb	r0, r4, r5
348189cc:	e3a01003 	mov	r1, #3
348189d0:	eb001d33 	bl	3481fea4 <__udivsi3>
		} while (wgap);
348189d4:	e2505000 	subs	r5, r0, #0
348189d8:	1affffd8 	bne	34818940 <qsort+0x4c>
	}
}
348189dc:	e8bd8eff 	pop	{r0, r1, r2, r3, r4, r5, r6, r7, r9, sl, fp, pc}

348189e0 <strcmp_compar>:

int strcmp_compar(const void *p1, const void *p2)
{
	return strcmp(*(const char **)p1, *(const char **)p2);
348189e0:	e5900000 	ldr	r0, [r0]
348189e4:	e5911000 	ldr	r1, [r1]
348189e8:	ea000030 	b	34818ab0 <strcmp>

348189ec <strcpy>:
 */
char * strcpy(char * dest,const char *src)
{
	char *tmp = dest;

	while ((*dest++ = *src++) != '\0')
348189ec:	e3a03000 	mov	r3, #0
348189f0:	e7d12003 	ldrb	r2, [r1, r3]
348189f4:	e3520000 	cmp	r2, #0
348189f8:	e7c02003 	strb	r2, [r0, r3]
348189fc:	e2833001 	add	r3, r3, #1
34818a00:	1afffffa 	bne	348189f0 <strcpy+0x4>
		/* nothing */;
	return tmp;
}
34818a04:	e12fff1e 	bx	lr

34818a08 <strncpy>:
 */
char * strncpy(char * dest,const char *src,size_t count)
{
	char *tmp = dest;

	while (count-- && (*dest++ = *src++) != '\0')
34818a08:	e3a03000 	mov	r3, #0
34818a0c:	e3520000 	cmp	r2, #0
34818a10:	012fff1e 	bxeq	lr
34818a14:	e7d1c003 	ldrb	ip, [r1, r3]
34818a18:	e2422001 	sub	r2, r2, #1
34818a1c:	e35c0000 	cmp	ip, #0
34818a20:	e7c0c003 	strb	ip, [r0, r3]
34818a24:	e2833001 	add	r3, r3, #1
34818a28:	1afffff7 	bne	34818a0c <strncpy+0x4>
		/* nothing */;

	return tmp;
}
34818a2c:	e12fff1e 	bx	lr

34818a30 <strcat>:
 */
char * strcat(char * dest, const char * src)
{
	char *tmp = dest;

	while (*dest)
34818a30:	e1a0c000 	mov	ip, r0
34818a34:	e5dc3000 	ldrb	r3, [ip]
34818a38:	e1a0200c 	mov	r2, ip
34818a3c:	e3530000 	cmp	r3, #0
34818a40:	e28cc001 	add	ip, ip, #1
34818a44:	1afffffa 	bne	34818a34 <strcat+0x4>
		dest++;
	while ((*dest++ = *src++) != '\0')
34818a48:	e7d1c003 	ldrb	ip, [r1, r3]
34818a4c:	e35c0000 	cmp	ip, #0
34818a50:	e7c2c003 	strb	ip, [r2, r3]
34818a54:	e2833001 	add	r3, r3, #1
34818a58:	1afffffa 	bne	34818a48 <strcat+0x18>
		;

	return tmp;
}
34818a5c:	e12fff1e 	bx	lr

34818a60 <strncat>:
 */
char * strncat(char *dest, const char *src, size_t count)
{
	char *tmp = dest;

	if (count) {
34818a60:	e3520000 	cmp	r2, #0
 *
 * Note that in contrast to strncpy, strncat ensures the result is
 * terminated.
 */
char * strncat(char *dest, const char *src, size_t count)
{
34818a64:	e92d4010 	push	{r4, lr}
	char *tmp = dest;

	if (count) {
34818a68:	08bd8010 	popeq	{r4, pc}
34818a6c:	e1a04000 	mov	r4, r0
34818a70:	e1a0c004 	mov	ip, r4
		while (*dest)
34818a74:	e4d43001 	ldrb	r3, [r4], #1
34818a78:	e3530000 	cmp	r3, #0
34818a7c:	1afffffb 	bne	34818a70 <strncat+0x10>
34818a80:	ea000005 	b	34818a9c <strncat+0x3c>
34818a84:	e2833001 	add	r3, r3, #1
			dest++;
		while ((*dest++ = *src++)) {
			if (--count == 0) {
34818a88:	e1520003 	cmp	r2, r3
34818a8c:	1a000002 	bne	34818a9c <strncat+0x3c>
				*dest = '\0';
34818a90:	e3a03000 	mov	r3, #0
34818a94:	e5cc3000 	strb	r3, [ip]
				break;
34818a98:	e8bd8010 	pop	{r4, pc}
	char *tmp = dest;

	if (count) {
		while (*dest)
			dest++;
		while ((*dest++ = *src++)) {
34818a9c:	e7d14003 	ldrb	r4, [r1, r3]
34818aa0:	e3540000 	cmp	r4, #0
34818aa4:	e4cc4001 	strb	r4, [ip], #1
34818aa8:	1afffff5 	bne	34818a84 <strncat+0x24>
			}
		}
	}

	return tmp;
}
34818aac:	e8bd8010 	pop	{r4, pc}

34818ab0 <strcmp>:
 * strcmp - Compare two strings
 * @cs: One string
 * @ct: Another string
 */
int strcmp(const char * cs,const char * ct)
{
34818ab0:	e3a03000 	mov	r3, #0
	register signed char __res;

	while (1) {
		if ((__res = *cs - *ct++) != 0 || !*cs++)
34818ab4:	e7d0c003 	ldrb	ip, [r0, r3]
34818ab8:	e7d12003 	ldrb	r2, [r1, r3]
34818abc:	e062200c 	rsb	r2, r2, ip
34818ac0:	e6ef2072 	uxtb	r2, r2
34818ac4:	e3520000 	cmp	r2, #0
34818ac8:	1a000002 	bne	34818ad8 <strcmp+0x28>
34818acc:	e35c0000 	cmp	ip, #0
34818ad0:	e2833001 	add	r3, r3, #1
34818ad4:	1afffff6 	bne	34818ab4 <strcmp+0x4>
			break;
	}

	return __res;
}
34818ad8:	e6af0072 	sxtb	r0, r2
34818adc:	e12fff1e 	bx	lr

34818ae0 <strncmp>:
 * @cs: One string
 * @ct: Another string
 * @count: The maximum number of bytes to compare
 */
int strncmp(const char * cs,const char * ct,size_t count)
{
34818ae0:	e92d4010 	push	{r4, lr}
	register signed char __res = 0;

	while (count) {
34818ae4:	e3a03000 	mov	r3, #0
34818ae8:	ea000009 	b	34818b14 <strncmp+0x34>
		if ((__res = *cs - *ct++) != 0 || !*cs++)
34818aec:	e7d04003 	ldrb	r4, [r0, r3]
34818af0:	e7d1c003 	ldrb	ip, [r1, r3]
34818af4:	e06cc004 	rsb	ip, ip, r4
34818af8:	e6efc07c 	uxtb	ip, ip
34818afc:	e35c0000 	cmp	ip, #0
34818b00:	1a000006 	bne	34818b20 <strncmp+0x40>
34818b04:	e3540000 	cmp	r4, #0
34818b08:	e2833001 	add	r3, r3, #1
34818b0c:	0a000003 	beq	34818b20 <strncmp+0x40>
			break;
		count--;
34818b10:	e2422001 	sub	r2, r2, #1
 */
int strncmp(const char * cs,const char * ct,size_t count)
{
	register signed char __res = 0;

	while (count) {
34818b14:	e3520000 	cmp	r2, #0
34818b18:	1afffff3 	bne	34818aec <strncmp+0xc>
34818b1c:	e1a0c002 	mov	ip, r2
			break;
		count--;
	}

	return __res;
}
34818b20:	e6af007c 	sxtb	r0, ip
34818b24:	e8bd8010 	pop	{r4, pc}

34818b28 <strchr>:
 */
char * strchr(const char * s, int c)
{
	for(; *s != (char) c; ++s)
		if (*s == '\0')
			return NULL;
34818b28:	e1a03000 	mov	r3, r0
 * @s: The string to be searched
 * @c: The character to search for
 */
char * strchr(const char * s, int c)
{
	for(; *s != (char) c; ++s)
34818b2c:	e6ef1071 	uxtb	r1, r1
34818b30:	ea000001 	b	34818b3c <strchr+0x14>
		if (*s == '\0')
34818b34:	e3520000 	cmp	r2, #0
34818b38:	0a000005 	beq	34818b54 <strchr+0x2c>
 * @s: The string to be searched
 * @c: The character to search for
 */
char * strchr(const char * s, int c)
{
	for(; *s != (char) c; ++s)
34818b3c:	e5d32000 	ldrb	r2, [r3]
		if (*s == '\0')
34818b40:	e1a00003 	mov	r0, r3
 * @s: The string to be searched
 * @c: The character to search for
 */
char * strchr(const char * s, int c)
{
	for(; *s != (char) c; ++s)
34818b44:	e1520001 	cmp	r2, r1
34818b48:	e2833001 	add	r3, r3, #1
34818b4c:	1afffff8 	bne	34818b34 <strchr+0xc>
34818b50:	e12fff1e 	bx	lr
		if (*s == '\0')
			return NULL;
34818b54:	e1a00002 	mov	r0, r2
	return (char *) s;
}
34818b58:	e12fff1e 	bx	lr

34818b5c <skip_spaces>:
 *
 * Returns a pointer to the first non-whitespace character in @str.
 */
char *skip_spaces(const char *str)
{
	while (isspace(*str))
34818b5c:	e59f2018 	ldr	r2, [pc, #24]	; 34818b7c <skip_spaces+0x20>
 * @str: The string to be stripped.
 *
 * Returns a pointer to the first non-whitespace character in @str.
 */
char *skip_spaces(const char *str)
{
34818b60:	e1a03000 	mov	r3, r0
	while (isspace(*str))
34818b64:	e1a00003 	mov	r0, r3
34818b68:	e4d31001 	ldrb	r1, [r3], #1
34818b6c:	e7d21001 	ldrb	r1, [r2, r1]
34818b70:	e3110020 	tst	r1, #32
34818b74:	1afffffa 	bne	34818b64 <skip_spaces+0x8>
		++str;
	return (char *)str;
}
34818b78:	e12fff1e 	bx	lr
34818b7c:	34821fd4 	.word	0x34821fd4

34818b80 <strlen>:
/**
 * strlen - Find the length of a string
 * @s: The string to be sized
 */
size_t strlen(const char * s)
{
34818b80:	e1a03000 	mov	r3, r0
	const char *sc;

	for (sc = s; *sc != '\0'; ++sc)
34818b84:	e1a02003 	mov	r2, r3
34818b88:	e4d31001 	ldrb	r1, [r3], #1
34818b8c:	e3510000 	cmp	r1, #0
34818b90:	1afffffb 	bne	34818b84 <strlen+0x4>
		/* nothing */;
	return sc - s;
}
34818b94:	e0600002 	rsb	r0, r0, r2
34818b98:	e12fff1e 	bx	lr

34818b9c <strim>:
 * Note that the first trailing whitespace is replaced with a %NUL-terminator
 * in the given string @s. Returns a pointer to the first non-whitespace
 * character in @s.
 */
char *strim(char *s)
{
34818b9c:	e92d4010 	push	{r4, lr}
	size_t size;
	char *end;

	s = skip_spaces(s);
34818ba0:	ebffffed 	bl	34818b5c <skip_spaces>
34818ba4:	e1a04000 	mov	r4, r0
	size = strlen(s);
34818ba8:	ebfffff4 	bl	34818b80 <strlen>
	if (!size)
34818bac:	e2503000 	subs	r3, r0, #0
34818bb0:	0a00000b 	beq	34818be4 <strim+0x48>
		return s;

	end = s + size - 1;
34818bb4:	e2433001 	sub	r3, r3, #1
	while (end >= s && isspace(*end))
34818bb8:	e59f102c 	ldr	r1, [pc, #44]	; 34818bec <strim+0x50>
	s = skip_spaces(s);
	size = strlen(s);
	if (!size)
		return s;

	end = s + size - 1;
34818bbc:	e0843003 	add	r3, r4, r3
	while (end >= s && isspace(*end))
34818bc0:	e1530004 	cmp	r3, r4
34818bc4:	e1a02003 	mov	r2, r3
34818bc8:	3a000003 	bcc	34818bdc <strim+0x40>
34818bcc:	e4530001 	ldrb	r0, [r3], #-1
34818bd0:	e7d10000 	ldrb	r0, [r1, r0]
34818bd4:	e3100020 	tst	r0, #32
34818bd8:	1afffff8 	bne	34818bc0 <strim+0x24>
		end--;
	*(end + 1) = '\0';
34818bdc:	e3a03000 	mov	r3, #0
34818be0:	e5c23001 	strb	r3, [r2, #1]

	return s;
}
34818be4:	e1a00004 	mov	r0, r4
34818be8:	e8bd8010 	pop	{r4, pc}
34818bec:	34821fd4 	.word	0x34821fd4

34818bf0 <strrchr>:
 * strrchr - Find the last occurrence of a character in a string
 * @s: The string to be searched
 * @c: The character to search for
 */
char * strrchr(const char * s, int c)
{
34818bf0:	e92d4038 	push	{r3, r4, r5, lr}
34818bf4:	e1a04000 	mov	r4, r0
34818bf8:	e1a05001 	mov	r5, r1
       const char *p = s + strlen(s);
34818bfc:	ebffffdf 	bl	34818b80 <strlen>
       do {
	   if (*p == (char)c)
34818c00:	e6ef5075 	uxtb	r5, r5
 * @s: The string to be searched
 * @c: The character to search for
 */
char * strrchr(const char * s, int c)
{
       const char *p = s + strlen(s);
34818c04:	e0843000 	add	r3, r4, r0
       do {
	   if (*p == (char)c)
34818c08:	e5d32000 	ldrb	r2, [r3]
 * @s: The string to be searched
 * @c: The character to search for
 */
char * strrchr(const char * s, int c)
{
       const char *p = s + strlen(s);
34818c0c:	e1a00003 	mov	r0, r3
       do {
	   if (*p == (char)c)
34818c10:	e1520005 	cmp	r2, r5
34818c14:	e2433001 	sub	r3, r3, #1
34818c18:	08bd8038 	popeq	{r3, r4, r5, pc}
	       return (char *)p;
       } while (--p >= s);
34818c1c:	e1540003 	cmp	r4, r3
34818c20:	9afffff8 	bls	34818c08 <strrchr+0x18>
       return NULL;
34818c24:	e3a00000 	mov	r0, #0
}
34818c28:	e8bd8038 	pop	{r3, r4, r5, pc}

34818c2c <strnlen>:
 * strnlen - Find the length of a length-limited string
 * @s: The string to be sized
 * @count: The maximum number of bytes to search
 */
size_t strnlen(const char * s, size_t count)
{
34818c2c:	e1a03000 	mov	r3, r0
	const char *sc;

	for (sc = s; count-- && *sc != '\0'; ++sc)
34818c30:	e3510000 	cmp	r1, #0
34818c34:	e1a02003 	mov	r2, r3
34818c38:	0a000003 	beq	34818c4c <strnlen+0x20>
34818c3c:	e4d3c001 	ldrb	ip, [r3], #1
34818c40:	e2411001 	sub	r1, r1, #1
34818c44:	e35c0000 	cmp	ip, #0
34818c48:	1afffff8 	bne	34818c30 <strnlen+0x4>
		/* nothing */;
	return sc - s;
}
34818c4c:	e0600002 	rsb	r0, r0, r2
34818c50:	e12fff1e 	bx	lr

34818c54 <strdup>:
#endif

#ifndef __HAVE_ARCH_STRDUP
char * strdup(const char *s)
{
34818c54:	e92d4038 	push	{r3, r4, r5, lr}
	char *new;

	if ((s == NULL)	||
34818c58:	e2505000 	subs	r5, r0, #0
	    ((new = malloc (strlen(s) + 1)) == NULL) ) {
		return NULL;
34818c5c:	01a04005 	moveq	r4, r5
#ifndef __HAVE_ARCH_STRDUP
char * strdup(const char *s)
{
	char *new;

	if ((s == NULL)	||
34818c60:	0a000006 	beq	34818c80 <strdup+0x2c>
	    ((new = malloc (strlen(s) + 1)) == NULL) ) {
34818c64:	ebffffc5 	bl	34818b80 <strlen>
34818c68:	e2800001 	add	r0, r0, #1
34818c6c:	ebffc27d 	bl	34809668 <malloc>
#ifndef __HAVE_ARCH_STRDUP
char * strdup(const char *s)
{
	char *new;

	if ((s == NULL)	||
34818c70:	e2504000 	subs	r4, r0, #0
34818c74:	0a000001 	beq	34818c80 <strdup+0x2c>
	    ((new = malloc (strlen(s) + 1)) == NULL) ) {
		return NULL;
	}

	strcpy (new, s);
34818c78:	e1a01005 	mov	r1, r5
34818c7c:	ebffff5a 	bl	348189ec <strcpy>
	return new;
}
34818c80:	e1a00004 	mov	r0, r4
34818c84:	e8bd8038 	pop	{r3, r4, r5, pc}

34818c88 <strspn>:
 *	contain letters in @accept
 * @s: The string to be searched
 * @accept: The string to search for
 */
size_t strspn(const char *s, const char *accept)
{
34818c88:	e1a03000 	mov	r3, r0
34818c8c:	e92d4010 	push	{r4, lr}
	const char *p;
	const char *a;
	size_t count = 0;
34818c90:	e3a00000 	mov	r0, #0

	for (p = s; *p != '\0'; ++p) {
34818c94:	ea000006 	b	34818cb4 <strspn+0x2c>
		for (a = accept; *a != '\0'; ++a) {
			if (*p == *a)
34818c98:	e15c0004 	cmp	ip, r4
				break;
		}
		if (*a == '\0')
			return count;
		++count;
34818c9c:	02800001 	addeq	r0, r0, #1
34818ca0:	0a000003 	beq	34818cb4 <strspn+0x2c>
	const char *p;
	const char *a;
	size_t count = 0;

	for (p = s; *p != '\0'; ++p) {
		for (a = accept; *a != '\0'; ++a) {
34818ca4:	e4d24001 	ldrb	r4, [r2], #1
34818ca8:	e3540000 	cmp	r4, #0
34818cac:	1afffff9 	bne	34818c98 <strspn+0x10>
34818cb0:	e8bd8010 	pop	{r4, pc}
{
	const char *p;
	const char *a;
	size_t count = 0;

	for (p = s; *p != '\0'; ++p) {
34818cb4:	e7d3c000 	ldrb	ip, [r3, r0]
34818cb8:	e35c0000 	cmp	ip, #0
34818cbc:	08bd8010 	popeq	{r4, pc}
34818cc0:	e1a02001 	mov	r2, r1
34818cc4:	eafffff6 	b	34818ca4 <strspn+0x1c>

34818cc8 <strpbrk>:
 * strpbrk - Find the first occurrence of a set of characters
 * @cs: The string to be searched
 * @ct: The characters to search for
 */
char * strpbrk(const char * cs,const char * ct)
{
34818cc8:	e92d4010 	push	{r4, lr}
		for( sc2 = ct; *sc2 != '\0'; ++sc2) {
			if (*sc1 == *sc2)
				return (char *) sc1;
		}
	}
	return NULL;
34818ccc:	e1a02000 	mov	r2, r0
 */
char * strpbrk(const char * cs,const char * ct)
{
	const char *sc1,*sc2;

	for( sc1 = cs; *sc1 != '\0'; ++sc1) {
34818cd0:	ea000004 	b	34818ce8 <strpbrk+0x20>
		for( sc2 = ct; *sc2 != '\0'; ++sc2) {
			if (*sc1 == *sc2)
34818cd4:	e1530004 	cmp	r3, r4
34818cd8:	08bd8010 	popeq	{r4, pc}
char * strpbrk(const char * cs,const char * ct)
{
	const char *sc1,*sc2;

	for( sc1 = cs; *sc1 != '\0'; ++sc1) {
		for( sc2 = ct; *sc2 != '\0'; ++sc2) {
34818cdc:	e4dc4001 	ldrb	r4, [ip], #1
34818ce0:	e3540000 	cmp	r4, #0
34818ce4:	1afffffa 	bne	34818cd4 <strpbrk+0xc>
34818ce8:	e1a00002 	mov	r0, r2
 */
char * strpbrk(const char * cs,const char * ct)
{
	const char *sc1,*sc2;

	for( sc1 = cs; *sc1 != '\0'; ++sc1) {
34818cec:	e4d23001 	ldrb	r3, [r2], #1
34818cf0:	e3530000 	cmp	r3, #0
34818cf4:	11a0c001 	movne	ip, r1
34818cf8:	1afffff7 	bne	34818cdc <strpbrk+0x14>
		for( sc2 = ct; *sc2 != '\0'; ++sc2) {
			if (*sc1 == *sc2)
				return (char *) sc1;
		}
	}
	return NULL;
34818cfc:	e1a00003 	mov	r0, r3
}
34818d00:	e8bd8010 	pop	{r4, pc}

34818d04 <strtok>:
 * @ct: The characters to search for
 *
 * WARNING: strtok is deprecated, use strsep instead.
 */
char * strtok(char * s,const char * ct)
{
34818d04:	e92d4038 	push	{r3, r4, r5, lr}
	char *sbegin, *send;

	sbegin  = s ? s : ___strtok;
34818d08:	e2504000 	subs	r4, r0, #0
 * @ct: The characters to search for
 *
 * WARNING: strtok is deprecated, use strsep instead.
 */
char * strtok(char * s,const char * ct)
{
34818d0c:	e1a05001 	mov	r5, r1
	char *sbegin, *send;

	sbegin  = s ? s : ___strtok;
34818d10:	1a000003 	bne	34818d24 <strtok+0x20>
34818d14:	e59f3060 	ldr	r3, [pc, #96]	; 34818d7c <strtok+0x78>
34818d18:	e5934000 	ldr	r4, [r3]
	if (!sbegin) {
34818d1c:	e3540000 	cmp	r4, #0
34818d20:	0a000013 	beq	34818d74 <strtok+0x70>
		return NULL;
	}
	sbegin += strspn(sbegin,ct);
34818d24:	e1a00004 	mov	r0, r4
34818d28:	e1a01005 	mov	r1, r5
34818d2c:	ebffffd5 	bl	34818c88 <strspn>
	if (*sbegin == '\0') {
34818d30:	e7f43000 	ldrb	r3, [r4, r0]!
34818d34:	e3530000 	cmp	r3, #0
		___strtok = NULL;
34818d38:	059f203c 	ldreq	r2, [pc, #60]	; 34818d7c <strtok+0x78>
		return( NULL );
34818d3c:	01a04003 	moveq	r4, r3
	if (!sbegin) {
		return NULL;
	}
	sbegin += strspn(sbegin,ct);
	if (*sbegin == '\0') {
		___strtok = NULL;
34818d40:	05823000 	streq	r3, [r2]
		return( NULL );
34818d44:	0a00000a 	beq	34818d74 <strtok+0x70>
	}
	send = strpbrk( sbegin, ct);
34818d48:	e1a00004 	mov	r0, r4
34818d4c:	e1a01005 	mov	r1, r5
34818d50:	ebffffdc 	bl	34818cc8 <strpbrk>
	if (send && *send != '\0')
34818d54:	e3500000 	cmp	r0, #0
34818d58:	0a000003 	beq	34818d6c <strtok+0x68>
34818d5c:	e5d03000 	ldrb	r3, [r0]
34818d60:	e3530000 	cmp	r3, #0
		*send++ = '\0';
34818d64:	13a03000 	movne	r3, #0
34818d68:	14c03001 	strbne	r3, [r0], #1
	___strtok = send;
34818d6c:	e59f3008 	ldr	r3, [pc, #8]	; 34818d7c <strtok+0x78>
34818d70:	e5830000 	str	r0, [r3]
	return (sbegin);
}
34818d74:	e1a00004 	mov	r0, r4
34818d78:	e8bd8038 	pop	{r3, r4, r5, pc}
34818d7c:	3482b33c 	.word	0x3482b33c

34818d80 <strsep>:
 * It returns empty tokens, too, behaving exactly like the libc function
 * of that name. In fact, it was stolen from glibc2 and de-fancy-fied.
 * Same semantics, slimmer shape. ;)
 */
char * strsep(char **s, const char *ct)
{
34818d80:	e92d4038 	push	{r3, r4, r5, lr}
	char *sbegin = *s, *end;
34818d84:	e5904000 	ldr	r4, [r0]
 * It returns empty tokens, too, behaving exactly like the libc function
 * of that name. In fact, it was stolen from glibc2 and de-fancy-fied.
 * Same semantics, slimmer shape. ;)
 */
char * strsep(char **s, const char *ct)
{
34818d88:	e1a05000 	mov	r5, r0
	char *sbegin = *s, *end;

	if (sbegin == NULL)
34818d8c:	e3540000 	cmp	r4, #0
34818d90:	0a000005 	beq	34818dac <strsep+0x2c>
		return NULL;

	end = strpbrk(sbegin, ct);
34818d94:	e1a00004 	mov	r0, r4
34818d98:	ebffffca 	bl	34818cc8 <strpbrk>
	if (end)
34818d9c:	e3500000 	cmp	r0, #0
		*end++ = '\0';
34818da0:	13a03000 	movne	r3, #0
34818da4:	14c03001 	strbne	r3, [r0], #1
	*s = end;
34818da8:	e5850000 	str	r0, [r5]

	return sbegin;
}
34818dac:	e1a00004 	mov	r0, r4
34818db0:	e8bd8038 	pop	{r3, r4, r5, pc}

34818db4 <strswab>:
 */
char *strswab(const char *s)
{
	char *p, *q;

	if ((NULL == s) || ('\0' == *s)) {
34818db4:	e3500000 	cmp	r0, #0
34818db8:	012fff1e 	bxeq	lr
34818dbc:	e5d03000 	ldrb	r3, [r0]
34818dc0:	e3530000 	cmp	r3, #0
34818dc4:	11a03000 	movne	r3, r0
34818dc8:	1a000002 	bne	34818dd8 <strswab+0x24>
34818dcc:	ea000009 	b	34818df8 <strswab+0x44>

	for (p=(char *)s, q=p+1; (*p != '\0') && (*q != '\0'); p+=2, q+=2) {
		char  tmp;

		tmp = *p;
		*p  = *q;
34818dd0:	e5432002 	strb	r2, [r3, #-2]
		*q  = tmp;
34818dd4:	e5431001 	strb	r1, [r3, #-1]

	if ((NULL == s) || ('\0' == *s)) {
		return (NULL);
	}

	for (p=(char *)s, q=p+1; (*p != '\0') && (*q != '\0'); p+=2, q+=2) {
34818dd8:	e5d31000 	ldrb	r1, [r3]
34818ddc:	e3510000 	cmp	r1, #0
34818de0:	012fff1e 	bxeq	lr
34818de4:	e5d32001 	ldrb	r2, [r3, #1]
34818de8:	e2833002 	add	r3, r3, #2
34818dec:	e3520000 	cmp	r2, #0
34818df0:	1afffff6 	bne	34818dd0 <strswab+0x1c>
34818df4:	e12fff1e 	bx	lr
char *strswab(const char *s)
{
	char *p, *q;

	if ((NULL == s) || ('\0' == *s)) {
		return (NULL);
34818df8:	e1a00003 	mov	r0, r3
		*p  = *q;
		*q  = tmp;
	}

	return (char *) s;
}
34818dfc:	e12fff1e 	bx	lr

34818e00 <memset>:
	unsigned long cl = 0;
	char *s8;
	int i;

	/* do it one word at a time (32 bits or 64 bits) while possible */
	if ( ((ulong)s & (sizeof(*sl) - 1)) == 0) {
34818e00:	e210c003 	ands	ip, r0, #3
 * @count: The size of the area.
 *
 * Do not use memset() to access IO space, use memset_io() instead.
 */
void * memset(void * s,int c,size_t count)
{
34818e04:	e92d4010 	push	{r4, lr}
	unsigned long *sl = (unsigned long *) s;
34818e08:	e1a03000 	mov	r3, r0
	unsigned long cl = 0;
	char *s8;
	int i;

	/* do it one word at a time (32 bits or 64 bits) while possible */
	if ( ((ulong)s & (sizeof(*sl) - 1)) == 0) {
34818e0c:	1a000012 	bne	34818e5c <memset+0x5c>
34818e10:	e1a0300c 	mov	r3, ip
		for (i = 0; i < sizeof(*sl); i++) {
			cl <<= 8;
			cl |= c & 0xff;
34818e14:	e20140ff 	and	r4, r1, #255	; 0xff
	char *s8;
	int i;

	/* do it one word at a time (32 bits or 64 bits) while possible */
	if ( ((ulong)s & (sizeof(*sl) - 1)) == 0) {
		for (i = 0; i < sizeof(*sl); i++) {
34818e18:	e2833001 	add	r3, r3, #1
34818e1c:	e3530004 	cmp	r3, #4
			cl <<= 8;
			cl |= c & 0xff;
34818e20:	e184c40c 	orr	ip, r4, ip, lsl #8
	char *s8;
	int i;

	/* do it one word at a time (32 bits or 64 bits) while possible */
	if ( ((ulong)s & (sizeof(*sl) - 1)) == 0) {
		for (i = 0; i < sizeof(*sl); i++) {
34818e24:	1afffffb 	bne	34818e18 <memset+0x18>
34818e28:	e1a04000 	mov	r4, r0
34818e2c:	e1a03002 	mov	r3, r2
34818e30:	ea000001 	b	34818e3c <memset+0x3c>
			cl <<= 8;
			cl |= c & 0xff;
		}
		while (count >= sizeof(*sl)) {
			*sl++ = cl;
34818e34:	e484c004 	str	ip, [r4], #4
			count -= sizeof(*sl);
34818e38:	e2433004 	sub	r3, r3, #4
	if ( ((ulong)s & (sizeof(*sl) - 1)) == 0) {
		for (i = 0; i < sizeof(*sl); i++) {
			cl <<= 8;
			cl |= c & 0xff;
		}
		while (count >= sizeof(*sl)) {
34818e3c:	e3530003 	cmp	r3, #3
34818e40:	8afffffb 	bhi	34818e34 <memset+0x34>
 * @c: The byte to fill the area with
 * @count: The size of the area.
 *
 * Do not use memset() to access IO space, use memset_io() instead.
 */
void * memset(void * s,int c,size_t count)
34818e44:	e3c23003 	bic	r3, r2, #3
	if ( ((ulong)s & (sizeof(*sl) - 1)) == 0) {
		for (i = 0; i < sizeof(*sl); i++) {
			cl <<= 8;
			cl |= c & 0xff;
		}
		while (count >= sizeof(*sl)) {
34818e48:	e0803003 	add	r3, r0, r3
 * @c: The byte to fill the area with
 * @count: The size of the area.
 *
 * Do not use memset() to access IO space, use memset_io() instead.
 */
void * memset(void * s,int c,size_t count)
34818e4c:	e2022003 	and	r2, r2, #3
			count -= sizeof(*sl);
		}
	}
	/* fill 8 bits at a time */
	s8 = (char *)sl;
	while (count--)
34818e50:	ea000001 	b	34818e5c <memset+0x5c>
		*s8++ = c;
34818e54:	e4c31001 	strb	r1, [r3], #1
34818e58:	e2422001 	sub	r2, r2, #1
			count -= sizeof(*sl);
		}
	}
	/* fill 8 bits at a time */
	s8 = (char *)sl;
	while (count--)
34818e5c:	e3520000 	cmp	r2, #0
34818e60:	1afffffb 	bne	34818e54 <memset+0x54>
		*s8++ = c;

	return s;
}
34818e64:	e8bd8010 	pop	{r4, pc}

34818e68 <bcopy>:
 *
 * You should not use this function to access IO space, use memcpy_toio()
 * or memcpy_fromio() instead.
 */
char * bcopy(const char * src, char * dest, int count)
{
34818e68:	e1a03000 	mov	r3, r0
	char *tmp = dest;

	while (count--)
34818e6c:	e3a00000 	mov	r0, #0
34818e70:	ea000002 	b	34818e80 <bcopy+0x18>
		*tmp++ = *src++;
34818e74:	e7d3c000 	ldrb	ip, [r3, r0]
34818e78:	e7c1c000 	strb	ip, [r1, r0]
34818e7c:	e2800001 	add	r0, r0, #1
 */
char * bcopy(const char * src, char * dest, int count)
{
	char *tmp = dest;

	while (count--)
34818e80:	e2522001 	subs	r2, r2, #1
34818e84:	2afffffa 	bcs	34818e74 <bcopy+0xc>
		*tmp++ = *src++;

	return dest;
}
34818e88:	e1a00001 	mov	r0, r1
34818e8c:	e12fff1e 	bx	lr

34818e90 <memcpy>:
void * memcpy(void *dest, const void *src, size_t count)
{
	unsigned long *dl = (unsigned long *)dest, *sl = (unsigned long *)src;
	char *d8, *s8;

	if (src == dest)
34818e90:	e1510000 	cmp	r1, r0
 *
 * You should not use this function to access IO space, use memcpy_toio()
 * or memcpy_fromio() instead.
 */
void * memcpy(void *dest, const void *src, size_t count)
{
34818e94:	e92d4010 	push	{r4, lr}
	unsigned long *dl = (unsigned long *)dest, *sl = (unsigned long *)src;
	char *d8, *s8;

	if (src == dest)
34818e98:	08bd8010 	popeq	{r4, pc}
		return dest;

	/* while all data is aligned (common case), copy a word at a time */
	if ( (((ulong)dest | (ulong)src) & (sizeof(*dl) - 1)) == 0) {
34818e9c:	e1813000 	orr	r3, r1, r0
34818ea0:	e2133003 	ands	r3, r3, #3
 * You should not use this function to access IO space, use memcpy_toio()
 * or memcpy_fromio() instead.
 */
void * memcpy(void *dest, const void *src, size_t count)
{
	unsigned long *dl = (unsigned long *)dest, *sl = (unsigned long *)src;
34818ea4:	e1a0c000 	mov	ip, r0
34818ea8:	e1a04001 	mov	r4, r1

	if (src == dest)
		return dest;

	/* while all data is aligned (common case), copy a word at a time */
	if ( (((ulong)dest | (ulong)src) & (sizeof(*dl) - 1)) == 0) {
34818eac:	01a0c002 	moveq	ip, r2
34818eb0:	0a000004 	beq	34818ec8 <memcpy+0x38>
34818eb4:	ea000009 	b	34818ee0 <memcpy+0x50>
		while (count >= sizeof(*dl)) {
			*dl++ = *sl++;
34818eb8:	e7914003 	ldr	r4, [r1, r3]
			count -= sizeof(*dl);
34818ebc:	e24cc004 	sub	ip, ip, #4
		return dest;

	/* while all data is aligned (common case), copy a word at a time */
	if ( (((ulong)dest | (ulong)src) & (sizeof(*dl) - 1)) == 0) {
		while (count >= sizeof(*dl)) {
			*dl++ = *sl++;
34818ec0:	e7804003 	str	r4, [r0, r3]
			count -= sizeof(*dl);
34818ec4:	e2833004 	add	r3, r3, #4
	if (src == dest)
		return dest;

	/* while all data is aligned (common case), copy a word at a time */
	if ( (((ulong)dest | (ulong)src) & (sizeof(*dl) - 1)) == 0) {
		while (count >= sizeof(*dl)) {
34818ec8:	e35c0003 	cmp	ip, #3
34818ecc:	8afffff9 	bhi	34818eb8 <memcpy+0x28>
 * @count: The size of the area.
 *
 * You should not use this function to access IO space, use memcpy_toio()
 * or memcpy_fromio() instead.
 */
void * memcpy(void *dest, const void *src, size_t count)
34818ed0:	e3c24003 	bic	r4, r2, #3
34818ed4:	e080c004 	add	ip, r0, r4
34818ed8:	e2022003 	and	r2, r2, #3
34818edc:	e0814004 	add	r4, r1, r4
		}
	}
	/* copy the reset one byte at a time */
	d8 = (char *)dl;
	s8 = (char *)sl;
	while (count--)
34818ee0:	e3a03000 	mov	r3, #0
34818ee4:	ea000003 	b	34818ef8 <memcpy+0x68>
		*d8++ = *s8++;
34818ee8:	e7d41003 	ldrb	r1, [r4, r3]
34818eec:	e2422001 	sub	r2, r2, #1
34818ef0:	e7cc1003 	strb	r1, [ip, r3]
34818ef4:	e2833001 	add	r3, r3, #1
		}
	}
	/* copy the reset one byte at a time */
	d8 = (char *)dl;
	s8 = (char *)sl;
	while (count--)
34818ef8:	e3520000 	cmp	r2, #0
34818efc:	1afffff9 	bne	34818ee8 <memcpy+0x58>
		*d8++ = *s8++;

	return dest;
}
34818f00:	e8bd8010 	pop	{r4, pc}

34818f04 <memmove>:
 */
void * memmove(void * dest,const void *src,size_t count)
{
	char *tmp, *s;

	if (src == dest)
34818f04:	e1510000 	cmp	r1, r0
34818f08:	012fff1e 	bxeq	lr
		return dest;

	if (dest <= src) {
34818f0c:	e1500001 	cmp	r0, r1
34818f10:	93a03000 	movls	r3, #0
34818f14:	9a000004 	bls	34818f2c <memmove+0x28>
34818f18:	ea000006 	b	34818f38 <memmove+0x34>
		tmp = (char *) dest;
		s = (char *) src;
		while (count--)
			*tmp++ = *s++;
34818f1c:	e7d1c003 	ldrb	ip, [r1, r3]
34818f20:	e2422001 	sub	r2, r2, #1
34818f24:	e7c0c003 	strb	ip, [r0, r3]
34818f28:	e2833001 	add	r3, r3, #1
		return dest;

	if (dest <= src) {
		tmp = (char *) dest;
		s = (char *) src;
		while (count--)
34818f2c:	e3520000 	cmp	r2, #0
34818f30:	1afffff9 	bne	34818f1c <memmove+0x18>
34818f34:	e12fff1e 	bx	lr
			*tmp++ = *s++;
		}
	else {
		tmp = (char *) dest + count;
		s = (char *) src + count;
34818f38:	e0811002 	add	r1, r1, r2
		s = (char *) src;
		while (count--)
			*tmp++ = *s++;
		}
	else {
		tmp = (char *) dest + count;
34818f3c:	e0803002 	add	r3, r0, r2
		s = (char *) src + count;
		while (count--)
34818f40:	ea000002 	b	34818f50 <memmove+0x4c>
			*--tmp = *--s;
34818f44:	e571c001 	ldrb	ip, [r1, #-1]!
34818f48:	e2422001 	sub	r2, r2, #1
34818f4c:	e563c001 	strb	ip, [r3, #-1]!
			*tmp++ = *s++;
		}
	else {
		tmp = (char *) dest + count;
		s = (char *) src + count;
		while (count--)
34818f50:	e3520000 	cmp	r2, #0
34818f54:	1afffffa 	bne	34818f44 <memmove+0x40>
			*--tmp = *--s;
		}

	return dest;
}
34818f58:	e12fff1e 	bx	lr

34818f5c <memcmp>:
 * @cs: One area of memory
 * @ct: Another area of memory
 * @count: The size of the area.
 */
int memcmp(const void * cs,const void * ct,size_t count)
{
34818f5c:	e92d4010 	push	{r4, lr}
34818f60:	e1a03000 	mov	r3, r0
	const unsigned char *su1, *su2;
	int res = 0;

	for( su1 = cs, su2 = ct; 0 < count; ++su1, ++su2, count--)
34818f64:	e3a0c000 	mov	ip, #0
34818f68:	ea000005 	b	34818f84 <memcmp+0x28>
		if ((res = *su1 - *su2) != 0)
34818f6c:	e7d3400c 	ldrb	r4, [r3, ip]
34818f70:	e7d1000c 	ldrb	r0, [r1, ip]
34818f74:	e28cc001 	add	ip, ip, #1
34818f78:	e0540000 	subs	r0, r4, r0
34818f7c:	18bd8010 	popne	{r4, pc}
int memcmp(const void * cs,const void * ct,size_t count)
{
	const unsigned char *su1, *su2;
	int res = 0;

	for( su1 = cs, su2 = ct; 0 < count; ++su1, ++su2, count--)
34818f80:	e2422001 	sub	r2, r2, #1
34818f84:	e3520000 	cmp	r2, #0
34818f88:	1afffff7 	bne	34818f6c <memcmp+0x10>
34818f8c:	e1a00002 	mov	r0, r2
		if ((res = *su1 - *su2) != 0)
			break;
	return res;
}
34818f90:	e8bd8010 	pop	{r4, pc}

34818f94 <memscan>:
 *
 * returns the address of the first occurrence of @c, or 1 byte past
 * the area if @c is not found
 */
void * memscan(void * addr, int c, size_t size)
{
34818f94:	e1a03000 	mov	r3, r0
	unsigned char * p = (unsigned char *) addr;

	while (size) {
34818f98:	ea000003 	b	34818fac <memscan+0x18>
		if (*p == c)
34818f9c:	e4d3c001 	ldrb	ip, [r3], #1
34818fa0:	e15c0001 	cmp	ip, r1
34818fa4:	012fff1e 	bxeq	lr
			return (void *) p;
		p++;
		size--;
34818fa8:	e2422001 	sub	r2, r2, #1
 */
void * memscan(void * addr, int c, size_t size)
{
	unsigned char * p = (unsigned char *) addr;

	while (size) {
34818fac:	e3520000 	cmp	r2, #0
		if (*p == c)
			return (void *) p;
		p++;
		size--;
34818fb0:	e1a00003 	mov	r0, r3
 */
void * memscan(void * addr, int c, size_t size)
{
	unsigned char * p = (unsigned char *) addr;

	while (size) {
34818fb4:	1afffff8 	bne	34818f9c <memscan+0x8>
			return (void *) p;
		p++;
		size--;
	}
	return (void *) p;
}
34818fb8:	e12fff1e 	bx	lr

34818fbc <strstr>:
 * strstr - Find the first substring in a %NUL terminated string
 * @s1: The string to be searched
 * @s2: The string to search for
 */
char * strstr(const char * s1,const char * s2)
{
34818fbc:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
34818fc0:	e1a04000 	mov	r4, r0
	int l1, l2;

	l2 = strlen(s2);
34818fc4:	e1a00001 	mov	r0, r1
 * strstr - Find the first substring in a %NUL terminated string
 * @s1: The string to be searched
 * @s2: The string to search for
 */
char * strstr(const char * s1,const char * s2)
{
34818fc8:	e1a07001 	mov	r7, r1
	int l1, l2;

	l2 = strlen(s2);
34818fcc:	ebfffeeb 	bl	34818b80 <strlen>
	if (!l2)
34818fd0:	e2506000 	subs	r6, r0, #0
34818fd4:	0a00000e 	beq	34819014 <strstr+0x58>
		return (char *) s1;
	l1 = strlen(s1);
34818fd8:	e1a00004 	mov	r0, r4
34818fdc:	ebfffee7 	bl	34818b80 <strlen>
34818fe0:	e1a05000 	mov	r5, r0
	while (l1 >= l2) {
34818fe4:	ea000007 	b	34819008 <strstr+0x4c>
		l1--;
		if (!memcmp(s1,s2,l2))
34818fe8:	e1a00004 	mov	r0, r4
34818fec:	e1a01007 	mov	r1, r7
34818ff0:	e1a02006 	mov	r2, r6
34818ff4:	ebffffd8 	bl	34818f5c <memcmp>
34818ff8:	e3500000 	cmp	r0, #0
34818ffc:	0a000004 	beq	34819014 <strstr+0x58>
	l2 = strlen(s2);
	if (!l2)
		return (char *) s1;
	l1 = strlen(s1);
	while (l1 >= l2) {
		l1--;
34819000:	e2455001 	sub	r5, r5, #1
		if (!memcmp(s1,s2,l2))
			return (char *) s1;
		s1++;
34819004:	e2844001 	add	r4, r4, #1

	l2 = strlen(s2);
	if (!l2)
		return (char *) s1;
	l1 = strlen(s1);
	while (l1 >= l2) {
34819008:	e1550006 	cmp	r5, r6
3481900c:	aafffff5 	bge	34818fe8 <strstr+0x2c>
		l1--;
		if (!memcmp(s1,s2,l2))
			return (char *) s1;
		s1++;
	}
	return NULL;
34819010:	e3a04000 	mov	r4, #0
}
34819014:	e1a00004 	mov	r0, r4
34819018:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}

3481901c <memchr>:
 */
void *memchr(const void *s, int c, size_t n)
{
	const unsigned char *p = s;
	while (n-- != 0) {
		if ((unsigned char)c == *p++) {
3481901c:	e6ef1071 	uxtb	r1, r1
 * if @c is not found
 */
void *memchr(const void *s, int c, size_t n)
{
	const unsigned char *p = s;
	while (n-- != 0) {
34819020:	ea000003 	b	34819034 <memchr+0x18>
		if ((unsigned char)c == *p++) {
34819024:	e4d0c001 	ldrb	ip, [r0], #1
34819028:	e2422001 	sub	r2, r2, #1
3481902c:	e151000c 	cmp	r1, ip
34819030:	0a000004 	beq	34819048 <memchr+0x2c>
 * if @c is not found
 */
void *memchr(const void *s, int c, size_t n)
{
	const unsigned char *p = s;
	while (n-- != 0) {
34819034:	e3520000 	cmp	r2, #0
		if ((unsigned char)c == *p++) {
34819038:	e1a03000 	mov	r3, r0
 * if @c is not found
 */
void *memchr(const void *s, int c, size_t n)
{
	const unsigned char *p = s;
	while (n-- != 0) {
3481903c:	1afffff8 	bne	34819024 <memchr+0x8>
		if ((unsigned char)c == *p++) {
			return (void *)(p-1);
		}
	}
	return NULL;
34819040:	e1a00002 	mov	r0, r2
34819044:	e12fff1e 	bx	lr
void *memchr(const void *s, int c, size_t n)
{
	const unsigned char *p = s;
	while (n-- != 0) {
		if ((unsigned char)c == *p++) {
			return (void *)(p-1);
34819048:	e1a00003 	mov	r0, r3
		}
	}
	return NULL;
}
3481904c:	e12fff1e 	bx	lr

34819050 <strmhz>:
 * MA 02111-1307 USA
 */
#include <common.h>

char *strmhz (char *buf, unsigned long hz)
{
34819050:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
	long l, n;
	long m;

	n = DIV_ROUND(hz, 1000) / 1000L;
34819054:	e2815f7d 	add	r5, r1, #500	; 0x1f4
 * MA 02111-1307 USA
 */
#include <common.h>

char *strmhz (char *buf, unsigned long hz)
{
34819058:	e1a04000 	mov	r4, r0
	long l, n;
	long m;

	n = DIV_ROUND(hz, 1000) / 1000L;
3481905c:	e59f1048 	ldr	r1, [pc, #72]	; 348190ac <strmhz+0x5c>
34819060:	e1a00005 	mov	r0, r5
34819064:	eb001b8e 	bl	3481fea4 <__udivsi3>
34819068:	e1a06000 	mov	r6, r0
	l = sprintf (buf, "%ld", n);
3481906c:	e1a02006 	mov	r2, r6
34819070:	e59f1038 	ldr	r1, [pc, #56]	; 348190b0 <strmhz+0x60>
34819074:	e1a00004 	mov	r0, r4
34819078:	eb000384 	bl	34819e90 <sprintf>
3481907c:	e1a07000 	mov	r7, r0

	hz -= n * 1000000L;
	m = DIV_ROUND(hz, 1000L);
34819080:	e59f002c 	ldr	r0, [pc, #44]	; 348190b4 <strmhz+0x64>
34819084:	e3a01ffa 	mov	r1, #1000	; 0x3e8
34819088:	e0205690 	mla	r0, r0, r6, r5
3481908c:	eb001b84 	bl	3481fea4 <__udivsi3>
	if (m != 0)
34819090:	e2502000 	subs	r2, r0, #0
34819094:	0a000002 	beq	348190a4 <strmhz+0x54>
		sprintf (buf + l, ".%03ld", m);
34819098:	e0840007 	add	r0, r4, r7
3481909c:	e59f1014 	ldr	r1, [pc, #20]	; 348190b8 <strmhz+0x68>
348190a0:	eb00037a 	bl	34819e90 <sprintf>
	return (buf);
}
348190a4:	e1a00004 	mov	r0, r4
348190a8:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
348190ac:	000f4240 	.word	0x000f4240
348190b0:	348276da 	.word	0x348276da
348190b4:	fff0bdc0 	.word	0xfff0bdc0
348190b8:	34827876 	.word	0x34827876

348190bc <udelay>:
#endif

/* ------------------------------------------------------------------------- */

void udelay(unsigned long usec)
{
348190bc:	e92d4070 	push	{r4, r5, r6, lr}
	ulong kv;

	do {
		WATCHDOG_RESET();
		kv = usec > CONFIG_WD_PERIOD ? CONFIG_WD_PERIOD : usec;
348190c0:	e59f6020 	ldr	r6, [pc, #32]	; 348190e8 <udelay+0x2c>
#endif

/* ------------------------------------------------------------------------- */

void udelay(unsigned long usec)
{
348190c4:	e1a04000 	mov	r4, r0
	ulong kv;

	do {
		WATCHDOG_RESET();
		kv = usec > CONFIG_WD_PERIOD ? CONFIG_WD_PERIOD : usec;
348190c8:	e1540006 	cmp	r4, r6
348190cc:	31a05004 	movcc	r5, r4
348190d0:	21a05006 	movcs	r5, r6
		__udelay (kv);
348190d4:	e1a00005 	mov	r0, r5
348190d8:	ebffa062 	bl	34801268 <__udelay>
		usec -= kv;
	} while(usec);
348190dc:	e0544005 	subs	r4, r4, r5
348190e0:	1afffff8 	bne	348190c8 <udelay+0xc>
}
348190e4:	e8bd8070 	pop	{r4, r5, r6, pc}
348190e8:	00989680 	.word	0x00989680

348190ec <mdelay>:

void mdelay(unsigned long msec)
{
348190ec:	e92d4010 	push	{r4, lr}
348190f0:	e1a04000 	mov	r4, r0
	while (msec--)
348190f4:	ea000002 	b	34819104 <mdelay+0x18>
		udelay(1000);
348190f8:	e3a00ffa 	mov	r0, #1000	; 0x3e8
348190fc:	ebffffee 	bl	348190bc <udelay>
34819100:	e2444001 	sub	r4, r4, #1
	} while(usec);
}

void mdelay(unsigned long msec)
{
	while (msec--)
34819104:	e3540000 	cmp	r4, #0
34819108:	1afffffa 	bne	348190f8 <mdelay+0xc>
		udelay(1000);
}
3481910c:	e8bd8010 	pop	{r4, pc}

34819110 <pack_hex_byte>:
#define hex_asc_lo(x)   hex_asc[((x) & 0x0f)]
#define hex_asc_hi(x)   hex_asc[((x) & 0xf0) >> 4]

static inline char *pack_hex_byte(char *buf, u8 byte)
{
	*buf++ = hex_asc_hi(byte);
34819110:	e59f201c 	ldr	r2, [pc, #28]	; 34819134 <pack_hex_byte+0x24>
34819114:	e1a03000 	mov	r3, r0
34819118:	e7d2c221 	ldrb	ip, [r2, r1, lsr #4]
	*buf++ = hex_asc_lo(byte);
3481911c:	e201100f 	and	r1, r1, #15
34819120:	e7d22001 	ldrb	r2, [r2, r1]
#define hex_asc_lo(x)   hex_asc[((x) & 0x0f)]
#define hex_asc_hi(x)   hex_asc[((x) & 0xf0) >> 4]

static inline char *pack_hex_byte(char *buf, u8 byte)
{
	*buf++ = hex_asc_hi(byte);
34819124:	e4c3c001 	strb	ip, [r3], #1
	*buf++ = hex_asc_lo(byte);
34819128:	e5c02001 	strb	r2, [r0, #1]
	return buf;
}
3481912c:	e2830001 	add	r0, r3, #1
34819130:	e12fff1e 	bx	lr
34819134:	348220dc 	.word	0x348220dc

34819138 <put_dec_trunc>:

/* Formats correctly any integer in [0,99999].
 * Outputs from one to five digits depending on input.
 * On i386 gcc 4.1.2 -O2: ~250 bytes of code. */
static char* put_dec_trunc(char *buf, unsigned q)
{
34819138:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
	unsigned d3, d2, d1, d0;
	d1 = (q>>4) & 0xf;
3481913c:	e7e37251 	ubfx	r7, r1, #4, #4
	d2 = (q>>8) & 0xf;
34819140:	e7e34451 	ubfx	r4, r1, #8, #4
	d3 = (q>>12);
34819144:	e1a02621 	lsr	r2, r1, #12

	d0 = 6*(d3 + d2 + d1) + (q & 0xf);
34819148:	e087c004 	add	ip, r7, r4

/* Formats correctly any integer in [0,99999].
 * Outputs from one to five digits depending on input.
 * On i386 gcc 4.1.2 -O2: ~250 bytes of code. */
static char* put_dec_trunc(char *buf, unsigned q)
{
3481914c:	e1a03000 	mov	r3, r0
	unsigned d3, d2, d1, d0;
	d1 = (q>>4) & 0xf;
	d2 = (q>>8) & 0xf;
	d3 = (q>>12);

	d0 = 6*(d3 + d2 + d1) + (q & 0xf);
34819150:	e08cc002 	add	ip, ip, r2
34819154:	e201000f 	and	r0, r1, #15
34819158:	e3a01006 	mov	r1, #6
3481915c:	e0210c91 	mla	r1, r1, ip, r0
	q = (d0 * 0xcd) >> 11;
34819160:	e3a050cd 	mov	r5, #205	; 0xcd
34819164:	e0060195 	mul	r6, r5, r1
	d0 = d0 - 10*q;
34819168:	e3a0c00a 	mov	ip, #10
	d1 = (q>>4) & 0xf;
	d2 = (q>>8) & 0xf;
	d3 = (q>>12);

	d0 = 6*(d3 + d2 + d1) + (q & 0xf);
	q = (d0 * 0xcd) >> 11;
3481916c:	e1a065a6 	lsr	r6, r6, #11
	d0 = d0 - 10*q;
34819170:	e061169c 	mls	r1, ip, r6, r1
	*buf++ = d0 + '0'; /* least significant digit */
34819174:	e1a00003 	mov	r0, r3
34819178:	e2811030 	add	r1, r1, #48	; 0x30
3481917c:	e4c01001 	strb	r1, [r0], #1
	d1 = q + 9*d3 + 5*d2 + d1;
34819180:	e0821182 	add	r1, r2, r2, lsl #3
34819184:	e0811007 	add	r1, r1, r7
34819188:	e084a104 	add	sl, r4, r4, lsl #2
3481918c:	e081100a 	add	r1, r1, sl
	if (d1 != 0) {
34819190:	e0916006 	adds	r6, r1, r6
34819194:	08bd84f0 	popeq	{r4, r5, r6, r7, sl, pc}
		q = (d1 * 0xcd) >> 11;
34819198:	e0010695 	mul	r1, r5, r6
3481919c:	e1a015a1 	lsr	r1, r1, #11
		d1 = d1 - 10*q;
348191a0:	e066619c 	mls	r6, ip, r1, r6
		*buf++ = d1 + '0'; /* next digit */

		d2 = q + 2*d2;
348191a4:	e0814084 	add	r4, r1, r4, lsl #1
	*buf++ = d0 + '0'; /* least significant digit */
	d1 = q + 9*d3 + 5*d2 + d1;
	if (d1 != 0) {
		q = (d1 * 0xcd) >> 11;
		d1 = d1 - 10*q;
		*buf++ = d1 + '0'; /* next digit */
348191a8:	e2866030 	add	r6, r6, #48	; 0x30
348191ac:	e5c36001 	strb	r6, [r3, #1]

		d2 = q + 2*d2;
		if ((d2 != 0) || (d3 != 0)) {
348191b0:	e1943002 	orrs	r3, r4, r2
	*buf++ = d0 + '0'; /* least significant digit */
	d1 = q + 9*d3 + 5*d2 + d1;
	if (d1 != 0) {
		q = (d1 * 0xcd) >> 11;
		d1 = d1 - 10*q;
		*buf++ = d1 + '0'; /* next digit */
348191b4:	e2800001 	add	r0, r0, #1

		d2 = q + 2*d2;
		if ((d2 != 0) || (d3 != 0)) {
348191b8:	08bd84f0 	popeq	{r4, r5, r6, r7, sl, pc}
			q = (d2 * 0xd) >> 7;
348191bc:	e3a0300d 	mov	r3, #13
348191c0:	e0030493 	mul	r3, r3, r4
348191c4:	e1a033a3 	lsr	r3, r3, #7
			d2 = d2 - 10*q;
348191c8:	e064439c 	mls	r4, ip, r3, r4
			*buf++ = d2 + '0'; /* next digit */

			d3 = q + 4*d3;
			if (d3 != 0) {
348191cc:	e0932102 	adds	r2, r3, r2, lsl #2

		d2 = q + 2*d2;
		if ((d2 != 0) || (d3 != 0)) {
			q = (d2 * 0xd) >> 7;
			d2 = d2 - 10*q;
			*buf++ = d2 + '0'; /* next digit */
348191d0:	e2844030 	add	r4, r4, #48	; 0x30
348191d4:	e4c04001 	strb	r4, [r0], #1

			d3 = q + 4*d3;
			if (d3 != 0) {
348191d8:	08bd84f0 	popeq	{r4, r5, r6, r7, sl, pc}
				q = (d3 * 0xcd) >> 11;
348191dc:	e0030295 	mul	r3, r5, r2
348191e0:	e1a035a3 	lsr	r3, r3, #11
				d3 = d3 - 10*q;
348191e4:	e062239c 	mls	r2, ip, r3, r2
				*buf++ = d3 + '0';  /* next digit */
				if (q != 0)
348191e8:	e3530000 	cmp	r3, #0

			d3 = q + 4*d3;
			if (d3 != 0) {
				q = (d3 * 0xcd) >> 11;
				d3 = d3 - 10*q;
				*buf++ = d3 + '0';  /* next digit */
348191ec:	e2822030 	add	r2, r2, #48	; 0x30
348191f0:	e4c02001 	strb	r2, [r0], #1
				if (q != 0)
					*buf++ = q + '0';  /* most sign. digit */
348191f4:	12833030 	addne	r3, r3, #48	; 0x30
348191f8:	14c03001 	strbne	r3, [r0], #1
			}
		}
	}
	return buf;
}
348191fc:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}

34819200 <put_dec>:
					*buf++ = q + '0';
	return buf;
}
/* No inlining helps gcc to use registers better */
static noinline char* put_dec(char *buf, unsigned NUM_TYPE num)
{
34819200:	e92d4ef3 	push	{r0, r1, r4, r5, r6, r7, r9, sl, fp, lr}
34819204:	e28d5008 	add	r5, sp, #8
34819208:	e16520f8 	strd	r2, [r5, #-8]!
3481920c:	e1a04000 	mov	r4, r0
	 * (x * 0x1a) >> 8:     11010 - same
	 * (x * 0x0d) >> 7:      1101 - same, shortest code (on i386)
	 */

	d0 = 6*(d3 + d2 + d1) + (q & 0xf);
	q = (d0 * 0xcd) >> 11;
34819210:	e3a090cd 	mov	r9, #205	; 0xcd
	d0 = d0 - 10*q;
34819214:	e3a0a00a 	mov	sl, #10
/* No inlining helps gcc to use registers better */
static noinline char* put_dec(char *buf, unsigned NUM_TYPE num)
{
	while (1) {
		unsigned rem;
		if (num < 100000)
34819218:	e89d0880 	ldm	sp, {r7, fp}
3481921c:	e35b0000 	cmp	fp, #0
34819220:	1a00000f 	bne	34819264 <put_dec+0x64>
34819224:	e59f00e8 	ldr	r0, [pc, #232]	; 34819314 <put_dec+0x114>
34819228:	e1570000 	cmp	r7, r0
3481922c:	8a000003 	bhi	34819240 <put_dec+0x40>
			return put_dec_trunc(buf, num);
34819230:	e1a00004 	mov	r0, r4
34819234:	e1a01007 	mov	r1, r7
34819238:	ebffffbe 	bl	34819138 <put_dec_trunc>
		rem = do_div(num, 100000);
		buf = put_dec_full(buf, rem);
	}
}
3481923c:	e8bd8efc 	pop	{r2, r3, r4, r5, r6, r7, r9, sl, fp, pc}
{
	while (1) {
		unsigned rem;
		if (num < 100000)
			return put_dec_trunc(buf, num);
		rem = do_div(num, 100000);
34819240:	e1a00007 	mov	r0, r7
34819244:	e59f10cc 	ldr	r1, [pc, #204]	; 34819318 <put_dec+0x118>
34819248:	eb001b90 	bl	34820090 <__aeabi_uidivmod>
3481924c:	e1a00007 	mov	r0, r7
34819250:	e1a06001 	mov	r6, r1
34819254:	e59f10bc 	ldr	r1, [pc, #188]	; 34819318 <put_dec+0x118>
34819258:	eb001b11 	bl	3481fea4 <__udivsi3>
3481925c:	e88d0801 	stm	sp, {r0, fp}
34819260:	ea000003 	b	34819274 <put_dec+0x74>
34819264:	e1a0000d 	mov	r0, sp
34819268:	e59f10a8 	ldr	r1, [pc, #168]	; 34819318 <put_dec+0x118>
3481926c:	ebfff842 	bl	3481737c <__div64_32>
34819270:	e1a06000 	mov	r6, r0
{
	/* BTW, if q is in [0,9999], 8-bit ints will be enough, */
	/* but anyway, gcc produces better code with full-sized ints */
	unsigned d3, d2, d1, d0;
	d1 = (q>>4) & 0xf;
	d2 = (q>>8) & 0xf;
34819274:	e7e32456 	ubfx	r2, r6, #8, #4
static char* put_dec_full(char *buf, unsigned q)
{
	/* BTW, if q is in [0,9999], 8-bit ints will be enough, */
	/* but anyway, gcc produces better code with full-sized ints */
	unsigned d3, d2, d1, d0;
	d1 = (q>>4) & 0xf;
34819278:	e7e3c256 	ubfx	ip, r6, #4, #4
	d2 = (q>>8) & 0xf;
	d3 = (q>>12);
3481927c:	e1a03626 	lsr	r3, r6, #12
	 * (x * 0x34) >> 9:    110100 - same
	 * (x * 0x1a) >> 8:     11010 - same
	 * (x * 0x0d) >> 7:      1101 - same, shortest code (on i386)
	 */

	d0 = 6*(d3 + d2 + d1) + (q & 0xf);
34819280:	e08c1002 	add	r1, ip, r2
34819284:	e0811003 	add	r1, r1, r3
34819288:	e3a00006 	mov	r0, #6
3481928c:	e206600f 	and	r6, r6, #15
34819290:	e0266190 	mla	r6, r0, r1, r6
	q = (d0 * 0xcd) >> 11;
34819294:	e0010699 	mul	r1, r9, r6
	d0 = d0 - 10*q;
	*buf++ = d0 + '0';
	d1 = q + 9*d3 + 5*d2 + d1;
34819298:	e0830183 	add	r0, r3, r3, lsl #3
3481929c:	e082e102 	add	lr, r2, r2, lsl #2
348192a0:	e080000c 	add	r0, r0, ip
	 * (x * 0x1a) >> 8:     11010 - same
	 * (x * 0x0d) >> 7:      1101 - same, shortest code (on i386)
	 */

	d0 = 6*(d3 + d2 + d1) + (q & 0xf);
	q = (d0 * 0xcd) >> 11;
348192a4:	e1a015a1 	lsr	r1, r1, #11
	d0 = d0 - 10*q;
	*buf++ = d0 + '0';
	d1 = q + 9*d3 + 5*d2 + d1;
348192a8:	e080000e 	add	r0, r0, lr
348192ac:	e0800001 	add	r0, r0, r1
	 * (x * 0x0d) >> 7:      1101 - same, shortest code (on i386)
	 */

	d0 = 6*(d3 + d2 + d1) + (q & 0xf);
	q = (d0 * 0xcd) >> 11;
	d0 = d0 - 10*q;
348192b0:	e066619a 	mls	r6, sl, r1, r6
	*buf++ = d0 + '0';
	d1 = q + 9*d3 + 5*d2 + d1;
		q = (d1 * 0xcd) >> 11;
348192b4:	e0010099 	mul	r1, r9, r0
348192b8:	e1a015a1 	lsr	r1, r1, #11
		d1 = d1 - 10*q;
348192bc:	e060019a 	mls	r0, sl, r1, r0
		*buf++ = d1 + '0';
348192c0:	e2800030 	add	r0, r0, #48	; 0x30
348192c4:	e5c40001 	strb	r0, [r4, #1]

		d2 = q + 2*d2;
348192c8:	e0812082 	add	r2, r1, r2, lsl #1
			q = (d2 * 0xd) >> 7;
348192cc:	e3a0000d 	mov	r0, #13
348192d0:	e0010290 	mul	r1, r0, r2
348192d4:	e1a013a1 	lsr	r1, r1, #7
			d2 = d2 - 10*q;
348192d8:	e062219a 	mls	r2, sl, r1, r2
			*buf++ = d2 + '0';

			d3 = q + 4*d3;
348192dc:	e0813103 	add	r3, r1, r3, lsl #2
		*buf++ = d1 + '0';

		d2 = q + 2*d2;
			q = (d2 * 0xd) >> 7;
			d2 = d2 - 10*q;
			*buf++ = d2 + '0';
348192e0:	e2822030 	add	r2, r2, #48	; 0x30
348192e4:	e5c42002 	strb	r2, [r4, #2]

			d3 = q + 4*d3;
				q = (d3 * 0xcd) >> 11; /* - shorter code */
348192e8:	e0020399 	mul	r2, r9, r3
348192ec:	e1a025a2 	lsr	r2, r2, #11
				/* q = (d3 * 0x67) >> 10; - would also work */
				d3 = d3 - 10*q;
348192f0:	e063329a 	mls	r3, sl, r2, r3
	 */

	d0 = 6*(d3 + d2 + d1) + (q & 0xf);
	q = (d0 * 0xcd) >> 11;
	d0 = d0 - 10*q;
	*buf++ = d0 + '0';
348192f4:	e2866030 	add	r6, r6, #48	; 0x30

			d3 = q + 4*d3;
				q = (d3 * 0xcd) >> 11; /* - shorter code */
				/* q = (d3 * 0x67) >> 10; - would also work */
				d3 = d3 - 10*q;
				*buf++ = d3 + '0';
348192f8:	e2833030 	add	r3, r3, #48	; 0x30
					*buf++ = q + '0';
348192fc:	e2822030 	add	r2, r2, #48	; 0x30
	 */

	d0 = 6*(d3 + d2 + d1) + (q & 0xf);
	q = (d0 * 0xcd) >> 11;
	d0 = d0 - 10*q;
	*buf++ = d0 + '0';
34819300:	e5c46000 	strb	r6, [r4]

			d3 = q + 4*d3;
				q = (d3 * 0xcd) >> 11; /* - shorter code */
				/* q = (d3 * 0x67) >> 10; - would also work */
				d3 = d3 - 10*q;
				*buf++ = d3 + '0';
34819304:	e5c43003 	strb	r3, [r4, #3]
					*buf++ = q + '0';
34819308:	e5c42004 	strb	r2, [r4, #4]
	return buf;
}
/* No inlining helps gcc to use registers better */
static noinline char* put_dec(char *buf, unsigned NUM_TYPE num)
3481930c:	e2844005 	add	r4, r4, #5
		unsigned rem;
		if (num < 100000)
			return put_dec_trunc(buf, num);
		rem = do_div(num, 100000);
		buf = put_dec_full(buf, rem);
	}
34819310:	eaffffc0 	b	34819218 <put_dec+0x18>
34819314:	0001869f 	.word	0x0001869f
34819318:	000186a0 	.word	0x000186a0

3481931c <string.clone.0>:
	while (--size >= 0)
		ADDCH(buf, ' ');
	return buf;
}

static char *string(char *buf, char *end, char *s, int field_width,
3481931c:	e92d4070 	push	{r4, r5, r6, lr}
		int precision, int flags)
{
	int len, i;

	if (s == 0)
		s = "<NULL>";
34819320:	e3510000 	cmp	r1, #0
34819324:	e59f607c 	ldr	r6, [pc, #124]	; 348193a8 <string.clone.0+0x8c>
34819328:	11a06001 	movne	r6, r1
	while (--size >= 0)
		ADDCH(buf, ' ');
	return buf;
}

static char *string(char *buf, char *end, char *s, int field_width,
3481932c:	e1a04000 	mov	r4, r0
	int len, i;

	if (s == 0)
		s = "<NULL>";

	len = strnlen(s, precision);
34819330:	e1a01003 	mov	r1, r3
34819334:	e1a00006 	mov	r0, r6
	while (--size >= 0)
		ADDCH(buf, ' ');
	return buf;
}

static char *string(char *buf, char *end, char *s, int field_width,
34819338:	e1a05002 	mov	r5, r2
	int len, i;

	if (s == 0)
		s = "<NULL>";

	len = strnlen(s, precision);
3481933c:	ebfffe3a 	bl	34818c2c <strnlen>

	if (!(flags & LEFT))
34819340:	e59d3010 	ldr	r3, [sp, #16]
34819344:	e3130010 	tst	r3, #16
34819348:	1a000007 	bne	3481936c <string.clone.0+0x50>
3481934c:	ea000001 	b	34819358 <string.clone.0+0x3c>
		while (len < field_width--)
			ADDCH(buf, ' ');
34819350:	e4c43001 	strb	r3, [r4], #1
34819354:	ea000000 	b	3481935c <string.clone.0+0x40>
34819358:	e3a03020 	mov	r3, #32
		s = "<NULL>";

	len = strnlen(s, precision);

	if (!(flags & LEFT))
		while (len < field_width--)
3481935c:	e2455001 	sub	r5, r5, #1
	while (--size >= 0)
		ADDCH(buf, ' ');
	return buf;
}

static char *string(char *buf, char *end, char *s, int field_width,
34819360:	e2852001 	add	r2, r5, #1
		s = "<NULL>";

	len = strnlen(s, precision);

	if (!(flags & LEFT))
		while (len < field_width--)
34819364:	e1500002 	cmp	r0, r2
34819368:	bafffff8 	blt	34819350 <string.clone.0+0x34>
			ADDCH(buf, ' ');
	for (i = 0; i < len; ++i)
3481936c:	e3a03000 	mov	r3, #0
34819370:	ea000002 	b	34819380 <string.clone.0+0x64>
		ADDCH(buf, *s++);
34819374:	e7d62003 	ldrb	r2, [r6, r3]
	len = strnlen(s, precision);

	if (!(flags & LEFT))
		while (len < field_width--)
			ADDCH(buf, ' ');
	for (i = 0; i < len; ++i)
34819378:	e2833001 	add	r3, r3, #1
		ADDCH(buf, *s++);
3481937c:	e4c42001 	strb	r2, [r4], #1
	len = strnlen(s, precision);

	if (!(flags & LEFT))
		while (len < field_width--)
			ADDCH(buf, ' ');
	for (i = 0; i < len; ++i)
34819380:	e1530000 	cmp	r3, r0
34819384:	bafffffa 	blt	34819374 <string.clone.0+0x58>
		ADDCH(buf, *s++);
	while (len < field_width--)
		ADDCH(buf, ' ');
34819388:	e3a03020 	mov	r3, #32
3481938c:	ea000001 	b	34819398 <string.clone.0+0x7c>
34819390:	e4c43001 	strb	r3, [r4], #1
34819394:	e2455001 	sub	r5, r5, #1
	if (!(flags & LEFT))
		while (len < field_width--)
			ADDCH(buf, ' ');
	for (i = 0; i < len; ++i)
		ADDCH(buf, *s++);
	while (len < field_width--)
34819398:	e1500005 	cmp	r0, r5
3481939c:	bafffffb 	blt	34819390 <string.clone.0+0x74>
		ADDCH(buf, ' ');
	return buf;
}
348193a0:	e1a00004 	mov	r0, r4
348193a4:	e8bd8070 	pop	{r4, r5, r6, pc}
348193a8:	3482787d 	.word	0x3482787d

348193ac <number.clone.4>:
	} while (0)
#else
#define ADDCH(str, ch)	(*(str)++ = (ch))
#endif

static char *number(char *buf, char *end, unsigned NUM_TYPE num,
348193ac:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
348193b0:	e24dd058 	sub	sp, sp, #88	; 0x58
348193b4:	e59d5084 	ldr	r5, [sp, #132]	; 0x84
348193b8:	e59d9078 	ldr	r9, [sp, #120]	; 0x78
	int need_pfx = ((type & SPECIAL) && base != 10);
	int i;

	/* locase = 0 or 0x20. ORing digits or letters with 'locase'
	 * produces same digits or (maybe lowercased) letters */
	locase = (type & SMALL);
348193bc:	e2051020 	and	r1, r5, #32
	static const char digits[16] = "0123456789ABCDEF"; /* "GHIJKLMNOPQRSTUVWXYZ"; */

	char tmp[66];
	char sign;
	char locase;
	int need_pfx = ((type & SPECIAL) && base != 10);
348193c0:	e259b00a 	subs	fp, r9, #10
348193c4:	13a0b001 	movne	fp, #1
	int i;

	/* locase = 0 or 0x20. ORing digits or letters with 'locase'
	 * produces same digits or (maybe lowercased) letters */
	locase = (type & SMALL);
	if (type & LEFT)
348193c8:	e3150010 	tst	r5, #16
	static const char digits[16] = "0123456789ABCDEF"; /* "GHIJKLMNOPQRSTUVWXYZ"; */

	char tmp[66];
	char sign;
	char locase;
	int need_pfx = ((type & SPECIAL) && base != 10);
348193cc:	e00bb325 	and	fp, fp, r5, lsr #6

	/* locase = 0 or 0x20. ORing digits or letters with 'locase'
	 * produces same digits or (maybe lowercased) letters */
	locase = (type & SMALL);
	if (type & LEFT)
		type &= ~ZEROPAD;
348193d0:	13c55001 	bicne	r5, r5, #1
	int need_pfx = ((type & SPECIAL) && base != 10);
	int i;

	/* locase = 0 or 0x20. ORing digits or letters with 'locase'
	 * produces same digits or (maybe lowercased) letters */
	locase = (type & SMALL);
348193d4:	e6ef1071 	uxtb	r1, r1
	if (type & LEFT)
		type &= ~ZEROPAD;
	sign = 0;
	if (type & SIGN) {
348193d8:	e215a002 	ands	sl, r5, #2
	} while (0)
#else
#define ADDCH(str, ch)	(*(str)++ = (ch))
#endif

static char *number(char *buf, char *end, unsigned NUM_TYPE num,
348193dc:	e1a04000 	mov	r4, r0
348193e0:	e59d607c 	ldr	r6, [sp, #124]	; 0x7c
	int need_pfx = ((type & SPECIAL) && base != 10);
	int i;

	/* locase = 0 or 0x20. ORing digits or letters with 'locase'
	 * produces same digits or (maybe lowercased) letters */
	locase = (type & SMALL);
348193e4:	e58d1004 	str	r1, [sp, #4]
	if (type & LEFT)
		type &= ~ZEROPAD;
	sign = 0;
	if (type & SIGN) {
348193e8:	0a00000f 	beq	3481942c <number.clone.4+0x80>
		if ((signed NUM_TYPE) num < 0) {
348193ec:	e3530000 	cmp	r3, #0
348193f0:	ba000002 	blt	34819400 <number.clone.4+0x54>
			sign = '-';
			num = - (signed NUM_TYPE) num;
			size--;
		} else if (type & PLUS) {
348193f4:	e3150004 	tst	r5, #4
348193f8:	0a000008 	beq	34819420 <number.clone.4+0x74>
348193fc:	ea000004 	b	34819414 <number.clone.4+0x68>
		type &= ~ZEROPAD;
	sign = 0;
	if (type & SIGN) {
		if ((signed NUM_TYPE) num < 0) {
			sign = '-';
			num = - (signed NUM_TYPE) num;
34819400:	e2722000 	rsbs	r2, r2, #0
34819404:	e2e33000 	rsc	r3, r3, #0
			size--;
34819408:	e2466001 	sub	r6, r6, #1
	if (type & LEFT)
		type &= ~ZEROPAD;
	sign = 0;
	if (type & SIGN) {
		if ((signed NUM_TYPE) num < 0) {
			sign = '-';
3481940c:	e3a0a02d 	mov	sl, #45	; 0x2d
34819410:	ea000005 	b	3481942c <number.clone.4+0x80>
			num = - (signed NUM_TYPE) num;
			size--;
		} else if (type & PLUS) {
			sign = '+';
			size--;
34819414:	e2466001 	sub	r6, r6, #1
		if ((signed NUM_TYPE) num < 0) {
			sign = '-';
			num = - (signed NUM_TYPE) num;
			size--;
		} else if (type & PLUS) {
			sign = '+';
34819418:	e3a0a02b 	mov	sl, #43	; 0x2b
3481941c:	ea000002 	b	3481942c <number.clone.4+0x80>
			size--;
		} else if (type & SPACE) {
34819420:	e215a008 	ands	sl, r5, #8
			sign = ' ';
			size--;
34819424:	12466001 	subne	r6, r6, #1
			size--;
		} else if (type & PLUS) {
			sign = '+';
			size--;
		} else if (type & SPACE) {
			sign = ' ';
34819428:	13a0a020 	movne	sl, #32
			size--;
		}
	}
	if (need_pfx) {
3481942c:	e35b0000 	cmp	fp, #0
34819430:	0a000002 	beq	34819440 <number.clone.4+0x94>
		size--;
34819434:	e2466001 	sub	r6, r6, #1
		if (base == 16)
34819438:	e3590010 	cmp	r9, #16
			size--;
3481943c:	02466001 	subeq	r6, r6, #1
	}

	/* generate full string in tmp[], in reverse order */
	i = 0;
	if (num == 0)
34819440:	e1921003 	orrs	r1, r2, r3
		tmp[i++] = '0';
34819444:	03a03030 	moveq	r3, #48	; 0x30
34819448:	05cd3014 	strbeq	r3, [sp, #20]
3481944c:	03a07001 	moveq	r7, #1
			size--;
	}

	/* generate full string in tmp[], in reverse order */
	i = 0;
	if (num == 0)
34819450:	0a000023 	beq	348194e4 <number.clone.4+0x138>
	/* Generic code, for any base:
	else do {
		tmp[i++] = (digits[do_div(num,base)] | locase);
	} while (num != 0);
	*/
	else if (base != 10) { /* 8 or 16 */
34819454:	e359000a 	cmp	r9, #10
34819458:	0a00001d 	beq	348194d4 <number.clone.4+0x128>
		int mask = base - 1;
		int shift = 3;
3481945c:	e3590010 	cmp	r9, #16
	else do {
		tmp[i++] = (digits[do_div(num,base)] | locase);
	} while (num != 0);
	*/
	else if (base != 10) { /* 8 or 16 */
		int mask = base - 1;
34819460:	e2491001 	sub	r1, r9, #1
		int shift = 3;
34819464:	03a0c004 	moveq	ip, #4
34819468:	13a0c003 	movne	ip, #3
	else do {
		tmp[i++] = (digits[do_div(num,base)] | locase);
	} while (num != 0);
	*/
	else if (base != 10) { /* 8 or 16 */
		int mask = base - 1;
3481946c:	e58d1008 	str	r1, [sp, #8]
		int shift = 3;
		if (base == 16) shift = 4;
		do {
			tmp[i++] = (digits[((unsigned char)num) & mask] | locase);
34819470:	e58db00c 	str	fp, [sp, #12]
	} while (num != 0);
	*/
	else if (base != 10) { /* 8 or 16 */
		int mask = base - 1;
		int shift = 3;
		if (base == 16) shift = 4;
34819474:	e3a07000 	mov	r7, #0
		do {
			tmp[i++] = (digits[((unsigned char)num) & mask] | locase);
34819478:	e1a0b00a 	mov	fp, sl
3481947c:	e1a00002 	mov	r0, r2
34819480:	e1a0a004 	mov	sl, r4
34819484:	e1a01003 	mov	r1, r3
34819488:	e1a0400c 	mov	r4, ip
3481948c:	e59d3008 	ldr	r3, [sp, #8]
34819490:	e0032000 	and	r2, r3, r0
34819494:	e59f3120 	ldr	r3, [pc, #288]	; 348195bc <number.clone.4+0x210>
34819498:	e6e32072 	uxtab	r2, r3, r2
3481949c:	e5d2c011 	ldrb	ip, [r2, #17]
348194a0:	e59d3004 	ldr	r3, [sp, #4]
348194a4:	e28d2014 	add	r2, sp, #20
348194a8:	e183c00c 	orr	ip, r3, ip
348194ac:	e7c2c007 	strb	ip, [r2, r7]
			num >>= shift;
348194b0:	e1a02004 	mov	r2, r4
348194b4:	eb001b8d 	bl	348202f0 <__lshrdi3>
		} while (num);
348194b8:	e1903001 	orrs	r3, r0, r1
	else if (base != 10) { /* 8 or 16 */
		int mask = base - 1;
		int shift = 3;
		if (base == 16) shift = 4;
		do {
			tmp[i++] = (digits[((unsigned char)num) & mask] | locase);
348194bc:	e2877001 	add	r7, r7, #1
			num >>= shift;
		} while (num);
348194c0:	1afffff1 	bne	3481948c <number.clone.4+0xe0>
348194c4:	e1a0400a 	mov	r4, sl
348194c8:	e1a0a00b 	mov	sl, fp
348194cc:	e59db00c 	ldr	fp, [sp, #12]
348194d0:	ea000003 	b	348194e4 <number.clone.4+0x138>
	} else { /* base 10 */
		i = put_dec(tmp, num) - tmp;
348194d4:	e28d7014 	add	r7, sp, #20
348194d8:	e1a00007 	mov	r0, r7
348194dc:	ebffff47 	bl	34819200 <put_dec>
348194e0:	e0677000 	rsb	r7, r7, r0
348194e4:	e59d3080 	ldr	r3, [sp, #128]	; 0x80
348194e8:	e1570003 	cmp	r7, r3
348194ec:	a1a03007 	movge	r3, r7
348194f0:	b1a03003 	movlt	r3, r3
	/* printing 100 using %2d gives "100", not "00" */
	if (i > precision)
		precision = i;
	/* leading space padding */
	size -= precision;
	if (!(type & (ZEROPAD + LEFT))) {
348194f4:	e3150011 	tst	r5, #17

	/* printing 100 using %2d gives "100", not "00" */
	if (i > precision)
		precision = i;
	/* leading space padding */
	size -= precision;
348194f8:	e0636006 	rsb	r6, r3, r6
	if (!(type & (ZEROPAD + LEFT))) {
348194fc:	1a000005 	bne	34819518 <number.clone.4+0x16c>
34819500:	ea000001 	b	3481950c <number.clone.4+0x160>
		while (--size >= 0)
			ADDCH(buf, ' ');
34819504:	e4c42001 	strb	r2, [r4], #1
34819508:	ea000000 	b	34819510 <number.clone.4+0x164>
3481950c:	e3a02020 	mov	r2, #32
	if (i > precision)
		precision = i;
	/* leading space padding */
	size -= precision;
	if (!(type & (ZEROPAD + LEFT))) {
		while (--size >= 0)
34819510:	e2566001 	subs	r6, r6, #1
34819514:	5afffffa 	bpl	34819504 <number.clone.4+0x158>
			ADDCH(buf, ' ');
	}
	/* sign */
	if (sign)
34819518:	e35a0000 	cmp	sl, #0
		ADDCH(buf, sign);
3481951c:	14c4a001 	strbne	sl, [r4], #1
	/* "0x" / "0" prefix */
	if (need_pfx) {
34819520:	e35b0000 	cmp	fp, #0
34819524:	0a000005 	beq	34819540 <number.clone.4+0x194>
		ADDCH(buf, '0');
34819528:	e3a02030 	mov	r2, #48	; 0x30
3481952c:	e4c42001 	strb	r2, [r4], #1
		if (base == 16)
34819530:	e3590010 	cmp	r9, #16
			ADDCH(buf, 'X' | locase);
34819534:	059d1004 	ldreq	r1, [sp, #4]
34819538:	03812058 	orreq	r2, r1, #88	; 0x58
3481953c:	04c42001 	strbeq	r2, [r4], #1
	}
	/* zero or space padding */
	if (!(type & LEFT)) {
34819540:	e3150010 	tst	r5, #16
34819544:	1a000009 	bne	34819570 <number.clone.4+0x1c4>
		char c = (type & ZEROPAD) ? '0' : ' ';
34819548:	e3150001 	tst	r5, #1
3481954c:	03a02020 	moveq	r2, #32
34819550:	13a02030 	movne	r2, #48	; 0x30
34819554:	ea000000 	b	3481955c <number.clone.4+0x1b0>

		while (--size >= 0)
			ADDCH(buf, c);
34819558:	e4c42001 	strb	r2, [r4], #1
	}
	/* zero or space padding */
	if (!(type & LEFT)) {
		char c = (type & ZEROPAD) ? '0' : ' ';

		while (--size >= 0)
3481955c:	e2566001 	subs	r6, r6, #1
34819560:	5afffffc 	bpl	34819558 <number.clone.4+0x1ac>
34819564:	ea000001 	b	34819570 <number.clone.4+0x1c4>
			ADDCH(buf, c);
	}
	/* hmm even more zero padding? */
	while (i <= --precision)
		ADDCH(buf, '0');
34819568:	e4c42001 	strb	r2, [r4], #1
3481956c:	ea000000 	b	34819574 <number.clone.4+0x1c8>
34819570:	e3a02030 	mov	r2, #48	; 0x30

		while (--size >= 0)
			ADDCH(buf, c);
	}
	/* hmm even more zero padding? */
	while (i <= --precision)
34819574:	e2433001 	sub	r3, r3, #1
34819578:	e1570003 	cmp	r7, r3
3481957c:	dafffff9 	ble	34819568 <number.clone.4+0x1bc>
34819580:	ea000002 	b	34819590 <number.clone.4+0x1e4>
		ADDCH(buf, '0');
	/* actual digits of result */
	while (--i >= 0)
		ADDCH(buf, tmp[i]);
34819584:	e28d3014 	add	r3, sp, #20
34819588:	e7d33007 	ldrb	r3, [r3, r7]
3481958c:	e4c43001 	strb	r3, [r4], #1
	}
	/* hmm even more zero padding? */
	while (i <= --precision)
		ADDCH(buf, '0');
	/* actual digits of result */
	while (--i >= 0)
34819590:	e2577001 	subs	r7, r7, #1
34819594:	5afffffa 	bpl	34819584 <number.clone.4+0x1d8>
34819598:	ea000001 	b	348195a4 <number.clone.4+0x1f8>
		ADDCH(buf, tmp[i]);
	/* trailing space padding */
	while (--size >= 0)
		ADDCH(buf, ' ');
3481959c:	e4c43001 	strb	r3, [r4], #1
348195a0:	ea000000 	b	348195a8 <number.clone.4+0x1fc>
348195a4:	e3a03020 	mov	r3, #32
		ADDCH(buf, '0');
	/* actual digits of result */
	while (--i >= 0)
		ADDCH(buf, tmp[i]);
	/* trailing space padding */
	while (--size >= 0)
348195a8:	e2566001 	subs	r6, r6, #1
348195ac:	5afffffa 	bpl	3481959c <number.clone.4+0x1f0>
		ADDCH(buf, ' ');
	return buf;
}
348195b0:	e1a00004 	mov	r0, r4
348195b4:	e28dd058 	add	sp, sp, #88	; 0x58
348195b8:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
348195bc:	348220dc 	.word	0x348220dc

348195c0 <vsnprintf_internal.clone.6>:
	}
	return number(buf, end, (unsigned long)ptr, 16, field_width,
		      precision, flags);
}

static int vsnprintf_internal(char *buf, size_t size, const char *fmt,
348195c0:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
348195c4:	e24dd058 	sub	sp, sp, #88	; 0x58
348195c8:	e58d0020 	str	r0, [sp, #32]
	if (end < buf) {
		end = ((void *)-1);
		size = end - buf;
	}
#endif
	str = buf;
348195cc:	e1a09000 	mov	r9, r0
	char temp[3];	/* hold each IP quad in reverse order */
	char *p = ip4_addr;
	int i, digits;

	for (i = 0; i < 4; i++) {
		digits = put_dec_trunc(temp, addr[i]) - temp;
348195d0:	e28d0054 	add	r0, sp, #84	; 0x54
	}
	return number(buf, end, (unsigned long)ptr, 16, field_width,
		      precision, flags);
}

static int vsnprintf_internal(char *buf, size_t size, const char *fmt,
348195d4:	e1a06001 	mov	r6, r1
	char temp[3];	/* hold each IP quad in reverse order */
	char *p = ip4_addr;
	int i, digits;

	for (i = 0; i < 4; i++) {
		digits = put_dec_trunc(temp, addr[i]) - temp;
348195d8:	e58d0014 	str	r0, [sp, #20]
348195dc:	ea00017b 	b	34819bd0 <vsnprintf_internal.clone.6+0x610>
	}
#endif
	str = buf;

	for (; *fmt ; ++fmt) {
		if (*fmt != '%') {
348195e0:	e3530025 	cmp	r3, #37	; 0x25
348195e4:	1a000140 	bne	34819aec <vsnprintf_internal.clone.6+0x52c>
	}
	return number(buf, end, (unsigned long)ptr, 16, field_width,
		      precision, flags);
}

static int vsnprintf_internal(char *buf, size_t size, const char *fmt,
348195e8:	e2861001 	add	r1, r6, #1
348195ec:	e3a0a000 	mov	sl, #0
#endif
	str = buf;

	for (; *fmt ; ++fmt) {
		if (*fmt != '%') {
			ADDCH(str, *fmt);
348195f0:	e1a06001 	mov	r6, r1

		/* process flags */
		flags = 0;
		repeat:
			++fmt;		/* this also skips first '%' */
			switch (*fmt) {
348195f4:	e4d13001 	ldrb	r3, [r1], #1
348195f8:	e353002b 	cmp	r3, #43	; 0x2b
348195fc:	0a00000c 	beq	34819634 <vsnprintf_internal.clone.6+0x74>
34819600:	8a000004 	bhi	34819618 <vsnprintf_internal.clone.6+0x58>
34819604:	e3530020 	cmp	r3, #32
34819608:	0a00000b 	beq	3481963c <vsnprintf_internal.clone.6+0x7c>
3481960c:	e3530023 	cmp	r3, #35	; 0x23
34819610:	1a00000f 	bne	34819654 <vsnprintf_internal.clone.6+0x94>
34819614:	ea00000a 	b	34819644 <vsnprintf_internal.clone.6+0x84>
34819618:	e353002d 	cmp	r3, #45	; 0x2d
3481961c:	0a000002 	beq	3481962c <vsnprintf_internal.clone.6+0x6c>
34819620:	e3530030 	cmp	r3, #48	; 0x30
34819624:	1a00000a 	bne	34819654 <vsnprintf_internal.clone.6+0x94>
34819628:	ea000007 	b	3481964c <vsnprintf_internal.clone.6+0x8c>
				case '-': flags |= LEFT; goto repeat;
3481962c:	e38aa010 	orr	sl, sl, #16
34819630:	eaffffee 	b	348195f0 <vsnprintf_internal.clone.6+0x30>
				case '+': flags |= PLUS; goto repeat;
34819634:	e38aa004 	orr	sl, sl, #4
34819638:	eaffffec 	b	348195f0 <vsnprintf_internal.clone.6+0x30>
				case ' ': flags |= SPACE; goto repeat;
3481963c:	e38aa008 	orr	sl, sl, #8
34819640:	eaffffea 	b	348195f0 <vsnprintf_internal.clone.6+0x30>
				case '#': flags |= SPECIAL; goto repeat;
34819644:	e38aa040 	orr	sl, sl, #64	; 0x40
34819648:	eaffffe8 	b	348195f0 <vsnprintf_internal.clone.6+0x30>
				case '0': flags |= ZEROPAD; goto repeat;
3481964c:	e38aa001 	orr	sl, sl, #1
34819650:	eaffffe6 	b	348195f0 <vsnprintf_internal.clone.6+0x30>
			}

		/* get field width */
		field_width = -1;
		if (is_digit(*fmt))
34819654:	e2431030 	sub	r1, r3, #48	; 0x30
34819658:	e6ef1071 	uxtb	r1, r1
3481965c:	e3510009 	cmp	r1, #9
34819660:	91a03006 	movls	r3, r6
34819664:	93a0b000 	movls	fp, #0
static int skip_atoi(const char **s)
{
	int i=0;

	while (is_digit(**s))
		i = i*10 + *((*s)++) - '0';
34819668:	93a0000a 	movls	r0, #10
				case '0': flags |= ZEROPAD; goto repeat;
			}

		/* get field width */
		field_width = -1;
		if (is_digit(*fmt))
3481966c:	9a000001 	bls	34819678 <vsnprintf_internal.clone.6+0xb8>
34819670:	ea000007 	b	34819694 <vsnprintf_internal.clone.6+0xd4>
static int skip_atoi(const char **s)
{
	int i=0;

	while (is_digit(**s))
		i = i*10 + *((*s)++) - '0';
34819674:	e02b1b90 	mla	fp, r0, fp, r1
34819678:	e1a06003 	mov	r6, r3

static int skip_atoi(const char **s)
{
	int i=0;

	while (is_digit(**s))
3481967c:	e4d31001 	ldrb	r1, [r3], #1
34819680:	e2411030 	sub	r1, r1, #48	; 0x30
34819684:	e6efc071 	uxtb	ip, r1
34819688:	e35c0009 	cmp	ip, #9
3481968c:	9afffff8 	bls	34819674 <vsnprintf_internal.clone.6+0xb4>
34819690:	ea000009 	b	348196bc <vsnprintf_internal.clone.6+0xfc>

		/* get field width */
		field_width = -1;
		if (is_digit(*fmt))
			field_width = skip_atoi(&fmt);
		else if (*fmt == '*') {
34819694:	e353002a 	cmp	r3, #42	; 0x2a
				case '#': flags |= SPECIAL; goto repeat;
				case '0': flags |= ZEROPAD; goto repeat;
			}

		/* get field width */
		field_width = -1;
34819698:	13e0b000 	mvnne	fp, #0
		if (is_digit(*fmt))
			field_width = skip_atoi(&fmt);
		else if (*fmt == '*') {
3481969c:	1a000006 	bne	348196bc <vsnprintf_internal.clone.6+0xfc>
			++fmt;
			/* it's the next argument */
			field_width = va_arg(args, int);
348196a0:	e592b000 	ldr	fp, [r2]
348196a4:	e2823004 	add	r3, r2, #4
			if (field_width < 0) {
348196a8:	e35b0000 	cmp	fp, #0
		/* get field width */
		field_width = -1;
		if (is_digit(*fmt))
			field_width = skip_atoi(&fmt);
		else if (*fmt == '*') {
			++fmt;
348196ac:	e2866001 	add	r6, r6, #1
			/* it's the next argument */
			field_width = va_arg(args, int);
			if (field_width < 0) {
				field_width = -field_width;
348196b0:	b26bb000 	rsblt	fp, fp, #0
				flags |= LEFT;
348196b4:	b38aa010 	orrlt	sl, sl, #16
		if (is_digit(*fmt))
			field_width = skip_atoi(&fmt);
		else if (*fmt == '*') {
			++fmt;
			/* it's the next argument */
			field_width = va_arg(args, int);
348196b8:	e1a02003 	mov	r2, r3
			}
		}

		/* get the precision */
		precision = -1;
		if (*fmt == '.') {
348196bc:	e5d63000 	ldrb	r3, [r6]
348196c0:	e353002e 	cmp	r3, #46	; 0x2e
				flags |= LEFT;
			}
		}

		/* get the precision */
		precision = -1;
348196c4:	13e07000 	mvnne	r7, #0
		if (*fmt == '.') {
348196c8:	1a00001d 	bne	34819744 <vsnprintf_internal.clone.6+0x184>
			++fmt;
			if (is_digit(*fmt))
348196cc:	e5f63001 	ldrb	r3, [r6, #1]!
348196d0:	e2431030 	sub	r1, r3, #48	; 0x30
348196d4:	e6ef1071 	uxtb	r1, r1
348196d8:	e3510009 	cmp	r1, #9
348196dc:	91a03006 	movls	r3, r6
348196e0:	93a07000 	movls	r7, #0
static int skip_atoi(const char **s)
{
	int i=0;

	while (is_digit(**s))
		i = i*10 + *((*s)++) - '0';
348196e4:	93a0000a 	movls	r0, #10

		/* get the precision */
		precision = -1;
		if (*fmt == '.') {
			++fmt;
			if (is_digit(*fmt))
348196e8:	9a000001 	bls	348196f4 <vsnprintf_internal.clone.6+0x134>
348196ec:	ea000009 	b	34819718 <vsnprintf_internal.clone.6+0x158>
static int skip_atoi(const char **s)
{
	int i=0;

	while (is_digit(**s))
		i = i*10 + *((*s)++) - '0';
348196f0:	e0271790 	mla	r7, r0, r7, r1

static int skip_atoi(const char **s)
{
	int i=0;

	while (is_digit(**s))
348196f4:	e5d31000 	ldrb	r1, [r3]
		i = i*10 + *((*s)++) - '0';
348196f8:	e1a06003 	mov	r6, r3

static int skip_atoi(const char **s)
{
	int i=0;

	while (is_digit(**s))
348196fc:	e2411030 	sub	r1, r1, #48	; 0x30
34819700:	e6efc071 	uxtb	ip, r1
34819704:	e35c0009 	cmp	ip, #9
34819708:	e2833001 	add	r3, r3, #1
3481970c:	9afffff7 	bls	348196f0 <vsnprintf_internal.clone.6+0x130>
34819710:	e1a03002 	mov	r3, r2
34819714:	ea000006 	b	34819734 <vsnprintf_internal.clone.6+0x174>
		precision = -1;
		if (*fmt == '.') {
			++fmt;
			if (is_digit(*fmt))
				precision = skip_atoi(&fmt);
			else if (*fmt == '*') {
34819718:	e353002a 	cmp	r3, #42	; 0x2a
3481971c:	1a000007 	bne	34819740 <vsnprintf_internal.clone.6+0x180>
				++fmt;
				/* it's the next argument */
				precision = va_arg(args, int);
34819720:	e5927000 	ldr	r7, [r2]
		if (*fmt == '.') {
			++fmt;
			if (is_digit(*fmt))
				precision = skip_atoi(&fmt);
			else if (*fmt == '*') {
				++fmt;
34819724:	e2866001 	add	r6, r6, #1
				/* it's the next argument */
				precision = va_arg(args, int);
			}
			if (precision < 0)
34819728:	e3570000 	cmp	r7, #0
			if (is_digit(*fmt))
				precision = skip_atoi(&fmt);
			else if (*fmt == '*') {
				++fmt;
				/* it's the next argument */
				precision = va_arg(args, int);
3481972c:	e2823004 	add	r3, r2, #4
			}
			if (precision < 0)
34819730:	ba000001 	blt	3481973c <vsnprintf_internal.clone.6+0x17c>
				flags |= LEFT;
			}
		}

		/* get the precision */
		precision = -1;
34819734:	e1a02003 	mov	r2, r3
34819738:	ea000001 	b	34819744 <vsnprintf_internal.clone.6+0x184>
			if (is_digit(*fmt))
				precision = skip_atoi(&fmt);
			else if (*fmt == '*') {
				++fmt;
				/* it's the next argument */
				precision = va_arg(args, int);
3481973c:	e1a02003 	mov	r2, r3
			}
			if (precision < 0)
				precision = 0;
34819740:	e3a07000 	mov	r7, #0
		}

		/* get the conversion qualifier */
		qualifier = -1;
		if (*fmt == 'h' || *fmt == 'l' || *fmt == 'L' ||
34819744:	e5d61000 	ldrb	r1, [r6]
34819748:	e3510068 	cmp	r1, #104	; 0x68
3481974c:	1351006c 	cmpne	r1, #108	; 0x6c
34819750:	0a000008 	beq	34819778 <vsnprintf_internal.clone.6+0x1b8>
34819754:	e351004c 	cmp	r1, #76	; 0x4c
34819758:	0a000006 	beq	34819778 <vsnprintf_internal.clone.6+0x1b8>
3481975c:	e351005a 	cmp	r1, #90	; 0x5a
34819760:	0a000004 	beq	34819778 <vsnprintf_internal.clone.6+0x1b8>
		    *fmt == 'Z' || *fmt == 'z' || *fmt == 't') {
34819764:	e351007a 	cmp	r1, #122	; 0x7a
34819768:	0a000002 	beq	34819778 <vsnprintf_internal.clone.6+0x1b8>
3481976c:	e3510074 	cmp	r1, #116	; 0x74
			if (precision < 0)
				precision = 0;
		}

		/* get the conversion qualifier */
		qualifier = -1;
34819770:	13e01000 	mvnne	r1, #0
		if (*fmt == 'h' || *fmt == 'l' || *fmt == 'L' ||
		    *fmt == 'Z' || *fmt == 'z' || *fmt == 't') {
34819774:	1a000006 	bne	34819794 <vsnprintf_internal.clone.6+0x1d4>
			qualifier = *fmt;
			++fmt;
			if (qualifier == 'l' && *fmt == 'l') {
34819778:	e351006c 	cmp	r1, #108	; 0x6c
		/* get the conversion qualifier */
		qualifier = -1;
		if (*fmt == 'h' || *fmt == 'l' || *fmt == 'L' ||
		    *fmt == 'Z' || *fmt == 'z' || *fmt == 't') {
			qualifier = *fmt;
			++fmt;
3481977c:	e2866001 	add	r6, r6, #1
			if (qualifier == 'l' && *fmt == 'l') {
34819780:	1a000003 	bne	34819794 <vsnprintf_internal.clone.6+0x1d4>
34819784:	e5d63000 	ldrb	r3, [r6]
34819788:	e353006c 	cmp	r3, #108	; 0x6c
				qualifier = 'L';
				++fmt;
3481978c:	02866001 	addeq	r6, r6, #1
		if (*fmt == 'h' || *fmt == 'l' || *fmt == 'L' ||
		    *fmt == 'Z' || *fmt == 'z' || *fmt == 't') {
			qualifier = *fmt;
			++fmt;
			if (qualifier == 'l' && *fmt == 'l') {
				qualifier = 'L';
34819790:	03a0104c 	moveq	r1, #76	; 0x4c
		}

		/* default base */
		base = 10;

		switch (*fmt) {
34819794:	e5d63000 	ldrb	r3, [r6]
34819798:	e353006e 	cmp	r3, #110	; 0x6e
3481979c:	0a0000c0 	beq	34819aa4 <vsnprintf_internal.clone.6+0x4e4>
348197a0:	8a00000c 	bhi	348197d8 <vsnprintf_internal.clone.6+0x218>
348197a4:	e3530063 	cmp	r3, #99	; 0x63
348197a8:	0a000017 	beq	3481980c <vsnprintf_internal.clone.6+0x24c>
348197ac:	8a000004 	bhi	348197c4 <vsnprintf_internal.clone.6+0x204>
348197b0:	e3530025 	cmp	r3, #37	; 0x25
348197b4:	0a0000cc 	beq	34819aec <vsnprintf_internal.clone.6+0x52c>
348197b8:	e3530058 	cmp	r3, #88	; 0x58
348197bc:	1a0000c4 	bne	34819ad4 <vsnprintf_internal.clone.6+0x514>
348197c0:	ea0000cd 	b	34819afc <vsnprintf_internal.clone.6+0x53c>
348197c4:	e3530064 	cmp	r3, #100	; 0x64
348197c8:	0a0000bf 	beq	34819acc <vsnprintf_internal.clone.6+0x50c>
348197cc:	e3530069 	cmp	r3, #105	; 0x69
348197d0:	1a0000bf 	bne	34819ad4 <vsnprintf_internal.clone.6+0x514>
348197d4:	ea0000bc 	b	34819acc <vsnprintf_internal.clone.6+0x50c>
348197d8:	e3530073 	cmp	r3, #115	; 0x73
348197dc:	0a00001e 	beq	3481985c <vsnprintf_internal.clone.6+0x29c>
348197e0:	8a000004 	bhi	348197f8 <vsnprintf_internal.clone.6+0x238>
348197e4:	e353006f 	cmp	r3, #111	; 0x6f
348197e8:	0a0000b3 	beq	34819abc <vsnprintf_internal.clone.6+0x4fc>
348197ec:	e3530070 	cmp	r3, #112	; 0x70
348197f0:	1a0000b7 	bne	34819ad4 <vsnprintf_internal.clone.6+0x514>
348197f4:	ea000022 	b	34819884 <vsnprintf_internal.clone.6+0x2c4>
348197f8:	e3530075 	cmp	r3, #117	; 0x75
348197fc:	0a0000bc 	beq	34819af4 <vsnprintf_internal.clone.6+0x534>
34819800:	e3530078 	cmp	r3, #120	; 0x78
34819804:	1a0000b2 	bne	34819ad4 <vsnprintf_internal.clone.6+0x514>
34819808:	ea0000ad 	b	34819ac4 <vsnprintf_internal.clone.6+0x504>
		case 'c':
			if (!(flags & LEFT)) {
3481980c:	e31a0010 	tst	sl, #16
34819810:	1a000006 	bne	34819830 <vsnprintf_internal.clone.6+0x270>
34819814:	ea000001 	b	34819820 <vsnprintf_internal.clone.6+0x260>
				while (--field_width > 0)
					ADDCH(str, ' ');
34819818:	e4c93001 	strb	r3, [r9], #1
3481981c:	ea000000 	b	34819824 <vsnprintf_internal.clone.6+0x264>
34819820:	e3a03020 	mov	r3, #32
		base = 10;

		switch (*fmt) {
		case 'c':
			if (!(flags & LEFT)) {
				while (--field_width > 0)
34819824:	e24bb001 	sub	fp, fp, #1
34819828:	e35b0000 	cmp	fp, #0
3481982c:	cafffff9 	bgt	34819818 <vsnprintf_internal.clone.6+0x258>
					ADDCH(str, ' ');
			}
			ADDCH(str, (unsigned char) va_arg(args, int));
34819830:	e2823004 	add	r3, r2, #4
34819834:	e5922000 	ldr	r2, [r2]
34819838:	e4c92001 	strb	r2, [r9], #1
			while (--field_width > 0)
				ADDCH(str, ' ');
3481983c:	e3a02020 	mov	r2, #32
34819840:	ea000000 	b	34819848 <vsnprintf_internal.clone.6+0x288>
34819844:	e4c92001 	strb	r2, [r9], #1
			if (!(flags & LEFT)) {
				while (--field_width > 0)
					ADDCH(str, ' ');
			}
			ADDCH(str, (unsigned char) va_arg(args, int));
			while (--field_width > 0)
34819848:	e24bb001 	sub	fp, fp, #1
3481984c:	e35b0000 	cmp	fp, #0
34819850:	cafffffb 	bgt	34819844 <vsnprintf_internal.clone.6+0x284>
		case 'c':
			if (!(flags & LEFT)) {
				while (--field_width > 0)
					ADDCH(str, ' ');
			}
			ADDCH(str, (unsigned char) va_arg(args, int));
34819854:	e1a02003 	mov	r2, r3
34819858:	ea0000db 	b	34819bcc <vsnprintf_internal.clone.6+0x60c>
			while (--field_width > 0)
				ADDCH(str, ' ');
			continue;

		case 's':
			str = string(str, end, va_arg(args, char *),
3481985c:	e58da000 	str	sl, [sp]
34819860:	e2824004 	add	r4, r2, #4
34819864:	e1a00009 	mov	r0, r9
34819868:	e5921000 	ldr	r1, [r2]
3481986c:	e1a03007 	mov	r3, r7
34819870:	e1a0200b 	mov	r2, fp
34819874:	ebfffea8 	bl	3481931c <string.clone.0>
34819878:	e1a02004 	mov	r2, r4
3481987c:	e1a09000 	mov	r9, r0
34819880:	ea0000d1 	b	34819bcc <vsnprintf_internal.clone.6+0x60c>
				     field_width, precision, flags);
			continue;

		case 'p':
			str = pointer(fmt+1, str, end,
34819884:	e2821004 	add	r1, r2, #4
34819888:	e5922000 	ldr	r2, [r2]
3481988c:	e58d1024 	str	r1, [sp, #36]	; 0x24
 * pointer to the real address.
 */
static char *pointer(const char *fmt, char *buf, char *end, void *ptr,
		int field_width, int precision, int flags)
{
	if (!ptr)
34819890:	e3520000 	cmp	r2, #0
		return string(buf, end, "(null)", field_width, precision,
34819894:	058da000 	streq	sl, [sp]
34819898:	01a00009 	moveq	r0, r9
3481989c:	059f134c 	ldreq	r1, [pc, #844]	; 34819bf0 <vsnprintf_internal.clone.6+0x630>
348198a0:	0a000065 	beq	34819a3c <vsnprintf_internal.clone.6+0x47c>
			      flags);

#ifdef CONFIG_CMD_NET
	switch (*fmt) {
348198a4:	e5d63001 	ldrb	r3, [r6, #1]
			str = string(str, end, va_arg(args, char *),
				     field_width, precision, flags);
			continue;

		case 'p':
			str = pointer(fmt+1, str, end,
348198a8:	e2861001 	add	r1, r6, #1
	if (!ptr)
		return string(buf, end, "(null)", field_width, precision,
			      flags);

#ifdef CONFIG_CMD_NET
	switch (*fmt) {
348198ac:	e353004d 	cmp	r3, #77	; 0x4d
348198b0:	0a000008 	beq	348198d8 <vsnprintf_internal.clone.6+0x318>
348198b4:	8a000002 	bhi	348198c4 <vsnprintf_internal.clone.6+0x304>
348198b8:	e3530049 	cmp	r3, #73	; 0x49
348198bc:	1a000062 	bne	34819a4c <vsnprintf_internal.clone.6+0x48c>
348198c0:	ea00001a 	b	34819930 <vsnprintf_internal.clone.6+0x370>
348198c4:	e3530069 	cmp	r3, #105	; 0x69
348198c8:	0a000017 	beq	3481992c <vsnprintf_internal.clone.6+0x36c>
348198cc:	e353006d 	cmp	r3, #109	; 0x6d
348198d0:	1a00005d 	bne	34819a4c <vsnprintf_internal.clone.6+0x48c>
	case 'm':
		flags |= SPECIAL;
348198d4:	e38aa040 	orr	sl, sl, #64	; 0x40
	char *p = mac_addr;
	int i;

	for (i = 0; i < 6; i++) {
		p = pack_hex_byte(p, addr[i]);
		if (!(flags & SPECIAL) && i != 5)
348198d8:	e1a03009 	mov	r3, r9
#ifdef CONFIG_CMD_NET
static char *mac_address_string(char *buf, char *end, u8 *addr, int field_width,
				int precision, int flags)
{
	char mac_addr[6 * 3]; /* (6 * 2 hex digits), 5 colons and trailing zero */
	char *p = mac_addr;
348198dc:	e28d002c 	add	r0, sp, #44	; 0x2c
	int i;

	for (i = 0; i < 6; i++) {
348198e0:	e3a04000 	mov	r4, #0
		p = pack_hex_byte(p, addr[i]);
		if (!(flags & SPECIAL) && i != 5)
348198e4:	e20a5040 	and	r5, sl, #64	; 0x40
348198e8:	e1a09002 	mov	r9, r2
	char mac_addr[6 * 3]; /* (6 * 2 hex digits), 5 colons and trailing zero */
	char *p = mac_addr;
	int i;

	for (i = 0; i < 6; i++) {
		p = pack_hex_byte(p, addr[i]);
348198ec:	e7d91004 	ldrb	r1, [r9, r4]
348198f0:	e58d301c 	str	r3, [sp, #28]
348198f4:	ebfffe05 	bl	34819110 <pack_hex_byte>
		if (!(flags & SPECIAL) && i != 5)
348198f8:	e2542005 	subs	r2, r4, #5
348198fc:	13a02001 	movne	r2, #1
34819900:	e3550000 	cmp	r5, #0
34819904:	13a02000 	movne	r2, #0
34819908:	e3520000 	cmp	r2, #0
			*p++ = ':';
3481990c:	13a0203a 	movne	r2, #58	; 0x3a
{
	char mac_addr[6 * 3]; /* (6 * 2 hex digits), 5 colons and trailing zero */
	char *p = mac_addr;
	int i;

	for (i = 0; i < 6; i++) {
34819910:	e2844001 	add	r4, r4, #1
		p = pack_hex_byte(p, addr[i]);
		if (!(flags & SPECIAL) && i != 5)
34819914:	e59d301c 	ldr	r3, [sp, #28]
			*p++ = ':';
34819918:	14c02001 	strbne	r2, [r0], #1
{
	char mac_addr[6 * 3]; /* (6 * 2 hex digits), 5 colons and trailing zero */
	char *p = mac_addr;
	int i;

	for (i = 0; i < 6; i++) {
3481991c:	e3540006 	cmp	r4, #6
34819920:	1afffff1 	bne	348198ec <vsnprintf_internal.clone.6+0x32c>
34819924:	e1a09003 	mov	r9, r3
34819928:	ea00001b 	b	3481999c <vsnprintf_internal.clone.6+0x3dc>
		/* Fallthrough */
	case 'M':
		return mac_address_string(buf, end, ptr, field_width,
					  precision, flags);
	case 'i':
		flags |= SPECIAL;
3481992c:	e38aa040 	orr	sl, sl, #64	; 0x40
		/* Fallthrough */
	case 'I':
		if (fmt[1] == '6')
34819930:	e5d13001 	ldrb	r3, [r1, #1]
34819934:	e3530036 	cmp	r3, #54	; 0x36
34819938:	1a00001a 	bne	348199a8 <vsnprintf_internal.clone.6+0x3e8>
	int i;

	for (i = 0; i < 8; i++) {
		p = pack_hex_byte(p, addr[2 * i]);
		p = pack_hex_byte(p, addr[2 * i + 1]);
		if (!(flags & SPECIAL) && i != 7)
3481993c:	e20a3040 	and	r3, sl, #64	; 0x40
34819940:	e1a0c009 	mov	ip, r9
					  precision, flags);
	case 'i':
		flags |= SPECIAL;
		/* Fallthrough */
	case 'I':
		if (fmt[1] == '6')
34819944:	e1a05002 	mov	r5, r2

static char *ip6_addr_string(char *buf, char *end, u8 *addr, int field_width,
			 int precision, int flags)
{
	char ip6_addr[8 * 5]; /* (8 * 4 hex digits), 7 colons and trailing zero */
	char *p = ip6_addr;
34819948:	e28d002c 	add	r0, sp, #44	; 0x2c
	int i;

	for (i = 0; i < 8; i++) {
3481994c:	e3a04000 	mov	r4, #0
		p = pack_hex_byte(p, addr[2 * i]);
		p = pack_hex_byte(p, addr[2 * i + 1]);
		if (!(flags & SPECIAL) && i != 7)
34819950:	e1a09003 	mov	r9, r3
	char ip6_addr[8 * 5]; /* (8 * 4 hex digits), 7 colons and trailing zero */
	char *p = ip6_addr;
	int i;

	for (i = 0; i < 8; i++) {
		p = pack_hex_byte(p, addr[2 * i]);
34819954:	e5d51000 	ldrb	r1, [r5]
34819958:	e58dc01c 	str	ip, [sp, #28]
3481995c:	ebfffdeb 	bl	34819110 <pack_hex_byte>
		p = pack_hex_byte(p, addr[2 * i + 1]);
34819960:	e5d51001 	ldrb	r1, [r5, #1]
34819964:	ebfffde9 	bl	34819110 <pack_hex_byte>
		if (!(flags & SPECIAL) && i != 7)
34819968:	e2542007 	subs	r2, r4, #7
3481996c:	13a02001 	movne	r2, #1
34819970:	e3590000 	cmp	r9, #0
34819974:	13a02000 	movne	r2, #0
34819978:	e3520000 	cmp	r2, #0
			*p++ = ':';
3481997c:	13a0303a 	movne	r3, #58	; 0x3a
{
	char ip6_addr[8 * 5]; /* (8 * 4 hex digits), 7 colons and trailing zero */
	char *p = ip6_addr;
	int i;

	for (i = 0; i < 8; i++) {
34819980:	e2844001 	add	r4, r4, #1
		p = pack_hex_byte(p, addr[2 * i]);
		p = pack_hex_byte(p, addr[2 * i + 1]);
		if (!(flags & SPECIAL) && i != 7)
34819984:	e59dc01c 	ldr	ip, [sp, #28]
			*p++ = ':';
34819988:	14c03001 	strbne	r3, [r0], #1
{
	char ip6_addr[8 * 5]; /* (8 * 4 hex digits), 7 colons and trailing zero */
	char *p = ip6_addr;
	int i;

	for (i = 0; i < 8; i++) {
3481998c:	e3540008 	cmp	r4, #8
34819990:	e2855002 	add	r5, r5, #2
34819994:	1affffee 	bne	34819954 <vsnprintf_internal.clone.6+0x394>
34819998:	e1a0900c 	mov	r9, ip
		p = pack_hex_byte(p, addr[2 * i]);
		p = pack_hex_byte(p, addr[2 * i + 1]);
		if (!(flags & SPECIAL) && i != 7)
			*p++ = ':';
	}
	*p = '\0';
3481999c:	e3a03000 	mov	r3, #0
348199a0:	e5c03000 	strb	r3, [r0]
348199a4:	ea000020 	b	34819a2c <vsnprintf_internal.clone.6+0x46c>
		/* Fallthrough */
	case 'I':
		if (fmt[1] == '6')
			return ip6_addr_string(buf, end, ptr, field_width,
					       precision, flags);
		if (fmt[1] == '4')
348199a8:	e3530034 	cmp	r3, #52	; 0x34
			return ip4_addr_string(buf, end, ptr, field_width,
					       precision, flags);
		flags &= ~SPECIAL;
348199ac:	13caa040 	bicne	sl, sl, #64	; 0x40
		/* Fallthrough */
	case 'I':
		if (fmt[1] == '6')
			return ip6_addr_string(buf, end, ptr, field_width,
					       precision, flags);
		if (fmt[1] == '4')
348199b0:	1a000025 	bne	34819a4c <vsnprintf_internal.clone.6+0x48c>
	char ip4_addr[4 * 4]; /* (4 * 3 decimal digits), 3 dots and trailing zero */
	char temp[3];	/* hold each IP quad in reverse order */
	char *p = ip4_addr;
	int i, digits;

	for (i = 0; i < 4; i++) {
348199b4:	e1a03009 	mov	r3, r9
static char *ip4_addr_string(char *buf, char *end, u8 *addr, int field_width,
			 int precision, int flags)
{
	char ip4_addr[4 * 4]; /* (4 * 3 decimal digits), 3 dots and trailing zero */
	char temp[3];	/* hold each IP quad in reverse order */
	char *p = ip4_addr;
348199b8:	e28d402c 	add	r4, sp, #44	; 0x2c
	int i, digits;

	for (i = 0; i < 4; i++) {
348199bc:	e3a05000 	mov	r5, #0
348199c0:	e1a09002 	mov	r9, r2
		digits = put_dec_trunc(temp, addr[i]) - temp;
348199c4:	e7d91005 	ldrb	r1, [r9, r5]
348199c8:	e28d0054 	add	r0, sp, #84	; 0x54
348199cc:	e58d301c 	str	r3, [sp, #28]
348199d0:	ebfffdd8 	bl	34819138 <put_dec_trunc>
348199d4:	e59dc014 	ldr	ip, [sp, #20]
	}
	return number(buf, end, (unsigned long)ptr, 16, field_width,
		      precision, flags);
}

static int vsnprintf_internal(char *buf, size_t size, const char *fmt,
348199d8:	e28d1054 	add	r1, sp, #84	; 0x54
	char temp[3];	/* hold each IP quad in reverse order */
	char *p = ip4_addr;
	int i, digits;

	for (i = 0; i < 4; i++) {
		digits = put_dec_trunc(temp, addr[i]) - temp;
348199dc:	e06c0000 	rsb	r0, ip, r0
	}
	return number(buf, end, (unsigned long)ptr, 16, field_width,
		      precision, flags);
}

static int vsnprintf_internal(char *buf, size_t size, const char *fmt,
348199e0:	e0812000 	add	r2, r1, r0
348199e4:	e59d301c 	ldr	r3, [sp, #28]
348199e8:	e1a01004 	mov	r1, r4
348199ec:	ea000001 	b	348199f8 <vsnprintf_internal.clone.6+0x438>

	for (i = 0; i < 4; i++) {
		digits = put_dec_trunc(temp, addr[i]) - temp;
		/* reverse the digits in the quad */
		while (digits--)
			*p++ = temp[digits];
348199f0:	e572c001 	ldrb	ip, [r2, #-1]!
348199f4:	e4c1c001 	strb	ip, [r1], #1
	int i, digits;

	for (i = 0; i < 4; i++) {
		digits = put_dec_trunc(temp, addr[i]) - temp;
		/* reverse the digits in the quad */
		while (digits--)
348199f8:	e59dc014 	ldr	ip, [sp, #20]
348199fc:	e152000c 	cmp	r2, ip
34819a00:	1afffffa 	bne	348199f0 <vsnprintf_internal.clone.6+0x430>
			*p++ = temp[digits];
		if (i != 3)
34819a04:	e3550003 	cmp	r5, #3
	int i, digits;

	for (i = 0; i < 4; i++) {
		digits = put_dec_trunc(temp, addr[i]) - temp;
		/* reverse the digits in the quad */
		while (digits--)
34819a08:	e0844000 	add	r4, r4, r0
	char ip4_addr[4 * 4]; /* (4 * 3 decimal digits), 3 dots and trailing zero */
	char temp[3];	/* hold each IP quad in reverse order */
	char *p = ip4_addr;
	int i, digits;

	for (i = 0; i < 4; i++) {
34819a0c:	e2855001 	add	r5, r5, #1
		digits = put_dec_trunc(temp, addr[i]) - temp;
		/* reverse the digits in the quad */
		while (digits--)
			*p++ = temp[digits];
		if (i != 3)
			*p++ = '.';
34819a10:	13a0002e 	movne	r0, #46	; 0x2e
34819a14:	14c40001 	strbne	r0, [r4], #1
	char ip4_addr[4 * 4]; /* (4 * 3 decimal digits), 3 dots and trailing zero */
	char temp[3];	/* hold each IP quad in reverse order */
	char *p = ip4_addr;
	int i, digits;

	for (i = 0; i < 4; i++) {
34819a18:	e3550004 	cmp	r5, #4
34819a1c:	1affffe8 	bne	348199c4 <vsnprintf_internal.clone.6+0x404>
34819a20:	e1a09003 	mov	r9, r3
		while (digits--)
			*p++ = temp[digits];
		if (i != 3)
			*p++ = '.';
	}
	*p = '\0';
34819a24:	e3a03000 	mov	r3, #0
34819a28:	e5c43000 	strb	r3, [r4]

	return string(buf, end, ip4_addr, field_width, precision,
34819a2c:	e3caa040 	bic	sl, sl, #64	; 0x40
34819a30:	e58da000 	str	sl, [sp]
34819a34:	e1a00009 	mov	r0, r9
34819a38:	e28d102c 	add	r1, sp, #44	; 0x2c
34819a3c:	e1a0200b 	mov	r2, fp
34819a40:	e1a03007 	mov	r3, r7
34819a44:	ebfffe34 	bl	3481931c <string.clone.0>
34819a48:	ea00000a 	b	34819a78 <vsnprintf_internal.clone.6+0x4b8>
		flags &= ~SPECIAL;
		break;
	}
#endif
	flags |= SMALL;
	if (field_width == -1) {
34819a4c:	e37b0001 	cmn	fp, #1
					       precision, flags);
		flags &= ~SPECIAL;
		break;
	}
#endif
	flags |= SMALL;
34819a50:	e38a3020 	orr	r3, sl, #32
	if (field_width == -1) {
		field_width = 2*sizeof(void *);
		flags |= ZEROPAD;
34819a54:	038a3021 	orreq	r3, sl, #33	; 0x21
		break;
	}
#endif
	flags |= SMALL;
	if (field_width == -1) {
		field_width = 2*sizeof(void *);
34819a58:	028bb009 	addeq	fp, fp, #9
		flags |= ZEROPAD;
	}
	return number(buf, end, (unsigned long)ptr, 16, field_width,
34819a5c:	e3a01010 	mov	r1, #16
34819a60:	e58d300c 	str	r3, [sp, #12]
34819a64:	e1a00009 	mov	r0, r9
34819a68:	e3a03000 	mov	r3, #0
34819a6c:	e88d0802 	stm	sp, {r1, fp}
34819a70:	e58d7008 	str	r7, [sp, #8]
34819a74:	ebfffe4c 	bl	348193ac <number.clone.4>
34819a78:	e1a09000 	mov	r9, r0
34819a7c:	e1a03006 	mov	r3, r6
		case 'p':
			str = pointer(fmt+1, str, end,
					va_arg(args, void *),
					field_width, precision, flags);
			/* Skip all alphanumeric pointer suffixes */
			while (isalnum(fmt[1]))
34819a80:	e5d32001 	ldrb	r2, [r3, #1]
34819a84:	e59f1168 	ldr	r1, [pc, #360]	; 34819bf4 <vsnprintf_internal.clone.6+0x634>
	flags |= SMALL;
	if (field_width == -1) {
		field_width = 2*sizeof(void *);
		flags |= ZEROPAD;
	}
	return number(buf, end, (unsigned long)ptr, 16, field_width,
34819a88:	e1a06003 	mov	r6, r3
		case 'p':
			str = pointer(fmt+1, str, end,
					va_arg(args, void *),
					field_width, precision, flags);
			/* Skip all alphanumeric pointer suffixes */
			while (isalnum(fmt[1]))
34819a8c:	e7d12002 	ldrb	r2, [r1, r2]
34819a90:	e2833001 	add	r3, r3, #1
34819a94:	e3120007 	tst	r2, #7
34819a98:	1afffff8 	bne	34819a80 <vsnprintf_internal.clone.6+0x4c0>
			str = string(str, end, va_arg(args, char *),
				     field_width, precision, flags);
			continue;

		case 'p':
			str = pointer(fmt+1, str, end,
34819a9c:	e59d2024 	ldr	r2, [sp, #36]	; 0x24
34819aa0:	ea000049 	b	34819bcc <vsnprintf_internal.clone.6+0x60c>
34819aa4:	e59dc020 	ldr	ip, [sp, #32]
34819aa8:	e2821004 	add	r1, r2, #4
			if (qualifier == 'l') {
				long * ip = va_arg(args, long *);
				*ip = (str - buf);
			} else {
				int * ip = va_arg(args, int *);
				*ip = (str - buf);
34819aac:	e5922000 	ldr	r2, [r2]
34819ab0:	e06c3009 	rsb	r3, ip, r9
34819ab4:	e5823000 	str	r3, [r2]
34819ab8:	ea000042 	b	34819bc8 <vsnprintf_internal.clone.6+0x608>
			ADDCH(str, '%');
			continue;

		/* integer number formats - set up the flags and "break" */
		case 'o':
			base = 8;
34819abc:	e3a03008 	mov	r3, #8
34819ac0:	ea00000e 	b	34819b00 <vsnprintf_internal.clone.6+0x540>
			break;

		case 'x':
			flags |= SMALL;
34819ac4:	e38aa020 	orr	sl, sl, #32
34819ac8:	ea00000b 	b	34819afc <vsnprintf_internal.clone.6+0x53c>
			base = 16;
			break;

		case 'd':
		case 'i':
			flags |= SIGN;
34819acc:	e38aa002 	orr	sl, sl, #2
34819ad0:	ea000007 	b	34819af4 <vsnprintf_internal.clone.6+0x534>
		case 'u':
			break;

		default:
			ADDCH(str, '%');
34819ad4:	e3a03025 	mov	r3, #37	; 0x25
34819ad8:	e4c93001 	strb	r3, [r9], #1
			if (*fmt)
34819adc:	e5d63000 	ldrb	r3, [r6]
34819ae0:	e3530000 	cmp	r3, #0
				ADDCH(str, *fmt);
			else
				--fmt;
34819ae4:	02466001 	subeq	r6, r6, #1
		case 'u':
			break;

		default:
			ADDCH(str, '%');
			if (*fmt)
34819ae8:	0a000037 	beq	34819bcc <vsnprintf_internal.clone.6+0x60c>
				ADDCH(str, *fmt);
34819aec:	e4c93001 	strb	r3, [r9], #1
34819af0:	ea000035 	b	34819bcc <vsnprintf_internal.clone.6+0x60c>
				++fmt;
			}
		}

		/* default base */
		base = 10;
34819af4:	e3a0300a 	mov	r3, #10
34819af8:	ea000000 	b	34819b00 <vsnprintf_internal.clone.6+0x540>
			break;

		case 'x':
			flags |= SMALL;
		case 'X':
			base = 16;
34819afc:	e3a03010 	mov	r3, #16
				ADDCH(str, *fmt);
			else
				--fmt;
			continue;
		}
		if (qualifier == 'L')  /* "quad" for 64 bit variables */
34819b00:	e351004c 	cmp	r1, #76	; 0x4c
			num = va_arg(args, unsigned long long);
34819b04:	02822007 	addeq	r2, r2, #7
34819b08:	03c22007 	biceq	r2, r2, #7
34819b0c:	02821008 	addeq	r1, r2, #8
34819b10:	01c240d0 	ldrdeq	r4, [r2]
34819b14:	0a000020 	beq	34819b9c <vsnprintf_internal.clone.6+0x5dc>
		else if (qualifier == 'l') {
34819b18:	e351006c 	cmp	r1, #108	; 0x6c
34819b1c:	1a000005 	bne	34819b38 <vsnprintf_internal.clone.6+0x578>
			num = va_arg(args, unsigned long);
34819b20:	e5924000 	ldr	r4, [r2]
			if (flags & SIGN)
34819b24:	e31a0002 	tst	sl, #2
			continue;
		}
		if (qualifier == 'L')  /* "quad" for 64 bit variables */
			num = va_arg(args, unsigned long long);
		else if (qualifier == 'l') {
			num = va_arg(args, unsigned long);
34819b28:	e2821004 	add	r1, r2, #4
34819b2c:	e3a05000 	mov	r5, #0
			if (flags & SIGN)
34819b30:	0a000019 	beq	34819b9c <vsnprintf_internal.clone.6+0x5dc>
34819b34:	ea000017 	b	34819b98 <vsnprintf_internal.clone.6+0x5d8>
				num = (signed long) num;
		} else if (qualifier == 'Z' || qualifier == 'z') {
34819b38:	e351005a 	cmp	r1, #90	; 0x5a
34819b3c:	1351007a 	cmpne	r1, #122	; 0x7a
			num = va_arg(args, size_t);
34819b40:	05924000 	ldreq	r4, [r2]
34819b44:	02821004 	addeq	r1, r2, #4
34819b48:	03a05000 	moveq	r5, #0
			num = va_arg(args, unsigned long long);
		else if (qualifier == 'l') {
			num = va_arg(args, unsigned long);
			if (flags & SIGN)
				num = (signed long) num;
		} else if (qualifier == 'Z' || qualifier == 'z') {
34819b4c:	0a000012 	beq	34819b9c <vsnprintf_internal.clone.6+0x5dc>
			num = va_arg(args, size_t);
		} else if (qualifier == 't') {
34819b50:	e3510074 	cmp	r1, #116	; 0x74
			num = va_arg(args, ptrdiff_t);
34819b54:	02821004 	addeq	r1, r2, #4
34819b58:	05924000 	ldreq	r4, [r2]
			num = va_arg(args, unsigned long);
			if (flags & SIGN)
				num = (signed long) num;
		} else if (qualifier == 'Z' || qualifier == 'z') {
			num = va_arg(args, size_t);
		} else if (qualifier == 't') {
34819b5c:	0a00000d 	beq	34819b98 <vsnprintf_internal.clone.6+0x5d8>
			num = va_arg(args, ptrdiff_t);
		} else if (qualifier == 'h') {
34819b60:	e3510068 	cmp	r1, #104	; 0x68
34819b64:	e5924000 	ldr	r4, [r2]
34819b68:	e2821004 	add	r1, r2, #4
34819b6c:	e20a2002 	and	r2, sl, #2
34819b70:	1a000005 	bne	34819b8c <vsnprintf_internal.clone.6+0x5cc>
			num = (unsigned short) va_arg(args, int);
34819b74:	e6ff4074 	uxth	r4, r4
34819b78:	e3a05000 	mov	r5, #0
			if (flags & SIGN)
34819b7c:	e3520000 	cmp	r2, #0
				num = (signed short) num;
34819b80:	16bf4074 	sxthne	r4, r4
			num = va_arg(args, size_t);
		} else if (qualifier == 't') {
			num = va_arg(args, ptrdiff_t);
		} else if (qualifier == 'h') {
			num = (unsigned short) va_arg(args, int);
			if (flags & SIGN)
34819b84:	1a000003 	bne	34819b98 <vsnprintf_internal.clone.6+0x5d8>
34819b88:	ea000003 	b	34819b9c <vsnprintf_internal.clone.6+0x5dc>
				num = (signed short) num;
		} else {
			num = va_arg(args, unsigned int);
			if (flags & SIGN)
34819b8c:	e3520000 	cmp	r2, #0
		} else if (qualifier == 'h') {
			num = (unsigned short) va_arg(args, int);
			if (flags & SIGN)
				num = (signed short) num;
		} else {
			num = va_arg(args, unsigned int);
34819b90:	e3a05000 	mov	r5, #0
			if (flags & SIGN)
34819b94:	0a000000 	beq	34819b9c <vsnprintf_internal.clone.6+0x5dc>
				num = (signed int) num;
34819b98:	e1a05fc4 	asr	r5, r4, #31
		}
		str = number(str, end, num, base, field_width, precision,
34819b9c:	e58d3000 	str	r3, [sp]
34819ba0:	e1a00009 	mov	r0, r9
34819ba4:	e1a02004 	mov	r2, r4
34819ba8:	e1a03005 	mov	r3, r5
34819bac:	e58d101c 	str	r1, [sp, #28]
34819bb0:	e58db004 	str	fp, [sp, #4]
34819bb4:	e58d7008 	str	r7, [sp, #8]
34819bb8:	e58da00c 	str	sl, [sp, #12]
34819bbc:	ebfffdfa 	bl	348193ac <number.clone.4>
34819bc0:	e59d101c 	ldr	r1, [sp, #28]
34819bc4:	e1a09000 	mov	r9, r0
34819bc8:	e1a02001 	mov	r2, r1
		size = end - buf;
	}
#endif
	str = buf;

	for (; *fmt ; ++fmt) {
34819bcc:	e2866001 	add	r6, r6, #1
34819bd0:	e5d63000 	ldrb	r3, [r6]
34819bd4:	e3530000 	cmp	r3, #0
34819bd8:	1afffe80 	bne	348195e0 <vsnprintf_internal.clone.6+0x20>
		ADDCH(str, '\0');
		if (str > end)
			end[-1] = '\0';
	}
#else
	*str = '\0';
34819bdc:	e5c93000 	strb	r3, [r9]
#endif
	/* the trailing null byte doesn't count towards the total */
	return str-buf;
}
34819be0:	e59d1020 	ldr	r1, [sp, #32]
34819be4:	e0610009 	rsb	r0, r1, r9
34819be8:	e28dd058 	add	sp, sp, #88	; 0x58
34819bec:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
34819bf0:	34827884 	.word	0x34827884
34819bf4:	34821fd4 	.word	0x34821fd4

34819bf8 <simple_strtoul>:
	*buf++ = hex_asc_lo(byte);
	return buf;
}

unsigned long simple_strtoul(const char *cp,char **endp,unsigned int base)
{
34819bf8:	e92d4070 	push	{r4, r5, r6, lr}
	unsigned long result = 0,value;

	if (*cp == '0') {
34819bfc:	e5d03000 	ldrb	r3, [r0]
34819c00:	e3530030 	cmp	r3, #48	; 0x30
34819c04:	1a00000d 	bne	34819c40 <simple_strtoul+0x48>
		cp++;
		if ((*cp == 'x') && isxdigit(cp[1])) {
34819c08:	e5f03001 	ldrb	r3, [r0, #1]!
34819c0c:	e3530078 	cmp	r3, #120	; 0x78
34819c10:	1a000007 	bne	34819c34 <simple_strtoul+0x3c>
34819c14:	e5d0c001 	ldrb	ip, [r0, #1]
34819c18:	e59f4080 	ldr	r4, [pc, #128]	; 34819ca0 <simple_strtoul+0xa8>
34819c1c:	e2803001 	add	r3, r0, #1
34819c20:	e7d4c00c 	ldrb	ip, [r4, ip]
34819c24:	e31c0044 	tst	ip, #68	; 0x44
34819c28:	11a00003 	movne	r0, r3
			base = 16;
34819c2c:	13a02010 	movne	r2, #16
{
	unsigned long result = 0,value;

	if (*cp == '0') {
		cp++;
		if ((*cp == 'x') && isxdigit(cp[1])) {
34819c30:	1a000004 	bne	34819c48 <simple_strtoul+0x50>
			base = 16;
			cp++;
		}
		if (!base) {
			base = 8;
34819c34:	e3520000 	cmp	r2, #0
34819c38:	03a02008 	moveq	r2, #8
34819c3c:	ea000001 	b	34819c48 <simple_strtoul+0x50>
		}
	}
	if (!base) {
		base = 10;
34819c40:	e3520000 	cmp	r2, #0
34819c44:	03a0200a 	moveq	r2, #10
		}
		if (!base) {
			base = 8;
		}
	}
	if (!base) {
34819c48:	e1a0c000 	mov	ip, r0
		base = 10;
	}
	while (isxdigit(*cp) && (value = isdigit(*cp) ? *cp-'0' : (islower(*cp)
34819c4c:	e59f604c 	ldr	r6, [pc, #76]	; 34819ca0 <simple_strtoul+0xa8>
		if (!base) {
			base = 8;
		}
	}
	if (!base) {
		base = 10;
34819c50:	e3a00000 	mov	r0, #0
34819c54:	ea000000 	b	34819c5c <simple_strtoul+0x64>
	}
	while (isxdigit(*cp) && (value = isdigit(*cp) ? *cp-'0' : (islower(*cp)
	    ? toupper(*cp) : *cp)-'A'+10) < base) {
		result = result*base + value;
34819c58:	e0203092 	mla	r0, r2, r0, r3
34819c5c:	e1a0500c 	mov	r5, ip
		}
	}
	if (!base) {
		base = 10;
	}
	while (isxdigit(*cp) && (value = isdigit(*cp) ? *cp-'0' : (islower(*cp)
34819c60:	e4dc3001 	ldrb	r3, [ip], #1
34819c64:	e7d64003 	ldrb	r4, [r6, r3]
34819c68:	e3140044 	tst	r4, #68	; 0x44
34819c6c:	0a000008 	beq	34819c94 <simple_strtoul+0x9c>
34819c70:	e3140004 	tst	r4, #4
34819c74:	12433030 	subne	r3, r3, #48	; 0x30
34819c78:	1a000003 	bne	34819c8c <simple_strtoul+0x94>
34819c7c:	e3140002 	tst	r4, #2
}

static inline unsigned char __toupper(unsigned char c)
{
	if (islower(c))
		c -= 'a'-'A';
34819c80:	12433020 	subne	r3, r3, #32
	    ? toupper(*cp) : *cp)-'A'+10) < base) {
34819c84:	16ef3073 	uxtbne	r3, r3
34819c88:	e2433037 	sub	r3, r3, #55	; 0x37
		}
	}
	if (!base) {
		base = 10;
	}
	while (isxdigit(*cp) && (value = isdigit(*cp) ? *cp-'0' : (islower(*cp)
34819c8c:	e1530002 	cmp	r3, r2
34819c90:	3afffff0 	bcc	34819c58 <simple_strtoul+0x60>
	    ? toupper(*cp) : *cp)-'A'+10) < base) {
		result = result*base + value;
		cp++;
	}
	if (endp)
34819c94:	e3510000 	cmp	r1, #0
		*endp = (char *)cp;
34819c98:	15815000 	strne	r5, [r1]
	return result;
}
34819c9c:	e8bd8070 	pop	{r4, r5, r6, pc}
34819ca0:	34821fd4 	.word	0x34821fd4

34819ca4 <strict_strtoul>:
{
	char *tail;
	unsigned long val;
	size_t len;

	*res = 0;
34819ca4:	e3a03000 	mov	r3, #0
		*endp = (char *)cp;
	return result;
}

int strict_strtoul(const char *cp, unsigned int base, unsigned long *res)
{
34819ca8:	e92d40f7 	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	char *tail;
	unsigned long val;
	size_t len;

	*res = 0;
34819cac:	e5823000 	str	r3, [r2]
		*endp = (char *)cp;
	return result;
}

int strict_strtoul(const char *cp, unsigned int base, unsigned long *res)
{
34819cb0:	e1a04000 	mov	r4, r0
34819cb4:	e1a07001 	mov	r7, r1
34819cb8:	e1a05002 	mov	r5, r2
	char *tail;
	unsigned long val;
	size_t len;

	*res = 0;
	len = strlen(cp);
34819cbc:	ebfffbaf 	bl	34818b80 <strlen>
	if (len == 0)
34819cc0:	e2506000 	subs	r6, r0, #0
34819cc4:	0a000012 	beq	34819d14 <strict_strtoul+0x70>
		return -EINVAL;

	val = simple_strtoul(cp, &tail, base);
34819cc8:	e1a00004 	mov	r0, r4
34819ccc:	e28d1004 	add	r1, sp, #4
34819cd0:	e1a02007 	mov	r2, r7
34819cd4:	ebffffc7 	bl	34819bf8 <simple_strtoul>
	if (tail == cp)
34819cd8:	e59d3004 	ldr	r3, [sp, #4]
34819cdc:	e1530004 	cmp	r3, r4
34819ce0:	0a00000b 	beq	34819d14 <strict_strtoul+0x70>
		return -EINVAL;

	if ((*tail == '\0') ||
34819ce4:	e5d32000 	ldrb	r2, [r3]
34819ce8:	e3520000 	cmp	r2, #0
34819cec:	0a000005 	beq	34819d08 <strict_strtoul+0x64>
		((len == (size_t)(tail - cp) + 1) && (*tail == '\n'))) {
34819cf0:	e0643003 	rsb	r3, r4, r3
34819cf4:	e2833001 	add	r3, r3, #1

	val = simple_strtoul(cp, &tail, base);
	if (tail == cp)
		return -EINVAL;

	if ((*tail == '\0') ||
34819cf8:	e1560003 	cmp	r6, r3
34819cfc:	1a000004 	bne	34819d14 <strict_strtoul+0x70>
		((len == (size_t)(tail - cp) + 1) && (*tail == '\n'))) {
34819d00:	e352000a 	cmp	r2, #10
34819d04:	1a000002 	bne	34819d14 <strict_strtoul+0x70>
		*res = val;
34819d08:	e5850000 	str	r0, [r5]
		return 0;
34819d0c:	e3a00000 	mov	r0, #0
34819d10:	ea000000 	b	34819d18 <strict_strtoul+0x74>
	}

	return -EINVAL;
34819d14:	e3e00015 	mvn	r0, #21
}
34819d18:	e8bd80fe 	pop	{r1, r2, r3, r4, r5, r6, r7, pc}

34819d1c <simple_strtol>:

long simple_strtol(const char *cp,char **endp,unsigned int base)
{
34819d1c:	e92d4010 	push	{r4, lr}
	if(*cp=='-')
34819d20:	e5d0c000 	ldrb	ip, [r0]
34819d24:	e35c002d 	cmp	ip, #45	; 0x2d
34819d28:	1a000003 	bne	34819d3c <simple_strtol+0x20>
		return -simple_strtoul(cp+1,endp,base);
34819d2c:	e2800001 	add	r0, r0, #1
34819d30:	ebffffb0 	bl	34819bf8 <simple_strtoul>
	return simple_strtoul(cp,endp,base);
}
34819d34:	e2600000 	rsb	r0, r0, #0
34819d38:	e8bd8010 	pop	{r4, pc}
34819d3c:	e8bd4010 	pop	{r4, lr}

long simple_strtol(const char *cp,char **endp,unsigned int base)
{
	if(*cp=='-')
		return -simple_strtoul(cp+1,endp,base);
	return simple_strtoul(cp,endp,base);
34819d40:	eaffffac 	b	34819bf8 <simple_strtoul>

34819d44 <ustrtoul>:
}

int ustrtoul(const char *cp, char **endp, unsigned int base)
{
34819d44:	e92d4010 	push	{r4, lr}
34819d48:	e1a04001 	mov	r4, r1
	unsigned long result = simple_strtoul(cp, endp, base);
34819d4c:	ebffffa9 	bl	34819bf8 <simple_strtoul>
	switch (**endp) {
34819d50:	e5943000 	ldr	r3, [r4]
34819d54:	e5d32000 	ldrb	r2, [r3]
34819d58:	e352004b 	cmp	r2, #75	; 0x4b
34819d5c:	0a00000a 	beq	34819d8c <ustrtoul+0x48>
34819d60:	8a000002 	bhi	34819d70 <ustrtoul+0x2c>
34819d64:	e3520047 	cmp	r2, #71	; 0x47
34819d68:	18bd8010 	popne	{r4, pc}
34819d6c:	ea000004 	b	34819d84 <ustrtoul+0x40>
34819d70:	e352004d 	cmp	r2, #77	; 0x4d
34819d74:	0a000003 	beq	34819d88 <ustrtoul+0x44>
34819d78:	e352006b 	cmp	r2, #107	; 0x6b
34819d7c:	18bd8010 	popne	{r4, pc}
34819d80:	ea000001 	b	34819d8c <ustrtoul+0x48>
	case 'G' :
		result *= 1024;
34819d84:	e1a00500 	lsl	r0, r0, #10
		/* fall through */
	case 'M':
		result *= 1024;
34819d88:	e1a00500 	lsl	r0, r0, #10
		/* fall through */
	case 'K':
	case 'k':
		result *= 1024;
		if ((*endp)[1] == 'i') {
34819d8c:	e5d32001 	ldrb	r2, [r3, #1]
	case 'M':
		result *= 1024;
		/* fall through */
	case 'K':
	case 'k':
		result *= 1024;
34819d90:	e1a00500 	lsl	r0, r0, #10
		if ((*endp)[1] == 'i') {
34819d94:	e3520069 	cmp	r2, #105	; 0x69
34819d98:	18bd8010 	popne	{r4, pc}
			if ((*endp)[2] == 'B')
34819d9c:	e5d31002 	ldrb	r1, [r3, #2]
34819da0:	e2832002 	add	r2, r3, #2
34819da4:	e3510042 	cmp	r1, #66	; 0x42
				(*endp) += 3;
34819da8:	02833003 	addeq	r3, r3, #3
34819dac:	05843000 	streq	r3, [r4]
			else
				(*endp) += 2;
34819db0:	15842000 	strne	r2, [r4]
		}
	}
	return result;
}
34819db4:	e8bd8010 	pop	{r4, pc}

34819db8 <simple_strtoull>:

unsigned long long simple_strtoull (const char *cp, char **endp, unsigned int base)
{
34819db8:	e92d4cf0 	push	{r4, r5, r6, r7, sl, fp, lr}
	unsigned long long result = 0, value;

	if (*cp == '0') {
34819dbc:	e5d03000 	ldrb	r3, [r0]
34819dc0:	e3530030 	cmp	r3, #48	; 0x30
34819dc4:	1a00000d 	bne	34819e00 <simple_strtoull+0x48>
		cp++;
		if ((*cp == 'x') && isxdigit (cp[1])) {
34819dc8:	e5f03001 	ldrb	r3, [r0, #1]!
34819dcc:	e3530078 	cmp	r3, #120	; 0x78
34819dd0:	1a000007 	bne	34819df4 <simple_strtoull+0x3c>
34819dd4:	e5d0c001 	ldrb	ip, [r0, #1]
34819dd8:	e59f40a8 	ldr	r4, [pc, #168]	; 34819e88 <simple_strtoull+0xd0>
34819ddc:	e2803001 	add	r3, r0, #1
34819de0:	e7d4c00c 	ldrb	ip, [r4, ip]
34819de4:	e31c0044 	tst	ip, #68	; 0x44
34819de8:	11a00003 	movne	r0, r3
			base = 16;
34819dec:	13a02010 	movne	r2, #16
{
	unsigned long long result = 0, value;

	if (*cp == '0') {
		cp++;
		if ((*cp == 'x') && isxdigit (cp[1])) {
34819df0:	1a000004 	bne	34819e08 <simple_strtoull+0x50>
			base = 16;
			cp++;
		}
		if (!base) {
			base = 8;
34819df4:	e3520000 	cmp	r2, #0
34819df8:	03a02008 	moveq	r2, #8
34819dfc:	ea000001 	b	34819e08 <simple_strtoull+0x50>
		}
	}
	if (!base) {
		base = 10;
34819e00:	e3520000 	cmp	r2, #0
34819e04:	03a0200a 	moveq	r2, #10
34819e08:	e3a04000 	mov	r4, #0
34819e0c:	e3a05000 	mov	r5, #0
	}
	while (isxdigit (*cp) && (value = isdigit (*cp)
34819e10:	e59fc070 	ldr	ip, [pc, #112]	; 34819e88 <simple_strtoull+0xd0>
				? *cp - '0'
				: (islower (*cp) ? toupper (*cp) : *cp) - 'A' + 10) < base) {
34819e14:	e3a03000 	mov	r3, #0
34819e18:	ea000003 	b	34819e2c <simple_strtoull+0x74>
		result = result * base + value;
34819e1c:	e0876294 	umull	r6, r7, r4, r2
34819e20:	e0277592 	mla	r7, r2, r5, r7
34819e24:	e09a4006 	adds	r4, sl, r6
34819e28:	e0ab5007 	adc	r5, fp, r7
34819e2c:	e1a07000 	mov	r7, r0
		}
	}
	if (!base) {
		base = 10;
	}
	while (isxdigit (*cp) && (value = isdigit (*cp)
34819e30:	e4d06001 	ldrb	r6, [r0], #1
34819e34:	e7dca006 	ldrb	sl, [ip, r6]
34819e38:	e31a0044 	tst	sl, #68	; 0x44
34819e3c:	0a00000c 	beq	34819e74 <simple_strtoull+0xbc>
34819e40:	e31a0004 	tst	sl, #4
34819e44:	12466030 	subne	r6, r6, #48	; 0x30
34819e48:	1a000003 	bne	34819e5c <simple_strtoull+0xa4>
34819e4c:	e31a0002 	tst	sl, #2
34819e50:	12466020 	subne	r6, r6, #32
				? *cp - '0'
				: (islower (*cp) ? toupper (*cp) : *cp) - 'A' + 10) < base) {
34819e54:	16ef6076 	uxtbne	r6, r6
		}
	}
	if (!base) {
		base = 10;
	}
	while (isxdigit (*cp) && (value = isdigit (*cp)
34819e58:	e2466037 	sub	r6, r6, #55	; 0x37
34819e5c:	e1a0a006 	mov	sl, r6
34819e60:	e1a0bfca 	asr	fp, sl, #31
34819e64:	e153000b 	cmp	r3, fp
34819e68:	1a000001 	bne	34819e74 <simple_strtoull+0xbc>
34819e6c:	e1520006 	cmp	r2, r6
34819e70:	8affffe9 	bhi	34819e1c <simple_strtoull+0x64>
				? *cp - '0'
				: (islower (*cp) ? toupper (*cp) : *cp) - 'A' + 10) < base) {
		result = result * base + value;
		cp++;
	}
	if (endp)
34819e74:	e3510000 	cmp	r1, #0
		*endp = (char *) cp;
34819e78:	15817000 	strne	r7, [r1]
	return result;
}
34819e7c:	e1a00004 	mov	r0, r4
34819e80:	e1a01005 	mov	r1, r5
34819e84:	e8bd8cf0 	pop	{r4, r5, r6, r7, sl, fp, pc}
34819e88:	34821fd4 	.word	0x34821fd4

34819e8c <vsprintf>:
 *
 * If you're not already dealing with a va_list consider using sprintf().
 */
int vsprintf(char *buf, const char *fmt, va_list args)
{
	return vsnprintf_internal(buf, INT_MAX, fmt, args);
34819e8c:	eafffdcb 	b	348195c0 <vsnprintf_internal.clone.6>

34819e90 <sprintf>:
}

int sprintf(char * buf, const char *fmt, ...)
{
34819e90:	e92d000e 	push	{r1, r2, r3}
34819e94:	e92d4003 	push	{r0, r1, lr}
 *
 * If you're not already dealing with a va_list consider using sprintf().
 */
int vsprintf(char *buf, const char *fmt, va_list args)
{
	return vsnprintf_internal(buf, INT_MAX, fmt, args);
34819e98:	e59d100c 	ldr	r1, [sp, #12]
int sprintf(char * buf, const char *fmt, ...)
{
	va_list args;
	int i;

	va_start(args, fmt);
34819e9c:	e28d2010 	add	r2, sp, #16
34819ea0:	e58d2004 	str	r2, [sp, #4]
 *
 * If you're not already dealing with a va_list consider using sprintf().
 */
int vsprintf(char *buf, const char *fmt, va_list args)
{
	return vsnprintf_internal(buf, INT_MAX, fmt, args);
34819ea4:	ebfffdc5 	bl	348195c0 <vsnprintf_internal.clone.6>

	va_start(args, fmt);
	i=vsprintf(buf,fmt,args);
	va_end(args);
	return i;
}
34819ea8:	e8bd400c 	pop	{r2, r3, lr}
34819eac:	e28dd00c 	add	sp, sp, #12
34819eb0:	e12fff1e 	bx	lr

34819eb4 <panic>:

void panic(const char *fmt, ...)
{
34819eb4:	e92d000f 	push	{r0, r1, r2, r3}
34819eb8:	e92d4007 	push	{r0, r1, r2, lr}
	va_list	args;
	va_start(args, fmt);
	vprintf(fmt, args);
34819ebc:	e59d0010 	ldr	r0, [sp, #16]
}

void panic(const char *fmt, ...)
{
	va_list	args;
	va_start(args, fmt);
34819ec0:	e28d1014 	add	r1, sp, #20
34819ec4:	e58d1004 	str	r1, [sp, #4]
	vprintf(fmt, args);
34819ec8:	ebffbc33 	bl	34808f9c <vprintf>
	putc('\n');
34819ecc:	e3a0000a 	mov	r0, #10
34819ed0:	ebffbc09 	bl	34808efc <putc>
	va_end(args);
#if defined (CONFIG_PANIC_HANG)
	hang();
#else
	udelay (100000);	/* allow messages to go out */
34819ed4:	e59f0018 	ldr	r0, [pc, #24]	; 34819ef4 <panic+0x40>
34819ed8:	ebfffc77 	bl	348190bc <udelay>
	do_reset (NULL, 0, 0, NULL);
34819edc:	e3a00000 	mov	r0, #0
34819ee0:	e1a01000 	mov	r1, r0
34819ee4:	e1a02000 	mov	r2, r0
34819ee8:	e1a03000 	mov	r3, r0
34819eec:	ebffa079 	bl	348020d8 <do_reset>
34819ef0:	eafffffe 	b	34819ef0 <panic+0x3c>
34819ef4:	000186a0 	.word	0x000186a0

34819ef8 <__assert_fail>:
		;
}

void __assert_fail(const char *assertion, const char *file, unsigned line,
		   const char *function)
{
34819ef8:	e92d4007 	push	{r0, r1, r2, lr}
	/* This will not return */
	panic("%s:%u: %s: Assertion `%s' failed.", file, line, function,
34819efc:	e58d0000 	str	r0, [sp]
34819f00:	e59f0000 	ldr	r0, [pc, #0]	; 34819f08 <__assert_fail+0x10>
34819f04:	ebffffea 	bl	34819eb4 <panic>
34819f08:	3482788b 	.word	0x3482788b

34819f0c <simple_itoa>:
	      assertion);
}

char *simple_itoa(ulong i)
{
34819f0c:	e92d4070 	push	{r4, r5, r6, lr}
	/* 21 digits plus null terminator, good for 64-bit or smaller ints */
	static char local[22];
	char *p = &local[21];

	*p-- = '\0';
34819f10:	e59f4048 	ldr	r4, [pc, #72]	; 34819f60 <simple_itoa+0x54>
34819f14:	e3a03000 	mov	r3, #0
34819f18:	e5c43015 	strb	r3, [r4, #21]
	panic("%s:%u: %s: Assertion `%s' failed.", file, line, function,
	      assertion);
}

char *simple_itoa(ulong i)
{
34819f1c:	e1a05000 	mov	r5, r0
	/* 21 digits plus null terminator, good for 64-bit or smaller ints */
	static char local[22];
	char *p = &local[21];

	*p-- = '\0';
34819f20:	e2844014 	add	r4, r4, #20
34819f24:	ea000000 	b	34819f2c <simple_itoa+0x20>
	do {
		*p-- = '0' + i % 10;
34819f28:	e1a04006 	mov	r4, r6
34819f2c:	e1a00005 	mov	r0, r5
34819f30:	e3a0100a 	mov	r1, #10
34819f34:	eb001855 	bl	34820090 <__aeabi_uidivmod>
34819f38:	e1a06004 	mov	r6, r4
34819f3c:	e2811030 	add	r1, r1, #48	; 0x30
34819f40:	e4461001 	strb	r1, [r6], #-1
		i /= 10;
34819f44:	e1a00005 	mov	r0, r5
34819f48:	e3a0100a 	mov	r1, #10
34819f4c:	eb0017d4 	bl	3481fea4 <__udivsi3>
	} while (i > 0);
34819f50:	e2505000 	subs	r5, r0, #0
34819f54:	1afffff3 	bne	34819f28 <simple_itoa+0x1c>
	return p + 1;
}
34819f58:	e1a00004 	mov	r0, r4
34819f5c:	e8bd8070 	pop	{r4, r5, r6, pc}
34819f60:	3482b340 	.word	0x3482b340

34819f64 <zcfree>:
void  zcfree (opaque, ptr, nb)
	voidpf opaque;
	voidpf ptr;
	unsigned nb;
{
	free(ptr);
34819f64:	e1a00001 	mov	r0, r1
34819f68:	eaffbd35 	b	34809444 <free>

34819f6c <zcalloc>:
	unsigned items;
	unsigned size;
{
	if (opaque)
		items += size - size; /* make compiler happy */
	return sizeof(uInt) > 2 ? (voidpf)malloc(items * size) :
34819f6c:	e0000291 	mul	r0, r1, r2
34819f70:	eaffbdbc 	b	34809668 <malloc>

34819f74 <inflate_fast>:
      output space.
 */
void inflate_fast(strm, start)
z_streamp strm;
unsigned start;         /* inflate()'s starting value for strm->avail_out */
{
34819f74:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
    unsigned char FAR *from;    /* where to copy match from */

    /* copy state to local variables */
    state = (struct inflate_state FAR *)strm->state;
    in = strm->next_in - OFF;
    last = in + (strm->avail_in - 5);
34819f78:	e5903004 	ldr	r3, [r0, #4]
    unsigned dist;              /* match distance */
    unsigned char FAR *from;    /* where to copy match from */

    /* copy state to local variables */
    state = (struct inflate_state FAR *)strm->state;
    in = strm->next_in - OFF;
34819f7c:	e5904000 	ldr	r4, [r0]
    last = in + (strm->avail_in - 5);
34819f80:	e2432005 	sub	r2, r3, #5
    unsigned dist;              /* match distance */
    unsigned char FAR *from;    /* where to copy match from */

    /* copy state to local variables */
    state = (struct inflate_state FAR *)strm->state;
    in = strm->next_in - OFF;
34819f84:	e2444001 	sub	r4, r4, #1
      output space.
 */
void inflate_fast(strm, start)
z_streamp strm;
unsigned start;         /* inflate()'s starting value for strm->avail_out */
{
34819f88:	e24dd048 	sub	sp, sp, #72	; 0x48

    /* copy state to local variables */
    state = (struct inflate_state FAR *)strm->state;
    in = strm->next_in - OFF;
    last = in + (strm->avail_in - 5);
    if (in > last && strm->avail_in > 5) {
34819f8c:	e0942002 	adds	r2, r4, r2
    unsigned len;               /* match length, unused bytes */
    unsigned dist;              /* match distance */
    unsigned char FAR *from;    /* where to copy match from */

    /* copy state to local variables */
    state = (struct inflate_state FAR *)strm->state;
34819f90:	e590501c 	ldr	r5, [r0, #28]
    in = strm->next_in - OFF;
    last = in + (strm->avail_in - 5);
    if (in > last && strm->avail_in > 5) {
34819f94:	e58d201c 	str	r2, [sp, #28]
34819f98:	3a000005 	bcc	34819fb4 <inflate_fast+0x40>
34819f9c:	e3530005 	cmp	r3, #5
        /*
         * overflow detected, limit strm->avail_in to the
         * max. possible size and recalculate last
         */
	strm->avail_in = 0xffffffff - (uintptr_t)in;
34819fa0:	81e03004 	mvnhi	r3, r4
34819fa4:	85803004 	strhi	r3, [r0, #4]
        last = in + (strm->avail_in - 5);
34819fa8:	82433005 	subhi	r3, r3, #5
34819fac:	80843003 	addhi	r3, r4, r3
34819fb0:	858d301c 	strhi	r3, [sp, #28]
    end = out + (strm->avail_out - 257);
#ifdef INFLATE_STRICT
    dmax = state->dmax;
#endif
    wsize = state->wsize;
    whave = state->whave;
34819fb4:	e595602c 	ldr	r6, [r5, #44]	; 0x2c
    write = state->write;
    window = state->window;
    hold = state->hold;
    bits = state->bits;
    lcode = state->lencode;
    dcode = state->distcode;
34819fb8:	e595c050 	ldr	ip, [r5, #80]	; 0x50
    end = out + (strm->avail_out - 257);
#ifdef INFLATE_STRICT
    dmax = state->dmax;
#endif
    wsize = state->wsize;
    whave = state->whave;
34819fbc:	e58d6038 	str	r6, [sp, #56]	; 0x38
    window = state->window;
    hold = state->hold;
    bits = state->bits;
    lcode = state->lencode;
    dcode = state->distcode;
    lmask = (1U << state->lenbits) - 1;
34819fc0:	e5956054 	ldr	r6, [r5, #84]	; 0x54
    write = state->write;
    window = state->window;
    hold = state->hold;
    bits = state->bits;
    lcode = state->lencode;
    dcode = state->distcode;
34819fc4:	e58dc024 	str	ip, [sp, #36]	; 0x24
    lmask = (1U << state->lenbits) - 1;
34819fc8:	e3a0c001 	mov	ip, #1
34819fcc:	e1a0661c 	lsl	r6, ip, r6
34819fd0:	e2466001 	sub	r6, r6, #1
34819fd4:	e58d603c 	str	r6, [sp, #60]	; 0x3c
    dmask = (1U << state->distbits) - 1;
34819fd8:	e5956058 	ldr	r6, [r5, #88]	; 0x58
         */
	strm->avail_in = 0xffffffff - (uintptr_t)in;
        last = in + (strm->avail_in - 5);
    }
    out = strm->next_out - OFF;
    beg = out - (start - strm->avail_out);
34819fdc:	e5902010 	ldr	r2, [r0, #16]
    hold = state->hold;
    bits = state->bits;
    lcode = state->lencode;
    dcode = state->distcode;
    lmask = (1U << state->lenbits) - 1;
    dmask = (1U << state->distbits) - 1;
34819fe0:	e1a0661c 	lsl	r6, ip, r6
         * max. possible size and recalculate last
         */
	strm->avail_in = 0xffffffff - (uintptr_t)in;
        last = in + (strm->avail_in - 5);
    }
    out = strm->next_out - OFF;
34819fe4:	e590300c 	ldr	r3, [r0, #12]
    beg = out - (start - strm->avail_out);
34819fe8:	e0611002 	rsb	r1, r1, r2
    end = out + (strm->avail_out - 257);
34819fec:	e2422c01 	sub	r2, r2, #256	; 0x100
         * max. possible size and recalculate last
         */
	strm->avail_in = 0xffffffff - (uintptr_t)in;
        last = in + (strm->avail_in - 5);
    }
    out = strm->next_out - OFF;
34819ff0:	e2433001 	sub	r3, r3, #1
    beg = out - (start - strm->avail_out);
    end = out + (strm->avail_out - 257);
34819ff4:	e2422001 	sub	r2, r2, #1
34819ff8:	e0832002 	add	r2, r3, r2
34819ffc:	e58d2028 	str	r2, [sp, #40]	; 0x28
#ifdef INFLATE_STRICT
    dmax = state->dmax;
#endif
    wsize = state->wsize;
3481a000:	e5952028 	ldr	r2, [r5, #40]	; 0x28
    whave = state->whave;
    write = state->write;
    window = state->window;
3481a004:	e5959034 	ldr	r9, [r5, #52]	; 0x34
    beg = out - (start - strm->avail_out);
    end = out + (strm->avail_out - 257);
#ifdef INFLATE_STRICT
    dmax = state->dmax;
#endif
    wsize = state->wsize;
3481a008:	e58d202c 	str	r2, [sp, #44]	; 0x2c
    hold = state->hold;
    bits = state->bits;
    lcode = state->lencode;
    dcode = state->distcode;
    lmask = (1U << state->lenbits) - 1;
    dmask = (1U << state->distbits) - 1;
3481a00c:	e2466001 	sub	r6, r6, #1
#ifdef INFLATE_STRICT
    dmax = state->dmax;
#endif
    wsize = state->wsize;
    whave = state->whave;
    write = state->write;
3481a010:	e5957030 	ldr	r7, [r5, #48]	; 0x30
    window = state->window;
3481a014:	e58d9030 	str	r9, [sp, #48]	; 0x30
    hold = state->hold;
    bits = state->bits;
    lcode = state->lencode;
    dcode = state->distcode;
    lmask = (1U << state->lenbits) - 1;
    dmask = (1U << state->distbits) - 1;
3481a018:	e58d6040 	str	r6, [sp, #64]	; 0x40
                    if (op > whave) {
                        strm->msg = (char *)"invalid distance too far back";
                        state->mode = BAD;
                        break;
                    }
                    from = window - OFF;
3481a01c:	e2496001 	sub	r6, r9, #1
                            } while (--op);
                            from = out - dist;  /* rest from output */
                        }
                    }
                    else if (write < op) {      /* wrap around window */
                        from += wsize + write - op;
3481a020:	e59d902c 	ldr	r9, [sp, #44]	; 0x2c
         */
	strm->avail_in = 0xffffffff - (uintptr_t)in;
        last = in + (strm->avail_in - 5);
    }
    out = strm->next_out - OFF;
    beg = out - (start - strm->avail_out);
3481a024:	e0831001 	add	r1, r3, r1
    whave = state->whave;
    write = state->write;
    window = state->window;
    hold = state->hold;
    bits = state->bits;
    lcode = state->lencode;
3481a028:	e595a04c 	ldr	sl, [r5, #76]	; 0x4c
         */
	strm->avail_in = 0xffffffff - (uintptr_t)in;
        last = in + (strm->avail_in - 5);
    }
    out = strm->next_out - OFF;
    beg = out - (start - strm->avail_out);
3481a02c:	e58d1034 	str	r1, [sp, #52]	; 0x34
                            } while (--op);
                            from = out - dist;  /* rest from output */
                        }
                    }
                    else if (write < op) {      /* wrap around window */
                        from += wsize + write - op;
3481a030:	e0879009 	add	r9, r7, r9
#endif
    wsize = state->wsize;
    whave = state->whave;
    write = state->write;
    window = state->window;
    hold = state->hold;
3481a034:	e5951038 	ldr	r1, [r5, #56]	; 0x38
    bits = state->bits;
3481a038:	e595203c 	ldr	r2, [r5, #60]	; 0x3c
    lcode = state->lencode;
3481a03c:	e58da020 	str	sl, [sp, #32]
                    if (op > whave) {
                        strm->msg = (char *)"invalid distance too far back";
                        state->mode = BAD;
                        break;
                    }
                    from = window - OFF;
3481a040:	e58d600c 	str	r6, [sp, #12]
                            } while (--op);
                            from = out - dist;  /* rest from output */
                        }
                    }
                    else if (write < op) {      /* wrap around window */
                        from += wsize + write - op;
3481a044:	e58d9044 	str	r9, [sp, #68]	; 0x44
3481a048:	e58d5010 	str	r5, [sp, #16]
3481a04c:	e58d0014 	str	r0, [sp, #20]
    dmask = (1U << state->distbits) - 1;

    /* decode literals and length/distances until end-of-block or not enough
       input data or output space */
    do {
        if (bits < 15) {
3481a050:	e352000e 	cmp	r2, #14
3481a054:	8a000007 	bhi	3481a078 <inflate_fast+0x104>
            hold += (unsigned long)(PUP(in)) << bits;
3481a058:	e5d4c001 	ldrb	ip, [r4, #1]
3481a05c:	e2840001 	add	r0, r4, #1
3481a060:	e081121c 	add	r1, r1, ip, lsl r2
            bits += 8;
            hold += (unsigned long)(PUP(in)) << bits;
3481a064:	e2804001 	add	r4, r0, #1
3481a068:	e5d00001 	ldrb	r0, [r0, #1]
    /* decode literals and length/distances until end-of-block or not enough
       input data or output space */
    do {
        if (bits < 15) {
            hold += (unsigned long)(PUP(in)) << bits;
            bits += 8;
3481a06c:	e2822008 	add	r2, r2, #8
            hold += (unsigned long)(PUP(in)) << bits;
3481a070:	e0811210 	add	r1, r1, r0, lsl r2
            bits += 8;
3481a074:	e2822008 	add	r2, r2, #8
        }
        this = lcode[hold & lmask];
3481a078:	e59da03c 	ldr	sl, [sp, #60]	; 0x3c
3481a07c:	e59d5020 	ldr	r5, [sp, #32]
3481a080:	e001000a 	and	r0, r1, sl
3481a084:	e085c100 	add	ip, r5, r0, lsl #2
3481a088:	e7d56100 	ldrb	r6, [r5, r0, lsl #2]
3481a08c:	e5dc0001 	ldrb	r0, [ip, #1]
3481a090:	e1dcc0b2 	ldrh	ip, [ip, #2]
3481a094:	e1a0a005 	mov	sl, r5
      dolen:
        op = (unsigned)(this.bits);
        hold >>= op;
        bits -= op;
        op = (unsigned)(this.op);
        if (op == 0) {                          /* literal */
3481a098:	e3560000 	cmp	r6, #0
            bits += 8;
        }
        this = lcode[hold & lmask];
      dolen:
        op = (unsigned)(this.bits);
        hold >>= op;
3481a09c:	e1a01031 	lsr	r1, r1, r0
        bits -= op;
3481a0a0:	e0602002 	rsb	r2, r0, r2
        op = (unsigned)(this.op);
        if (op == 0) {                          /* literal */
            Tracevv((stderr, this.val >= 0x20 && this.val < 0x7f ?
                    "inflate:         literal '%c'\n" :
                    "inflate:         literal 0x%02x\n", this.val));
            PUP(out) = (unsigned char)(this.val);
3481a0a4:	05e3c001 	strbeq	ip, [r3, #1]!
3481a0a8:	0a0000ed 	beq	3481a464 <inflate_fast+0x4f0>
        }
        else if (op & 16) {                     /* length base */
3481a0ac:	e3160010 	tst	r6, #16
3481a0b0:	0a0000d8 	beq	3481a418 <inflate_fast+0x4a4>
            len = (unsigned)(this.val);
            op &= 15;                           /* number of extra bits */
            if (op) {
3481a0b4:	e216600f 	ands	r6, r6, #15
                    "inflate:         literal '%c'\n" :
                    "inflate:         literal 0x%02x\n", this.val));
            PUP(out) = (unsigned char)(this.val);
        }
        else if (op & 16) {                     /* length base */
            len = (unsigned)(this.val);
3481a0b8:	e1a0000c 	mov	r0, ip
            op &= 15;                           /* number of extra bits */
            if (op) {
3481a0bc:	0a00000a 	beq	3481a0ec <inflate_fast+0x178>
                if (bits < op) {
3481a0c0:	e1520006 	cmp	r2, r6
                    hold += (unsigned long)(PUP(in)) << bits;
3481a0c4:	35f40001 	ldrbcc	r0, [r4, #1]!
                    bits += 8;
                }
                len += (unsigned)hold & ((1U << op) - 1);
3481a0c8:	e3a09001 	mov	r9, #1
        else if (op & 16) {                     /* length base */
            len = (unsigned)(this.val);
            op &= 15;                           /* number of extra bits */
            if (op) {
                if (bits < op) {
                    hold += (unsigned long)(PUP(in)) << bits;
3481a0cc:	30811210 	addcc	r1, r1, r0, lsl r2
                    bits += 8;
                }
                len += (unsigned)hold & ((1U << op) - 1);
3481a0d0:	e1a00619 	lsl	r0, r9, r6
3481a0d4:	e2400001 	sub	r0, r0, #1
3481a0d8:	e0010000 	and	r0, r1, r0
                hold >>= op;
3481a0dc:	e1a01631 	lsr	r1, r1, r6
            len = (unsigned)(this.val);
            op &= 15;                           /* number of extra bits */
            if (op) {
                if (bits < op) {
                    hold += (unsigned long)(PUP(in)) << bits;
                    bits += 8;
3481a0e0:	32822008 	addcc	r2, r2, #8
                }
                len += (unsigned)hold & ((1U << op) - 1);
3481a0e4:	e08c0000 	add	r0, ip, r0
                hold >>= op;
                bits -= op;
3481a0e8:	e0662002 	rsb	r2, r6, r2
            }
            Tracevv((stderr, "inflate:         length %u\n", len));
            if (bits < 15) {
3481a0ec:	e352000e 	cmp	r2, #14
3481a0f0:	8a000007 	bhi	3481a114 <inflate_fast+0x1a0>
                hold += (unsigned long)(PUP(in)) << bits;
3481a0f4:	e284c001 	add	ip, r4, #1
3481a0f8:	e5d44001 	ldrb	r4, [r4, #1]
3481a0fc:	e0811214 	add	r1, r1, r4, lsl r2
                bits += 8;
                hold += (unsigned long)(PUP(in)) << bits;
3481a100:	e28c4001 	add	r4, ip, #1
3481a104:	e5dcc001 	ldrb	ip, [ip, #1]
                bits -= op;
            }
            Tracevv((stderr, "inflate:         length %u\n", len));
            if (bits < 15) {
                hold += (unsigned long)(PUP(in)) << bits;
                bits += 8;
3481a108:	e2822008 	add	r2, r2, #8
                hold += (unsigned long)(PUP(in)) << bits;
3481a10c:	e081121c 	add	r1, r1, ip, lsl r2
                bits += 8;
3481a110:	e2822008 	add	r2, r2, #8
            }
            this = dcode[hold & dmask];
3481a114:	e59da040 	ldr	sl, [sp, #64]	; 0x40
3481a118:	e59d5024 	ldr	r5, [sp, #36]	; 0x24
3481a11c:	e001c00a 	and	ip, r1, sl
3481a120:	e085610c 	add	r6, r5, ip, lsl #2
3481a124:	e59d9024 	ldr	r9, [sp, #36]	; 0x24
3481a128:	e7d5c10c 	ldrb	ip, [r5, ip, lsl #2]
3481a12c:	e5d65001 	ldrb	r5, [r6, #1]
3481a130:	e1d660b2 	ldrh	r6, [r6, #2]
          dodist:
            op = (unsigned)(this.bits);
            hold >>= op;
            bits -= op;
            op = (unsigned)(this.op);
            if (op & 16) {                      /* distance base */
3481a134:	e31c0010 	tst	ip, #16
                bits += 8;
            }
            this = dcode[hold & dmask];
          dodist:
            op = (unsigned)(this.bits);
            hold >>= op;
3481a138:	e1a01531 	lsr	r1, r1, r5
            bits -= op;
3481a13c:	e0652002 	rsb	r2, r5, r2
            op = (unsigned)(this.op);
            if (op & 16) {                      /* distance base */
3481a140:	0a0000a1 	beq	3481a3cc <inflate_fast+0x458>
                dist = (unsigned)(this.val);
                op &= 15;                       /* number of extra bits */
3481a144:	e20cc00f 	and	ip, ip, #15
                if (bits < op) {
3481a148:	e152000c 	cmp	r2, ip
3481a14c:	2a000006 	bcs	3481a16c <inflate_fast+0x1f8>
                    hold += (unsigned long)(PUP(in)) << bits;
3481a150:	e5f45001 	ldrb	r5, [r4, #1]!
3481a154:	e0811215 	add	r1, r1, r5, lsl r2
                    bits += 8;
3481a158:	e2822008 	add	r2, r2, #8
                    if (bits < op) {
3481a15c:	e152000c 	cmp	r2, ip
                        hold += (unsigned long)(PUP(in)) << bits;
3481a160:	35f45001 	ldrbcc	r5, [r4, #1]!
3481a164:	30811215 	addcc	r1, r1, r5, lsl r2
                        bits += 8;
3481a168:	32822008 	addcc	r2, r2, #8
                    }
                }
                dist += (unsigned)hold & ((1U << op) - 1);
3481a16c:	e3a09001 	mov	r9, #1
3481a170:	e1a05c19 	lsl	r5, r9, ip
                }
#endif
                hold >>= op;
                bits -= op;
                Tracevv((stderr, "inflate:         distance %u\n", dist));
                op = (unsigned)(out - beg);     /* max distance in output */
3481a174:	e59da034 	ldr	sl, [sp, #52]	; 0x34
                    if (bits < op) {
                        hold += (unsigned long)(PUP(in)) << bits;
                        bits += 8;
                    }
                }
                dist += (unsigned)hold & ((1U << op) - 1);
3481a178:	e2455001 	sub	r5, r5, #1
3481a17c:	e0015005 	and	r5, r1, r5
3481a180:	e0855006 	add	r5, r5, r6
                    strm->msg = (char *)"invalid distance too far back";
                    state->mode = BAD;
                    break;
                }
#endif
                hold >>= op;
3481a184:	e1a01c31 	lsr	r1, r1, ip
                bits -= op;
3481a188:	e06c2002 	rsb	r2, ip, r2
                Tracevv((stderr, "inflate:         distance %u\n", dist));
                op = (unsigned)(out - beg);     /* max distance in output */
3481a18c:	e06ac003 	rsb	ip, sl, r3
                if (dist > op) {                /* see if copy from window */
3481a190:	e155000c 	cmp	r5, ip
3481a194:	9a000062 	bls	3481a324 <inflate_fast+0x3b0>
                    op = dist - op;             /* distance back in window */
                    if (op > whave) {
3481a198:	e59d6038 	ldr	r6, [sp, #56]	; 0x38
                hold >>= op;
                bits -= op;
                Tracevv((stderr, "inflate:         distance %u\n", dist));
                op = (unsigned)(out - beg);     /* max distance in output */
                if (dist > op) {                /* see if copy from window */
                    op = dist - op;             /* distance back in window */
3481a19c:	e06cc005 	rsb	ip, ip, r5
                    if (op > whave) {
3481a1a0:	e15c0006 	cmp	ip, r6
3481a1a4:	859d5010 	ldrhi	r5, [sp, #16]
3481a1a8:	859d0014 	ldrhi	r0, [sp, #20]
                        strm->msg = (char *)"invalid distance too far back";
3481a1ac:	859fc328 	ldrhi	ip, [pc, #808]	; 3481a4dc <inflate_fast+0x568>
3481a1b0:	8a000094 	bhi	3481a408 <inflate_fast+0x494>
                        state->mode = BAD;
                        break;
                    }
                    from = window - OFF;
                    if (write == 0) {           /* very common case */
3481a1b4:	e3570000 	cmp	r7, #0
                    if (op > whave) {
                        strm->msg = (char *)"invalid distance too far back";
                        state->mode = BAD;
                        break;
                    }
                    from = window - OFF;
3481a1b8:	e59da00c 	ldr	sl, [sp, #12]
                    if (write == 0) {           /* very common case */
3481a1bc:	1a000010 	bne	3481a204 <inflate_fast+0x290>
                        from += wsize - op;
3481a1c0:	e59d902c 	ldr	r9, [sp, #44]	; 0x2c
3481a1c4:	e59d600c 	ldr	r6, [sp, #12]
3481a1c8:	e06ca009 	rsb	sl, ip, r9
                        if (op < len) {         /* some from window */
3481a1cc:	e15c0000 	cmp	ip, r0
                        state->mode = BAD;
                        break;
                    }
                    from = window - OFF;
                    if (write == 0) {           /* very common case */
                        from += wsize - op;
3481a1d0:	e086a00a 	add	sl, r6, sl
                        if (op < len) {         /* some from window */
3481a1d4:	2a000008 	bcs	3481a1fc <inflate_fast+0x288>
                            len -= op;
3481a1d8:	e06c0000 	rsb	r0, ip, r0
3481a1dc:	e1a06003 	mov	r6, r3
3481a1e0:	e1a0b00c 	mov	fp, ip
3481a1e4:	e1a09004 	mov	r9, r4
                            do {
                                PUP(out) = PUP(from);
3481a1e8:	e5fa4001 	ldrb	r4, [sl, #1]!
                            } while (--op);
3481a1ec:	e25bb001 	subs	fp, fp, #1
                    if (write == 0) {           /* very common case */
                        from += wsize - op;
                        if (op < len) {         /* some from window */
                            len -= op;
                            do {
                                PUP(out) = PUP(from);
3481a1f0:	e5e64001 	strb	r4, [r6, #1]!
                            } while (--op);
3481a1f4:	1afffffb 	bne	3481a1e8 <inflate_fast+0x274>
3481a1f8:	ea000033 	b	3481a2cc <inflate_fast+0x358>
                            from = out - dist;  /* rest from output */
3481a1fc:	e1a0c003 	mov	ip, r3
3481a200:	ea00003b 	b	3481a2f4 <inflate_fast+0x380>
                        }
                    }
                    else if (write < op) {      /* wrap around window */
3481a204:	e157000c 	cmp	r7, ip
3481a208:	2a000022 	bcs	3481a298 <inflate_fast+0x324>
                        from += wsize + write - op;
3481a20c:	e59d9044 	ldr	r9, [sp, #68]	; 0x44
3481a210:	e59d600c 	ldr	r6, [sp, #12]
3481a214:	e06cb009 	rsb	fp, ip, r9
                        op -= write;
3481a218:	e067c00c 	rsb	ip, r7, ip
                            } while (--op);
                            from = out - dist;  /* rest from output */
                        }
                    }
                    else if (write < op) {      /* wrap around window */
                        from += wsize + write - op;
3481a21c:	e086b00b 	add	fp, r6, fp
                        op -= write;
                        if (op < len) {         /* some from end of window */
3481a220:	e15c0000 	cmp	ip, r0
                            } while (--op);
                            from = out - dist;  /* rest from output */
                        }
                    }
                    else if (write < op) {      /* wrap around window */
                        from += wsize + write - op;
3481a224:	21a0a00b 	movcs	sl, fp
                        op -= write;
                        if (op < len) {         /* some from end of window */
3481a228:	2afffff3 	bcs	3481a1fc <inflate_fast+0x288>
                            len -= op;
3481a22c:	e06c0000 	rsb	r0, ip, r0
3481a230:	e58d3018 	str	r3, [sp, #24]
3481a234:	e1a0600c 	mov	r6, ip
3481a238:	e1a09004 	mov	r9, r4
3481a23c:	e58d3004 	str	r3, [sp, #4]
                            do {
                                PUP(out) = PUP(from);
3481a240:	e5fb4001 	ldrb	r4, [fp, #1]!
3481a244:	e59d3018 	ldr	r3, [sp, #24]
                            } while (--op);
3481a248:	e2566001 	subs	r6, r6, #1
                        from += wsize + write - op;
                        op -= write;
                        if (op < len) {         /* some from end of window */
                            len -= op;
                            do {
                                PUP(out) = PUP(from);
3481a24c:	e5e34001 	strb	r4, [r3, #1]!
3481a250:	e58d3018 	str	r3, [sp, #24]
                            } while (--op);
3481a254:	1afffff9 	bne	3481a240 <inflate_fast+0x2cc>
3481a258:	e59d3004 	ldr	r3, [sp, #4]
                            from = window - OFF;
                            if (write < len) {  /* some from start of window */
3481a25c:	e1570000 	cmp	r7, r0
3481a260:	e1a04009 	mov	r4, r9
                        op -= write;
                        if (op < len) {         /* some from end of window */
                            len -= op;
                            do {
                                PUP(out) = PUP(from);
                            } while (--op);
3481a264:	e083300c 	add	r3, r3, ip
                            from = window - OFF;
                            if (write < len) {  /* some from start of window */
3481a268:	2affffe3 	bcs	3481a1fc <inflate_fast+0x288>
                                op = write;
                                len -= op;
3481a26c:	e0670000 	rsb	r0, r7, r0
3481a270:	e1a0c003 	mov	ip, r3
                                do {
                                    PUP(out) = PUP(from);
3481a274:	e59d9030 	ldr	r9, [sp, #48]	; 0x30
3481a278:	e7d9a006 	ldrb	sl, [r9, r6]
3481a27c:	e2866001 	add	r6, r6, #1
                                } while (--op);
3481a280:	e1570006 	cmp	r7, r6
                            from = window - OFF;
                            if (write < len) {  /* some from start of window */
                                op = write;
                                len -= op;
                                do {
                                    PUP(out) = PUP(from);
3481a284:	e5eca001 	strb	sl, [ip, #1]!
                                } while (--op);
3481a288:	1afffff9 	bne	3481a274 <inflate_fast+0x300>
3481a28c:	e0833007 	add	r3, r3, r7
                                from = out - dist;      /* rest from output */
3481a290:	e065a003 	rsb	sl, r5, r3
3481a294:	eaffffd8 	b	3481a1fc <inflate_fast+0x288>
                            }
                        }
                    }
                    else {                      /* contiguous in window */
                        from += write - op;
3481a298:	e59d600c 	ldr	r6, [sp, #12]
3481a29c:	e06ca007 	rsb	sl, ip, r7
                        if (op < len) {         /* some from window */
3481a2a0:	e15c0000 	cmp	ip, r0
                                from = out - dist;      /* rest from output */
                            }
                        }
                    }
                    else {                      /* contiguous in window */
                        from += write - op;
3481a2a4:	e086a00a 	add	sl, r6, sl
                        if (op < len) {         /* some from window */
3481a2a8:	2affffd3 	bcs	3481a1fc <inflate_fast+0x288>
                            len -= op;
3481a2ac:	e06c0000 	rsb	r0, ip, r0
3481a2b0:	e1a06003 	mov	r6, r3
3481a2b4:	e1a0b00c 	mov	fp, ip
3481a2b8:	e1a09004 	mov	r9, r4
                            do {
                                PUP(out) = PUP(from);
3481a2bc:	e5fa4001 	ldrb	r4, [sl, #1]!
                            } while (--op);
3481a2c0:	e25bb001 	subs	fp, fp, #1
                    else {                      /* contiguous in window */
                        from += write - op;
                        if (op < len) {         /* some from window */
                            len -= op;
                            do {
                                PUP(out) = PUP(from);
3481a2c4:	e5e64001 	strb	r4, [r6, #1]!
                            } while (--op);
3481a2c8:	1afffffb 	bne	3481a2bc <inflate_fast+0x348>
3481a2cc:	e1a04009 	mov	r4, r9
3481a2d0:	e083300c 	add	r3, r3, ip
3481a2d4:	eaffffed 	b	3481a290 <inflate_fast+0x31c>
                            from = out - dist;  /* rest from output */
                        }
                    }
                    while (len > 2) {
                        PUP(out) = PUP(from);
3481a2d8:	e5da3001 	ldrb	r3, [sl, #1]
                        PUP(out) = PUP(from);
                        PUP(out) = PUP(from);
                        len -= 3;
3481a2dc:	e2400003 	sub	r0, r0, #3
                            } while (--op);
                            from = out - dist;  /* rest from output */
                        }
                    }
                    while (len > 2) {
                        PUP(out) = PUP(from);
3481a2e0:	e5cc3001 	strb	r3, [ip, #1]
                        PUP(out) = PUP(from);
3481a2e4:	e5da3002 	ldrb	r3, [sl, #2]
3481a2e8:	e5cc3002 	strb	r3, [ip, #2]
                        PUP(out) = PUP(from);
3481a2ec:	e5fa3003 	ldrb	r3, [sl, #3]!
3481a2f0:	e5ec3003 	strb	r3, [ip, #3]!
                                PUP(out) = PUP(from);
                            } while (--op);
                            from = out - dist;  /* rest from output */
                        }
                    }
                    while (len > 2) {
3481a2f4:	e3500002 	cmp	r0, #2
                        PUP(out) = PUP(from);
                        PUP(out) = PUP(from);
                        PUP(out) = PUP(from);
                        len -= 3;
3481a2f8:	e1a0300c 	mov	r3, ip
                                PUP(out) = PUP(from);
                            } while (--op);
                            from = out - dist;  /* rest from output */
                        }
                    }
                    while (len > 2) {
3481a2fc:	8afffff5 	bhi	3481a2d8 <inflate_fast+0x364>
                        PUP(out) = PUP(from);
                        PUP(out) = PUP(from);
                        PUP(out) = PUP(from);
                        len -= 3;
                    }
                    if (len) {
3481a300:	e3500000 	cmp	r0, #0
3481a304:	0a000056 	beq	3481a464 <inflate_fast+0x4f0>
                        PUP(out) = PUP(from);
3481a308:	e5da5001 	ldrb	r5, [sl, #1]
3481a30c:	e28ac001 	add	ip, sl, #1
3481a310:	e5e35001 	strb	r5, [r3, #1]!
                        if (len > 1)
3481a314:	e3500002 	cmp	r0, #2
                            PUP(out) = PUP(from);
3481a318:	05dc0001 	ldrbeq	r0, [ip, #1]
                        PUP(out) = PUP(from);
                        len -= 3;
                    }
                    if (len) {
                        PUP(out) = PUP(from);
                        if (len > 1)
3481a31c:	0a000028 	beq	3481a3c4 <inflate_fast+0x450>
3481a320:	ea00004f 	b	3481a464 <inflate_fast+0x4f0>
		    unsigned long loops;

                    from = out - dist;          /* copy direct from output */
                    /* minimum length is three */
		    /* Align out addr */
		    if (!((long)(out - 1 + OFF) & 1)) {
3481a324:	e3130001 	tst	r3, #1
                }
                else {
		    unsigned short *sout;
		    unsigned long loops;

                    from = out - dist;          /* copy direct from output */
3481a328:	e0656003 	rsb	r6, r5, r3
                    /* minimum length is three */
		    /* Align out addr */
		    if (!((long)(out - 1 + OFF) & 1)) {
			PUP(out) = PUP(from);
3481a32c:	05f6c001 	ldrbeq	ip, [r6, #1]!
			len--;
3481a330:	02400001 	subeq	r0, r0, #1

                    from = out - dist;          /* copy direct from output */
                    /* minimum length is three */
		    /* Align out addr */
		    if (!((long)(out - 1 + OFF) & 1)) {
			PUP(out) = PUP(from);
3481a334:	05e3c001 	strbeq	ip, [r3, #1]!
			len--;
		    }
		    sout = (unsigned short *)(out - OFF);
		    if (dist > 2 ) {
3481a338:	e3550002 	cmp	r5, #2
		    /* Align out addr */
		    if (!((long)(out - 1 + OFF) & 1)) {
			PUP(out) = PUP(from);
			len--;
		    }
		    sout = (unsigned short *)(out - OFF);
3481a33c:	e243c001 	sub	ip, r3, #1
		    if (dist > 2 ) {
3481a340:	9a000010 	bls	3481a388 <inflate_fast+0x414>
			unsigned short *sfrom;

			sfrom = (unsigned short *)(from - OFF);
3481a344:	e2469001 	sub	r9, r6, #1
			loops = len >> 1;
3481a348:	e1a030a0 	lsr	r3, r0, #1
3481a34c:	e1a05006 	mov	r5, r6
		    }
		    sout = (unsigned short *)(out - OFF);
		    if (dist > 2 ) {
			unsigned short *sfrom;

			sfrom = (unsigned short *)(from - OFF);
3481a350:	e58d9018 	str	r9, [sp, #24]
			loops = len >> 1;
3481a354:	e1a0a00c 	mov	sl, ip
3481a358:	e1a06003 	mov	r6, r3

#include <linux/types.h>

static inline u16 __get_unaligned_le16(const u8 *p)
{
	return p[0] | p[1] << 8;
3481a35c:	e5d5b002 	ldrb	fp, [r5, #2]
3481a360:	e5d59001 	ldrb	r9, [r5, #1]
			do
			    PUP(sout) = get_unaligned(++sfrom);
			while (--loops);
3481a364:	e2566001 	subs	r6, r6, #1
3481a368:	e189940b 	orr	r9, r9, fp, lsl #8
			unsigned short *sfrom;

			sfrom = (unsigned short *)(from - OFF);
			loops = len >> 1;
			do
			    PUP(sout) = get_unaligned(++sfrom);
3481a36c:	e1ea90b2 	strh	r9, [sl, #2]!
			while (--loops);
3481a370:	e2855002 	add	r5, r5, #2
3481a374:	1afffff8 	bne	3481a35c <inflate_fast+0x3e8>
    - The maximum bytes that a single length/distance pair can output is 258
      bytes, which is the maximum length that can be coded.  inflate_fast()
      requires strm->avail_out >= 258 for each loop to avoid checking for
      output space.
 */
void inflate_fast(strm, start)
3481a378:	e59da018 	ldr	sl, [sp, #24]
3481a37c:	e08a6083 	add	r6, sl, r3, lsl #1

			sfrom = (unsigned short *)(from - OFF);
			loops = len >> 1;
			do
			    PUP(sout) = get_unaligned(++sfrom);
			while (--loops);
3481a380:	e2866001 	add	r6, r6, #1
3481a384:	ea000009 	b	3481a3b0 <inflate_fast+0x43c>
			out = (unsigned char *)sout + OFF;
			from = (unsigned char *)sfrom + OFF;
		    } else { /* dist == 1 or dist == 2 */
			unsigned short pat16;

			pat16 = *(sout-2+2*OFF);
3481a388:	e153a0b1 	ldrh	sl, [r3, #-1]
			if (dist == 1)
3481a38c:	e3550001 	cmp	r5, #1
#if defined(__BIG_ENDIAN)
			    pat16 = (pat16 & 0xff) | ((pat16 & 0xff ) << 8);
#elif defined(__LITTLE_ENDIAN)
			    pat16 = (pat16 & 0xff00) | ((pat16 & 0xff00 ) >> 8);
3481a390:	03ca30ff 	biceq	r3, sl, #255	; 0xff
3481a394:	0183a42a 	orreq	sl, r3, sl, lsr #8
#else
#error __BIG_ENDIAN nor __LITTLE_ENDIAN is defined
#endif
			loops = len >> 1;
3481a398:	e1a030a0 	lsr	r3, r0, #1
3481a39c:	e1a0900c 	mov	r9, ip
3481a3a0:	e1a05003 	mov	r5, r3
			do
			    PUP(sout) = pat16;
			while (--loops);
3481a3a4:	e2555001 	subs	r5, r5, #1
#else
#error __BIG_ENDIAN nor __LITTLE_ENDIAN is defined
#endif
			loops = len >> 1;
			do
			    PUP(sout) = pat16;
3481a3a8:	e1e9a0b2 	strh	sl, [r9, #2]!
			while (--loops);
3481a3ac:	1afffffc 	bne	3481a3a4 <inflate_fast+0x430>
			out = (unsigned char *)sout + OFF;
3481a3b0:	e08c3083 	add	r3, ip, r3, lsl #1
		    }
		    if (len & 1)
3481a3b4:	e3100001 	tst	r0, #1
#endif
			loops = len >> 1;
			do
			    PUP(sout) = pat16;
			while (--loops);
			out = (unsigned char *)sout + OFF;
3481a3b8:	e2833001 	add	r3, r3, #1
		    }
		    if (len & 1)
3481a3bc:	0a000028 	beq	3481a464 <inflate_fast+0x4f0>
			PUP(out) = PUP(from);
3481a3c0:	e5d60001 	ldrb	r0, [r6, #1]
3481a3c4:	e5e30001 	strb	r0, [r3, #1]!
3481a3c8:	ea000025 	b	3481a464 <inflate_fast+0x4f0>
                }
            }
            else if ((op & 64) == 0) {          /* 2nd level distance code */
3481a3cc:	e31c0040 	tst	ip, #64	; 0x40
3481a3d0:	1a000009 	bne	3481a3fc <inflate_fast+0x488>
                this = dcode[this.val + (hold & ((1U << op) - 1))];
3481a3d4:	e3a05001 	mov	r5, #1
3481a3d8:	e1a0cc15 	lsl	ip, r5, ip
3481a3dc:	e24cc001 	sub	ip, ip, #1
3481a3e0:	e00cc001 	and	ip, ip, r1
3481a3e4:	e08c6006 	add	r6, ip, r6
3481a3e8:	e089a106 	add	sl, r9, r6, lsl #2
3481a3ec:	e7d9c106 	ldrb	ip, [r9, r6, lsl #2]
3481a3f0:	e5da5001 	ldrb	r5, [sl, #1]
3481a3f4:	e1da60b2 	ldrh	r6, [sl, #2]
                goto dodist;
3481a3f8:	eaffff4d 	b	3481a134 <inflate_fast+0x1c0>
3481a3fc:	e59d5010 	ldr	r5, [sp, #16]
3481a400:	e59d0014 	ldr	r0, [sp, #20]
            }
            else {
                strm->msg = (char *)"invalid distance code";
3481a404:	e59fc0d4 	ldr	ip, [pc, #212]	; 3481a4e0 <inflate_fast+0x56c>
3481a408:	e580c018 	str	ip, [r0, #24]
                state->mode = BAD;
3481a40c:	e3a0c01b 	mov	ip, #27
3481a410:	e585c000 	str	ip, [r5]
                break;
3481a414:	ea000019 	b	3481a480 <inflate_fast+0x50c>
            }
        }
        else if ((op & 64) == 0) {              /* 2nd level length code */
3481a418:	e3160040 	tst	r6, #64	; 0x40
3481a41c:	1a000009 	bne	3481a448 <inflate_fast+0x4d4>
            this = lcode[this.val + (hold & ((1U << op) - 1))];
3481a420:	e3a09001 	mov	r9, #1
3481a424:	e1a06619 	lsl	r6, r9, r6
3481a428:	e2466001 	sub	r6, r6, #1
3481a42c:	e0066001 	and	r6, r6, r1
3481a430:	e086c00c 	add	ip, r6, ip
3481a434:	e08a510c 	add	r5, sl, ip, lsl #2
3481a438:	e7da610c 	ldrb	r6, [sl, ip, lsl #2]
3481a43c:	e5d50001 	ldrb	r0, [r5, #1]
3481a440:	e1d5c0b2 	ldrh	ip, [r5, #2]
            goto dolen;
3481a444:	eaffff13 	b	3481a098 <inflate_fast+0x124>
        }
        else if (op & 32) {                     /* end-of-block */
3481a448:	e3160020 	tst	r6, #32
3481a44c:	e59d5010 	ldr	r5, [sp, #16]
3481a450:	e59d0014 	ldr	r0, [sp, #20]
            Tracevv((stderr, "inflate:         end of block\n"));
            state->mode = TYPE;
3481a454:	13a0c00b 	movne	ip, #11
            break;
        }
        else {
            strm->msg = (char *)"invalid literal/length code";
3481a458:	059fc084 	ldreq	ip, [pc, #132]	; 3481a4e4 <inflate_fast+0x570>
        }
        else if ((op & 64) == 0) {              /* 2nd level length code */
            this = lcode[this.val + (hold & ((1U << op) - 1))];
            goto dolen;
        }
        else if (op & 32) {                     /* end-of-block */
3481a45c:	0affffe9 	beq	3481a408 <inflate_fast+0x494>
3481a460:	eaffffea 	b	3481a410 <inflate_fast+0x49c>
        else {
            strm->msg = (char *)"invalid literal/length code";
            state->mode = BAD;
            break;
        }
    } while (in < last && out < end);
3481a464:	e59da028 	ldr	sl, [sp, #40]	; 0x28
3481a468:	e59dc01c 	ldr	ip, [sp, #28]
3481a46c:	e153000a 	cmp	r3, sl
3481a470:	3154000c 	cmpcc	r4, ip
3481a474:	3afffef5 	bcc	3481a050 <inflate_fast+0xdc>
3481a478:	e59d5010 	ldr	r5, [sp, #16]
3481a47c:	e59d0014 	ldr	r0, [sp, #20]

    /* return unused bytes (on entry, bits < 8, so in won't go too far back) */
    len = bits >> 3;
3481a480:	e1a0c1a2 	lsr	ip, r2, #3
    in -= len;
3481a484:	e06c4004 	rsb	r4, ip, r4
    bits -= len << 3;
3481a488:	e1a0c18c 	lsl	ip, ip, #3
3481a48c:	e06c2002 	rsb	r2, ip, r2
    hold &= (1U << bits) - 1;
3481a490:	e3e0c000 	mvn	ip, #0
3481a494:	e1c1121c 	bic	r1, r1, ip, lsl r2
3481a498:	e59d601c 	ldr	r6, [sp, #28]

    /* update state and return */
    strm->next_in = in + OFF;
3481a49c:	e284c001 	add	ip, r4, #1
3481a4a0:	e580c000 	str	ip, [r0]
3481a4a4:	e59d9028 	ldr	r9, [sp, #40]	; 0x28
    strm->next_out = out + OFF;
3481a4a8:	e283c001 	add	ip, r3, #1
3481a4ac:	e580c00c 	str	ip, [r0, #12]
3481a4b0:	e286c005 	add	ip, r6, #5
    strm->avail_in = (unsigned)(in < last ? 5 + (last - in) : 5 - (in - last));
3481a4b4:	e064400c 	rsb	r4, r4, ip
3481a4b8:	e289cc01 	add	ip, r9, #256	; 0x100
3481a4bc:	e28cc001 	add	ip, ip, #1
    strm->avail_out = (unsigned)(out < end ?
                                 257 + (end - out) : 257 - (out - end));
3481a4c0:	e063300c 	rsb	r3, r3, ip
    hold &= (1U << bits) - 1;

    /* update state and return */
    strm->next_in = in + OFF;
    strm->next_out = out + OFF;
    strm->avail_in = (unsigned)(in < last ? 5 + (last - in) : 5 - (in - last));
3481a4c4:	e5804004 	str	r4, [r0, #4]
    strm->avail_out = (unsigned)(out < end ?
3481a4c8:	e5803010 	str	r3, [r0, #16]
                                 257 + (end - out) : 257 - (out - end));
    state->hold = hold;
3481a4cc:	e5851038 	str	r1, [r5, #56]	; 0x38
    state->bits = bits;
3481a4d0:	e585203c 	str	r2, [r5, #60]	; 0x3c
    return;
}
3481a4d4:	e28dd048 	add	sp, sp, #72	; 0x48
3481a4d8:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
3481a4dc:	348278ad 	.word	0x348278ad
3481a4e0:	348278cb 	.word	0x348278cb
3481a4e4:	348278e1 	.word	0x348278e1

3481a4e8 <inflate_table>:
unsigned short FAR *lens;
unsigned codes;
code FAR * FAR *table;
unsigned FAR *bits;
unsigned short FAR *work;
{
3481a4e8:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
3481a4ec:	e24dd088 	sub	sp, sp, #136	; 0x88
    }

    /* set return parameters */
    *table += used;
    *bits = root;
    return 0;
3481a4f0:	e28d4068 	add	r4, sp, #104	; 0x68
unsigned short FAR *lens;
unsigned codes;
code FAR * FAR *table;
unsigned FAR *bits;
unsigned short FAR *work;
{
3481a4f4:	e58d1030 	str	r1, [sp, #48]	; 0x30
3481a4f8:	e59d10ac 	ldr	r1, [sp, #172]	; 0xac
    }

    /* set return parameters */
    *table += used;
    *bits = root;
    return 0;
3481a4fc:	e28dc066 	add	ip, sp, #102	; 0x66
   on return points to the next available entry's address.  bits is the
   requested root table index bits, and on return it is the actual root
   table index bits.  It will differ if the request is greater than the
   longest code or if it is less than the shortest code.
 */
int inflate_table(type, lens, codes, table, bits, work)
3481a500:	e1a05004 	mov	r5, r4
3481a504:	e284701e 	add	r7, r4, #30
       decoding tables.
     */

    /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
    for (len = 0; len <= MAXBITS; len++)
        count[len] = 0;
3481a508:	e3a06000 	mov	r6, #0
3481a50c:	e1ec60b2 	strh	r6, [ip, #2]!
       at length counts to determine sub-table sizes when building the
       decoding tables.
     */

    /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
    for (len = 0; len <= MAXBITS; len++)
3481a510:	e15c0007 	cmp	ip, r7
3481a514:	1afffffb 	bne	3481a508 <inflate_table+0x20>
3481a518:	e59db030 	ldr	fp, [sp, #48]	; 0x30
3481a51c:	e3a0c000 	mov	ip, #0
3481a520:	e1a0600b 	mov	r6, fp
3481a524:	ea000006 	b	3481a544 <inflate_table+0x5c>
        count[len] = 0;
    for (sym = 0; sym < codes; sym++)
        count[lens[sym]]++;
3481a528:	e0d690b2 	ldrh	r9, [r6], #2
3481a52c:	e28da088 	add	sl, sp, #136	; 0x88
3481a530:	e08a9089 	add	r9, sl, r9, lsl #1
3481a534:	e159a2b0 	ldrh	sl, [r9, #-32]	; 0xffffffe0
     */

    /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
    for (len = 0; len <= MAXBITS; len++)
        count[len] = 0;
    for (sym = 0; sym < codes; sym++)
3481a538:	e28cc001 	add	ip, ip, #1
        count[lens[sym]]++;
3481a53c:	e28aa001 	add	sl, sl, #1
3481a540:	e149a2b0 	strh	sl, [r9, #-32]	; 0xffffffe0
     */

    /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
    for (len = 0; len <= MAXBITS; len++)
        count[len] = 0;
    for (sym = 0; sym < codes; sym++)
3481a544:	e15c0002 	cmp	ip, r2
3481a548:	3afffff6 	bcc	3481a528 <inflate_table+0x40>
        count[lens[sym]]++;

    /* bound code lengths, force root to be within code lengths */
    root = *bits;
3481a54c:	e59d60a8 	ldr	r6, [sp, #168]	; 0xa8
3481a550:	e28da088 	add	sl, sp, #136	; 0x88
3481a554:	e596c000 	ldr	ip, [r6]
    for (max = MAXBITS; max >= 1; max--)
3481a558:	e3a0600f 	mov	r6, #15
        if (count[max] != 0) break;
3481a55c:	e17a90b2 	ldrh	r9, [sl, #-2]!
3481a560:	e3590000 	cmp	r9, #0
3481a564:	0a000004 	beq	3481a57c <inflate_table+0x94>
    if (root > max) root = max;
    if (max == 0) {                     /* no symbols to code at all */
3481a568:	e3560000 	cmp	r6, #0
3481a56c:	11a0a004 	movne	sl, r4
3481a570:	13a04001 	movne	r4, #1
3481a574:	1a000013 	bne	3481a5c8 <inflate_table+0xe0>
3481a578:	ea000001 	b	3481a584 <inflate_table+0x9c>
    for (sym = 0; sym < codes; sym++)
        count[lens[sym]]++;

    /* bound code lengths, force root to be within code lengths */
    root = *bits;
    for (max = MAXBITS; max >= 1; max--)
3481a57c:	e2566001 	subs	r6, r6, #1
3481a580:	1afffff5 	bne	3481a55c <inflate_table+0x74>
    if (root > max) root = max;
    if (max == 0) {                     /* no symbols to code at all */
        this.op = (unsigned char)64;    /* invalid code marker */
        this.bits = (unsigned char)1;
        this.val = (unsigned short)0;
        *(*table)++ = this;             /* make a table to force an error */
3481a584:	e5932000 	ldr	r2, [r3]
3481a588:	e3a01001 	mov	r1, #1
3481a58c:	e2820004 	add	r0, r2, #4
3481a590:	e3a0c040 	mov	ip, #64	; 0x40
3481a594:	e5c21001 	strb	r1, [r2, #1]
3481a598:	e5c2c000 	strb	ip, [r2]
3481a59c:	e5c01001 	strb	r1, [r0, #1]
3481a5a0:	e5c2c004 	strb	ip, [r2, #4]
3481a5a4:	e3a07000 	mov	r7, #0
        *(*table)++ = this;
        *bits = 1;
3481a5a8:	e59d90a8 	ldr	r9, [sp, #168]	; 0xa8
    if (root > max) root = max;
    if (max == 0) {                     /* no symbols to code at all */
        this.op = (unsigned char)64;    /* invalid code marker */
        this.bits = (unsigned char)1;
        this.val = (unsigned short)0;
        *(*table)++ = this;             /* make a table to force an error */
3481a5ac:	e1c270b2 	strh	r7, [r2, #2]
3481a5b0:	e1c070b2 	strh	r7, [r0, #2]
        *(*table)++ = this;
3481a5b4:	e2800004 	add	r0, r0, #4
3481a5b8:	e5830000 	str	r0, [r3]
        *bits = 1;
3481a5bc:	e5891000 	str	r1, [r9]
        return 0;     /* no symbols, but wait for decoding to report error */
3481a5c0:	e3a00000 	mov	r0, #0
3481a5c4:	ea00011e 	b	3481aa44 <inflate_table+0x55c>
    }
    for (min = 1; min <= MAXBITS; min++)
        if (count[min] != 0) break;
3481a5c8:	e1fa90b2 	ldrh	r9, [sl, #2]!
3481a5cc:	e3590000 	cmp	r9, #0
3481a5d0:	1a000004 	bne	3481a5e8 <inflate_table+0x100>
        *(*table)++ = this;             /* make a table to force an error */
        *(*table)++ = this;
        *bits = 1;
        return 0;     /* no symbols, but wait for decoding to report error */
    }
    for (min = 1; min <= MAXBITS; min++)
3481a5d4:	e2844001 	add	r4, r4, #1
3481a5d8:	e3540010 	cmp	r4, #16
3481a5dc:	1afffff9 	bne	3481a5c8 <inflate_table+0xe0>
3481a5e0:	e1a0c004 	mov	ip, r4
3481a5e4:	ea000003 	b	3481a5f8 <inflate_table+0x110>
3481a5e8:	e156000c 	cmp	r6, ip
3481a5ec:	31a0c006 	movcc	ip, r6
        if (count[min] != 0) break;
    if (root < min) root = min;
3481a5f0:	e15c0004 	cmp	ip, r4
3481a5f4:	31a0c004 	movcc	ip, r4

    /* check for an over-subscribed or incomplete set of lengths */
    left = 1;
3481a5f8:	e3a09001 	mov	r9, #1
    for (len = 1; len <= MAXBITS; len++) {
        left <<= 1;
3481a5fc:	e1a0a089 	lsl	sl, r9, #1
        left -= count[len];
3481a600:	e1f590b2 	ldrh	r9, [r5, #2]!
        if (left < 0) return -1;        /* over-subscribed */
3481a604:	e05a9009 	subs	r9, sl, r9
3481a608:	4a00010a 	bmi	3481aa38 <inflate_table+0x550>
        if (count[min] != 0) break;
    if (root < min) root = min;

    /* check for an over-subscribed or incomplete set of lengths */
    left = 1;
    for (len = 1; len <= MAXBITS; len++) {
3481a60c:	e1550007 	cmp	r5, r7
3481a610:	1afffff9 	bne	3481a5fc <inflate_table+0x114>
        left <<= 1;
        left -= count[len];
        if (left < 0) return -1;        /* over-subscribed */
    }
    if (left > 0 && (type == CODES || max != 1))
3481a614:	e3590000 	cmp	r9, #0
3481a618:	0a000005 	beq	3481a634 <inflate_table+0x14c>
3481a61c:	e2705001 	rsbs	r5, r0, #1
3481a620:	33a05000 	movcc	r5, #0
3481a624:	e3560001 	cmp	r6, #1
3481a628:	13855001 	orrne	r5, r5, #1
3481a62c:	e3550000 	cmp	r5, #0
3481a630:	1a000100 	bne	3481aa38 <inflate_table+0x550>
        return -1;                      /* incomplete set */

    /* generate offsets into symbol table for each length for sorting */
    offs[1] = 0;
3481a634:	e3a0a000 	mov	sl, #0
3481a638:	e1cda4ba 	strh	sl, [sp, #74]	; 0x4a
3481a63c:	e28d7048 	add	r7, sp, #72	; 0x48
3481a640:	e3a05000 	mov	r5, #0
   on return points to the next available entry's address.  bits is the
   requested root table index bits, and on return it is the actual root
   table index bits.  It will differ if the request is greater than the
   longest code or if it is less than the shortest code.
 */
int inflate_table(type, lens, codes, table, bits, work)
3481a644:	e2855002 	add	r5, r5, #2
        return -1;                      /* incomplete set */

    /* generate offsets into symbol table for each length for sorting */
    offs[1] = 0;
    for (len = 1; len < MAXBITS; len++)
        offs[len + 1] = offs[len] + count[len];
3481a648:	e28da068 	add	sl, sp, #104	; 0x68
3481a64c:	e19a90b5 	ldrh	r9, [sl, r5]
3481a650:	e1d7a0b2 	ldrh	sl, [r7, #2]
    if (left > 0 && (type == CODES || max != 1))
        return -1;                      /* incomplete set */

    /* generate offsets into symbol table for each length for sorting */
    offs[1] = 0;
    for (len = 1; len < MAXBITS; len++)
3481a654:	e355001c 	cmp	r5, #28
        offs[len + 1] = offs[len] + count[len];
3481a658:	e089a00a 	add	sl, r9, sl
3481a65c:	e1c7a0b4 	strh	sl, [r7, #4]
3481a660:	e2877002 	add	r7, r7, #2
    if (left > 0 && (type == CODES || max != 1))
        return -1;                      /* incomplete set */

    /* generate offsets into symbol table for each length for sorting */
    offs[1] = 0;
    for (len = 1; len < MAXBITS; len++)
3481a664:	1afffff6 	bne	3481a644 <inflate_table+0x15c>
3481a668:	e3a05000 	mov	r5, #0
3481a66c:	ea00000a 	b	3481a69c <inflate_table+0x1b4>
        offs[len + 1] = offs[len] + count[len];

    /* sort symbols by length, by symbol order within each length */
    for (sym = 0; sym < codes; sym++)
        if (lens[sym] != 0) work[offs[lens[sym]]++] = (unsigned short)sym;
3481a670:	e0db90b2 	ldrh	r9, [fp], #2
3481a674:	e3590000 	cmp	r9, #0
3481a678:	0a000006 	beq	3481a698 <inflate_table+0x1b0>
3481a67c:	e28d7088 	add	r7, sp, #136	; 0x88
3481a680:	e0879089 	add	r9, r7, r9, lsl #1
3481a684:	e15974b0 	ldrh	r7, [r9, #-64]	; 0xffffffc0
3481a688:	e1a0a087 	lsl	sl, r7, #1
3481a68c:	e2877001 	add	r7, r7, #1
3481a690:	e18150ba 	strh	r5, [r1, sl]
3481a694:	e14974b0 	strh	r7, [r9, #-64]	; 0xffffffc0
    offs[1] = 0;
    for (len = 1; len < MAXBITS; len++)
        offs[len + 1] = offs[len] + count[len];

    /* sort symbols by length, by symbol order within each length */
    for (sym = 0; sym < codes; sym++)
3481a698:	e2855001 	add	r5, r5, #1
3481a69c:	e1550002 	cmp	r5, r2
3481a6a0:	3afffff2 	bcc	3481a670 <inflate_table+0x188>
       routine permits incomplete codes, so another loop after this one fills
       in the rest of the decoding tables with invalid code markers.
     */

    /* set up for code type */
    switch (type) {
3481a6a4:	e3500000 	cmp	r0, #0
3481a6a8:	0a00000f 	beq	3481a6ec <inflate_table+0x204>
3481a6ac:	e3500001 	cmp	r0, #1
3481a6b0:	1a000006 	bne	3481a6d0 <inflate_table+0x1e8>
        break;
    case LENS:
        base = lbase;
        base -= 257;
        extra = lext;
        extra -= 257;
3481a6b4:	e59fa390 	ldr	sl, [pc, #912]	; 3481aa4c <inflate_table+0x564>
        end = 256;
3481a6b8:	e3a09c01 	mov	r9, #256	; 0x100
        base = extra = work;    /* dummy value--not used */
        end = 19;
        break;
    case LENS:
        base = lbase;
        base -= 257;
3481a6bc:	e28a2040 	add	r2, sl, #64	; 0x40
        extra = lext;
        extra -= 257;
        end = 256;
3481a6c0:	e58d9020 	str	r9, [sp, #32]
        break;
    case LENS:
        base = lbase;
        base -= 257;
        extra = lext;
        extra -= 257;
3481a6c4:	e58da010 	str	sl, [sp, #16]
        base = extra = work;    /* dummy value--not used */
        end = 19;
        break;
    case LENS:
        base = lbase;
        base -= 257;
3481a6c8:	e58d201c 	str	r2, [sp, #28]
3481a6cc:	ea00000a 	b	3481a6fc <inflate_table+0x214>
        extra -= 257;
        end = 256;
        break;
    default:            /* DISTS */
        base = dbase;
        extra = dext;
3481a6d0:	e59f7378 	ldr	r7, [pc, #888]	; 3481aa50 <inflate_table+0x568>
        end = -1;
3481a6d4:	e3e05000 	mvn	r5, #0
        extra = lext;
        extra -= 257;
        end = 256;
        break;
    default:            /* DISTS */
        base = dbase;
3481a6d8:	e2879040 	add	r9, r7, #64	; 0x40
        extra = dext;
        end = -1;
3481a6dc:	e58d5020 	str	r5, [sp, #32]
        extra -= 257;
        end = 256;
        break;
    default:            /* DISTS */
        base = dbase;
        extra = dext;
3481a6e0:	e58d7010 	str	r7, [sp, #16]
        extra = lext;
        extra -= 257;
        end = 256;
        break;
    default:            /* DISTS */
        base = dbase;
3481a6e4:	e58d901c 	str	r9, [sp, #28]
3481a6e8:	ea000003 	b	3481a6fc <inflate_table+0x214>

    /* set up for code type */
    switch (type) {
    case CODES:
        base = extra = work;    /* dummy value--not used */
        end = 19;
3481a6ec:	e3a0a013 	mov	sl, #19
     */

    /* set up for code type */
    switch (type) {
    case CODES:
        base = extra = work;    /* dummy value--not used */
3481a6f0:	e58d1010 	str	r1, [sp, #16]
3481a6f4:	e58d101c 	str	r1, [sp, #28]
        end = 19;
3481a6f8:	e58da020 	str	sl, [sp, #32]
    len = min;                  /* starting code length */
    next = *table;              /* current table to fill in */
    curr = root;                /* current table index bits */
    drop = 0;                   /* current bits to drop from code for index */
    low = (unsigned)(-1);       /* trigger new sub-table when len > root */
    used = 1U << root;          /* use root table entries */
3481a6fc:	e3a0a001 	mov	sl, #1
3481a700:	e1a02c1a 	lsl	r2, sl, ip
    mask = used - 1;            /* mask for comparing low */

    /* check available table space */
    if (type == LENS && used >= ENOUGH - MAXD)
3481a704:	e150000a 	cmp	r0, sl
3481a708:	13a00000 	movne	r0, #0
3481a70c:	03a00001 	moveq	r0, #1

    /* initialize state for loop */
    huff = 0;                   /* starting code */
    sym = 0;                    /* starting code symbol */
    len = min;                  /* starting code length */
    next = *table;              /* current table to fill in */
3481a710:	e5937000 	ldr	r7, [r3]
    curr = root;                /* current table index bits */
    drop = 0;                   /* current bits to drop from code for index */
    low = (unsigned)(-1);       /* trigger new sub-table when len > root */
    used = 1U << root;          /* use root table entries */
3481a714:	e58d200c 	str	r2, [sp, #12]
    mask = used - 1;            /* mask for comparing low */

    /* check available table space */
    if (type == LENS && used >= ENOUGH - MAXD)
3481a718:	e58d0038 	str	r0, [sp, #56]	; 0x38
    next = *table;              /* current table to fill in */
    curr = root;                /* current table index bits */
    drop = 0;                   /* current bits to drop from code for index */
    low = (unsigned)(-1);       /* trigger new sub-table when len > root */
    used = 1U << root;          /* use root table entries */
    mask = used - 1;            /* mask for comparing low */
3481a71c:	e2425001 	sub	r5, r2, #1

    /* check available table space */
    if (type == LENS && used >= ENOUGH - MAXD)
3481a720:	e59d900c 	ldr	r9, [sp, #12]
3481a724:	e59d2038 	ldr	r2, [sp, #56]	; 0x38
3481a728:	e30005af 	movw	r0, #1455	; 0x5af
3481a72c:	e1590000 	cmp	r9, r0
3481a730:	93a02000 	movls	r2, #0
3481a734:	82022001 	andhi	r2, r2, #1
3481a738:	e3520000 	cmp	r2, #0
    next = *table;              /* current table to fill in */
    curr = root;                /* current table index bits */
    drop = 0;                   /* current bits to drop from code for index */
    low = (unsigned)(-1);       /* trigger new sub-table when len > root */
    used = 1U << root;          /* use root table entries */
    mask = used - 1;            /* mask for comparing low */
3481a73c:	e58d5034 	str	r5, [sp, #52]	; 0x34

    /* check available table space */
    if (type == LENS && used >= ENOUGH - MAXD)
        return 1;
3481a740:	11a0000a 	movne	r0, sl
    low = (unsigned)(-1);       /* trigger new sub-table when len > root */
    used = 1U << root;          /* use root table entries */
    mask = used - 1;            /* mask for comparing low */

    /* check available table space */
    if (type == LENS && used >= ENOUGH - MAXD)
3481a744:	1a0000be 	bne	3481aa44 <inflate_table+0x55c>
3481a748:	e58d1018 	str	r1, [sp, #24]
3481a74c:	e3e01000 	mvn	r1, #0
3481a750:	e58d1014 	str	r1, [sp, #20]
3481a754:	e1a0500c 	mov	r5, ip
3481a758:	e1a01002 	mov	r1, r2
3481a75c:	e1a0b006 	mov	fp, r6
3481a760:	ea000000 	b	3481a768 <inflate_table+0x280>
3481a764:	e58d0014 	str	r0, [sp, #20]

    /* process all codes and make table entries */
    for (;;) {
        /* create table entry */
        this.bits = (unsigned char)(len - drop);
        if ((int)(work[sym]) < end) {
3481a768:	e59d6018 	ldr	r6, [sp, #24]
3481a76c:	e59d9020 	ldr	r9, [sp, #32]
3481a770:	e0d6a0b2 	ldrh	sl, [r6], #2
        return 1;

    /* process all codes and make table entries */
    for (;;) {
        /* create table entry */
        this.bits = (unsigned char)(len - drop);
3481a774:	e0610004 	rsb	r0, r1, r4
        if ((int)(work[sym]) < end) {
3481a778:	e15a0009 	cmp	sl, r9
        return 1;

    /* process all codes and make table entries */
    for (;;) {
        /* create table entry */
        this.bits = (unsigned char)(len - drop);
3481a77c:	e6ef0070 	uxtb	r0, r0
        if ((int)(work[sym]) < end) {
            this.op = (unsigned char)0;
3481a780:	b3a09000 	movlt	r9, #0
        return 1;

    /* process all codes and make table entries */
    for (;;) {
        /* create table entry */
        this.bits = (unsigned char)(len - drop);
3481a784:	e58d003c 	str	r0, [sp, #60]	; 0x3c
        if ((int)(work[sym]) < end) {
3481a788:	e58d6018 	str	r6, [sp, #24]
            this.op = (unsigned char)0;
3481a78c:	b58d902c 	strlt	r9, [sp, #44]	; 0x2c

    /* process all codes and make table entries */
    for (;;) {
        /* create table entry */
        this.bits = (unsigned char)(len - drop);
        if ((int)(work[sym]) < end) {
3481a790:	ba000008 	blt	3481a7b8 <inflate_table+0x2d0>
            this.op = (unsigned char)0;
            this.val = work[sym];
        }
        else if ((int)(work[sym]) > end) {
            this.op = (unsigned char)(extra[work[sym]]);
3481a794:	c59d0010 	ldrgt	r0, [sp, #16]
3481a798:	c1a0a08a 	lslgt	sl, sl, #1
            this.val = base[work[sym]];
3481a79c:	c59d601c 	ldrgt	r6, [sp, #28]
        if ((int)(work[sym]) < end) {
            this.op = (unsigned char)0;
            this.val = work[sym];
        }
        else if ((int)(work[sym]) > end) {
            this.op = (unsigned char)(extra[work[sym]]);
3481a7a0:	c7d0000a 	ldrbgt	r0, [r0, sl]
            this.val = base[work[sym]];
        }
        else {
            this.op = (unsigned char)(32 + 64);         /* end of block */
3481a7a4:	d3a00060 	movle	r0, #96	; 0x60
            this.op = (unsigned char)0;
            this.val = work[sym];
        }
        else if ((int)(work[sym]) > end) {
            this.op = (unsigned char)(extra[work[sym]]);
            this.val = base[work[sym]];
3481a7a8:	c196a0ba 	ldrhgt	sl, [r6, sl]
        if ((int)(work[sym]) < end) {
            this.op = (unsigned char)0;
            this.val = work[sym];
        }
        else if ((int)(work[sym]) > end) {
            this.op = (unsigned char)(extra[work[sym]]);
3481a7ac:	c58d002c 	strgt	r0, [sp, #44]	; 0x2c
            this.val = base[work[sym]];
        }
        else {
            this.op = (unsigned char)(32 + 64);         /* end of block */
            this.val = 0;
3481a7b0:	d3a0a000 	movle	sl, #0
        else if ((int)(work[sym]) > end) {
            this.op = (unsigned char)(extra[work[sym]]);
            this.val = base[work[sym]];
        }
        else {
            this.op = (unsigned char)(32 + 64);         /* end of block */
3481a7b4:	d58d002c 	strle	r0, [sp, #44]	; 0x2c
            this.val = 0;
        }

        /* replicate for those indices with low len bits equal to huff */
        incr = 1U << (len - drop);
3481a7b8:	e3a09001 	mov	r9, #1
3481a7bc:	e0616004 	rsb	r6, r1, r4
3481a7c0:	e1a06619 	lsl	r6, r9, r6
        fill = 1U << curr;
3481a7c4:	e1a00519 	lsl	r0, r9, r5
   on return points to the next available entry's address.  bits is the
   requested root table index bits, and on return it is the actual root
   table index bits.  It will differ if the request is greater than the
   longest code or if it is less than the shortest code.
 */
int inflate_table(type, lens, codes, table, bits, work)
3481a7c8:	e2669000 	rsb	r9, r6, #0
3481a7cc:	e58d9040 	str	r9, [sp, #64]	; 0x40
3481a7d0:	e3e09003 	mvn	r9, #3
3481a7d4:	e0090699 	mul	r9, r9, r6
            this.val = 0;
        }

        /* replicate for those indices with low len bits equal to huff */
        incr = 1U << (len - drop);
        fill = 1U << curr;
3481a7d8:	e58d0024 	str	r0, [sp, #36]	; 0x24
   on return points to the next available entry's address.  bits is the
   requested root table index bits, and on return it is the actual root
   table index bits.  It will differ if the request is greater than the
   longest code or if it is less than the shortest code.
 */
int inflate_table(type, lens, codes, table, bits, work)
3481a7dc:	e58d9044 	str	r9, [sp, #68]	; 0x44
        incr = 1U << (len - drop);
        fill = 1U << curr;
        min = fill;                 /* save offset to next table */
        do {
            fill -= incr;
            next[(huff >> drop) + fill] = this;
3481a7e0:	e59d9024 	ldr	r9, [sp, #36]	; 0x24
   on return points to the next available entry's address.  bits is the
   requested root table index bits, and on return it is the actual root
   table index bits.  It will differ if the request is greater than the
   longest code or if it is less than the shortest code.
 */
int inflate_table(type, lens, codes, table, bits, work)
3481a7e4:	e0660000 	rsb	r0, r6, r0
3481a7e8:	e58d0028 	str	r0, [sp, #40]	; 0x28
        incr = 1U << (len - drop);
        fill = 1U << curr;
        min = fill;                 /* save offset to next table */
        do {
            fill -= incr;
            next[(huff >> drop) + fill] = this;
3481a7ec:	e0890132 	add	r0, r9, r2, lsr r1
3481a7f0:	e0660000 	rsb	r0, r6, r0
3481a7f4:	e0870100 	add	r0, r7, r0, lsl #2
3481a7f8:	e1a0900c 	mov	r9, ip
3481a7fc:	e58d3004 	str	r3, [sp, #4]
   on return points to the next available entry's address.  bits is the
   requested root table index bits, and on return it is the actual root
   table index bits.  It will differ if the request is greater than the
   longest code or if it is less than the shortest code.
 */
int inflate_table(type, lens, codes, table, bits, work)
3481a800:	e59dc02c 	ldr	ip, [sp, #44]	; 0x2c
3481a804:	e5c0c000 	strb	ip, [r0]
3481a808:	e59d303c 	ldr	r3, [sp, #60]	; 0x3c
3481a80c:	e1c0a0b2 	strh	sl, [r0, #2]
3481a810:	e5c03001 	strb	r3, [r0, #1]
3481a814:	e59dc028 	ldr	ip, [sp, #40]	; 0x28
3481a818:	e59d3040 	ldr	r3, [sp, #64]	; 0x40
3481a81c:	e08cc003 	add	ip, ip, r3
3481a820:	e58dc028 	str	ip, [sp, #40]	; 0x28
        fill = 1U << curr;
        min = fill;                 /* save offset to next table */
        do {
            fill -= incr;
            next[(huff >> drop) + fill] = this;
        } while (fill != 0);
3481a824:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
   on return points to the next available entry's address.  bits is the
   requested root table index bits, and on return it is the actual root
   table index bits.  It will differ if the request is greater than the
   longest code or if it is less than the shortest code.
 */
int inflate_table(type, lens, codes, table, bits, work)
3481a828:	e59dc044 	ldr	ip, [sp, #68]	; 0x44
3481a82c:	e080000c 	add	r0, r0, ip
        fill = 1U << curr;
        min = fill;                 /* save offset to next table */
        do {
            fill -= incr;
            next[(huff >> drop) + fill] = this;
        } while (fill != 0);
3481a830:	e083c006 	add	ip, r3, r6
3481a834:	e35c0000 	cmp	ip, #0
3481a838:	1afffff0 	bne	3481a800 <inflate_table+0x318>

        /* backwards increment the len-bit code huff */
        incr = 1U << (len - 1);
3481a83c:	e2440001 	sub	r0, r4, #1
3481a840:	e3a06001 	mov	r6, #1
3481a844:	e1a0c009 	mov	ip, r9
3481a848:	e59d3004 	ldr	r3, [sp, #4]
3481a84c:	e1a00016 	lsl	r0, r6, r0
        while (huff & incr)
3481a850:	ea000000 	b	3481a858 <inflate_table+0x370>
            incr >>= 1;
3481a854:	e1a000a0 	lsr	r0, r0, #1
            next[(huff >> drop) + fill] = this;
        } while (fill != 0);

        /* backwards increment the len-bit code huff */
        incr = 1U << (len - 1);
        while (huff & incr)
3481a858:	e1100002 	tst	r0, r2
3481a85c:	1afffffc 	bne	3481a854 <inflate_table+0x36c>
            incr >>= 1;
        if (incr != 0) {
3481a860:	e3500000 	cmp	r0, #0
            huff &= incr - 1;
3481a864:	12406001 	subne	r6, r0, #1
        else
            huff = 0;

        /* go to next symbol, update count, len */
        sym++;
        if (--(count[len]) == 0) {
3481a868:	e28d9088 	add	r9, sp, #136	; 0x88
        /* backwards increment the len-bit code huff */
        incr = 1U << (len - 1);
        while (huff & incr)
            incr >>= 1;
        if (incr != 0) {
            huff &= incr - 1;
3481a86c:	10062002 	andne	r2, r6, r2
        else
            huff = 0;

        /* go to next symbol, update count, len */
        sym++;
        if (--(count[len]) == 0) {
3481a870:	e0896084 	add	r6, r9, r4, lsl #1
        incr = 1U << (len - 1);
        while (huff & incr)
            incr >>= 1;
        if (incr != 0) {
            huff &= incr - 1;
            huff += incr;
3481a874:	10822000 	addne	r2, r2, r0
        }
        else
            huff = 0;
3481a878:	01a02000 	moveq	r2, r0

        /* go to next symbol, update count, len */
        sym++;
        if (--(count[len]) == 0) {
3481a87c:	e15602b0 	ldrh	r0, [r6, #-32]	; 0xffffffe0
3481a880:	e2400001 	sub	r0, r0, #1
3481a884:	e6ff0070 	uxth	r0, r0
3481a888:	e3500000 	cmp	r0, #0
3481a88c:	e14602b0 	strh	r0, [r6, #-32]	; 0xffffffe0
3481a890:	1a000006 	bne	3481a8b0 <inflate_table+0x3c8>
            if (len == max) break;
3481a894:	e154000b 	cmp	r4, fp
3481a898:	0a000058 	beq	3481aa00 <inflate_table+0x518>
            len = lens[work[sym]];
3481a89c:	e59da018 	ldr	sl, [sp, #24]
3481a8a0:	e59d6030 	ldr	r6, [sp, #48]	; 0x30
3481a8a4:	e1da00b0 	ldrh	r0, [sl]
3481a8a8:	e1a00080 	lsl	r0, r0, #1
3481a8ac:	e19640b0 	ldrh	r4, [r6, r0]
        }

        /* create new sub-table if needed */
        if (len > root && (huff & mask) != low) {
3481a8b0:	e154000c 	cmp	r4, ip
3481a8b4:	959d0014 	ldrls	r0, [sp, #20]
3481a8b8:	9affffa9 	bls	3481a764 <inflate_table+0x27c>
3481a8bc:	e59d9034 	ldr	r9, [sp, #52]	; 0x34
3481a8c0:	e59da014 	ldr	sl, [sp, #20]
3481a8c4:	e0020009 	and	r0, r2, r9
3481a8c8:	e150000a 	cmp	r0, sl
3481a8cc:	0affffa4 	beq	3481a764 <inflate_table+0x27c>
            /* if first time, transition to sub-tables */
            if (drop == 0)
3481a8d0:	e3510000 	cmp	r1, #0
3481a8d4:	01a0100c 	moveq	r1, ip

            /* increment past last table */
            next += min;            /* here min is 1 << curr */

            /* determine length of next table */
            curr = len - drop;
3481a8d8:	e0615004 	rsb	r5, r1, r4
            left = (int)(1 << curr);
3481a8dc:	e3a09001 	mov	r9, #1
3481a8e0:	e1a06519 	lsl	r6, r9, r5
   on return points to the next available entry's address.  bits is the
   requested root table index bits, and on return it is the actual root
   table index bits.  It will differ if the request is greater than the
   longest code or if it is less than the shortest code.
 */
int inflate_table(type, lens, codes, table, bits, work)
3481a8e4:	e2419001 	sub	r9, r1, #1
3481a8e8:	e28da068 	add	sl, sp, #104	; 0x68
3481a8ec:	e0899005 	add	r9, r9, r5
3481a8f0:	e08a9089 	add	r9, sl, r9, lsl #1
3481a8f4:	e1a0a00c 	mov	sl, ip
            next += min;            /* here min is 1 << curr */

            /* determine length of next table */
            curr = len - drop;
            left = (int)(1 << curr);
            while (curr + drop < max) {
3481a8f8:	ea000005 	b	3481a914 <inflate_table+0x42c>
                left -= count[curr + drop];
3481a8fc:	e1f9c0b2 	ldrh	ip, [r9, #2]!
3481a900:	e06c6006 	rsb	r6, ip, r6
                if (left <= 0) break;
3481a904:	e3560000 	cmp	r6, #0
3481a908:	da000004 	ble	3481a920 <inflate_table+0x438>
                curr++;
3481a90c:	e2855001 	add	r5, r5, #1
                left <<= 1;
3481a910:	e1a06086 	lsl	r6, r6, #1
            next += min;            /* here min is 1 << curr */

            /* determine length of next table */
            curr = len - drop;
            left = (int)(1 << curr);
            while (curr + drop < max) {
3481a914:	e085c001 	add	ip, r5, r1
3481a918:	e15c000b 	cmp	ip, fp
3481a91c:	3afffff6 	bcc	3481a8fc <inflate_table+0x414>
                curr++;
                left <<= 1;
            }

            /* check for enough space */
            used += 1U << curr;
3481a920:	e59d600c 	ldr	r6, [sp, #12]
3481a924:	e3a09001 	mov	r9, #1
3481a928:	e0866519 	add	r6, r6, r9, lsl r5
3481a92c:	e58d600c 	str	r6, [sp, #12]
3481a930:	e1a0c00a 	mov	ip, sl
            if (type == LENS && used >= ENOUGH - MAXD)
3481a934:	e59d6038 	ldr	r6, [sp, #56]	; 0x38
3481a938:	e59da00c 	ldr	sl, [sp, #12]
3481a93c:	e30095af 	movw	r9, #1455	; 0x5af
3481a940:	e15a0009 	cmp	sl, r9
3481a944:	93a06000 	movls	r6, #0
3481a948:	82066001 	andhi	r6, r6, #1
3481a94c:	e3560000 	cmp	r6, #0
3481a950:	1a00003a 	bne	3481aa40 <inflate_table+0x558>
                return 1;

            /* point entry in root table to sub-table */
            low = huff & mask;
            (*table)[low].op = (unsigned char)curr;
3481a954:	e5936000 	ldr	r6, [r3]
            /* if first time, transition to sub-tables */
            if (drop == 0)
                drop = root;

            /* increment past last table */
            next += min;            /* here min is 1 << curr */
3481a958:	e59da024 	ldr	sl, [sp, #36]	; 0x24
            if (type == LENS && used >= ENOUGH - MAXD)
                return 1;

            /* point entry in root table to sub-table */
            low = huff & mask;
            (*table)[low].op = (unsigned char)curr;
3481a95c:	e7c65100 	strb	r5, [r6, r0, lsl #2]
            (*table)[low].bits = (unsigned char)root;
3481a960:	e5936000 	ldr	r6, [r3]
            /* if first time, transition to sub-tables */
            if (drop == 0)
                drop = root;

            /* increment past last table */
            next += min;            /* here min is 1 << curr */
3481a964:	e087710a 	add	r7, r7, sl, lsl #2
            if (type == LENS && used >= ENOUGH - MAXD)
                return 1;

            /* point entry in root table to sub-table */
            low = huff & mask;
            (*table)[low].op = (unsigned char)curr;
3481a968:	e1a0a100 	lsl	sl, r0, #2
            (*table)[low].bits = (unsigned char)root;
3481a96c:	e086600a 	add	r6, r6, sl
3481a970:	e5c6c001 	strb	ip, [r6, #1]
            (*table)[low].val = (unsigned short)(next - *table);
3481a974:	e5936000 	ldr	r6, [r3]
3481a978:	e086a00a 	add	sl, r6, sl
3481a97c:	e0666007 	rsb	r6, r6, r7
3481a980:	e1a06146 	asr	r6, r6, #2
3481a984:	e1ca60b2 	strh	r6, [sl, #2]
3481a988:	eaffff75 	b	3481a764 <inflate_table+0x27c>
    this.op = (unsigned char)64;                /* invalid code marker */
    this.bits = (unsigned char)(len - drop);
    this.val = (unsigned short)0;
    while (huff != 0) {
        /* when done with sub-table, drop back to root table */
        if (drop != 0 && (huff & mask) != low) {
3481a98c:	e3510000 	cmp	r1, #0
3481a990:	0a000007 	beq	3481a9b4 <inflate_table+0x4cc>
3481a994:	e59d9034 	ldr	r9, [sp, #52]	; 0x34
3481a998:	e0020009 	and	r0, r2, r9
3481a99c:	e59d9014 	ldr	r9, [sp, #20]
3481a9a0:	e1500009 	cmp	r0, r9
            drop = 0;
            len = root;
            next = *table;
3481a9a4:	15937000 	ldrne	r7, [r3]
            this.bits = (unsigned char)len;
3481a9a8:	11a0b00a 	movne	fp, sl
3481a9ac:	11a0400c 	movne	r4, ip
    this.bits = (unsigned char)(len - drop);
    this.val = (unsigned short)0;
    while (huff != 0) {
        /* when done with sub-table, drop back to root table */
        if (drop != 0 && (huff & mask) != low) {
            drop = 0;
3481a9b0:	13a01000 	movne	r1, #0
            next = *table;
            this.bits = (unsigned char)len;
        }

        /* put invalid code marker in table */
        next[huff >> drop] = this;
3481a9b4:	e1a09132 	lsr	r9, r2, r1
3481a9b8:	e0870109 	add	r0, r7, r9, lsl #2
3481a9bc:	e7c76109 	strb	r6, [r7, r9, lsl #2]
3481a9c0:	e3a09000 	mov	r9, #0
3481a9c4:	e5c0b001 	strb	fp, [r0, #1]
3481a9c8:	e1c090b2 	strh	r9, [r0, #2]

        /* backwards increment the len-bit code huff */
        incr = 1U << (len - 1);
3481a9cc:	e2440001 	sub	r0, r4, #1
3481a9d0:	e1a00015 	lsl	r0, r5, r0
        while (huff & incr)
3481a9d4:	ea000000 	b	3481a9dc <inflate_table+0x4f4>
            incr >>= 1;
3481a9d8:	e1a000a0 	lsr	r0, r0, #1
        /* put invalid code marker in table */
        next[huff >> drop] = this;

        /* backwards increment the len-bit code huff */
        incr = 1U << (len - 1);
        while (huff & incr)
3481a9dc:	e1100002 	tst	r0, r2
3481a9e0:	1afffffc 	bne	3481a9d8 <inflate_table+0x4f0>
            incr >>= 1;
        if (incr != 0) {
3481a9e4:	e3500000 	cmp	r0, #0
            huff &= incr - 1;
3481a9e8:	12409001 	subne	r9, r0, #1
3481a9ec:	10092002 	andne	r2, r9, r2
            huff += incr;
3481a9f0:	10822000 	addne	r2, r2, r0
3481a9f4:	1a000005 	bne	3481aa10 <inflate_table+0x528>
        }
        else
            huff = 0;
3481a9f8:	e1a02000 	mov	r2, r0
3481a9fc:	ea000005 	b	3481aa18 <inflate_table+0x530>

        /* put invalid code marker in table */
        next[huff >> drop] = this;

        /* backwards increment the len-bit code huff */
        incr = 1U << (len - 1);
3481aa00:	e59db03c 	ldr	fp, [sp, #60]	; 0x3c
        /* when done with sub-table, drop back to root table */
        if (drop != 0 && (huff & mask) != low) {
            drop = 0;
            len = root;
            next = *table;
            this.bits = (unsigned char)len;
3481aa04:	e6efa07c 	uxtb	sl, ip
        }

        /* put invalid code marker in table */
        next[huff >> drop] = this;
3481aa08:	e3a06040 	mov	r6, #64	; 0x40

        /* backwards increment the len-bit code huff */
        incr = 1U << (len - 1);
3481aa0c:	e3a05001 	mov	r5, #1
       drops back to the root table to fill in any remaining entries there.
     */
    this.op = (unsigned char)64;                /* invalid code marker */
    this.bits = (unsigned char)(len - drop);
    this.val = (unsigned short)0;
    while (huff != 0) {
3481aa10:	e3520000 	cmp	r2, #0
3481aa14:	1affffdc 	bne	3481a98c <inflate_table+0x4a4>
        else
            huff = 0;
    }

    /* set return parameters */
    *table += used;
3481aa18:	e5931000 	ldr	r1, [r3]
3481aa1c:	e59da00c 	ldr	sl, [sp, #12]
    *bits = root;
3481aa20:	e59d00a8 	ldr	r0, [sp, #168]	; 0xa8
        else
            huff = 0;
    }

    /* set return parameters */
    *table += used;
3481aa24:	e081110a 	add	r1, r1, sl, lsl #2
3481aa28:	e5831000 	str	r1, [r3]
    *bits = root;
3481aa2c:	e580c000 	str	ip, [r0]
    return 0;
3481aa30:	e1a00002 	mov	r0, r2
3481aa34:	ea000002 	b	3481aa44 <inflate_table+0x55c>
        left <<= 1;
        left -= count[len];
        if (left < 0) return -1;        /* over-subscribed */
    }
    if (left > 0 && (type == CODES || max != 1))
        return -1;                      /* incomplete set */
3481aa38:	e3e00000 	mvn	r0, #0
3481aa3c:	ea000000 	b	3481aa44 <inflate_table+0x55c>
            }

            /* check for enough space */
            used += 1U << curr;
            if (type == LENS && used >= ENOUGH - MAXD)
                return 1;
3481aa40:	e3a00001 	mov	r0, #1

    /* set return parameters */
    *table += used;
    *bits = root;
    return 0;
}
3481aa44:	e28dd088 	add	sp, sp, #136	; 0x88
3481aa48:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
3481aa4c:	34821efe 	.word	0x34821efe
3481aa50:	34822180 	.word	0x34822180

3481aa54 <inflateReset>:
int ZEXPORT inflateReset(strm)
z_streamp strm;
{
    struct inflate_state FAR *state;

    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
3481aa54:	e3500000 	cmp	r0, #0
3481aa58:	03e00001 	mvneq	r0, #1
3481aa5c:	012fff1e 	bxeq	lr
3481aa60:	e590301c 	ldr	r3, [r0, #28]
3481aa64:	e3530000 	cmp	r3, #0
3481aa68:	0a000017 	beq	3481aacc <inflateReset+0x78>
    state = (struct inflate_state FAR *)strm->state;
    strm->total_in = strm->total_out = state->total = 0;
3481aa6c:	e3a02000 	mov	r2, #0
    strm->msg = Z_NULL;
    strm->adler = 1;        /* to support ill-conceived Java test suite */
3481aa70:	e3a01001 	mov	r1, #1
{
    struct inflate_state FAR *state;

    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
    state = (struct inflate_state FAR *)strm->state;
    strm->total_in = strm->total_out = state->total = 0;
3481aa74:	e583201c 	str	r2, [r3, #28]
    strm->msg = Z_NULL;
    strm->adler = 1;        /* to support ill-conceived Java test suite */
3481aa78:	e5801034 	str	r1, [r0, #52]	; 0x34
    state->mode = HEAD;
    state->last = 0;
    state->havedict = 0;
    state->dmax = 32768U;
3481aa7c:	e3a01902 	mov	r1, #32768	; 0x8000
{
    struct inflate_state FAR *state;

    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
    state = (struct inflate_state FAR *)strm->state;
    strm->total_in = strm->total_out = state->total = 0;
3481aa80:	e5802014 	str	r2, [r0, #20]
3481aa84:	e5802008 	str	r2, [r0, #8]
    strm->msg = Z_NULL;
3481aa88:	e5802018 	str	r2, [r0, #24]
    strm->adler = 1;        /* to support ill-conceived Java test suite */
    state->mode = HEAD;
    state->last = 0;
    state->havedict = 0;
    state->dmax = 32768U;
3481aa8c:	e5831014 	str	r1, [r3, #20]
    state->wsize = 0;
    state->whave = 0;
    state->write = 0;
    state->hold = 0;
    state->bits = 0;
    state->lencode = state->distcode = state->next = state->codes;
3481aa90:	e2831e53 	add	r1, r3, #1328	; 0x530
    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
    state = (struct inflate_state FAR *)strm->state;
    strm->total_in = strm->total_out = state->total = 0;
    strm->msg = Z_NULL;
    strm->adler = 1;        /* to support ill-conceived Java test suite */
    state->mode = HEAD;
3481aa94:	e5832000 	str	r2, [r3]
    state->last = 0;
3481aa98:	e5832004 	str	r2, [r3, #4]
    state->havedict = 0;
3481aa9c:	e583200c 	str	r2, [r3, #12]
    state->dmax = 32768U;
    state->head = Z_NULL;
3481aaa0:	e5832020 	str	r2, [r3, #32]
    state->wsize = 0;
3481aaa4:	e5832028 	str	r2, [r3, #40]	; 0x28
    state->whave = 0;
3481aaa8:	e583202c 	str	r2, [r3, #44]	; 0x2c
    state->write = 0;
3481aaac:	e5832030 	str	r2, [r3, #48]	; 0x30
    state->hold = 0;
3481aab0:	e5832038 	str	r2, [r3, #56]	; 0x38
    state->bits = 0;
3481aab4:	e583203c 	str	r2, [r3, #60]	; 0x3c
    state->lencode = state->distcode = state->next = state->codes;
3481aab8:	e583106c 	str	r1, [r3, #108]	; 0x6c
3481aabc:	e5831050 	str	r1, [r3, #80]	; 0x50
3481aac0:	e583104c 	str	r1, [r3, #76]	; 0x4c
    WATCHDOG_RESET();
    Tracev((stderr, "inflate: reset\n"));
    return Z_OK;
3481aac4:	e1a00002 	mov	r0, r2
3481aac8:	e12fff1e 	bx	lr
int ZEXPORT inflateReset(strm)
z_streamp strm;
{
    struct inflate_state FAR *state;

    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
3481aacc:	e3e00001 	mvn	r0, #1
    state->bits = 0;
    state->lencode = state->distcode = state->next = state->codes;
    WATCHDOG_RESET();
    Tracev((stderr, "inflate: reset\n"));
    return Z_OK;
}
3481aad0:	e12fff1e 	bx	lr

3481aad4 <inflateInit2_>:
const char *version;
int stream_size;
{
    struct inflate_state FAR *state;

    if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||
3481aad4:	e3520000 	cmp	r2, #0
int ZEXPORT inflateInit2_(strm, windowBits, version, stream_size)
z_streamp strm;
int windowBits;
const char *version;
int stream_size;
{
3481aad8:	e92d4070 	push	{r4, r5, r6, lr}
3481aadc:	e1a04000 	mov	r4, r0
3481aae0:	e1a05001 	mov	r5, r1
    struct inflate_state FAR *state;

    if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||
3481aae4:	0a000033 	beq	3481abb8 <inflateInit2_+0xe4>
3481aae8:	e5d22000 	ldrb	r2, [r2]
3481aaec:	e3520031 	cmp	r2, #49	; 0x31
3481aaf0:	0353003c 	cmpeq	r3, #60	; 0x3c
3481aaf4:	03a03000 	moveq	r3, #0
3481aaf8:	13a03001 	movne	r3, #1
3481aafc:	1a00002d 	bne	3481abb8 <inflateInit2_+0xe4>
        stream_size != (int)(sizeof(z_stream)))
        return Z_VERSION_ERROR;
    if (strm == Z_NULL) return Z_STREAM_ERROR;
3481ab00:	e3500000 	cmp	r0, #0
3481ab04:	0a00002d 	beq	3481abc0 <inflateInit2_+0xec>
    strm->msg = Z_NULL;                 /* in case we return an error */
3481ab08:	e5803018 	str	r3, [r0, #24]
    if (strm->zalloc == (alloc_func)0) {
3481ab0c:	e5903020 	ldr	r3, [r0, #32]
        strm->zalloc = zcalloc;
        strm->opaque = (voidpf)0;
    }
    if (strm->zfree == (free_func)0) strm->zfree = zcfree;
    state = (struct inflate_state FAR *)
            ZALLOC(strm, 1, sizeof(struct inflate_state));
3481ab10:	e3a01001 	mov	r1, #1
    if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||
        stream_size != (int)(sizeof(z_stream)))
        return Z_VERSION_ERROR;
    if (strm == Z_NULL) return Z_STREAM_ERROR;
    strm->msg = Z_NULL;                 /* in case we return an error */
    if (strm->zalloc == (alloc_func)0) {
3481ab14:	e3530000 	cmp	r3, #0
        strm->zalloc = zcalloc;
        strm->opaque = (voidpf)0;
3481ab18:	05803028 	streq	r3, [r0, #40]	; 0x28
        stream_size != (int)(sizeof(z_stream)))
        return Z_VERSION_ERROR;
    if (strm == Z_NULL) return Z_STREAM_ERROR;
    strm->msg = Z_NULL;                 /* in case we return an error */
    if (strm->zalloc == (alloc_func)0) {
        strm->zalloc = zcalloc;
3481ab1c:	059f20ac 	ldreq	r2, [pc, #172]	; 3481abd0 <inflateInit2_+0xfc>
        strm->opaque = (voidpf)0;
    }
    if (strm->zfree == (free_func)0) strm->zfree = zcfree;
3481ab20:	e5903024 	ldr	r3, [r0, #36]	; 0x24
        stream_size != (int)(sizeof(z_stream)))
        return Z_VERSION_ERROR;
    if (strm == Z_NULL) return Z_STREAM_ERROR;
    strm->msg = Z_NULL;                 /* in case we return an error */
    if (strm->zalloc == (alloc_func)0) {
        strm->zalloc = zcalloc;
3481ab24:	05802020 	streq	r2, [r0, #32]
        strm->opaque = (voidpf)0;
    }
    if (strm->zfree == (free_func)0) strm->zfree = zcfree;
3481ab28:	e3530000 	cmp	r3, #0
3481ab2c:	059f30a0 	ldreq	r3, [pc, #160]	; 3481abd4 <inflateInit2_+0x100>
    state = (struct inflate_state FAR *)
            ZALLOC(strm, 1, sizeof(struct inflate_state));
3481ab30:	e3022530 	movw	r2, #9520	; 0x2530
    strm->msg = Z_NULL;                 /* in case we return an error */
    if (strm->zalloc == (alloc_func)0) {
        strm->zalloc = zcalloc;
        strm->opaque = (voidpf)0;
    }
    if (strm->zfree == (free_func)0) strm->zfree = zcfree;
3481ab34:	05803024 	streq	r3, [r0, #36]	; 0x24
    state = (struct inflate_state FAR *)
            ZALLOC(strm, 1, sizeof(struct inflate_state));
3481ab38:	e5903020 	ldr	r3, [r0, #32]
3481ab3c:	e5900028 	ldr	r0, [r0, #40]	; 0x28
3481ab40:	e12fff33 	blx	r3
    if (state == Z_NULL) return Z_MEM_ERROR;
3481ab44:	e2501000 	subs	r1, r0, #0
3481ab48:	0a00001e 	beq	3481abc8 <inflateInit2_+0xf4>
    Tracev((stderr, "inflate: allocated\n"));
    strm->state = (struct internal_state FAR *)state;
    if (windowBits < 0) {
3481ab4c:	e3550000 	cmp	r5, #0
        state->wrap = 0;
3481ab50:	b3a03000 	movlt	r3, #0
    if (strm->zfree == (free_func)0) strm->zfree = zcfree;
    state = (struct inflate_state FAR *)
            ZALLOC(strm, 1, sizeof(struct inflate_state));
    if (state == Z_NULL) return Z_MEM_ERROR;
    Tracev((stderr, "inflate: allocated\n"));
    strm->state = (struct internal_state FAR *)state;
3481ab54:	e584101c 	str	r1, [r4, #28]
    if (windowBits < 0) {
        state->wrap = 0;
        windowBits = -windowBits;
3481ab58:	b2655000 	rsblt	r5, r5, #0
            ZALLOC(strm, 1, sizeof(struct inflate_state));
    if (state == Z_NULL) return Z_MEM_ERROR;
    Tracev((stderr, "inflate: allocated\n"));
    strm->state = (struct internal_state FAR *)state;
    if (windowBits < 0) {
        state->wrap = 0;
3481ab5c:	b5813008 	strlt	r3, [r1, #8]
    state = (struct inflate_state FAR *)
            ZALLOC(strm, 1, sizeof(struct inflate_state));
    if (state == Z_NULL) return Z_MEM_ERROR;
    Tracev((stderr, "inflate: allocated\n"));
    strm->state = (struct internal_state FAR *)state;
    if (windowBits < 0) {
3481ab60:	ba000004 	blt	3481ab78 <inflateInit2_+0xa4>
        state->wrap = 0;
        windowBits = -windowBits;
    }
    else {
        state->wrap = (windowBits >> 4) + 1;
3481ab64:	e1a03245 	asr	r3, r5, #4
3481ab68:	e2833001 	add	r3, r3, #1
#ifdef GUNZIP
        if (windowBits < 48) windowBits &= 15;
3481ab6c:	e355002f 	cmp	r5, #47	; 0x2f
    if (windowBits < 0) {
        state->wrap = 0;
        windowBits = -windowBits;
    }
    else {
        state->wrap = (windowBits >> 4) + 1;
3481ab70:	e5813008 	str	r3, [r1, #8]
#ifdef GUNZIP
        if (windowBits < 48) windowBits &= 15;
3481ab74:	d205500f 	andle	r5, r5, #15
#endif
    }
    if (windowBits < 8 || windowBits > 15) {
3481ab78:	e2453008 	sub	r3, r5, #8
3481ab7c:	e3530007 	cmp	r3, #7
3481ab80:	9a000006 	bls	3481aba0 <inflateInit2_+0xcc>
        ZFREE(strm, state);
3481ab84:	e5943024 	ldr	r3, [r4, #36]	; 0x24
3481ab88:	e5940028 	ldr	r0, [r4, #40]	; 0x28
3481ab8c:	e3a02000 	mov	r2, #0
3481ab90:	e12fff33 	blx	r3
        strm->state = Z_NULL;
3481ab94:	e3a03000 	mov	r3, #0
3481ab98:	e584301c 	str	r3, [r4, #28]
3481ab9c:	ea000007 	b	3481abc0 <inflateInit2_+0xec>
        return Z_STREAM_ERROR;
    }
    state->wbits = (unsigned)windowBits;
    state->window = Z_NULL;
3481aba0:	e3a03000 	mov	r3, #0
    return inflateReset(strm);
3481aba4:	e1a00004 	mov	r0, r4
    if (windowBits < 8 || windowBits > 15) {
        ZFREE(strm, state);
        strm->state = Z_NULL;
        return Z_STREAM_ERROR;
    }
    state->wbits = (unsigned)windowBits;
3481aba8:	e5815024 	str	r5, [r1, #36]	; 0x24
    state->window = Z_NULL;
3481abac:	e5813034 	str	r3, [r1, #52]	; 0x34
    return inflateReset(strm);
}
3481abb0:	e8bd4070 	pop	{r4, r5, r6, lr}
        strm->state = Z_NULL;
        return Z_STREAM_ERROR;
    }
    state->wbits = (unsigned)windowBits;
    state->window = Z_NULL;
    return inflateReset(strm);
3481abb4:	eaffffa6 	b	3481aa54 <inflateReset>
{
    struct inflate_state FAR *state;

    if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||
        stream_size != (int)(sizeof(z_stream)))
        return Z_VERSION_ERROR;
3481abb8:	e3e00005 	mvn	r0, #5
3481abbc:	e8bd8070 	pop	{r4, r5, r6, pc}
    if (strm == Z_NULL) return Z_STREAM_ERROR;
3481abc0:	e3e00001 	mvn	r0, #1
3481abc4:	e8bd8070 	pop	{r4, r5, r6, pc}
        strm->opaque = (voidpf)0;
    }
    if (strm->zfree == (free_func)0) strm->zfree = zcfree;
    state = (struct inflate_state FAR *)
            ZALLOC(strm, 1, sizeof(struct inflate_state));
    if (state == Z_NULL) return Z_MEM_ERROR;
3481abc8:	e3e00003 	mvn	r0, #3
        return Z_STREAM_ERROR;
    }
    state->wbits = (unsigned)windowBits;
    state->window = Z_NULL;
    return inflateReset(strm);
}
3481abcc:	e8bd8070 	pop	{r4, r5, r6, pc}
3481abd0:	34819f6c 	.word	0x34819f6c
3481abd4:	34819f64 	.word	0x34819f64

3481abd8 <inflateInit_>:

int ZEXPORT inflateInit_(strm, version, stream_size)
z_streamp strm;
const char *version;
int stream_size;
{
3481abd8:	e1a0c001 	mov	ip, r1
3481abdc:	e1a03002 	mov	r3, r2
    return inflateInit2_(strm, DEF_WBITS, version, stream_size);
3481abe0:	e3a0100f 	mov	r1, #15
3481abe4:	e1a0200c 	mov	r2, ip
3481abe8:	eaffffb9 	b	3481aad4 <inflateInit2_>

3481abec <inflateEnd>:
    return ret;
}

int ZEXPORT inflateEnd(strm)
z_streamp strm;
{
3481abec:	e92d4010 	push	{r4, lr}
    struct inflate_state FAR *state;
    if (strm == Z_NULL || strm->state == Z_NULL || strm->zfree == (free_func)0)
3481abf0:	e2504000 	subs	r4, r0, #0
3481abf4:	0a000013 	beq	3481ac48 <inflateEnd+0x5c>
3481abf8:	e594201c 	ldr	r2, [r4, #28]
3481abfc:	e3520000 	cmp	r2, #0
3481ac00:	0a000010 	beq	3481ac48 <inflateEnd+0x5c>
3481ac04:	e5943024 	ldr	r3, [r4, #36]	; 0x24
3481ac08:	e3530000 	cmp	r3, #0
3481ac0c:	0a00000f 	beq	3481ac50 <inflateEnd+0x64>
        return Z_STREAM_ERROR;
    state = (struct inflate_state FAR *)strm->state;
    if (state->window != Z_NULL) {
3481ac10:	e5921034 	ldr	r1, [r2, #52]	; 0x34
3481ac14:	e3510000 	cmp	r1, #0
3481ac18:	0a000002 	beq	3481ac28 <inflateEnd+0x3c>
	WATCHDOG_RESET();
	ZFREE(strm, state->window);
3481ac1c:	e5940028 	ldr	r0, [r4, #40]	; 0x28
3481ac20:	e3a02000 	mov	r2, #0
3481ac24:	e12fff33 	blx	r3
    }
    ZFREE(strm, strm->state);
3481ac28:	e5940028 	ldr	r0, [r4, #40]	; 0x28
3481ac2c:	e5943024 	ldr	r3, [r4, #36]	; 0x24
3481ac30:	e594101c 	ldr	r1, [r4, #28]
3481ac34:	e3a02000 	mov	r2, #0
3481ac38:	e12fff33 	blx	r3
    strm->state = Z_NULL;
3481ac3c:	e3a00000 	mov	r0, #0
3481ac40:	e584001c 	str	r0, [r4, #28]
    Tracev((stderr, "inflate: end\n"));
    return Z_OK;
3481ac44:	e8bd8010 	pop	{r4, pc}
int ZEXPORT inflateEnd(strm)
z_streamp strm;
{
    struct inflate_state FAR *state;
    if (strm == Z_NULL || strm->state == Z_NULL || strm->zfree == (free_func)0)
        return Z_STREAM_ERROR;
3481ac48:	e3e00001 	mvn	r0, #1
3481ac4c:	e8bd8010 	pop	{r4, pc}
3481ac50:	e3e00001 	mvn	r0, #1
    }
    ZFREE(strm, strm->state);
    strm->state = Z_NULL;
    Tracev((stderr, "inflate: end\n"));
    return Z_OK;
}
3481ac54:	e8bd8010 	pop	{r4, pc}

3481ac58 <adler32>:
    /* split Adler-32 into component sums */
    sum2 = (adler >> 16) & 0xffff;
    adler &= 0xffff;

    /* in case user likes doing a byte at a time, keep it fast */
    if (len == 1) {
3481ac58:	e3520001 	cmp	r2, #1
/* ========================================================================= */
uLong ZEXPORT adler32(adler, buf, len)
    uLong adler;
    const Bytef *buf;
    uInt len;
{
3481ac5c:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
3481ac60:	e1a04001 	mov	r4, r1
3481ac64:	e1a07002 	mov	r7, r2
    unsigned long sum2;
    unsigned n;

    /* split Adler-32 into component sums */
    sum2 = (adler >> 16) & 0xffff;
3481ac68:	e1a06820 	lsr	r6, r0, #16
    adler &= 0xffff;
3481ac6c:	e6ff5070 	uxth	r5, r0

    /* in case user likes doing a byte at a time, keep it fast */
    if (len == 1) {
3481ac70:	1a00000b 	bne	3481aca4 <adler32+0x4c>
        adler += buf[0];
3481ac74:	e5d13000 	ldrb	r3, [r1]
3481ac78:	e0835005 	add	r5, r3, r5
        if (adler >= BASE)
3481ac7c:	e30f3ff0 	movw	r3, #65520	; 0xfff0
3481ac80:	e1550003 	cmp	r5, r3
            adler -= BASE;
3481ac84:	82455cff 	subhi	r5, r5, #65280	; 0xff00
3481ac88:	824550f1 	subhi	r5, r5, #241	; 0xf1
        sum2 += adler;
3481ac8c:	e0856006 	add	r6, r5, r6
        if (sum2 >= BASE)
3481ac90:	e30f3ff0 	movw	r3, #65520	; 0xfff0
3481ac94:	e1560003 	cmp	r6, r3
            sum2 -= BASE;
3481ac98:	82466cff 	subhi	r6, r6, #65280	; 0xff00
3481ac9c:	824660f1 	subhi	r6, r6, #241	; 0xf1
3481aca0:	ea0000a2 	b	3481af30 <adler32+0x2d8>
        return adler | (sum2 << 16);
    }

    /* initial Adler-32 value (deferred check for len == 1 speed) */
    if (buf == Z_NULL)
3481aca4:	e3510000 	cmp	r1, #0
3481aca8:	0a0000a2 	beq	3481af38 <adler32+0x2e0>
        return 1L;

    /* in case short lengths are provided, keep it somewhat fast */
    if (len < 16) {
3481acac:	e352000f 	cmp	r2, #15
3481acb0:	9a000004 	bls	3481acc8 <adler32+0x70>
3481acb4:	ea000050 	b	3481adfc <adler32+0x1a4>
        while (len--) {
            adler += *buf++;
3481acb8:	e4d43001 	ldrb	r3, [r4], #1
            sum2 += adler;
3481acbc:	e2477001 	sub	r7, r7, #1
        return 1L;

    /* in case short lengths are provided, keep it somewhat fast */
    if (len < 16) {
        while (len--) {
            adler += *buf++;
3481acc0:	e0855003 	add	r5, r5, r3
            sum2 += adler;
3481acc4:	e0866005 	add	r6, r6, r5
    if (buf == Z_NULL)
        return 1L;

    /* in case short lengths are provided, keep it somewhat fast */
    if (len < 16) {
        while (len--) {
3481acc8:	e3570000 	cmp	r7, #0
3481accc:	1afffff9 	bne	3481acb8 <adler32+0x60>
            adler += *buf++;
            sum2 += adler;
        }
        if (adler >= BASE)
3481acd0:	e30f3ff0 	movw	r3, #65520	; 0xfff0
3481acd4:	e1550003 	cmp	r5, r3
            adler -= BASE;
3481acd8:	82455cff 	subhi	r5, r5, #65280	; 0xff00
        MOD4(sum2);             /* only added so many BASE's */
3481acdc:	e1a00006 	mov	r0, r6
3481ace0:	e30f1ff1 	movw	r1, #65521	; 0xfff1
        while (len--) {
            adler += *buf++;
            sum2 += adler;
        }
        if (adler >= BASE)
            adler -= BASE;
3481ace4:	824550f1 	subhi	r5, r5, #241	; 0xf1
        MOD4(sum2);             /* only added so many BASE's */
3481ace8:	eb0014e8 	bl	34820090 <__aeabi_uidivmod>
        return adler | (sum2 << 16);
3481acec:	e1850801 	orr	r0, r5, r1, lsl #16
3481acf0:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
    }

    /* do length NMAX blocks -- requires just one modulo operation */
    while (len >= NMAX) {
        len -= NMAX;
3481acf4:	e2477d56 	sub	r7, r7, #5504	; 0x1580
3481acf8:	e2477030 	sub	r7, r7, #48	; 0x30
3481acfc:	e1a03004 	mov	r3, r4
        n = NMAX / 16;          /* NMAX is divisible by 16 */
3481ad00:	e300215b 	movw	r2, #347	; 0x15b
        do {
            DO16(buf);          /* 16 sums unrolled */
3481ad04:	e5d31000 	ldrb	r1, [r3]
            buf += 16;
        } while (--n);
3481ad08:	e2522001 	subs	r2, r2, #1
    /* do length NMAX blocks -- requires just one modulo operation */
    while (len >= NMAX) {
        len -= NMAX;
        n = NMAX / 16;          /* NMAX is divisible by 16 */
        do {
            DO16(buf);          /* 16 sums unrolled */
3481ad0c:	e0855001 	add	r5, r5, r1
3481ad10:	e5d31001 	ldrb	r1, [r3, #1]
3481ad14:	e0856006 	add	r6, r5, r6
3481ad18:	e0855001 	add	r5, r5, r1
3481ad1c:	e5d31002 	ldrb	r1, [r3, #2]
3481ad20:	e0866005 	add	r6, r6, r5
3481ad24:	e0855001 	add	r5, r5, r1
3481ad28:	e5d31003 	ldrb	r1, [r3, #3]
3481ad2c:	e0866005 	add	r6, r6, r5
3481ad30:	e0855001 	add	r5, r5, r1
3481ad34:	e5d31004 	ldrb	r1, [r3, #4]
3481ad38:	e0866005 	add	r6, r6, r5
3481ad3c:	e0855001 	add	r5, r5, r1
3481ad40:	e5d31005 	ldrb	r1, [r3, #5]
3481ad44:	e0866005 	add	r6, r6, r5
3481ad48:	e0855001 	add	r5, r5, r1
3481ad4c:	e5d31006 	ldrb	r1, [r3, #6]
3481ad50:	e0866005 	add	r6, r6, r5
3481ad54:	e0855001 	add	r5, r5, r1
3481ad58:	e5d31007 	ldrb	r1, [r3, #7]
3481ad5c:	e0866005 	add	r6, r6, r5
3481ad60:	e0855001 	add	r5, r5, r1
3481ad64:	e5d31008 	ldrb	r1, [r3, #8]
3481ad68:	e0866005 	add	r6, r6, r5
3481ad6c:	e0855001 	add	r5, r5, r1
3481ad70:	e5d31009 	ldrb	r1, [r3, #9]
3481ad74:	e0866005 	add	r6, r6, r5
3481ad78:	e0855001 	add	r5, r5, r1
3481ad7c:	e5d3100a 	ldrb	r1, [r3, #10]
3481ad80:	e0866005 	add	r6, r6, r5
3481ad84:	e0855001 	add	r5, r5, r1
3481ad88:	e5d3100b 	ldrb	r1, [r3, #11]
3481ad8c:	e0866005 	add	r6, r6, r5
3481ad90:	e0855001 	add	r5, r5, r1
3481ad94:	e5d3100c 	ldrb	r1, [r3, #12]
3481ad98:	e0866005 	add	r6, r6, r5
3481ad9c:	e0855001 	add	r5, r5, r1
3481ada0:	e5d3100d 	ldrb	r1, [r3, #13]
3481ada4:	e0866005 	add	r6, r6, r5
3481ada8:	e0855001 	add	r5, r5, r1
3481adac:	e5d3100e 	ldrb	r1, [r3, #14]
3481adb0:	e0866005 	add	r6, r6, r5
3481adb4:	e0855001 	add	r5, r5, r1
3481adb8:	e5d3100f 	ldrb	r1, [r3, #15]
3481adbc:	e0866005 	add	r6, r6, r5
3481adc0:	e0855001 	add	r5, r5, r1
3481adc4:	e0866005 	add	r6, r6, r5
            buf += 16;
3481adc8:	e2833010 	add	r3, r3, #16
        } while (--n);
3481adcc:	1affffcc 	bne	3481ad04 <adler32+0xac>
        MOD(adler);
3481add0:	e1a00005 	mov	r0, r5
3481add4:	e30f1ff1 	movw	r1, #65521	; 0xfff1
3481add8:	eb0014ac 	bl	34820090 <__aeabi_uidivmod>
        MOD(sum2);
3481addc:	e1a00006 	mov	r0, r6
        n = NMAX / 16;          /* NMAX is divisible by 16 */
        do {
            DO16(buf);          /* 16 sums unrolled */
            buf += 16;
        } while (--n);
        MOD(adler);
3481ade0:	e1a05001 	mov	r5, r1
        MOD(sum2);
3481ade4:	e30f1ff1 	movw	r1, #65521	; 0xfff1
3481ade8:	eb0014a8 	bl	34820090 <__aeabi_uidivmod>
        len -= NMAX;
        n = NMAX / 16;          /* NMAX is divisible by 16 */
        do {
            DO16(buf);          /* 16 sums unrolled */
            buf += 16;
        } while (--n);
3481adec:	e2844d56 	add	r4, r4, #5504	; 0x1580
3481adf0:	e2844030 	add	r4, r4, #48	; 0x30
        MOD(adler);
        MOD(sum2);
3481adf4:	e1a06001 	mov	r6, r1
3481adf8:	ea000000 	b	3481ae00 <adler32+0x1a8>
        MOD4(sum2);             /* only added so many BASE's */
        return adler | (sum2 << 16);
    }

    /* do length NMAX blocks -- requires just one modulo operation */
    while (len >= NMAX) {
3481adfc:	e301a5af 	movw	sl, #5551	; 0x15af
3481ae00:	e157000a 	cmp	r7, sl
3481ae04:	8affffba 	bhi	3481acf4 <adler32+0x9c>
        MOD(adler);
        MOD(sum2);
    }

    /* do remaining bytes (less than NMAX, still just one modulo) */
    if (len) {                  /* avoid modulos if none remaining */
3481ae08:	e2573000 	subs	r3, r7, #0
3481ae0c:	11a02004 	movne	r2, r4
3481ae10:	1a000031 	bne	3481aedc <adler32+0x284>
3481ae14:	ea000045 	b	3481af30 <adler32+0x2d8>
        while (len >= 16) {
            len -= 16;
            DO16(buf);
3481ae18:	e5521010 	ldrb	r1, [r2, #-16]
    }

    /* do remaining bytes (less than NMAX, still just one modulo) */
    if (len) {                  /* avoid modulos if none remaining */
        while (len >= 16) {
            len -= 16;
3481ae1c:	e2477010 	sub	r7, r7, #16
            DO16(buf);
3481ae20:	e0855001 	add	r5, r5, r1
3481ae24:	e552100f 	ldrb	r1, [r2, #-15]
3481ae28:	e0856006 	add	r6, r5, r6
3481ae2c:	e0855001 	add	r5, r5, r1
3481ae30:	e552100e 	ldrb	r1, [r2, #-14]
3481ae34:	e0866005 	add	r6, r6, r5
3481ae38:	e0855001 	add	r5, r5, r1
3481ae3c:	e552100d 	ldrb	r1, [r2, #-13]
3481ae40:	e0866005 	add	r6, r6, r5
3481ae44:	e0855001 	add	r5, r5, r1
3481ae48:	e552100c 	ldrb	r1, [r2, #-12]
3481ae4c:	e0866005 	add	r6, r6, r5
3481ae50:	e0855001 	add	r5, r5, r1
3481ae54:	e552100b 	ldrb	r1, [r2, #-11]
3481ae58:	e0866005 	add	r6, r6, r5
3481ae5c:	e0855001 	add	r5, r5, r1
3481ae60:	e552100a 	ldrb	r1, [r2, #-10]
3481ae64:	e0866005 	add	r6, r6, r5
3481ae68:	e0855001 	add	r5, r5, r1
3481ae6c:	e5521009 	ldrb	r1, [r2, #-9]
3481ae70:	e0866005 	add	r6, r6, r5
3481ae74:	e0855001 	add	r5, r5, r1
3481ae78:	e5521008 	ldrb	r1, [r2, #-8]
3481ae7c:	e0866005 	add	r6, r6, r5
3481ae80:	e0855001 	add	r5, r5, r1
3481ae84:	e5521007 	ldrb	r1, [r2, #-7]
3481ae88:	e0866005 	add	r6, r6, r5
3481ae8c:	e0855001 	add	r5, r5, r1
3481ae90:	e5521006 	ldrb	r1, [r2, #-6]
3481ae94:	e0866005 	add	r6, r6, r5
3481ae98:	e0855001 	add	r5, r5, r1
3481ae9c:	e5521005 	ldrb	r1, [r2, #-5]
3481aea0:	e0866005 	add	r6, r6, r5
3481aea4:	e0855001 	add	r5, r5, r1
3481aea8:	e5521004 	ldrb	r1, [r2, #-4]
3481aeac:	e0866005 	add	r6, r6, r5
3481aeb0:	e0855001 	add	r5, r5, r1
3481aeb4:	e5521003 	ldrb	r1, [r2, #-3]
3481aeb8:	e0866005 	add	r6, r6, r5
3481aebc:	e0855001 	add	r5, r5, r1
3481aec0:	e5521002 	ldrb	r1, [r2, #-2]
3481aec4:	e0866005 	add	r6, r6, r5
3481aec8:	e0855001 	add	r5, r5, r1
3481aecc:	e5521001 	ldrb	r1, [r2, #-1]
3481aed0:	e0866005 	add	r6, r6, r5
3481aed4:	e0855001 	add	r5, r5, r1
3481aed8:	e0866005 	add	r6, r6, r5
        MOD(sum2);
    }

    /* do remaining bytes (less than NMAX, still just one modulo) */
    if (len) {                  /* avoid modulos if none remaining */
        while (len >= 16) {
3481aedc:	e357000f 	cmp	r7, #15
            len -= 16;
            DO16(buf);
3481aee0:	e2822010 	add	r2, r2, #16
        MOD(sum2);
    }

    /* do remaining bytes (less than NMAX, still just one modulo) */
    if (len) {                  /* avoid modulos if none remaining */
        while (len >= 16) {
3481aee4:	8affffcb 	bhi	3481ae18 <adler32+0x1c0>
#  define MOD(a) a %= BASE
#  define MOD4(a) a %= BASE
#endif

/* ========================================================================= */
uLong ZEXPORT adler32(adler, buf, len)
3481aee8:	e3c3200f 	bic	r2, r3, #15
        MOD(sum2);
    }

    /* do remaining bytes (less than NMAX, still just one modulo) */
    if (len) {                  /* avoid modulos if none remaining */
        while (len >= 16) {
3481aeec:	e0844002 	add	r4, r4, r2
3481aef0:	e203300f 	and	r3, r3, #15
3481aef4:	ea000003 	b	3481af08 <adler32+0x2b0>
            len -= 16;
            DO16(buf);
            buf += 16;
        }
        while (len--) {
            adler += *buf++;
3481aef8:	e4d42001 	ldrb	r2, [r4], #1
            sum2 += adler;
3481aefc:	e2433001 	sub	r3, r3, #1
            len -= 16;
            DO16(buf);
            buf += 16;
        }
        while (len--) {
            adler += *buf++;
3481af00:	e0855002 	add	r5, r5, r2
            sum2 += adler;
3481af04:	e0866005 	add	r6, r6, r5
        while (len >= 16) {
            len -= 16;
            DO16(buf);
            buf += 16;
        }
        while (len--) {
3481af08:	e3530000 	cmp	r3, #0
3481af0c:	1afffff9 	bne	3481aef8 <adler32+0x2a0>
            adler += *buf++;
            sum2 += adler;
        }
        MOD(adler);
3481af10:	e1a00005 	mov	r0, r5
3481af14:	e30f1ff1 	movw	r1, #65521	; 0xfff1
3481af18:	eb00145c 	bl	34820090 <__aeabi_uidivmod>
        MOD(sum2);
3481af1c:	e1a00006 	mov	r0, r6
        }
        while (len--) {
            adler += *buf++;
            sum2 += adler;
        }
        MOD(adler);
3481af20:	e1a05001 	mov	r5, r1
        MOD(sum2);
3481af24:	e30f1ff1 	movw	r1, #65521	; 0xfff1
3481af28:	eb001458 	bl	34820090 <__aeabi_uidivmod>
3481af2c:	e1a06001 	mov	r6, r1
    }

    /* return recombined sums */
    return adler | (sum2 << 16);
3481af30:	e1850806 	orr	r0, r5, r6, lsl #16
3481af34:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
        return adler | (sum2 << 16);
    }

    /* initial Adler-32 value (deferred check for len == 1 speed) */
    if (buf == Z_NULL)
        return 1L;
3481af38:	e3a00001 	mov	r0, #1
        MOD(sum2);
    }

    /* return recombined sums */
    return adler | (sum2 << 16);
}
3481af3c:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}

3481af40 <inflate>:
   will return Z_BUF_ERROR if it has not reached the end of the stream.
 */
int ZEXPORT inflate(strm, flush)
z_streamp strm;
int flush;
{
3481af40:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
    unsigned char hbuf[4];      /* buffer for gzip header crc calculation */
#endif
    static const unsigned short order[19] = /* permutation of code lengths */
        {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};

    if (strm == Z_NULL || strm->state == Z_NULL ||
3481af44:	e250a000 	subs	sl, r0, #0
   will return Z_BUF_ERROR if it has not reached the end of the stream.
 */
int ZEXPORT inflate(strm, flush)
z_streamp strm;
int flush;
{
3481af48:	e24dd048 	sub	sp, sp, #72	; 0x48
3481af4c:	e58d103c 	str	r1, [sp, #60]	; 0x3c
    static const unsigned short order[19] = /* permutation of code lengths */
        {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};

    if (strm == Z_NULL || strm->state == Z_NULL ||
        (strm->next_in == Z_NULL && strm->avail_in != 0))
        return Z_STREAM_ERROR;
3481af50:	03e01001 	mvneq	r1, #1
    unsigned char hbuf[4];      /* buffer for gzip header crc calculation */
#endif
    static const unsigned short order[19] = /* permutation of code lengths */
        {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};

    if (strm == Z_NULL || strm->state == Z_NULL ||
3481af54:	0a00058b 	beq	3481c588 <inflate+0x1648>
3481af58:	e59a401c 	ldr	r4, [sl, #28]
3481af5c:	e3540000 	cmp	r4, #0
3481af60:	0a00058a 	beq	3481c590 <inflate+0x1650>
        (strm->next_in == Z_NULL && strm->avail_in != 0))
3481af64:	e59a9000 	ldr	r9, [sl]
    unsigned char hbuf[4];      /* buffer for gzip header crc calculation */
#endif
    static const unsigned short order[19] = /* permutation of code lengths */
        {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};

    if (strm == Z_NULL || strm->state == Z_NULL ||
3481af68:	e3590000 	cmp	r9, #0
3481af6c:	1a000003 	bne	3481af80 <inflate+0x40>
        (strm->next_in == Z_NULL && strm->avail_in != 0))
3481af70:	e59a3004 	ldr	r3, [sl, #4]
3481af74:	e3530000 	cmp	r3, #0
        return Z_STREAM_ERROR;
3481af78:	13e03001 	mvnne	r3, #1
#endif
    static const unsigned short order[19] = /* permutation of code lengths */
        {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};

    if (strm == Z_NULL || strm->state == Z_NULL ||
        (strm->next_in == Z_NULL && strm->avail_in != 0))
3481af7c:	1a000586 	bne	3481c59c <inflate+0x165c>
        return Z_STREAM_ERROR;

    state = (struct inflate_state FAR *)strm->state;
    if (state->mode == TYPE) state->mode = TYPEDO;      /* skip check */
3481af80:	e5943000 	ldr	r3, [r4]
    LOAD();
3481af84:	e59a1004 	ldr	r1, [sl, #4]
    if (strm == Z_NULL || strm->state == Z_NULL ||
        (strm->next_in == Z_NULL && strm->avail_in != 0))
        return Z_STREAM_ERROR;

    state = (struct inflate_state FAR *)strm->state;
    if (state->mode == TYPE) state->mode = TYPEDO;      /* skip check */
3481af88:	e353000b 	cmp	r3, #11
    LOAD();
3481af8c:	e59a000c 	ldr	r0, [sl, #12]
3481af90:	e59ab010 	ldr	fp, [sl, #16]
    if (strm == Z_NULL || strm->state == Z_NULL ||
        (strm->next_in == Z_NULL && strm->avail_in != 0))
        return Z_STREAM_ERROR;

    state = (struct inflate_state FAR *)strm->state;
    if (state->mode == TYPE) state->mode = TYPEDO;      /* skip check */
3481af94:	02833001 	addeq	r3, r3, #1
    LOAD();
    in = have;
    out = left;
    ret = Z_OK;
3481af98:	e3a02000 	mov	r2, #0
        (strm->next_in == Z_NULL && strm->avail_in != 0))
        return Z_STREAM_ERROR;

    state = (struct inflate_state FAR *)strm->state;
    if (state->mode == TYPE) state->mode = TYPEDO;      /* skip check */
    LOAD();
3481af9c:	e5946038 	ldr	r6, [r4, #56]	; 0x38
3481afa0:	e594503c 	ldr	r5, [r4, #60]	; 0x3c
    if (strm == Z_NULL || strm->state == Z_NULL ||
        (strm->next_in == Z_NULL && strm->avail_in != 0))
        return Z_STREAM_ERROR;

    state = (struct inflate_state FAR *)strm->state;
    if (state->mode == TYPE) state->mode = TYPEDO;      /* skip check */
3481afa4:	05843000 	streq	r3, [r4]
    LOAD();
3481afa8:	e58d0020 	str	r0, [sp, #32]
3481afac:	e58d1038 	str	r1, [sp, #56]	; 0x38
    in = have;
    out = left;
3481afb0:	e58db02c 	str	fp, [sp, #44]	; 0x2c
        (strm->next_in == Z_NULL && strm->avail_in != 0))
        return Z_STREAM_ERROR;

    state = (struct inflate_state FAR *)strm->state;
    if (state->mode == TYPE) state->mode = TYPEDO;      /* skip check */
    LOAD();
3481afb4:	e1a07001 	mov	r7, r1
    in = have;
    out = left;
    ret = Z_OK;
3481afb8:	e58d201c 	str	r2, [sp, #28]
    for (;;)
        switch (state->mode) {
3481afbc:	e5943000 	ldr	r3, [r4]
3481afc0:	e353001c 	cmp	r3, #28
3481afc4:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
3481afc8:	ea000575 	b	3481c5a4 <inflate+0x1664>
3481afcc:	3481b060 	.word	0x3481b060
3481afd0:	3481b058 	.word	0x3481b058
3481afd4:	3481b23c 	.word	0x3481b23c
3481afd8:	3481b2c0 	.word	0x3481b2c0
3481afdc:	3481b340 	.word	0x3481b340
3481afe0:	3481b3d8 	.word	0x3481b3d8
3481afe4:	3481b49c 	.word	0x3481b49c
3481afe8:	3481b558 	.word	0x3481b558
3481afec:	3481b60c 	.word	0x3481b60c
3481aff0:	3481b050 	.word	0x3481b050
3481aff4:	3481b6e8 	.word	0x3481b6e8
3481aff8:	3481b738 	.word	0x3481b738
3481affc:	3481b744 	.word	0x3481b744
3481b000:	3481b7fc 	.word	0x3481b7fc
3481b004:	3481b864 	.word	0x3481b864
3481b008:	3481b048 	.word	0x3481b048
3481b00c:	3481b948 	.word	0x3481b948
3481b010:	3481ba3c 	.word	0x3481ba3c
3481b014:	3481bce4 	.word	0x3481bce4
3481b018:	3481be84 	.word	0x3481be84
3481b01c:	3481bee8 	.word	0x3481bee8
3481b020:	3481c010 	.word	0x3481c010
3481b024:	3481c0e4 	.word	0x3481c0e4
3481b028:	3481c18c 	.word	0x3481c18c
3481b02c:	3481c1b0 	.word	0x3481c1b0
3481b030:	3481c2ac 	.word	0x3481c2ac
3481b034:	3481c338 	.word	0x3481c338
3481b038:	3481c32c 	.word	0x3481c32c
3481b03c:	3481b040 	.word	0x3481b040
            goto inf_leave;
        case BAD:
            ret = Z_DATA_ERROR;
            goto inf_leave;
        case MEM:
            return Z_MEM_ERROR;
3481b040:	e3e03003 	mvn	r3, #3
3481b044:	ea000554 	b	3481c59c <inflate+0x165c>
    LOAD();
    in = have;
    out = left;
    ret = Z_OK;
    for (;;)
        switch (state->mode) {
3481b048:	e1a03009 	mov	r3, r9
3481b04c:	ea000223 	b	3481b8e0 <inflate+0x9a0>
3481b050:	e1a03009 	mov	r3, r9
3481b054:	ea000193 	b	3481b6a8 <inflate+0x768>
3481b058:	e1a03009 	mov	r3, r9
3481b05c:	ea000058 	b	3481b1c4 <inflate+0x284>
        case HEAD:
            if (state->wrap == 0) {
3481b060:	e5943008 	ldr	r3, [r4, #8]
3481b064:	e3530000 	cmp	r3, #0
3481b068:	11a02009 	movne	r2, r9
                state->mode = TYPEDO;
3481b06c:	03a0300c 	moveq	r3, #12
    out = left;
    ret = Z_OK;
    for (;;)
        switch (state->mode) {
        case HEAD:
            if (state->wrap == 0) {
3481b070:	1a000006 	bne	3481b090 <inflate+0x150>
3481b074:	ea0004a3 	b	3481c308 <inflate+0x13c8>
                state->mode = TYPEDO;
                break;
            }
            NEEDBITS(16);
3481b078:	e3570000 	cmp	r7, #0
3481b07c:	0a0004af 	beq	3481c340 <inflate+0x1400>
3481b080:	e4d21001 	ldrb	r1, [r2], #1
3481b084:	e2477001 	sub	r7, r7, #1
3481b088:	e0866511 	add	r6, r6, r1, lsl r5
3481b08c:	e2855008 	add	r5, r5, #8
3481b090:	e355000f 	cmp	r5, #15
3481b094:	e1a09002 	mov	r9, r2
3481b098:	9afffff6 	bls	3481b078 <inflate+0x138>
#ifdef GUNZIP
            if ((state->wrap & 2) && hold == 0x8b1f) {  /* gzip header */
3481b09c:	e7e020d3 	ubfx	r2, r3, #1, #1
3481b0a0:	e3081b1f 	movw	r1, #35615	; 0x8b1f
3481b0a4:	e1560001 	cmp	r6, r1
3481b0a8:	13a02000 	movne	r2, #0
3481b0ac:	02022001 	andeq	r2, r2, #1
3481b0b0:	e3520000 	cmp	r2, #0
3481b0b4:	0a000010 	beq	3481b0fc <inflate+0x1bc>
                state->check = crc32(0L, Z_NULL, 0);
3481b0b8:	e3a00000 	mov	r0, #0
3481b0bc:	e1a01000 	mov	r1, r0
3481b0c0:	e1a02000 	mov	r2, r0
3481b0c4:	ebffefef 	bl	34817088 <crc32>
                CRC2(state->check, hold);
3481b0c8:	e3a0301f 	mov	r3, #31
3481b0cc:	e5cd3044 	strb	r3, [sp, #68]	; 0x44
                break;
            }
            NEEDBITS(16);
#ifdef GUNZIP
            if ((state->wrap & 2) && hold == 0x8b1f) {  /* gzip header */
                state->check = crc32(0L, Z_NULL, 0);
3481b0d0:	e5840018 	str	r0, [r4, #24]
                CRC2(state->check, hold);
3481b0d4:	e3e03074 	mvn	r3, #116	; 0x74
3481b0d8:	e28d1044 	add	r1, sp, #68	; 0x44
3481b0dc:	e3a02002 	mov	r2, #2
3481b0e0:	e5cd3045 	strb	r3, [sp, #69]	; 0x45
3481b0e4:	ebffefe7 	bl	34817088 <crc32>
                INITBITS();
                state->mode = FLAGS;
3481b0e8:	e3a0c001 	mov	ip, #1
            }
            NEEDBITS(16);
#ifdef GUNZIP
            if ((state->wrap & 2) && hold == 0x8b1f) {  /* gzip header */
                state->check = crc32(0L, Z_NULL, 0);
                CRC2(state->check, hold);
3481b0ec:	e5840018 	str	r0, [r4, #24]
                INITBITS();
                state->mode = FLAGS;
3481b0f0:	e584c000 	str	ip, [r4]
            NEEDBITS(16);
#ifdef GUNZIP
            if ((state->wrap & 2) && hold == 0x8b1f) {  /* gzip header */
                state->check = crc32(0L, Z_NULL, 0);
                CRC2(state->check, hold);
                INITBITS();
3481b0f4:	e3a05000 	mov	r5, #0
3481b0f8:	ea000029 	b	3481b1a4 <inflate+0x264>
                state->mode = FLAGS;
                break;
            }
            state->flags = 0;           /* expect zlib header */
3481b0fc:	e5842010 	str	r2, [r4, #16]
            if (state->head != Z_NULL)
3481b100:	e5942020 	ldr	r2, [r4, #32]
3481b104:	e3520000 	cmp	r2, #0
                state->head->done = -1;
3481b108:	13e01000 	mvnne	r1, #0
3481b10c:	15821030 	strne	r1, [r2, #48]	; 0x30
            if (!(state->wrap & 1) ||   /* check if zlib header allowed */
3481b110:	e3130001 	tst	r3, #1
3481b114:	0a000006 	beq	3481b134 <inflate+0x1f4>
#else
            if (
#endif
                ((BITS(8) << 8) + (hold >> 8)) % 31) {
3481b118:	e1a03426 	lsr	r3, r6, #8
3481b11c:	e1a00c06 	lsl	r0, r6, #24
3481b120:	e0830820 	add	r0, r3, r0, lsr #16
3481b124:	e3a0101f 	mov	r1, #31
3481b128:	eb0013d8 	bl	34820090 <__aeabi_uidivmod>
                break;
            }
            state->flags = 0;           /* expect zlib header */
            if (state->head != Z_NULL)
                state->head->done = -1;
            if (!(state->wrap & 1) ||   /* check if zlib header allowed */
3481b12c:	e2513000 	subs	r3, r1, #0
3481b130:	0a000001 	beq	3481b13c <inflate+0x1fc>
#else
            if (
#endif
                ((BITS(8) << 8) + (hold >> 8)) % 31) {
                strm->msg = (char *)"incorrect header check";
3481b134:	e59f3ee8 	ldr	r3, [pc, #3816]	; 3481c024 <inflate+0x10e4>
3481b138:	ea000470 	b	3481c300 <inflate+0x13c0>
                state->mode = BAD;
                break;
            }
            if (BITS(4) != Z_DEFLATED) {
3481b13c:	e206200f 	and	r2, r6, #15
3481b140:	e3520008 	cmp	r2, #8
3481b144:	1a000025 	bne	3481b1e0 <inflate+0x2a0>
                strm->msg = (char *)"unknown compression method";
                state->mode = BAD;
                break;
            }
            DROPBITS(4);
3481b148:	e1a06226 	lsr	r6, r6, #4
            len = BITS(4) + 8;
3481b14c:	e206000f 	and	r0, r6, #15
            if (len > state->wbits) {
3481b150:	e5942024 	ldr	r2, [r4, #36]	; 0x24
                strm->msg = (char *)"unknown compression method";
                state->mode = BAD;
                break;
            }
            DROPBITS(4);
            len = BITS(4) + 8;
3481b154:	e2800008 	add	r0, r0, #8
            if (len > state->wbits) {
3481b158:	e1500002 	cmp	r0, r2
            if (BITS(4) != Z_DEFLATED) {
                strm->msg = (char *)"unknown compression method";
                state->mode = BAD;
                break;
            }
            DROPBITS(4);
3481b15c:	82455004 	subhi	r5, r5, #4
            len = BITS(4) + 8;
            if (len > state->wbits) {
                strm->msg = (char *)"invalid window size";
3481b160:	859f3ec0 	ldrhi	r3, [pc, #3776]	; 3481c028 <inflate+0x10e8>
3481b164:	8a000465 	bhi	3481c300 <inflate+0x13c0>
                state->mode = BAD;
                break;
            }
            state->dmax = 1U << len;
3481b168:	e3a02001 	mov	r2, #1
3481b16c:	e1a00012 	lsl	r0, r2, r0
            Tracev((stderr, "inflate:   zlib header ok\n"));
            strm->adler = state->check = adler32(0L, Z_NULL, 0);
3481b170:	e1a02003 	mov	r2, r3
            if (len > state->wbits) {
                strm->msg = (char *)"invalid window size";
                state->mode = BAD;
                break;
            }
            state->dmax = 1U << len;
3481b174:	e5840014 	str	r0, [r4, #20]
            Tracev((stderr, "inflate:   zlib header ok\n"));
            strm->adler = state->check = adler32(0L, Z_NULL, 0);
3481b178:	e1a00003 	mov	r0, r3
3481b17c:	e58d3014 	str	r3, [sp, #20]
3481b180:	ebfffeb4 	bl	3481ac58 <adler32>
            state->mode = hold & 0x200 ? DICTID : TYPE;
3481b184:	e3160c02 	tst	r6, #512	; 0x200
            INITBITS();
3481b188:	e59d3014 	ldr	r3, [sp, #20]
                break;
            }
            state->dmax = 1U << len;
            Tracev((stderr, "inflate:   zlib header ok\n"));
            strm->adler = state->check = adler32(0L, Z_NULL, 0);
            state->mode = hold & 0x200 ? DICTID : TYPE;
3481b18c:	03a0200b 	moveq	r2, #11
3481b190:	13a02009 	movne	r2, #9
                state->mode = BAD;
                break;
            }
            state->dmax = 1U << len;
            Tracev((stderr, "inflate:   zlib header ok\n"));
            strm->adler = state->check = adler32(0L, Z_NULL, 0);
3481b194:	e5840018 	str	r0, [r4, #24]
            state->mode = hold & 0x200 ? DICTID : TYPE;
            INITBITS();
3481b198:	e1a05003 	mov	r5, r3
                state->mode = BAD;
                break;
            }
            state->dmax = 1U << len;
            Tracev((stderr, "inflate:   zlib header ok\n"));
            strm->adler = state->check = adler32(0L, Z_NULL, 0);
3481b19c:	e58a0034 	str	r0, [sl, #52]	; 0x34
            state->mode = hold & 0x200 ? DICTID : TYPE;
3481b1a0:	e5842000 	str	r2, [r4]
            INITBITS();
3481b1a4:	e1a06005 	mov	r6, r5
            break;
3481b1a8:	eaffff83 	b	3481afbc <inflate+0x7c>
#ifdef GUNZIP
        case FLAGS:
            NEEDBITS(16);
3481b1ac:	e3570000 	cmp	r7, #0
3481b1b0:	0a000462 	beq	3481c340 <inflate+0x1400>
3481b1b4:	e4d32001 	ldrb	r2, [r3], #1
3481b1b8:	e2477001 	sub	r7, r7, #1
3481b1bc:	e0866512 	add	r6, r6, r2, lsl r5
3481b1c0:	e2855008 	add	r5, r5, #8
3481b1c4:	e355000f 	cmp	r5, #15
3481b1c8:	e1a09003 	mov	r9, r3
3481b1cc:	9afffff6 	bls	3481b1ac <inflate+0x26c>
            state->flags = (int)(hold);
            if ((state->flags & 0xff) != Z_DEFLATED) {
3481b1d0:	e20630ff 	and	r3, r6, #255	; 0xff
3481b1d4:	e3530008 	cmp	r3, #8
            INITBITS();
            break;
#ifdef GUNZIP
        case FLAGS:
            NEEDBITS(16);
            state->flags = (int)(hold);
3481b1d8:	e5846010 	str	r6, [r4, #16]
            if ((state->flags & 0xff) != Z_DEFLATED) {
3481b1dc:	0a000001 	beq	3481b1e8 <inflate+0x2a8>
                strm->msg = (char *)"unknown compression method";
3481b1e0:	e59f3e44 	ldr	r3, [pc, #3652]	; 3481c02c <inflate+0x10ec>
3481b1e4:	ea000445 	b	3481c300 <inflate+0x13c0>
                state->mode = BAD;
                break;
            }
            if (state->flags & 0xe000) {
3481b1e8:	e3160a0e 	tst	r6, #57344	; 0xe000
                strm->msg = (char *)"unknown header flags set";
3481b1ec:	159f3e3c 	ldrne	r3, [pc, #3644]	; 3481c030 <inflate+0x10f0>
            if ((state->flags & 0xff) != Z_DEFLATED) {
                strm->msg = (char *)"unknown compression method";
                state->mode = BAD;
                break;
            }
            if (state->flags & 0xe000) {
3481b1f0:	1a000442 	bne	3481c300 <inflate+0x13c0>
                strm->msg = (char *)"unknown header flags set";
                state->mode = BAD;
                break;
            }
            if (state->head != Z_NULL)
3481b1f4:	e5943020 	ldr	r3, [r4, #32]
3481b1f8:	e3530000 	cmp	r3, #0
                state->head->text = (int)((hold >> 8) & 1);
3481b1fc:	17e02456 	ubfxne	r2, r6, #8, #1
3481b200:	15832000 	strne	r2, [r3]
            if (state->flags & 0x0200) CRC2(state->check, hold);
3481b204:	e3160c02 	tst	r6, #512	; 0x200
3481b208:	0a000007 	beq	3481b22c <inflate+0x2ec>
3481b20c:	e5cd6044 	strb	r6, [sp, #68]	; 0x44
3481b210:	e1a06426 	lsr	r6, r6, #8
3481b214:	e5cd6045 	strb	r6, [sp, #69]	; 0x45
3481b218:	e5940018 	ldr	r0, [r4, #24]
3481b21c:	e28d1044 	add	r1, sp, #68	; 0x44
3481b220:	e3a02002 	mov	r2, #2
3481b224:	ebffef97 	bl	34817088 <crc32>
3481b228:	e5840018 	str	r0, [r4, #24]
            INITBITS();
            state->mode = TIME;
3481b22c:	e3a03002 	mov	r3, #2
                break;
            }
            if (state->head != Z_NULL)
                state->head->text = (int)((hold >> 8) & 1);
            if (state->flags & 0x0200) CRC2(state->check, hold);
            INITBITS();
3481b230:	e3a05000 	mov	r5, #0
            state->mode = TIME;
3481b234:	e5843000 	str	r3, [r4]
                break;
            }
            if (state->head != Z_NULL)
                state->head->text = (int)((hold >> 8) & 1);
            if (state->flags & 0x0200) CRC2(state->check, hold);
            INITBITS();
3481b238:	e1a06005 	mov	r6, r5
            state->mode = TIME;
3481b23c:	e1a03009 	mov	r3, r9
3481b240:	ea000005 	b	3481b25c <inflate+0x31c>
        case TIME:
            NEEDBITS(32);
3481b244:	e3570000 	cmp	r7, #0
3481b248:	0a00043c 	beq	3481c340 <inflate+0x1400>
3481b24c:	e4d32001 	ldrb	r2, [r3], #1
3481b250:	e2477001 	sub	r7, r7, #1
3481b254:	e0866512 	add	r6, r6, r2, lsl r5
3481b258:	e2855008 	add	r5, r5, #8
3481b25c:	e355001f 	cmp	r5, #31
3481b260:	e1a09003 	mov	r9, r3
3481b264:	9afffff6 	bls	3481b244 <inflate+0x304>
            if (state->head != Z_NULL)
3481b268:	e5943020 	ldr	r3, [r4, #32]
3481b26c:	e3530000 	cmp	r3, #0
                state->head->time = hold;
3481b270:	15836004 	strne	r6, [r3, #4]
            if (state->flags & 0x0200) CRC4(state->check, hold);
3481b274:	e5943010 	ldr	r3, [r4, #16]
3481b278:	e3130c02 	tst	r3, #512	; 0x200
3481b27c:	0a00000b 	beq	3481b2b0 <inflate+0x370>
3481b280:	e1a03426 	lsr	r3, r6, #8
3481b284:	e5cd6044 	strb	r6, [sp, #68]	; 0x44
3481b288:	e5cd3045 	strb	r3, [sp, #69]	; 0x45
3481b28c:	e1a03826 	lsr	r3, r6, #16
3481b290:	e1a06c26 	lsr	r6, r6, #24
3481b294:	e5cd3046 	strb	r3, [sp, #70]	; 0x46
3481b298:	e5cd6047 	strb	r6, [sp, #71]	; 0x47
3481b29c:	e5940018 	ldr	r0, [r4, #24]
3481b2a0:	e28d1044 	add	r1, sp, #68	; 0x44
3481b2a4:	e3a02004 	mov	r2, #4
3481b2a8:	ebffef76 	bl	34817088 <crc32>
3481b2ac:	e5840018 	str	r0, [r4, #24]
            INITBITS();
            state->mode = OS;
3481b2b0:	e3a03003 	mov	r3, #3
        case TIME:
            NEEDBITS(32);
            if (state->head != Z_NULL)
                state->head->time = hold;
            if (state->flags & 0x0200) CRC4(state->check, hold);
            INITBITS();
3481b2b4:	e3a05000 	mov	r5, #0
            state->mode = OS;
3481b2b8:	e5843000 	str	r3, [r4]
        case TIME:
            NEEDBITS(32);
            if (state->head != Z_NULL)
                state->head->time = hold;
            if (state->flags & 0x0200) CRC4(state->check, hold);
            INITBITS();
3481b2bc:	e1a06005 	mov	r6, r5
            state->mode = OS;
3481b2c0:	e1a03009 	mov	r3, r9
3481b2c4:	ea000005 	b	3481b2e0 <inflate+0x3a0>
        case OS:
            NEEDBITS(16);
3481b2c8:	e3570000 	cmp	r7, #0
3481b2cc:	0a00041b 	beq	3481c340 <inflate+0x1400>
3481b2d0:	e4d32001 	ldrb	r2, [r3], #1
3481b2d4:	e2477001 	sub	r7, r7, #1
3481b2d8:	e0866512 	add	r6, r6, r2, lsl r5
3481b2dc:	e2855008 	add	r5, r5, #8
3481b2e0:	e355000f 	cmp	r5, #15
3481b2e4:	e1a09003 	mov	r9, r3
3481b2e8:	9afffff6 	bls	3481b2c8 <inflate+0x388>
            if (state->head != Z_NULL) {
3481b2ec:	e5943020 	ldr	r3, [r4, #32]
3481b2f0:	e3530000 	cmp	r3, #0
                state->head->xflags = (int)(hold & 0xff);
3481b2f4:	120620ff 	andne	r2, r6, #255	; 0xff
3481b2f8:	15832008 	strne	r2, [r3, #8]
                state->head->os = (int)(hold >> 8);
3481b2fc:	11a02426 	lsrne	r2, r6, #8
3481b300:	1583200c 	strne	r2, [r3, #12]
            }
            if (state->flags & 0x0200) CRC2(state->check, hold);
3481b304:	e5943010 	ldr	r3, [r4, #16]
3481b308:	e3130c02 	tst	r3, #512	; 0x200
3481b30c:	0a000007 	beq	3481b330 <inflate+0x3f0>
3481b310:	e5cd6044 	strb	r6, [sp, #68]	; 0x44
3481b314:	e1a06426 	lsr	r6, r6, #8
3481b318:	e5cd6045 	strb	r6, [sp, #69]	; 0x45
3481b31c:	e5940018 	ldr	r0, [r4, #24]
3481b320:	e28d1044 	add	r1, sp, #68	; 0x44
3481b324:	e3a02002 	mov	r2, #2
3481b328:	ebffef56 	bl	34817088 <crc32>
3481b32c:	e5840018 	str	r0, [r4, #24]
            INITBITS();
            state->mode = EXLEN;
3481b330:	e3a03004 	mov	r3, #4
            if (state->head != Z_NULL) {
                state->head->xflags = (int)(hold & 0xff);
                state->head->os = (int)(hold >> 8);
            }
            if (state->flags & 0x0200) CRC2(state->check, hold);
            INITBITS();
3481b334:	e3a05000 	mov	r5, #0
            state->mode = EXLEN;
3481b338:	e5843000 	str	r3, [r4]
            if (state->head != Z_NULL) {
                state->head->xflags = (int)(hold & 0xff);
                state->head->os = (int)(hold >> 8);
            }
            if (state->flags & 0x0200) CRC2(state->check, hold);
            INITBITS();
3481b33c:	e1a06005 	mov	r6, r5
            state->mode = EXLEN;
        case EXLEN:
            if (state->flags & 0x0400) {
3481b340:	e5943010 	ldr	r3, [r4, #16]
3481b344:	e2132b01 	ands	r2, r3, #1024	; 0x400
3481b348:	11a02009 	movne	r2, r9
3481b34c:	1a000006 	bne	3481b36c <inflate+0x42c>
3481b350:	ea000019 	b	3481b3bc <inflate+0x47c>
                NEEDBITS(16);
3481b354:	e3570000 	cmp	r7, #0
3481b358:	0a0003f8 	beq	3481c340 <inflate+0x1400>
3481b35c:	e4d21001 	ldrb	r1, [r2], #1
3481b360:	e2477001 	sub	r7, r7, #1
3481b364:	e0866511 	add	r6, r6, r1, lsl r5
3481b368:	e2855008 	add	r5, r5, #8
3481b36c:	e355000f 	cmp	r5, #15
3481b370:	e1a09002 	mov	r9, r2
3481b374:	9afffff6 	bls	3481b354 <inflate+0x414>
                state->length = (unsigned)(hold);
                if (state->head != Z_NULL)
3481b378:	e5942020 	ldr	r2, [r4, #32]
            INITBITS();
            state->mode = EXLEN;
        case EXLEN:
            if (state->flags & 0x0400) {
                NEEDBITS(16);
                state->length = (unsigned)(hold);
3481b37c:	e5846040 	str	r6, [r4, #64]	; 0x40
                if (state->head != Z_NULL)
3481b380:	e3520000 	cmp	r2, #0
                    state->head->extra_len = (unsigned)hold;
3481b384:	15826014 	strne	r6, [r2, #20]
                if (state->flags & 0x0200) CRC2(state->check, hold);
3481b388:	e2133c02 	ands	r3, r3, #512	; 0x200
                INITBITS();
3481b38c:	01a06003 	moveq	r6, r3
            if (state->flags & 0x0400) {
                NEEDBITS(16);
                state->length = (unsigned)(hold);
                if (state->head != Z_NULL)
                    state->head->extra_len = (unsigned)hold;
                if (state->flags & 0x0200) CRC2(state->check, hold);
3481b390:	0a00000d 	beq	3481b3cc <inflate+0x48c>
3481b394:	e5cd6044 	strb	r6, [sp, #68]	; 0x44
3481b398:	e1a06426 	lsr	r6, r6, #8
3481b39c:	e5cd6045 	strb	r6, [sp, #69]	; 0x45
3481b3a0:	e5940018 	ldr	r0, [r4, #24]
3481b3a4:	e28d1044 	add	r1, sp, #68	; 0x44
3481b3a8:	e3a02002 	mov	r2, #2
3481b3ac:	ebffef35 	bl	34817088 <crc32>
                INITBITS();
3481b3b0:	e3a06000 	mov	r6, #0
            if (state->flags & 0x0400) {
                NEEDBITS(16);
                state->length = (unsigned)(hold);
                if (state->head != Z_NULL)
                    state->head->extra_len = (unsigned)hold;
                if (state->flags & 0x0200) CRC2(state->check, hold);
3481b3b4:	e5840018 	str	r0, [r4, #24]
3481b3b8:	ea000003 	b	3481b3cc <inflate+0x48c>
                INITBITS();
            }
            else if (state->head != Z_NULL)
3481b3bc:	e5943020 	ldr	r3, [r4, #32]
3481b3c0:	e3530000 	cmp	r3, #0
                state->head->extra = Z_NULL;
3481b3c4:	15832010 	strne	r2, [r3, #16]
3481b3c8:	ea000000 	b	3481b3d0 <inflate+0x490>
                NEEDBITS(16);
                state->length = (unsigned)(hold);
                if (state->head != Z_NULL)
                    state->head->extra_len = (unsigned)hold;
                if (state->flags & 0x0200) CRC2(state->check, hold);
                INITBITS();
3481b3cc:	e1a05006 	mov	r5, r6
            }
            else if (state->head != Z_NULL)
                state->head->extra = Z_NULL;
            state->mode = EXTRA;
3481b3d0:	e3a03005 	mov	r3, #5
3481b3d4:	e5843000 	str	r3, [r4]
        case EXTRA:
            if (state->flags & 0x0400) {
3481b3d8:	e5943010 	ldr	r3, [r4, #16]
3481b3dc:	e3130b01 	tst	r3, #1024	; 0x400
3481b3e0:	0a000029 	beq	3481b48c <inflate+0x54c>
                copy = state->length;
3481b3e4:	e5942040 	ldr	r2, [r4, #64]	; 0x40
3481b3e8:	e1570002 	cmp	r7, r2
3481b3ec:	31a03007 	movcc	r3, r7
3481b3f0:	21a03002 	movcs	r3, r2
                if (copy > have) copy = have;
                if (copy) {
3481b3f4:	e3530000 	cmp	r3, #0
3481b3f8:	0a000020 	beq	3481b480 <inflate+0x540>
                    if (state->head != Z_NULL &&
3481b3fc:	e5941020 	ldr	r1, [r4, #32]
3481b400:	e3510000 	cmp	r1, #0
3481b404:	0a00000e 	beq	3481b444 <inflate+0x504>
                        state->head->extra != Z_NULL) {
3481b408:	e5910010 	ldr	r0, [r1, #16]
        case EXTRA:
            if (state->flags & 0x0400) {
                copy = state->length;
                if (copy > have) copy = have;
                if (copy) {
                    if (state->head != Z_NULL &&
3481b40c:	e3500000 	cmp	r0, #0
3481b410:	0a00000b 	beq	3481b444 <inflate+0x504>
                        state->head->extra != Z_NULL) {
                        len = state->head->extra_len - state->length;
3481b414:	e591c014 	ldr	ip, [r1, #20]
                        zmemcpy(state->head->extra + len, next,
                                len + copy > state->head->extra_max ?
3481b418:	e5911018 	ldr	r1, [r1, #24]
                copy = state->length;
                if (copy > have) copy = have;
                if (copy) {
                    if (state->head != Z_NULL &&
                        state->head->extra != Z_NULL) {
                        len = state->head->extra_len - state->length;
3481b41c:	e062200c 	rsb	r2, r2, ip
                        zmemcpy(state->head->extra + len, next,
                                len + copy > state->head->extra_max ?
3481b420:	e083c002 	add	ip, r3, r2
                if (copy > have) copy = have;
                if (copy) {
                    if (state->head != Z_NULL &&
                        state->head->extra != Z_NULL) {
                        len = state->head->extra_len - state->length;
                        zmemcpy(state->head->extra + len, next,
3481b424:	e15c0001 	cmp	ip, r1
3481b428:	e0800002 	add	r0, r0, r2
3481b42c:	80622001 	rsbhi	r2, r2, r1
3481b430:	91a02003 	movls	r2, r3
3481b434:	e1a01009 	mov	r1, r9
3481b438:	e58d3014 	str	r3, [sp, #20]
3481b43c:	ebfff693 	bl	34818e90 <memcpy>
3481b440:	e59d3014 	ldr	r3, [sp, #20]
                                len + copy > state->head->extra_max ?
                                state->head->extra_max - len : copy);
                    }
                    if (state->flags & 0x0200)
3481b444:	e5942010 	ldr	r2, [r4, #16]
3481b448:	e3120c02 	tst	r2, #512	; 0x200
3481b44c:	0a000006 	beq	3481b46c <inflate+0x52c>
                        state->check = crc32(state->check, next, copy);
3481b450:	e5940018 	ldr	r0, [r4, #24]
3481b454:	e1a02003 	mov	r2, r3
3481b458:	e1a01009 	mov	r1, r9
3481b45c:	e58d3014 	str	r3, [sp, #20]
3481b460:	ebffef08 	bl	34817088 <crc32>
3481b464:	e59d3014 	ldr	r3, [sp, #20]
3481b468:	e5840018 	str	r0, [r4, #24]
                    have -= copy;
                    next += copy;
                    state->length -= copy;
3481b46c:	e5942040 	ldr	r2, [r4, #64]	; 0x40
                                len + copy > state->head->extra_max ?
                                state->head->extra_max - len : copy);
                    }
                    if (state->flags & 0x0200)
                        state->check = crc32(state->check, next, copy);
                    have -= copy;
3481b470:	e0637007 	rsb	r7, r3, r7
                    next += copy;
3481b474:	e0899003 	add	r9, r9, r3
                    state->length -= copy;
3481b478:	e0633002 	rsb	r3, r3, r2
3481b47c:	e5843040 	str	r3, [r4, #64]	; 0x40
                }
                if (state->length) goto inf_leave;
3481b480:	e5943040 	ldr	r3, [r4, #64]	; 0x40
3481b484:	e3530000 	cmp	r3, #0
3481b488:	1a0003ac 	bne	3481c340 <inflate+0x1400>
            }
            state->length = 0;
3481b48c:	e3a03000 	mov	r3, #0
3481b490:	e5843040 	str	r3, [r4, #64]	; 0x40
            state->mode = NAME;
3481b494:	e2833006 	add	r3, r3, #6
3481b498:	e5843000 	str	r3, [r4]
        case NAME:
            if (state->flags & 0x0800) {
3481b49c:	e5942010 	ldr	r2, [r4, #16]
3481b4a0:	e2122b02 	ands	r2, r2, #2048	; 0x800
3481b4a4:	0a000024 	beq	3481b53c <inflate+0x5fc>
                if (have == 0) goto inf_leave;
3481b4a8:	e3570000 	cmp	r7, #0
3481b4ac:	0a0003a3 	beq	3481c340 <inflate+0x1400>
3481b4b0:	e3a03000 	mov	r3, #0
                copy = 0;
                do {
                    len = (unsigned)(next[copy++]);
                    if (state->head != Z_NULL &&
3481b4b4:	e5941020 	ldr	r1, [r4, #32]
        case NAME:
            if (state->flags & 0x0800) {
                if (have == 0) goto inf_leave;
                copy = 0;
                do {
                    len = (unsigned)(next[copy++]);
3481b4b8:	e7d9c003 	ldrb	ip, [r9, r3]
                    if (state->head != Z_NULL &&
3481b4bc:	e3510000 	cmp	r1, #0
        case NAME:
            if (state->flags & 0x0800) {
                if (have == 0) goto inf_leave;
                copy = 0;
                do {
                    len = (unsigned)(next[copy++]);
3481b4c0:	e2833001 	add	r3, r3, #1
                    if (state->head != Z_NULL &&
3481b4c4:	0a000008 	beq	3481b4ec <inflate+0x5ac>
                            state->head->name != Z_NULL &&
3481b4c8:	e591001c 	ldr	r0, [r1, #28]
            if (state->flags & 0x0800) {
                if (have == 0) goto inf_leave;
                copy = 0;
                do {
                    len = (unsigned)(next[copy++]);
                    if (state->head != Z_NULL &&
3481b4cc:	e3500000 	cmp	r0, #0
3481b4d0:	0a000005 	beq	3481b4ec <inflate+0x5ac>
                            state->head->name != Z_NULL &&
                            state->length < state->head->name_max)
3481b4d4:	e5942040 	ldr	r2, [r4, #64]	; 0x40
                if (have == 0) goto inf_leave;
                copy = 0;
                do {
                    len = (unsigned)(next[copy++]);
                    if (state->head != Z_NULL &&
                            state->head->name != Z_NULL &&
3481b4d8:	e5911020 	ldr	r1, [r1, #32]
3481b4dc:	e1520001 	cmp	r2, r1
                            state->length < state->head->name_max)
                        state->head->name[state->length++] = len;
3481b4e0:	37c0c002 	strbcc	ip, [r0, r2]
3481b4e4:	32822001 	addcc	r2, r2, #1
3481b4e8:	35842040 	strcc	r2, [r4, #64]	; 0x40
                } while (len && copy < have);
3481b4ec:	e35c0000 	cmp	ip, #0
3481b4f0:	11530007 	cmpne	r3, r7
3481b4f4:	3affffee 	bcc	3481b4b4 <inflate+0x574>
                if (state->flags & 0x0200)
3481b4f8:	e5942010 	ldr	r2, [r4, #16]
3481b4fc:	e3120c02 	tst	r2, #512	; 0x200
3481b500:	0a000008 	beq	3481b528 <inflate+0x5e8>
                    state->check = crc32(state->check, next, copy);
3481b504:	e5940018 	ldr	r0, [r4, #24]
3481b508:	e1a02003 	mov	r2, r3
3481b50c:	e1a01009 	mov	r1, r9
3481b510:	e58d3014 	str	r3, [sp, #20]
3481b514:	e58dc018 	str	ip, [sp, #24]
3481b518:	ebffeeda 	bl	34817088 <crc32>
3481b51c:	e59dc018 	ldr	ip, [sp, #24]
3481b520:	e59d3014 	ldr	r3, [sp, #20]
3481b524:	e5840018 	str	r0, [r4, #24]
                have -= copy;
                next += copy;
                if (len) goto inf_leave;
3481b528:	e35c0000 	cmp	ip, #0
                            state->length < state->head->name_max)
                        state->head->name[state->length++] = len;
                } while (len && copy < have);
                if (state->flags & 0x0200)
                    state->check = crc32(state->check, next, copy);
                have -= copy;
3481b52c:	e0637007 	rsb	r7, r3, r7
                next += copy;
3481b530:	e0899003 	add	r9, r9, r3
                if (len) goto inf_leave;
3481b534:	0a000003 	beq	3481b548 <inflate+0x608>
3481b538:	ea000380 	b	3481c340 <inflate+0x1400>
            }
            else if (state->head != Z_NULL)
3481b53c:	e5943020 	ldr	r3, [r4, #32]
3481b540:	e3530000 	cmp	r3, #0
                state->head->name = Z_NULL;
3481b544:	1583201c 	strne	r2, [r3, #28]
            state->length = 0;
3481b548:	e3a0c000 	mov	ip, #0
            state->mode = COMMENT;
3481b54c:	e3a03007 	mov	r3, #7
                next += copy;
                if (len) goto inf_leave;
            }
            else if (state->head != Z_NULL)
                state->head->name = Z_NULL;
            state->length = 0;
3481b550:	e584c040 	str	ip, [r4, #64]	; 0x40
            state->mode = COMMENT;
3481b554:	e5843000 	str	r3, [r4]
        case COMMENT:
            if (state->flags & 0x1000) {
3481b558:	e5942010 	ldr	r2, [r4, #16]
3481b55c:	e2122a01 	ands	r2, r2, #4096	; 0x1000
3481b560:	0a000024 	beq	3481b5f8 <inflate+0x6b8>
                if (have == 0) goto inf_leave;
3481b564:	e3570000 	cmp	r7, #0
3481b568:	0a000374 	beq	3481c340 <inflate+0x1400>
3481b56c:	e3a03000 	mov	r3, #0
                copy = 0;
                do {
                    len = (unsigned)(next[copy++]);
                    if (state->head != Z_NULL &&
3481b570:	e5941020 	ldr	r1, [r4, #32]
        case COMMENT:
            if (state->flags & 0x1000) {
                if (have == 0) goto inf_leave;
                copy = 0;
                do {
                    len = (unsigned)(next[copy++]);
3481b574:	e7d9c003 	ldrb	ip, [r9, r3]
                    if (state->head != Z_NULL &&
3481b578:	e3510000 	cmp	r1, #0
        case COMMENT:
            if (state->flags & 0x1000) {
                if (have == 0) goto inf_leave;
                copy = 0;
                do {
                    len = (unsigned)(next[copy++]);
3481b57c:	e2833001 	add	r3, r3, #1
                    if (state->head != Z_NULL &&
3481b580:	0a000008 	beq	3481b5a8 <inflate+0x668>
                            state->head->comment != Z_NULL &&
3481b584:	e5910024 	ldr	r0, [r1, #36]	; 0x24
            if (state->flags & 0x1000) {
                if (have == 0) goto inf_leave;
                copy = 0;
                do {
                    len = (unsigned)(next[copy++]);
                    if (state->head != Z_NULL &&
3481b588:	e3500000 	cmp	r0, #0
3481b58c:	0a000005 	beq	3481b5a8 <inflate+0x668>
                            state->head->comment != Z_NULL &&
                            state->length < state->head->comm_max)
3481b590:	e5942040 	ldr	r2, [r4, #64]	; 0x40
                if (have == 0) goto inf_leave;
                copy = 0;
                do {
                    len = (unsigned)(next[copy++]);
                    if (state->head != Z_NULL &&
                            state->head->comment != Z_NULL &&
3481b594:	e5911028 	ldr	r1, [r1, #40]	; 0x28
3481b598:	e1520001 	cmp	r2, r1
                            state->length < state->head->comm_max)
                        state->head->comment[state->length++] = len;
3481b59c:	37c0c002 	strbcc	ip, [r0, r2]
3481b5a0:	32822001 	addcc	r2, r2, #1
3481b5a4:	35842040 	strcc	r2, [r4, #64]	; 0x40
                } while (len && copy < have);
3481b5a8:	e35c0000 	cmp	ip, #0
3481b5ac:	11530007 	cmpne	r3, r7
3481b5b0:	3affffee 	bcc	3481b570 <inflate+0x630>
                if (state->flags & 0x0200)
3481b5b4:	e5942010 	ldr	r2, [r4, #16]
3481b5b8:	e3120c02 	tst	r2, #512	; 0x200
3481b5bc:	0a000008 	beq	3481b5e4 <inflate+0x6a4>
                    state->check = crc32(state->check, next, copy);
3481b5c0:	e5940018 	ldr	r0, [r4, #24]
3481b5c4:	e1a02003 	mov	r2, r3
3481b5c8:	e1a01009 	mov	r1, r9
3481b5cc:	e58d3014 	str	r3, [sp, #20]
3481b5d0:	e58dc018 	str	ip, [sp, #24]
3481b5d4:	ebffeeab 	bl	34817088 <crc32>
3481b5d8:	e59dc018 	ldr	ip, [sp, #24]
3481b5dc:	e59d3014 	ldr	r3, [sp, #20]
3481b5e0:	e5840018 	str	r0, [r4, #24]
                have -= copy;
                next += copy;
                if (len) goto inf_leave;
3481b5e4:	e35c0000 	cmp	ip, #0
                            state->length < state->head->comm_max)
                        state->head->comment[state->length++] = len;
                } while (len && copy < have);
                if (state->flags & 0x0200)
                    state->check = crc32(state->check, next, copy);
                have -= copy;
3481b5e8:	e0637007 	rsb	r7, r3, r7
                next += copy;
3481b5ec:	e0899003 	add	r9, r9, r3
                if (len) goto inf_leave;
3481b5f0:	0a000003 	beq	3481b604 <inflate+0x6c4>
3481b5f4:	ea000351 	b	3481c340 <inflate+0x1400>
            }
            else if (state->head != Z_NULL)
3481b5f8:	e5943020 	ldr	r3, [r4, #32]
3481b5fc:	e3530000 	cmp	r3, #0
                state->head->comment = Z_NULL;
3481b600:	15832024 	strne	r2, [r3, #36]	; 0x24
            state->mode = HCRC;
3481b604:	e3a03008 	mov	r3, #8
3481b608:	e5843000 	str	r3, [r4]
        case HCRC:
            if (state->flags & 0x0200) {
3481b60c:	e5942010 	ldr	r2, [r4, #16]
3481b610:	e3120c02 	tst	r2, #512	; 0x200
3481b614:	11a03009 	movne	r3, r9
3481b618:	1a000006 	bne	3481b638 <inflate+0x6f8>
3481b61c:	ea00000e 	b	3481b65c <inflate+0x71c>
                NEEDBITS(16);
3481b620:	e3570000 	cmp	r7, #0
3481b624:	0a000345 	beq	3481c340 <inflate+0x1400>
3481b628:	e4d31001 	ldrb	r1, [r3], #1
3481b62c:	e2477001 	sub	r7, r7, #1
3481b630:	e0866511 	add	r6, r6, r1, lsl r5
3481b634:	e2855008 	add	r5, r5, #8
3481b638:	e355000f 	cmp	r5, #15
3481b63c:	e1a09003 	mov	r9, r3
3481b640:	9afffff6 	bls	3481b620 <inflate+0x6e0>
                if (hold != (state->check & 0xffff)) {
3481b644:	e1d431b8 	ldrh	r3, [r4, #24]
3481b648:	e1560003 	cmp	r6, r3
                    strm->msg = (char *)"header crc mismatch";
3481b64c:	159f39e0 	ldrne	r3, [pc, #2528]	; 3481c034 <inflate+0x10f4>
                state->head->comment = Z_NULL;
            state->mode = HCRC;
        case HCRC:
            if (state->flags & 0x0200) {
                NEEDBITS(16);
                if (hold != (state->check & 0xffff)) {
3481b650:	1a00032a 	bne	3481c300 <inflate+0x13c0>
                    strm->msg = (char *)"header crc mismatch";
                    state->mode = BAD;
                    break;
                }
                INITBITS();
3481b654:	e3a05000 	mov	r5, #0
3481b658:	e1a06005 	mov	r6, r5
            }
            if (state->head != Z_NULL) {
3481b65c:	e5943020 	ldr	r3, [r4, #32]
3481b660:	e3530000 	cmp	r3, #0
                state->head->hcrc = (int)((state->flags >> 9) & 1);
                state->head->done = 1;
3481b664:	13a00001 	movne	r0, #1
                    break;
                }
                INITBITS();
            }
            if (state->head != Z_NULL) {
                state->head->hcrc = (int)((state->flags >> 9) & 1);
3481b668:	17e024d2 	ubfxne	r2, r2, #9, #1
                state->head->done = 1;
3481b66c:	15830030 	strne	r0, [r3, #48]	; 0x30
            }
            strm->adler = state->check = crc32(0L, Z_NULL, 0);
3481b670:	e3a00000 	mov	r0, #0
                    break;
                }
                INITBITS();
            }
            if (state->head != Z_NULL) {
                state->head->hcrc = (int)((state->flags >> 9) & 1);
3481b674:	1583202c 	strne	r2, [r3, #44]	; 0x2c
                state->head->done = 1;
            }
            strm->adler = state->check = crc32(0L, Z_NULL, 0);
3481b678:	e1a01000 	mov	r1, r0
3481b67c:	e1a02000 	mov	r2, r0
3481b680:	ebffee80 	bl	34817088 <crc32>
3481b684:	e5840018 	str	r0, [r4, #24]
3481b688:	e58a0034 	str	r0, [sl, #52]	; 0x34
3481b68c:	ea0001f3 	b	3481be60 <inflate+0xf20>
            state->mode = TYPE;
            break;
#endif
        case DICTID:
            NEEDBITS(32);
3481b690:	e3570000 	cmp	r7, #0
3481b694:	0a000329 	beq	3481c340 <inflate+0x1400>
3481b698:	e4d32001 	ldrb	r2, [r3], #1
3481b69c:	e2477001 	sub	r7, r7, #1
3481b6a0:	e0866512 	add	r6, r6, r2, lsl r5
3481b6a4:	e2855008 	add	r5, r5, #8
3481b6a8:	e355001f 	cmp	r5, #31
3481b6ac:	e1a09003 	mov	r9, r3
3481b6b0:	9afffff6 	bls	3481b690 <inflate+0x750>
            strm->adler = state->check = REVERSE(hold);
3481b6b4:	e1a02c26 	lsr	r2, r6, #24
3481b6b8:	e1a03426 	lsr	r3, r6, #8
3481b6bc:	e0822c06 	add	r2, r2, r6, lsl #24
3481b6c0:	e2033cff 	and	r3, r3, #65280	; 0xff00
3481b6c4:	e2066cff 	and	r6, r6, #65280	; 0xff00
3481b6c8:	e0823003 	add	r3, r2, r3
3481b6cc:	e0833406 	add	r3, r3, r6, lsl #8
3481b6d0:	e5843018 	str	r3, [r4, #24]
            INITBITS();
3481b6d4:	e3a06000 	mov	r6, #0
            state->mode = TYPE;
            break;
#endif
        case DICTID:
            NEEDBITS(32);
            strm->adler = state->check = REVERSE(hold);
3481b6d8:	e58a3034 	str	r3, [sl, #52]	; 0x34
            INITBITS();
            state->mode = DICT;
3481b6dc:	e3a0300a 	mov	r3, #10
3481b6e0:	e5843000 	str	r3, [r4]
            break;
#endif
        case DICTID:
            NEEDBITS(32);
            strm->adler = state->check = REVERSE(hold);
            INITBITS();
3481b6e4:	e1a05006 	mov	r5, r6
            state->mode = DICT;
        case DICT:
            if (state->havedict == 0) {
3481b6e8:	e594300c 	ldr	r3, [r4, #12]
3481b6ec:	e3530000 	cmp	r3, #0
3481b6f0:	1a000008 	bne	3481b718 <inflate+0x7d8>
                RESTORE();
3481b6f4:	e59d1020 	ldr	r1, [sp, #32]
3481b6f8:	e58ab010 	str	fp, [sl, #16]
3481b6fc:	e58a100c 	str	r1, [sl, #12]
3481b700:	e58a9000 	str	r9, [sl]
3481b704:	e58a7004 	str	r7, [sl, #4]
                return Z_NEED_DICT;
3481b708:	e3a02002 	mov	r2, #2
            strm->adler = state->check = REVERSE(hold);
            INITBITS();
            state->mode = DICT;
        case DICT:
            if (state->havedict == 0) {
                RESTORE();
3481b70c:	e5846038 	str	r6, [r4, #56]	; 0x38
3481b710:	e584503c 	str	r5, [r4, #60]	; 0x3c
3481b714:	ea00039e 	b	3481c594 <inflate+0x1654>
                return Z_NEED_DICT;
            }
            strm->adler = state->check = adler32(0L, Z_NULL, 0);
3481b718:	e3a00000 	mov	r0, #0
3481b71c:	e1a01000 	mov	r1, r0
3481b720:	e1a02000 	mov	r2, r0
3481b724:	ebfffd4b 	bl	3481ac58 <adler32>
            state->mode = TYPE;
3481b728:	e3a0300b 	mov	r3, #11
        case DICT:
            if (state->havedict == 0) {
                RESTORE();
                return Z_NEED_DICT;
            }
            strm->adler = state->check = adler32(0L, Z_NULL, 0);
3481b72c:	e5840018 	str	r0, [r4, #24]
3481b730:	e58a0034 	str	r0, [sl, #52]	; 0x34
            state->mode = TYPE;
3481b734:	e5843000 	str	r3, [r4]
        case TYPE:
	    WATCHDOG_RESET();
            if (flush == Z_BLOCK) goto inf_leave;
3481b738:	e59d303c 	ldr	r3, [sp, #60]	; 0x3c
3481b73c:	e3530005 	cmp	r3, #5
3481b740:	0a0002fe 	beq	3481c340 <inflate+0x1400>
        case TYPEDO:
            if (state->last) {
3481b744:	e5943004 	ldr	r3, [r4, #4]
3481b748:	e3530000 	cmp	r3, #0
3481b74c:	01a03009 	moveq	r3, r9
3481b750:	0a00000a 	beq	3481b780 <inflate+0x840>
                BYTEBITS();
3481b754:	e2053007 	and	r3, r5, #7
3481b758:	e1a06336 	lsr	r6, r6, r3
3481b75c:	e3c55007 	bic	r5, r5, #7
                state->mode = CHECK;
3481b760:	e3a03018 	mov	r3, #24
3481b764:	ea0002e7 	b	3481c308 <inflate+0x13c8>
                break;
            }
            NEEDBITS(3);
3481b768:	e3570000 	cmp	r7, #0
3481b76c:	0a0002f3 	beq	3481c340 <inflate+0x1400>
3481b770:	e4d32001 	ldrb	r2, [r3], #1
3481b774:	e2477001 	sub	r7, r7, #1
3481b778:	e0866512 	add	r6, r6, r2, lsl r5
3481b77c:	e2855008 	add	r5, r5, #8
3481b780:	e3550002 	cmp	r5, #2
3481b784:	e1a09003 	mov	r9, r3
3481b788:	9afffff6 	bls	3481b768 <inflate+0x828>
            state->last = BITS(1);
3481b78c:	e2063001 	and	r3, r6, #1
            DROPBITS(1);
3481b790:	e1a060a6 	lsr	r6, r6, #1
                BYTEBITS();
                state->mode = CHECK;
                break;
            }
            NEEDBITS(3);
            state->last = BITS(1);
3481b794:	e5843004 	str	r3, [r4, #4]
            DROPBITS(1);
            switch (BITS(2)) {
3481b798:	e2063003 	and	r3, r6, #3
3481b79c:	e3530002 	cmp	r3, #2
                state->mode = LEN;              /* decode codes */
                break;
            case 2:                             /* dynamic block */
                Tracev((stderr, "inflate:     dynamic codes block%s\n",
                        state->last ? " (last)" : ""));
                state->mode = TABLE;
3481b7a0:	03a0300f 	moveq	r3, #15
                break;
            }
            NEEDBITS(3);
            state->last = BITS(1);
            DROPBITS(1);
            switch (BITS(2)) {
3481b7a4:	0a000010 	beq	3481b7ec <inflate+0x8ac>
3481b7a8:	e3530003 	cmp	r3, #3
3481b7ac:	0a00000b 	beq	3481b7e0 <inflate+0x8a0>
3481b7b0:	e3530001 	cmp	r3, #1

local void fixedtables(state)
struct inflate_state FAR *state;
{
    state->lencode = lenfix;
    state->lenbits = 9;
3481b7b4:	03a03009 	moveq	r3, #9
}

local void fixedtables(state)
struct inflate_state FAR *state;
{
    state->lencode = lenfix;
3481b7b8:	059fc878 	ldreq	ip, [pc, #2168]	; 3481c038 <inflate+0x10f8>
    state->lenbits = 9;
    state->distcode = distfix;
3481b7bc:	059f0878 	ldreq	r0, [pc, #2168]	; 3481c03c <inflate+0x10fc>

local void fixedtables(state)
struct inflate_state FAR *state;
{
    state->lencode = lenfix;
    state->lenbits = 9;
3481b7c0:	05843054 	streq	r3, [r4, #84]	; 0x54
    state->distcode = distfix;
    state->distbits = 5;
3481b7c4:	03a03005 	moveq	r3, #5
3481b7c8:	05843058 	streq	r3, [r4, #88]	; 0x58
            DROPBITS(1);
            switch (BITS(2)) {
            case 0:                             /* stored block */
                Tracev((stderr, "inflate:     stored block%s\n",
                        state->last ? " (last)" : ""));
                state->mode = STORED;
3481b7cc:	13a0300d 	movne	r3, #13
}

local void fixedtables(state)
struct inflate_state FAR *state;
{
    state->lencode = lenfix;
3481b7d0:	0584c04c 	streq	ip, [r4, #76]	; 0x4c
    state->lenbits = 9;
    state->distcode = distfix;
3481b7d4:	05840050 	streq	r0, [r4, #80]	; 0x50
                break;
            case 1:                             /* fixed block */
                fixedtables(state);
                Tracev((stderr, "inflate:     fixed codes block%s\n",
                        state->last ? " (last)" : ""));
                state->mode = LEN;              /* decode codes */
3481b7d8:	0283300d 	addeq	r3, r3, #13
3481b7dc:	ea000002 	b	3481b7ec <inflate+0x8ac>
                Tracev((stderr, "inflate:     dynamic codes block%s\n",
                        state->last ? " (last)" : ""));
                state->mode = TABLE;
                break;
            case 3:
                strm->msg = (char *)"invalid block type";
3481b7e0:	e59f3858 	ldr	r3, [pc, #2136]	; 3481c040 <inflate+0x1100>
3481b7e4:	e58a3018 	str	r3, [sl, #24]
                state->mode = BAD;
3481b7e8:	e3a0301b 	mov	r3, #27
3481b7ec:	e5843000 	str	r3, [r4]
            }
            DROPBITS(2);
3481b7f0:	e1a06126 	lsr	r6, r6, #2
3481b7f4:	e2455003 	sub	r5, r5, #3
            break;
3481b7f8:	eafffdef 	b	3481afbc <inflate+0x7c>
        case STORED:
            BYTEBITS();                         /* go to byte boundary */
3481b7fc:	e2053007 	and	r3, r5, #7
3481b800:	e1a06336 	lsr	r6, r6, r3
3481b804:	e3c55007 	bic	r5, r5, #7
3481b808:	e1a03009 	mov	r3, r9
            NEEDBITS(32);
3481b80c:	ea000005 	b	3481b828 <inflate+0x8e8>
3481b810:	e3570000 	cmp	r7, #0
3481b814:	0a0002c9 	beq	3481c340 <inflate+0x1400>
3481b818:	e4d32001 	ldrb	r2, [r3], #1
3481b81c:	e2477001 	sub	r7, r7, #1
3481b820:	e0866512 	add	r6, r6, r2, lsl r5
3481b824:	e2855008 	add	r5, r5, #8
3481b828:	e355001f 	cmp	r5, #31
3481b82c:	e1a09003 	mov	r9, r3
3481b830:	9afffff6 	bls	3481b810 <inflate+0x8d0>
            if ((hold & 0xffff) != ((hold >> 16) ^ 0xffff)) {
3481b834:	e1a02826 	lsr	r2, r6, #16
3481b838:	e2222cff 	eor	r2, r2, #65280	; 0xff00
3481b83c:	e6ff3076 	uxth	r3, r6
3481b840:	e22220ff 	eor	r2, r2, #255	; 0xff
3481b844:	e1530002 	cmp	r3, r2
                strm->msg = (char *)"invalid stored block lengths";
3481b848:	159f37f4 	ldrne	r3, [pc, #2036]	; 3481c044 <inflate+0x1104>
            DROPBITS(2);
            break;
        case STORED:
            BYTEBITS();                         /* go to byte boundary */
            NEEDBITS(32);
            if ((hold & 0xffff) != ((hold >> 16) ^ 0xffff)) {
3481b84c:	1a0002ab 	bne	3481c300 <inflate+0x13c0>
                strm->msg = (char *)"invalid stored block lengths";
                state->mode = BAD;
                break;
            }
            state->length = (unsigned)hold & 0xffff;
3481b850:	e5843040 	str	r3, [r4, #64]	; 0x40
            Tracev((stderr, "inflate:       stored length %u\n",
                    state->length));
            INITBITS();
3481b854:	e3a05000 	mov	r5, #0
            state->mode = COPY;
3481b858:	e3a0300e 	mov	r3, #14
3481b85c:	e5843000 	str	r3, [r4]
                break;
            }
            state->length = (unsigned)hold & 0xffff;
            Tracev((stderr, "inflate:       stored length %u\n",
                    state->length));
            INITBITS();
3481b860:	e1a06005 	mov	r6, r5
            state->mode = COPY;
        case COPY:
            copy = state->length;
3481b864:	e5943040 	ldr	r3, [r4, #64]	; 0x40
            if (copy) {
3481b868:	e3530000 	cmp	r3, #0
3481b86c:	0a00017b 	beq	3481be60 <inflate+0xf20>
3481b870:	e15b0003 	cmp	fp, r3
3481b874:	31a0300b 	movcc	r3, fp
3481b878:	e1530007 	cmp	r3, r7
3481b87c:	21a03007 	movcs	r3, r7
                if (copy > have) copy = have;
                if (copy > left) copy = left;
                if (copy == 0) goto inf_leave;
3481b880:	e3530000 	cmp	r3, #0
3481b884:	0a0002ad 	beq	3481c340 <inflate+0x1400>
                zmemcpy(put, next, copy);
3481b888:	e1a01009 	mov	r1, r9
3481b88c:	e1a02003 	mov	r2, r3
3481b890:	e59d0020 	ldr	r0, [sp, #32]
3481b894:	e58d3014 	str	r3, [sp, #20]
3481b898:	ebfff57c 	bl	34818e90 <memcpy>
                have -= copy;
3481b89c:	e59d3014 	ldr	r3, [sp, #20]
                next += copy;
                left -= copy;
                put += copy;
3481b8a0:	e59d1020 	ldr	r1, [sp, #32]
                state->length -= copy;
3481b8a4:	e5942040 	ldr	r2, [r4, #64]	; 0x40
                if (copy == 0) goto inf_leave;
                zmemcpy(put, next, copy);
                have -= copy;
                next += copy;
                left -= copy;
                put += copy;
3481b8a8:	e0811003 	add	r1, r1, r3
            if (copy) {
                if (copy > have) copy = have;
                if (copy > left) copy = left;
                if (copy == 0) goto inf_leave;
                zmemcpy(put, next, copy);
                have -= copy;
3481b8ac:	e0637007 	rsb	r7, r3, r7
                next += copy;
3481b8b0:	e0899003 	add	r9, r9, r3
                left -= copy;
3481b8b4:	e063b00b 	rsb	fp, r3, fp
                put += copy;
                state->length -= copy;
3481b8b8:	e0633002 	rsb	r3, r3, r2
                if (copy == 0) goto inf_leave;
                zmemcpy(put, next, copy);
                have -= copy;
                next += copy;
                left -= copy;
                put += copy;
3481b8bc:	e58d1020 	str	r1, [sp, #32]
                state->length -= copy;
3481b8c0:	e5843040 	str	r3, [r4, #64]	; 0x40
                break;
3481b8c4:	eafffdbc 	b	3481afbc <inflate+0x7c>
            }
            Tracev((stderr, "inflate:       stored end\n"));
            state->mode = TYPE;
            break;
        case TABLE:
            NEEDBITS(14);
3481b8c8:	e3570000 	cmp	r7, #0
3481b8cc:	0a00029b 	beq	3481c340 <inflate+0x1400>
3481b8d0:	e4d32001 	ldrb	r2, [r3], #1
3481b8d4:	e2477001 	sub	r7, r7, #1
3481b8d8:	e0866512 	add	r6, r6, r2, lsl r5
3481b8dc:	e2855008 	add	r5, r5, #8
3481b8e0:	e355000d 	cmp	r5, #13
3481b8e4:	e1a09003 	mov	r9, r3
3481b8e8:	9afffff6 	bls	3481b8c8 <inflate+0x988>
            state->nlen = BITS(5) + 257;
3481b8ec:	e206201f 	and	r2, r6, #31
            DROPBITS(5);
            state->ndist = BITS(5) + 1;
            DROPBITS(5);
            state->ncode = BITS(4) + 4;
3481b8f0:	e7e31556 	ubfx	r1, r6, #10, #4
3481b8f4:	e2811004 	add	r1, r1, #4
            Tracev((stderr, "inflate:       stored end\n"));
            state->mode = TYPE;
            break;
        case TABLE:
            NEEDBITS(14);
            state->nlen = BITS(5) + 257;
3481b8f8:	e2822c01 	add	r2, r2, #256	; 0x100
3481b8fc:	e2822001 	add	r2, r2, #1
            DROPBITS(5);
            state->ndist = BITS(5) + 1;
3481b900:	e7e432d6 	ubfx	r3, r6, #5, #5
            DROPBITS(5);
            state->ncode = BITS(4) + 4;
3481b904:	e584105c 	str	r1, [r4, #92]	; 0x5c
            DROPBITS(4);
#ifndef PKZIP_BUG_WORKAROUND
            if (state->nlen > 286 || state->ndist > 30) {
3481b908:	e300111e 	movw	r1, #286	; 0x11e
            break;
        case TABLE:
            NEEDBITS(14);
            state->nlen = BITS(5) + 257;
            DROPBITS(5);
            state->ndist = BITS(5) + 1;
3481b90c:	e2833001 	add	r3, r3, #1
            DROPBITS(5);
            state->ncode = BITS(4) + 4;
            DROPBITS(4);
#ifndef PKZIP_BUG_WORKAROUND
            if (state->nlen > 286 || state->ndist > 30) {
3481b910:	e1520001 	cmp	r2, r1
            Tracev((stderr, "inflate:       stored end\n"));
            state->mode = TYPE;
            break;
        case TABLE:
            NEEDBITS(14);
            state->nlen = BITS(5) + 257;
3481b914:	e5842060 	str	r2, [r4, #96]	; 0x60
            DROPBITS(5);
            state->ndist = BITS(5) + 1;
3481b918:	e5843064 	str	r3, [r4, #100]	; 0x64
            DROPBITS(5);
            state->ncode = BITS(4) + 4;
            DROPBITS(4);
3481b91c:	e1a06726 	lsr	r6, r6, #14
3481b920:	e245500e 	sub	r5, r5, #14
#ifndef PKZIP_BUG_WORKAROUND
            if (state->nlen > 286 || state->ndist > 30) {
3481b924:	8a000001 	bhi	3481b930 <inflate+0x9f0>
3481b928:	e353001e 	cmp	r3, #30
3481b92c:	9a000001 	bls	3481b938 <inflate+0x9f8>
                strm->msg = (char *)"too many length or distance symbols";
3481b930:	e59f3710 	ldr	r3, [pc, #1808]	; 3481c048 <inflate+0x1108>
3481b934:	ea000271 	b	3481c300 <inflate+0x13c0>
                state->mode = BAD;
                break;
            }
#endif
            Tracev((stderr, "inflate:       table sizes ok\n"));
            state->have = 0;
3481b938:	e3a02000 	mov	r2, #0
            state->mode = LENLENS;
3481b93c:	e3a03010 	mov	r3, #16
                state->mode = BAD;
                break;
            }
#endif
            Tracev((stderr, "inflate:       table sizes ok\n"));
            state->have = 0;
3481b940:	e5842068 	str	r2, [r4, #104]	; 0x68
            state->mode = LENLENS;
3481b944:	e5843000 	str	r3, [r4]
        case LENLENS:
            while (state->have < state->ncode) {
3481b948:	e594205c 	ldr	r2, [r4, #92]	; 0x5c
3481b94c:	ea000013 	b	3481b9a0 <inflate+0xa60>
                NEEDBITS(3);
3481b950:	e3570000 	cmp	r7, #0
3481b954:	0a000279 	beq	3481c340 <inflate+0x1400>
3481b958:	e4d10001 	ldrb	r0, [r1], #1
3481b95c:	e2477001 	sub	r7, r7, #1
3481b960:	e0866510 	add	r6, r6, r0, lsl r5
3481b964:	e2855008 	add	r5, r5, #8
3481b968:	e3550002 	cmp	r5, #2
3481b96c:	e1a09001 	mov	r9, r1
3481b970:	9afffff6 	bls	3481b950 <inflate+0xa10>
                state->lens[order[state->have++]] = (unsigned short)BITS(3);
3481b974:	e59fc6d0 	ldr	ip, [pc, #1744]	; 3481c04c <inflate+0x110c>
3481b978:	e2060007 	and	r0, r6, #7
3481b97c:	e08c1083 	add	r1, ip, r3, lsl #1
3481b980:	e2811d26 	add	r1, r1, #2432	; 0x980
3481b984:	e1d110b0 	ldrh	r1, [r1]
3481b988:	e2833001 	add	r3, r3, #1
3481b98c:	e0841081 	add	r1, r4, r1, lsl #1
3481b990:	e1c107b0 	strh	r0, [r1, #112]	; 0x70
3481b994:	e5843068 	str	r3, [r4, #104]	; 0x68
                DROPBITS(3);
3481b998:	e1a061a6 	lsr	r6, r6, #3
3481b99c:	e2455003 	sub	r5, r5, #3
#endif
            Tracev((stderr, "inflate:       table sizes ok\n"));
            state->have = 0;
            state->mode = LENLENS;
        case LENLENS:
            while (state->have < state->ncode) {
3481b9a0:	e5943068 	ldr	r3, [r4, #104]	; 0x68
3481b9a4:	e1530002 	cmp	r3, r2
3481b9a8:	2a00000a 	bcs	3481b9d8 <inflate+0xa98>
3481b9ac:	e1a01009 	mov	r1, r9
3481b9b0:	eaffffec 	b	3481b968 <inflate+0xa28>
                NEEDBITS(3);
                state->lens[order[state->have++]] = (unsigned short)BITS(3);
                DROPBITS(3);
            }
            while (state->have < 19)
                state->lens[order[state->have++]] = 0;
3481b9b4:	e59f0690 	ldr	r0, [pc, #1680]	; 3481c04c <inflate+0x110c>
3481b9b8:	e3a01000 	mov	r1, #0
3481b9bc:	e0802083 	add	r2, r0, r3, lsl #1
3481b9c0:	e2822d26 	add	r2, r2, #2432	; 0x980
3481b9c4:	e1d220b0 	ldrh	r2, [r2]
3481b9c8:	e2833001 	add	r3, r3, #1
3481b9cc:	e0842082 	add	r2, r4, r2, lsl #1
3481b9d0:	e1c217b0 	strh	r1, [r2, #112]	; 0x70
3481b9d4:	e5843068 	str	r3, [r4, #104]	; 0x68
            while (state->have < state->ncode) {
                NEEDBITS(3);
                state->lens[order[state->have++]] = (unsigned short)BITS(3);
                DROPBITS(3);
            }
            while (state->have < 19)
3481b9d8:	e5943068 	ldr	r3, [r4, #104]	; 0x68
3481b9dc:	e3530012 	cmp	r3, #18
3481b9e0:	9afffff3 	bls	3481b9b4 <inflate+0xa74>
                state->lens[order[state->have++]] = 0;
            state->next = state->codes;
3481b9e4:	e2843e53 	add	r3, r4, #1328	; 0x530
3481b9e8:	e584306c 	str	r3, [r4, #108]	; 0x6c
            state->lencode = (code const FAR *)(state->next);
3481b9ec:	e584304c 	str	r3, [r4, #76]	; 0x4c
            state->lenbits = 7;
3481b9f0:	e3a03007 	mov	r3, #7
3481b9f4:	e5843054 	str	r3, [r4, #84]	; 0x54
            ret = inflate_table(CODES, state->lens, 19, &(state->next),
3481b9f8:	e2843054 	add	r3, r4, #84	; 0x54
3481b9fc:	e58d3000 	str	r3, [sp]
3481ba00:	e2843e2f 	add	r3, r4, #752	; 0x2f0
3481ba04:	e58d3004 	str	r3, [sp, #4]
3481ba08:	e3a00000 	mov	r0, #0
3481ba0c:	e284306c 	add	r3, r4, #108	; 0x6c
3481ba10:	e2841070 	add	r1, r4, #112	; 0x70
3481ba14:	e3a02013 	mov	r2, #19
3481ba18:	ebfffab2 	bl	3481a4e8 <inflate_table>
                                &(state->lenbits), state->work);
            if (ret) {
3481ba1c:	e3500000 	cmp	r0, #0
3481ba20:	e58d001c 	str	r0, [sp, #28]
                strm->msg = (char *)"invalid code lengths set";
3481ba24:	159f3624 	ldrne	r3, [pc, #1572]	; 3481c050 <inflate+0x1110>
            state->next = state->codes;
            state->lencode = (code const FAR *)(state->next);
            state->lenbits = 7;
            ret = inflate_table(CODES, state->lens, 19, &(state->next),
                                &(state->lenbits), state->work);
            if (ret) {
3481ba28:	1a000234 	bne	3481c300 <inflate+0x13c0>
                strm->msg = (char *)"invalid code lengths set";
                state->mode = BAD;
                break;
            }
            Tracev((stderr, "inflate:       code lengths ok\n"));
            state->have = 0;
3481ba2c:	e59d201c 	ldr	r2, [sp, #28]
            state->mode = CODELENS;
3481ba30:	e3a03011 	mov	r3, #17
                strm->msg = (char *)"invalid code lengths set";
                state->mode = BAD;
                break;
            }
            Tracev((stderr, "inflate:       code lengths ok\n"));
            state->have = 0;
3481ba34:	e5842068 	str	r2, [r4, #104]	; 0x68
            state->mode = CODELENS;
3481ba38:	e5843000 	str	r3, [r4]
        case CODELENS:
            while (state->have < state->nlen + state->ndist) {
3481ba3c:	e5942064 	ldr	r2, [r4, #100]	; 0x64
3481ba40:	e5943060 	ldr	r3, [r4, #96]	; 0x60
3481ba44:	e0823003 	add	r3, r2, r3
3481ba48:	e58d3024 	str	r3, [sp, #36]	; 0x24
3481ba4c:	ea000075 	b	3481bc28 <inflate+0xce8>
                for (;;) {
                    this = state->lencode[BITS(state->lenbits)];
3481ba50:	e5943054 	ldr	r3, [r4, #84]	; 0x54
3481ba54:	e3a00001 	mov	r0, #1
3481ba58:	e1a03310 	lsl	r3, r0, r3
3481ba5c:	e594c04c 	ldr	ip, [r4, #76]	; 0x4c
3481ba60:	e2433001 	sub	r3, r3, #1
3481ba64:	e58d3028 	str	r3, [sp, #40]	; 0x28
3481ba68:	e1a02009 	mov	r2, r9
3481ba6c:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
3481ba70:	e1a09002 	mov	r9, r2
3481ba74:	e0060003 	and	r0, r6, r3
3481ba78:	e08c0100 	add	r0, ip, r0, lsl #2
3481ba7c:	e5d03001 	ldrb	r3, [r0, #1]
3481ba80:	e1d000b2 	ldrh	r0, [r0, #2]
                    if ((unsigned)(this.bits) <= bits) break;
3481ba84:	e1530005 	cmp	r3, r5
3481ba88:	9a000006 	bls	3481baa8 <inflate+0xb68>
                    PULLBYTE();
3481ba8c:	e3570000 	cmp	r7, #0
3481ba90:	0a00022a 	beq	3481c340 <inflate+0x1400>
3481ba94:	e4d23001 	ldrb	r3, [r2], #1
3481ba98:	e2477001 	sub	r7, r7, #1
3481ba9c:	e0866513 	add	r6, r6, r3, lsl r5
3481baa0:	e2855008 	add	r5, r5, #8
                }
3481baa4:	eafffff0 	b	3481ba6c <inflate+0xb2c>
                if (this.val < 16) {
3481baa8:	e350000f 	cmp	r0, #15
3481baac:	8a000010 	bhi	3481baf4 <inflate+0xbb4>
3481bab0:	ea000005 	b	3481bacc <inflate+0xb8c>
                    NEEDBITS(this.bits);
3481bab4:	e3570000 	cmp	r7, #0
3481bab8:	0a000220 	beq	3481c340 <inflate+0x1400>
3481babc:	e4d2c001 	ldrb	ip, [r2], #1
3481bac0:	e2477001 	sub	r7, r7, #1
3481bac4:	e086651c 	add	r6, r6, ip, lsl r5
3481bac8:	e2855008 	add	r5, r5, #8
3481bacc:	e1550003 	cmp	r5, r3
3481bad0:	e1a09002 	mov	r9, r2
3481bad4:	3afffff6 	bcc	3481bab4 <inflate+0xb74>
                    DROPBITS(this.bits);
3481bad8:	e1a06336 	lsr	r6, r6, r3
3481badc:	e0635005 	rsb	r5, r3, r5
                    state->lens[state->have++] = this.val;
3481bae0:	e0843081 	add	r3, r4, r1, lsl #1
3481bae4:	e2811001 	add	r1, r1, #1
3481bae8:	e1c307b0 	strh	r0, [r3, #112]	; 0x70
3481baec:	e5841068 	str	r1, [r4, #104]	; 0x68
3481baf0:	ea00004c 	b	3481bc28 <inflate+0xce8>
                }
                else {
                    if (this.val == 16) {
3481baf4:	e3500010 	cmp	r0, #16
                        NEEDBITS(this.bits + 2);
3481baf8:	02830002 	addeq	r0, r3, #2
                    NEEDBITS(this.bits);
                    DROPBITS(this.bits);
                    state->lens[state->have++] = this.val;
                }
                else {
                    if (this.val == 16) {
3481bafc:	1a000014 	bne	3481bb54 <inflate+0xc14>
3481bb00:	ea000005 	b	3481bb1c <inflate+0xbdc>
                        NEEDBITS(this.bits + 2);
3481bb04:	e3570000 	cmp	r7, #0
3481bb08:	0a00020c 	beq	3481c340 <inflate+0x1400>
3481bb0c:	e4d2c001 	ldrb	ip, [r2], #1
3481bb10:	e2477001 	sub	r7, r7, #1
3481bb14:	e086651c 	add	r6, r6, ip, lsl r5
3481bb18:	e2855008 	add	r5, r5, #8
3481bb1c:	e1550000 	cmp	r5, r0
3481bb20:	e1a09002 	mov	r9, r2
3481bb24:	3afffff6 	bcc	3481bb04 <inflate+0xbc4>
                        DROPBITS(this.bits);
                        if (state->have == 0) {
3481bb28:	e3510000 	cmp	r1, #0
                    state->lens[state->have++] = this.val;
                }
                else {
                    if (this.val == 16) {
                        NEEDBITS(this.bits + 2);
                        DROPBITS(this.bits);
3481bb2c:	e1a06336 	lsr	r6, r6, r3
3481bb30:	e0635005 	rsb	r5, r3, r5
                        if (state->have == 0) {
3481bb34:	0a00002f 	beq	3481bbf8 <inflate+0xcb8>
                            strm->msg = (char *)"invalid bit length repeat";
                            state->mode = BAD;
                            break;
                        }
                        len = state->lens[state->have - 1];
                        copy = 3 + BITS(2);
3481bb38:	e2062003 	and	r2, r6, #3
                        if (state->have == 0) {
                            strm->msg = (char *)"invalid bit length repeat";
                            state->mode = BAD;
                            break;
                        }
                        len = state->lens[state->have - 1];
3481bb3c:	e0843081 	add	r3, r4, r1, lsl #1
3481bb40:	e1d336be 	ldrh	r3, [r3, #110]	; 0x6e
                        copy = 3 + BITS(2);
3481bb44:	e2822003 	add	r2, r2, #3
                        DROPBITS(2);
3481bb48:	e1a06126 	lsr	r6, r6, #2
3481bb4c:	e2455002 	sub	r5, r5, #2
3481bb50:	ea000024 	b	3481bbe8 <inflate+0xca8>
                    }
                    else if (this.val == 17) {
3481bb54:	e3500011 	cmp	r0, #17
                        len = 0;
                        copy = 3 + BITS(3);
                        DROPBITS(3);
                    }
                    else {
                        NEEDBITS(this.bits + 7);
3481bb58:	12830007 	addne	r0, r3, #7
                        len = state->lens[state->have - 1];
                        copy = 3 + BITS(2);
                        DROPBITS(2);
                    }
                    else if (this.val == 17) {
                        NEEDBITS(this.bits + 3);
3481bb5c:	02830003 	addeq	r0, r3, #3
                        }
                        len = state->lens[state->have - 1];
                        copy = 3 + BITS(2);
                        DROPBITS(2);
                    }
                    else if (this.val == 17) {
3481bb60:	1a000015 	bne	3481bbbc <inflate+0xc7c>
3481bb64:	ea000005 	b	3481bb80 <inflate+0xc40>
                        NEEDBITS(this.bits + 3);
3481bb68:	e3570000 	cmp	r7, #0
3481bb6c:	0a0001f3 	beq	3481c340 <inflate+0x1400>
3481bb70:	e4d2c001 	ldrb	ip, [r2], #1
3481bb74:	e2477001 	sub	r7, r7, #1
3481bb78:	e086651c 	add	r6, r6, ip, lsl r5
3481bb7c:	e2855008 	add	r5, r5, #8
3481bb80:	e1550000 	cmp	r5, r0
3481bb84:	e1a09002 	mov	r9, r2
3481bb88:	3afffff6 	bcc	3481bb68 <inflate+0xc28>
                        DROPBITS(this.bits);
3481bb8c:	e1a06336 	lsr	r6, r6, r3
                        len = 0;
                        copy = 3 + BITS(3);
3481bb90:	e2062007 	and	r2, r6, #7
3481bb94:	e2822003 	add	r2, r2, #3
                        DROPBITS(3);
3481bb98:	e1a061a6 	lsr	r6, r6, #3
                        copy = 3 + BITS(2);
                        DROPBITS(2);
                    }
                    else if (this.val == 17) {
                        NEEDBITS(this.bits + 3);
                        DROPBITS(this.bits);
3481bb9c:	e3e00002 	mvn	r0, #2
3481bba0:	ea00000d 	b	3481bbdc <inflate+0xc9c>
                        len = 0;
                        copy = 3 + BITS(3);
                        DROPBITS(3);
                    }
                    else {
                        NEEDBITS(this.bits + 7);
3481bba4:	e3570000 	cmp	r7, #0
3481bba8:	0a0001e4 	beq	3481c340 <inflate+0x1400>
3481bbac:	e4d2c001 	ldrb	ip, [r2], #1
3481bbb0:	e2477001 	sub	r7, r7, #1
3481bbb4:	e086651c 	add	r6, r6, ip, lsl r5
3481bbb8:	e2855008 	add	r5, r5, #8
3481bbbc:	e1550000 	cmp	r5, r0
3481bbc0:	e1a09002 	mov	r9, r2
3481bbc4:	3afffff6 	bcc	3481bba4 <inflate+0xc64>
                        DROPBITS(this.bits);
3481bbc8:	e1a06336 	lsr	r6, r6, r3
                        len = 0;
                        copy = 11 + BITS(7);
3481bbcc:	e206207f 	and	r2, r6, #127	; 0x7f
3481bbd0:	e282200b 	add	r2, r2, #11
                        DROPBITS(7);
3481bbd4:	e1a063a6 	lsr	r6, r6, #7
                        copy = 3 + BITS(3);
                        DROPBITS(3);
                    }
                    else {
                        NEEDBITS(this.bits + 7);
                        DROPBITS(this.bits);
3481bbd8:	e3e00006 	mvn	r0, #6
3481bbdc:	e0630000 	rsb	r0, r3, r0
                        len = 0;
                        copy = 11 + BITS(7);
                        DROPBITS(7);
3481bbe0:	e0855000 	add	r5, r5, r0
                        DROPBITS(3);
                    }
                    else {
                        NEEDBITS(this.bits + 7);
                        DROPBITS(this.bits);
                        len = 0;
3481bbe4:	e3a03000 	mov	r3, #0
                        copy = 11 + BITS(7);
                        DROPBITS(7);
                    }
                    if (state->have + copy > state->nlen + state->ndist) {
3481bbe8:	e59dc024 	ldr	ip, [sp, #36]	; 0x24
3481bbec:	e0821001 	add	r1, r2, r1
3481bbf0:	e151000c 	cmp	r1, ip
3481bbf4:	9a000004 	bls	3481bc0c <inflate+0xccc>
                        strm->msg = (char *)"invalid bit length repeat";
3481bbf8:	e59f3454 	ldr	r3, [pc, #1108]	; 3481c054 <inflate+0x1114>
3481bbfc:	e58a3018 	str	r3, [sl, #24]
                        state->mode = BAD;
3481bc00:	e3a0301b 	mov	r3, #27
3481bc04:	e5843000 	str	r3, [r4]
                        break;
3481bc08:	ea00000a 	b	3481bc38 <inflate+0xcf8>
                    }
                    while (copy--)
                        state->lens[state->have++] = (unsigned short)len;
3481bc0c:	e5941068 	ldr	r1, [r4, #104]	; 0x68
                    if (state->have + copy > state->nlen + state->ndist) {
                        strm->msg = (char *)"invalid bit length repeat";
                        state->mode = BAD;
                        break;
                    }
                    while (copy--)
3481bc10:	e2522001 	subs	r2, r2, #1
                        state->lens[state->have++] = (unsigned short)len;
3481bc14:	e0840081 	add	r0, r4, r1, lsl #1
3481bc18:	e2811001 	add	r1, r1, #1
3481bc1c:	e1c037b0 	strh	r3, [r0, #112]	; 0x70
3481bc20:	e5841068 	str	r1, [r4, #104]	; 0x68
                    if (state->have + copy > state->nlen + state->ndist) {
                        strm->msg = (char *)"invalid bit length repeat";
                        state->mode = BAD;
                        break;
                    }
                    while (copy--)
3481bc24:	1afffff8 	bne	3481bc0c <inflate+0xccc>
            }
            Tracev((stderr, "inflate:       code lengths ok\n"));
            state->have = 0;
            state->mode = CODELENS;
        case CODELENS:
            while (state->have < state->nlen + state->ndist) {
3481bc28:	e5941068 	ldr	r1, [r4, #104]	; 0x68
3481bc2c:	e59d0024 	ldr	r0, [sp, #36]	; 0x24
3481bc30:	e1510000 	cmp	r1, r0
3481bc34:	3affff85 	bcc	3481ba50 <inflate+0xb10>
                        state->lens[state->have++] = (unsigned short)len;
                }
            }

            /* handle error breaks in while */
            if (state->mode == BAD) break;
3481bc38:	e5943000 	ldr	r3, [r4]
3481bc3c:	e353001b 	cmp	r3, #27
3481bc40:	0afffcdd 	beq	3481afbc <inflate+0x7c>

            /* build code tables */
            state->next = state->codes;
3481bc44:	e2843e53 	add	r3, r4, #1328	; 0x530
3481bc48:	e584306c 	str	r3, [r4, #108]	; 0x6c
            state->lencode = (code const FAR *)(state->next);
3481bc4c:	e584304c 	str	r3, [r4, #76]	; 0x4c
            state->lenbits = 9;
3481bc50:	e3a03009 	mov	r3, #9
3481bc54:	e5843054 	str	r3, [r4, #84]	; 0x54
            ret = inflate_table(LENS, state->lens, state->nlen, &(state->next),
3481bc58:	e284ce2f 	add	ip, r4, #752	; 0x2f0
3481bc5c:	e284106c 	add	r1, r4, #108	; 0x6c
3481bc60:	e2843054 	add	r3, r4, #84	; 0x54
3481bc64:	e58d1024 	str	r1, [sp, #36]	; 0x24
3481bc68:	e88d1008 	stm	sp, {r3, ip}
3481bc6c:	e5942060 	ldr	r2, [r4, #96]	; 0x60
3481bc70:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
3481bc74:	e3a00001 	mov	r0, #1
3481bc78:	e2841070 	add	r1, r4, #112	; 0x70
3481bc7c:	e58dc018 	str	ip, [sp, #24]
3481bc80:	ebfffa18 	bl	3481a4e8 <inflate_table>
                                &(state->lenbits), state->work);
            if (ret) {
3481bc84:	e3500000 	cmp	r0, #0
3481bc88:	e58d001c 	str	r0, [sp, #28]
3481bc8c:	e59dc018 	ldr	ip, [sp, #24]
                strm->msg = (char *)"invalid literal/lengths set";
3481bc90:	159f33c0 	ldrne	r3, [pc, #960]	; 3481c058 <inflate+0x1118>
            state->next = state->codes;
            state->lencode = (code const FAR *)(state->next);
            state->lenbits = 9;
            ret = inflate_table(LENS, state->lens, state->nlen, &(state->next),
                                &(state->lenbits), state->work);
            if (ret) {
3481bc94:	1a000199 	bne	3481c300 <inflate+0x13c0>
                strm->msg = (char *)"invalid literal/lengths set";
                state->mode = BAD;
                break;
            }
            state->distcode = (code const FAR *)(state->next);
3481bc98:	e594306c 	ldr	r3, [r4, #108]	; 0x6c
            state->distbits = 6;
            ret = inflate_table(DISTS, state->lens + state->nlen, state->ndist,
3481bc9c:	e5941060 	ldr	r1, [r4, #96]	; 0x60
            if (ret) {
                strm->msg = (char *)"invalid literal/lengths set";
                state->mode = BAD;
                break;
            }
            state->distcode = (code const FAR *)(state->next);
3481bca0:	e5843050 	str	r3, [r4, #80]	; 0x50
            state->distbits = 6;
3481bca4:	e3a03006 	mov	r3, #6
3481bca8:	e5843058 	str	r3, [r4, #88]	; 0x58
            ret = inflate_table(DISTS, state->lens + state->nlen, state->ndist,
3481bcac:	e2843058 	add	r3, r4, #88	; 0x58
3481bcb0:	e88d1008 	stm	sp, {r3, ip}
3481bcb4:	e3a00002 	mov	r0, #2
3481bcb8:	e2811038 	add	r1, r1, #56	; 0x38
3481bcbc:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
3481bcc0:	e0214091 	mla	r1, r1, r0, r4
3481bcc4:	e5942064 	ldr	r2, [r4, #100]	; 0x64
3481bcc8:	ebfffa06 	bl	3481a4e8 <inflate_table>
                            &(state->next), &(state->distbits), state->work);
            if (ret) {
3481bccc:	e3500000 	cmp	r0, #0
3481bcd0:	e58d001c 	str	r0, [sp, #28]
                strm->msg = (char *)"invalid distances set";
3481bcd4:	159f3380 	ldrne	r3, [pc, #896]	; 3481c05c <inflate+0x111c>
            }
            state->distcode = (code const FAR *)(state->next);
            state->distbits = 6;
            ret = inflate_table(DISTS, state->lens + state->nlen, state->ndist,
                            &(state->next), &(state->distbits), state->work);
            if (ret) {
3481bcd8:	1a000188 	bne	3481c300 <inflate+0x13c0>
                strm->msg = (char *)"invalid distances set";
                state->mode = BAD;
                break;
            }
            Tracev((stderr, "inflate:       codes ok\n"));
            state->mode = LEN;
3481bcdc:	e3a03012 	mov	r3, #18
3481bce0:	e5843000 	str	r3, [r4]
        case LEN:
	    WATCHDOG_RESET();
            if (have >= 6 && left >= 258) {
3481bce4:	e3003101 	movw	r3, #257	; 0x101
3481bce8:	e3570005 	cmp	r7, #5
3481bcec:	815b0003 	cmphi	fp, r3
3481bcf0:	9a000011 	bls	3481bd3c <inflate+0xdfc>
                RESTORE();
3481bcf4:	e59d2020 	ldr	r2, [sp, #32]
3481bcf8:	e58ab010 	str	fp, [sl, #16]
3481bcfc:	e58a9000 	str	r9, [sl]
3481bd00:	e58a7004 	str	r7, [sl, #4]
3481bd04:	e58a200c 	str	r2, [sl, #12]
                inflate_fast(strm, out);
3481bd08:	e1a0000a 	mov	r0, sl
            Tracev((stderr, "inflate:       codes ok\n"));
            state->mode = LEN;
        case LEN:
	    WATCHDOG_RESET();
            if (have >= 6 && left >= 258) {
                RESTORE();
3481bd0c:	e5846038 	str	r6, [r4, #56]	; 0x38
3481bd10:	e584503c 	str	r5, [r4, #60]	; 0x3c
                inflate_fast(strm, out);
3481bd14:	e59d102c 	ldr	r1, [sp, #44]	; 0x2c
3481bd18:	ebfff895 	bl	34819f74 <inflate_fast>
                LOAD();
3481bd1c:	e59a300c 	ldr	r3, [sl, #12]
3481bd20:	e59ab010 	ldr	fp, [sl, #16]
3481bd24:	e58d3020 	str	r3, [sp, #32]
3481bd28:	e59a9000 	ldr	r9, [sl]
3481bd2c:	e59a7004 	ldr	r7, [sl, #4]
3481bd30:	e5946038 	ldr	r6, [r4, #56]	; 0x38
3481bd34:	e594503c 	ldr	r5, [r4, #60]	; 0x3c
                break;
3481bd38:	eafffc9f 	b	3481afbc <inflate+0x7c>
            }
            for (;;) {
                this = state->lencode[BITS(state->lenbits)];
3481bd3c:	e5943054 	ldr	r3, [r4, #84]	; 0x54
3481bd40:	e3a00001 	mov	r0, #1
3481bd44:	e1a03310 	lsl	r3, r0, r3
3481bd48:	e594c04c 	ldr	ip, [r4, #76]	; 0x4c
3481bd4c:	e2433001 	sub	r3, r3, #1
3481bd50:	e58dc00c 	str	ip, [sp, #12]
3481bd54:	e58d3028 	str	r3, [sp, #40]	; 0x28
3481bd58:	e1a00009 	mov	r0, r9
3481bd5c:	e59d1028 	ldr	r1, [sp, #40]	; 0x28
3481bd60:	e1a09000 	mov	r9, r0
3481bd64:	e0063001 	and	r3, r6, r1
3481bd68:	e08c1103 	add	r1, ip, r3, lsl #2
3481bd6c:	e5d12001 	ldrb	r2, [r1, #1]
3481bd70:	e1d110b2 	ldrh	r1, [r1, #2]
                if ((unsigned)(this.bits) <= bits) break;
3481bd74:	e1520005 	cmp	r2, r5
                inflate_fast(strm, out);
                LOAD();
                break;
            }
            for (;;) {
                this = state->lencode[BITS(state->lenbits)];
3481bd78:	e58d1024 	str	r1, [sp, #36]	; 0x24
3481bd7c:	e7dc3103 	ldrb	r3, [ip, r3, lsl #2]
                if ((unsigned)(this.bits) <= bits) break;
3481bd80:	e1a01002 	mov	r1, r2
3481bd84:	9a000006 	bls	3481bda4 <inflate+0xe64>
                PULLBYTE();
3481bd88:	e3570000 	cmp	r7, #0
3481bd8c:	0a00016b 	beq	3481c340 <inflate+0x1400>
3481bd90:	e4d03001 	ldrb	r3, [r0], #1
3481bd94:	e2477001 	sub	r7, r7, #1
3481bd98:	e0866513 	add	r6, r6, r3, lsl r5
3481bd9c:	e2855008 	add	r5, r5, #8
            }
3481bda0:	eaffffed 	b	3481bd5c <inflate+0xe1c>
3481bda4:	e58dc00c 	str	ip, [sp, #12]
                LOAD();
                break;
            }
            for (;;) {
                this = state->lencode[BITS(state->lenbits)];
                if ((unsigned)(this.bits) <= bits) break;
3481bda8:	e59dc024 	ldr	ip, [sp, #36]	; 0x24
                PULLBYTE();
            }
            if (this.op && (this.op & 0xf0) == 0) {
3481bdac:	e3530000 	cmp	r3, #0
                LOAD();
                break;
            }
            for (;;) {
                this = state->lencode[BITS(state->lenbits)];
                if ((unsigned)(this.bits) <= bits) break;
3481bdb0:	e58dc034 	str	ip, [sp, #52]	; 0x34
                PULLBYTE();
            }
            if (this.op && (this.op & 0xf0) == 0) {
3481bdb4:	0a000020 	beq	3481be3c <inflate+0xefc>
3481bdb8:	e31300f0 	tst	r3, #240	; 0xf0
3481bdbc:	1a00001e 	bne	3481be3c <inflate+0xefc>
                last = this;
                for (;;) {
                    this = state->lencode[last.val +
                            (BITS(last.bits + last.op) >> last.bits)];
3481bdc0:	e0823003 	add	r3, r2, r3
3481bdc4:	e3a02001 	mov	r2, #1
3481bdc8:	e1a03312 	lsl	r3, r2, r3
3481bdcc:	e59dc00c 	ldr	ip, [sp, #12]
3481bdd0:	e2433001 	sub	r3, r3, #1
3481bdd4:	e58d3030 	str	r3, [sp, #48]	; 0x30
3481bdd8:	e58d0028 	str	r0, [sp, #40]	; 0x28
3481bddc:	e59d0030 	ldr	r0, [sp, #48]	; 0x30
                PULLBYTE();
            }
            if (this.op && (this.op & 0xf0) == 0) {
                last = this;
                for (;;) {
                    this = state->lencode[last.val +
3481bde0:	e59d2034 	ldr	r2, [sp, #52]	; 0x34
                            (BITS(last.bits + last.op) >> last.bits)];
3481bde4:	e0063000 	and	r3, r6, r0
                PULLBYTE();
            }
            if (this.op && (this.op & 0xf0) == 0) {
                last = this;
                for (;;) {
                    this = state->lencode[last.val +
3481bde8:	e0823133 	add	r3, r2, r3, lsr r1
3481bdec:	e08c0103 	add	r0, ip, r3, lsl #2
3481bdf0:	e5d02001 	ldrb	r2, [r0, #1]
3481bdf4:	e1d000b2 	ldrh	r0, [r0, #2]
                            (BITS(last.bits + last.op) >> last.bits)];
3481bdf8:	e59d9028 	ldr	r9, [sp, #40]	; 0x28
                PULLBYTE();
            }
            if (this.op && (this.op & 0xf0) == 0) {
                last = this;
                for (;;) {
                    this = state->lencode[last.val +
3481bdfc:	e58d0024 	str	r0, [sp, #36]	; 0x24
                            (BITS(last.bits + last.op) >> last.bits)];
                    if ((unsigned)(last.bits + this.bits) <= bits) break;
3481be00:	e0810002 	add	r0, r1, r2
3481be04:	e1500005 	cmp	r0, r5
                PULLBYTE();
            }
            if (this.op && (this.op & 0xf0) == 0) {
                last = this;
                for (;;) {
                    this = state->lencode[last.val +
3481be08:	e7dc3103 	ldrb	r3, [ip, r3, lsl #2]
                            (BITS(last.bits + last.op) >> last.bits)];
                    if ((unsigned)(last.bits + this.bits) <= bits) break;
3481be0c:	9a000008 	bls	3481be34 <inflate+0xef4>
                    PULLBYTE();
3481be10:	e3570000 	cmp	r7, #0
3481be14:	0a000149 	beq	3481c340 <inflate+0x1400>
3481be18:	e1a00009 	mov	r0, r9
3481be1c:	e4d03001 	ldrb	r3, [r0], #1
3481be20:	e2477001 	sub	r7, r7, #1
3481be24:	e0866513 	add	r6, r6, r3, lsl r5
3481be28:	e58d0028 	str	r0, [sp, #40]	; 0x28
3481be2c:	e2855008 	add	r5, r5, #8
                }
3481be30:	eaffffe9 	b	3481bddc <inflate+0xe9c>
                DROPBITS(last.bits);
3481be34:	e1a06136 	lsr	r6, r6, r1
3481be38:	e0615005 	rsb	r5, r1, r5
            }
            DROPBITS(this.bits);
            state->length = (unsigned)this.val;
3481be3c:	e59d1024 	ldr	r1, [sp, #36]	; 0x24
            if ((int)(this.op) == 0) {
3481be40:	e3530000 	cmp	r3, #0
                    if ((unsigned)(last.bits + this.bits) <= bits) break;
                    PULLBYTE();
                }
                DROPBITS(last.bits);
            }
            DROPBITS(this.bits);
3481be44:	e1a06236 	lsr	r6, r6, r2
3481be48:	e0625005 	rsb	r5, r2, r5
            state->length = (unsigned)this.val;
3481be4c:	e5841040 	str	r1, [r4, #64]	; 0x40
            if ((int)(this.op) == 0) {
                Tracevv((stderr, this.val >= 0x20 && this.val < 0x7f ?
                        "inflate:         literal '%c'\n" :
                        "inflate:         literal 0x%02x\n", this.val));
                state->mode = LIT;
3481be50:	02833017 	addeq	r3, r3, #23
                }
                DROPBITS(last.bits);
            }
            DROPBITS(this.bits);
            state->length = (unsigned)this.val;
            if ((int)(this.op) == 0) {
3481be54:	0a00012b 	beq	3481c308 <inflate+0x13c8>
                        "inflate:         literal '%c'\n" :
                        "inflate:         literal 0x%02x\n", this.val));
                state->mode = LIT;
                break;
            }
            if (this.op & 32) {
3481be58:	e3130020 	tst	r3, #32
3481be5c:	0a000001 	beq	3481be68 <inflate+0xf28>
                Tracevv((stderr, "inflate:         end of block\n"));
                state->mode = TYPE;
3481be60:	e3a0300b 	mov	r3, #11
3481be64:	ea000127 	b	3481c308 <inflate+0x13c8>
                break;
            }
            if (this.op & 64) {
3481be68:	e3130040 	tst	r3, #64	; 0x40
                strm->msg = (char *)"invalid literal/length code";
3481be6c:	159f31ec 	ldrne	r3, [pc, #492]	; 3481c060 <inflate+0x1120>
            if (this.op & 32) {
                Tracevv((stderr, "inflate:         end of block\n"));
                state->mode = TYPE;
                break;
            }
            if (this.op & 64) {
3481be70:	1a000122 	bne	3481c300 <inflate+0x13c0>
                strm->msg = (char *)"invalid literal/length code";
                state->mode = BAD;
                break;
            }
            state->extra = (unsigned)(this.op) & 15;
3481be74:	e203300f 	and	r3, r3, #15
3481be78:	e5843048 	str	r3, [r4, #72]	; 0x48
            state->mode = LENEXT;
3481be7c:	e3a03013 	mov	r3, #19
3481be80:	e5843000 	str	r3, [r4]
        case LENEXT:
            if (state->extra) {
3481be84:	e5943048 	ldr	r3, [r4, #72]	; 0x48
3481be88:	e3530000 	cmp	r3, #0
3481be8c:	11a02009 	movne	r2, r9
3481be90:	1a000006 	bne	3481beb0 <inflate+0xf70>
3481be94:	ea000011 	b	3481bee0 <inflate+0xfa0>
                NEEDBITS(state->extra);
3481be98:	e3570000 	cmp	r7, #0
3481be9c:	0a000127 	beq	3481c340 <inflate+0x1400>
3481bea0:	e4d21001 	ldrb	r1, [r2], #1
3481bea4:	e2477001 	sub	r7, r7, #1
3481bea8:	e0866511 	add	r6, r6, r1, lsl r5
3481beac:	e2855008 	add	r5, r5, #8
3481beb0:	e1550003 	cmp	r5, r3
3481beb4:	e1a09002 	mov	r9, r2
3481beb8:	3afffff6 	bcc	3481be98 <inflate+0xf58>
                state->length += BITS(state->extra);
3481bebc:	e3a0c001 	mov	ip, #1
3481bec0:	e1a0231c 	lsl	r2, ip, r3
3481bec4:	e2422001 	sub	r2, r2, #1
3481bec8:	e0062002 	and	r2, r6, r2
                DROPBITS(state->extra);
3481becc:	e1a06336 	lsr	r6, r6, r3
            state->extra = (unsigned)(this.op) & 15;
            state->mode = LENEXT;
        case LENEXT:
            if (state->extra) {
                NEEDBITS(state->extra);
                state->length += BITS(state->extra);
3481bed0:	e5941040 	ldr	r1, [r4, #64]	; 0x40
                DROPBITS(state->extra);
3481bed4:	e0635005 	rsb	r5, r3, r5
            state->extra = (unsigned)(this.op) & 15;
            state->mode = LENEXT;
        case LENEXT:
            if (state->extra) {
                NEEDBITS(state->extra);
                state->length += BITS(state->extra);
3481bed8:	e0812002 	add	r2, r1, r2
3481bedc:	e5842040 	str	r2, [r4, #64]	; 0x40
                DROPBITS(state->extra);
            }
            Tracevv((stderr, "inflate:         length %u\n", state->length));
            state->mode = DIST;
3481bee0:	e3a03014 	mov	r3, #20
3481bee4:	e5843000 	str	r3, [r4]
        case DIST:
            for (;;) {
                this = state->distcode[BITS(state->distbits)];
3481bee8:	e5943058 	ldr	r3, [r4, #88]	; 0x58
3481beec:	e3a01001 	mov	r1, #1
3481bef0:	e1a03311 	lsl	r3, r1, r3
3481bef4:	e5940050 	ldr	r0, [r4, #80]	; 0x50
3481bef8:	e2433001 	sub	r3, r3, #1
3481befc:	e58d000c 	str	r0, [sp, #12]
3481bf00:	e59dc00c 	ldr	ip, [sp, #12]
3481bf04:	e58d3028 	str	r3, [sp, #40]	; 0x28
3481bf08:	e1a00009 	mov	r0, r9
3481bf0c:	e59d2028 	ldr	r2, [sp, #40]	; 0x28
3481bf10:	e1a09000 	mov	r9, r0
3481bf14:	e0063002 	and	r3, r6, r2
3481bf18:	e08c1103 	add	r1, ip, r3, lsl #2
3481bf1c:	e7dc2103 	ldrb	r2, [ip, r3, lsl #2]
3481bf20:	e5d13001 	ldrb	r3, [r1, #1]
3481bf24:	e1d110b2 	ldrh	r1, [r1, #2]
                if ((unsigned)(this.bits) <= bits) break;
3481bf28:	e1530005 	cmp	r3, r5
            }
            Tracevv((stderr, "inflate:         length %u\n", state->length));
            state->mode = DIST;
        case DIST:
            for (;;) {
                this = state->distcode[BITS(state->distbits)];
3481bf2c:	e58d1024 	str	r1, [sp, #36]	; 0x24
                if ((unsigned)(this.bits) <= bits) break;
3481bf30:	e1a01003 	mov	r1, r3
3481bf34:	9a000006 	bls	3481bf54 <inflate+0x1014>
                PULLBYTE();
3481bf38:	e3570000 	cmp	r7, #0
3481bf3c:	0a0000ff 	beq	3481c340 <inflate+0x1400>
3481bf40:	e4d03001 	ldrb	r3, [r0], #1
3481bf44:	e2477001 	sub	r7, r7, #1
3481bf48:	e0866513 	add	r6, r6, r3, lsl r5
3481bf4c:	e2855008 	add	r5, r5, #8
            }
3481bf50:	eaffffed 	b	3481bf0c <inflate+0xfcc>
3481bf54:	e58dc00c 	str	ip, [sp, #12]
            Tracevv((stderr, "inflate:         length %u\n", state->length));
            state->mode = DIST;
        case DIST:
            for (;;) {
                this = state->distcode[BITS(state->distbits)];
                if ((unsigned)(this.bits) <= bits) break;
3481bf58:	e59dc024 	ldr	ip, [sp, #36]	; 0x24
                PULLBYTE();
            }
            if ((this.op & 0xf0) == 0) {
3481bf5c:	e31200f0 	tst	r2, #240	; 0xf0
            Tracevv((stderr, "inflate:         length %u\n", state->length));
            state->mode = DIST;
        case DIST:
            for (;;) {
                this = state->distcode[BITS(state->distbits)];
                if ((unsigned)(this.bits) <= bits) break;
3481bf60:	e58dc034 	str	ip, [sp, #52]	; 0x34
                PULLBYTE();
            }
            if ((this.op & 0xf0) == 0) {
3481bf64:	1a00001e 	bne	3481bfe4 <inflate+0x10a4>
                last = this;
                for (;;) {
                    this = state->distcode[last.val +
                            (BITS(last.bits + last.op) >> last.bits)];
3481bf68:	e0832002 	add	r2, r3, r2
3481bf6c:	e3a03001 	mov	r3, #1
3481bf70:	e1a02213 	lsl	r2, r3, r2
3481bf74:	e59dc00c 	ldr	ip, [sp, #12]
3481bf78:	e2422001 	sub	r2, r2, #1
3481bf7c:	e58d2030 	str	r2, [sp, #48]	; 0x30
3481bf80:	e58d0028 	str	r0, [sp, #40]	; 0x28
3481bf84:	e59d0030 	ldr	r0, [sp, #48]	; 0x30
                PULLBYTE();
            }
            if ((this.op & 0xf0) == 0) {
                last = this;
                for (;;) {
                    this = state->distcode[last.val +
3481bf88:	e59d2034 	ldr	r2, [sp, #52]	; 0x34
                            (BITS(last.bits + last.op) >> last.bits)];
3481bf8c:	e0063000 	and	r3, r6, r0
                PULLBYTE();
            }
            if ((this.op & 0xf0) == 0) {
                last = this;
                for (;;) {
                    this = state->distcode[last.val +
3481bf90:	e0823133 	add	r3, r2, r3, lsr r1
3481bf94:	e08c0103 	add	r0, ip, r3, lsl #2
3481bf98:	e7dc2103 	ldrb	r2, [ip, r3, lsl #2]
3481bf9c:	e5d03001 	ldrb	r3, [r0, #1]
3481bfa0:	e1d000b2 	ldrh	r0, [r0, #2]
                            (BITS(last.bits + last.op) >> last.bits)];
3481bfa4:	e59d9028 	ldr	r9, [sp, #40]	; 0x28
                PULLBYTE();
            }
            if ((this.op & 0xf0) == 0) {
                last = this;
                for (;;) {
                    this = state->distcode[last.val +
3481bfa8:	e58d0024 	str	r0, [sp, #36]	; 0x24
                            (BITS(last.bits + last.op) >> last.bits)];
                    if ((unsigned)(last.bits + this.bits) <= bits) break;
3481bfac:	e0810003 	add	r0, r1, r3
3481bfb0:	e1500005 	cmp	r0, r5
3481bfb4:	9a000008 	bls	3481bfdc <inflate+0x109c>
                    PULLBYTE();
3481bfb8:	e3570000 	cmp	r7, #0
3481bfbc:	0a0000df 	beq	3481c340 <inflate+0x1400>
3481bfc0:	e1a00009 	mov	r0, r9
3481bfc4:	e4d03001 	ldrb	r3, [r0], #1
3481bfc8:	e2477001 	sub	r7, r7, #1
3481bfcc:	e0866513 	add	r6, r6, r3, lsl r5
3481bfd0:	e58d0028 	str	r0, [sp, #40]	; 0x28
3481bfd4:	e2855008 	add	r5, r5, #8
                }
3481bfd8:	eaffffe9 	b	3481bf84 <inflate+0x1044>
                DROPBITS(last.bits);
3481bfdc:	e1a06136 	lsr	r6, r6, r1
3481bfe0:	e0615005 	rsb	r5, r1, r5
            }
            DROPBITS(this.bits);
            if (this.op & 64) {
3481bfe4:	e3120040 	tst	r2, #64	; 0x40
                    if ((unsigned)(last.bits + this.bits) <= bits) break;
                    PULLBYTE();
                }
                DROPBITS(last.bits);
            }
            DROPBITS(this.bits);
3481bfe8:	e1a06336 	lsr	r6, r6, r3
3481bfec:	e0635005 	rsb	r5, r3, r5
            if (this.op & 64) {
                strm->msg = (char *)"invalid distance code";
3481bff0:	159f306c 	ldrne	r3, [pc, #108]	; 3481c064 <inflate+0x1124>
                    PULLBYTE();
                }
                DROPBITS(last.bits);
            }
            DROPBITS(this.bits);
            if (this.op & 64) {
3481bff4:	1a0000c1 	bne	3481c300 <inflate+0x13c0>
                strm->msg = (char *)"invalid distance code";
                state->mode = BAD;
                break;
            }
            state->offset = (unsigned)this.val;
3481bff8:	e59d1024 	ldr	r1, [sp, #36]	; 0x24
            state->extra = (unsigned)(this.op) & 15;
3481bffc:	e202200f 	and	r2, r2, #15
            state->mode = DISTEXT;
3481c000:	e3a03015 	mov	r3, #21
            if (this.op & 64) {
                strm->msg = (char *)"invalid distance code";
                state->mode = BAD;
                break;
            }
            state->offset = (unsigned)this.val;
3481c004:	e5841044 	str	r1, [r4, #68]	; 0x44
            state->extra = (unsigned)(this.op) & 15;
3481c008:	e5842048 	str	r2, [r4, #72]	; 0x48
            state->mode = DISTEXT;
3481c00c:	e5843000 	str	r3, [r4]
        case DISTEXT:
            if (state->extra) {
3481c010:	e5943048 	ldr	r3, [r4, #72]	; 0x48
3481c014:	e3530000 	cmp	r3, #0
3481c018:	11a02009 	movne	r2, r9
3481c01c:	1a00001a 	bne	3481c08c <inflate+0x114c>
3481c020:	ea000025 	b	3481c0bc <inflate+0x117c>
3481c024:	348278fd 	.word	0x348278fd
3481c028:	3482792f 	.word	0x3482792f
3481c02c:	34827914 	.word	0x34827914
3481c030:	34827943 	.word	0x34827943
3481c034:	3482795c 	.word	0x3482795c
3481c038:	34822200 	.word	0x34822200
3481c03c:	34822a00 	.word	0x34822a00
3481c040:	34827970 	.word	0x34827970
3481c044:	34827983 	.word	0x34827983
3481c048:	348279a0 	.word	0x348279a0
3481c04c:	34822100 	.word	0x34822100
3481c050:	348279c4 	.word	0x348279c4
3481c054:	348279dd 	.word	0x348279dd
3481c058:	348279f7 	.word	0x348279f7
3481c05c:	34827a13 	.word	0x34827a13
3481c060:	348278e1 	.word	0x348278e1
3481c064:	348278cb 	.word	0x348278cb
3481c068:	348278ad 	.word	0x348278ad
3481c06c:	34827a29 	.word	0x34827a29
3481c070:	34827a3e 	.word	0x34827a3e
                NEEDBITS(state->extra);
3481c074:	e3570000 	cmp	r7, #0
3481c078:	0a0000b0 	beq	3481c340 <inflate+0x1400>
3481c07c:	e4d21001 	ldrb	r1, [r2], #1
3481c080:	e2477001 	sub	r7, r7, #1
3481c084:	e0866511 	add	r6, r6, r1, lsl r5
3481c088:	e2855008 	add	r5, r5, #8
3481c08c:	e1550003 	cmp	r5, r3
3481c090:	e1a09002 	mov	r9, r2
3481c094:	3afffff6 	bcc	3481c074 <inflate+0x1134>
                state->offset += BITS(state->extra);
3481c098:	e3a0c001 	mov	ip, #1
3481c09c:	e1a0231c 	lsl	r2, ip, r3
3481c0a0:	e2422001 	sub	r2, r2, #1
3481c0a4:	e0062002 	and	r2, r6, r2
                DROPBITS(state->extra);
3481c0a8:	e1a06336 	lsr	r6, r6, r3
            state->extra = (unsigned)(this.op) & 15;
            state->mode = DISTEXT;
        case DISTEXT:
            if (state->extra) {
                NEEDBITS(state->extra);
                state->offset += BITS(state->extra);
3481c0ac:	e5941044 	ldr	r1, [r4, #68]	; 0x44
                DROPBITS(state->extra);
3481c0b0:	e0635005 	rsb	r5, r3, r5
            state->extra = (unsigned)(this.op) & 15;
            state->mode = DISTEXT;
        case DISTEXT:
            if (state->extra) {
                NEEDBITS(state->extra);
                state->offset += BITS(state->extra);
3481c0b4:	e0812002 	add	r2, r1, r2
3481c0b8:	e5842044 	str	r2, [r4, #68]	; 0x44
                strm->msg = (char *)"invalid distance too far back";
                state->mode = BAD;
                break;
            }
#endif
            if (state->offset > state->whave + out - left) {
3481c0bc:	e594302c 	ldr	r3, [r4, #44]	; 0x2c
3481c0c0:	e59d002c 	ldr	r0, [sp, #44]	; 0x2c
3481c0c4:	e5942044 	ldr	r2, [r4, #68]	; 0x44
3481c0c8:	e0803003 	add	r3, r0, r3
3481c0cc:	e06b3003 	rsb	r3, fp, r3
3481c0d0:	e1520003 	cmp	r2, r3
                strm->msg = (char *)"invalid distance too far back";
3481c0d4:	851f3074 	ldrhi	r3, [pc, #-116]	; 3481c068 <inflate+0x1128>
                strm->msg = (char *)"invalid distance too far back";
                state->mode = BAD;
                break;
            }
#endif
            if (state->offset > state->whave + out - left) {
3481c0d8:	8a000088 	bhi	3481c300 <inflate+0x13c0>
                strm->msg = (char *)"invalid distance too far back";
                state->mode = BAD;
                break;
            }
            Tracevv((stderr, "inflate:         distance %u\n", state->offset));
            state->mode = MATCH;
3481c0dc:	e3a03016 	mov	r3, #22
3481c0e0:	e5843000 	str	r3, [r4]
        case MATCH:
            if (left == 0) goto inf_leave;
3481c0e4:	e35b0000 	cmp	fp, #0
3481c0e8:	0a000094 	beq	3481c340 <inflate+0x1400>
            copy = out - left;
3481c0ec:	e59d102c 	ldr	r1, [sp, #44]	; 0x2c
3481c0f0:	e06b2001 	rsb	r2, fp, r1
            if (state->offset > copy) {         /* copy from window */
3481c0f4:	e5941044 	ldr	r1, [r4, #68]	; 0x44
3481c0f8:	e1510002 	cmp	r1, r2
                else
                    from = state->window + (state->write - copy);
                if (copy > state->length) copy = state->length;
            }
            else {                              /* copy from output */
                from = put - state->offset;
3481c0fc:	959d2020 	ldrls	r2, [sp, #32]
3481c100:	90611002 	rsbls	r1, r1, r2
                copy = state->length;
3481c104:	95942040 	ldrls	r2, [r4, #64]	; 0x40
            Tracevv((stderr, "inflate:         distance %u\n", state->offset));
            state->mode = MATCH;
        case MATCH:
            if (left == 0) goto inf_leave;
            copy = out - left;
            if (state->offset > copy) {         /* copy from window */
3481c108:	9a00000b 	bls	3481c13c <inflate+0x11fc>
                copy = state->offset - copy;
                if (copy > state->write) {
3481c10c:	e5943030 	ldr	r3, [r4, #48]	; 0x30
            state->mode = MATCH;
        case MATCH:
            if (left == 0) goto inf_leave;
            copy = out - left;
            if (state->offset > copy) {         /* copy from window */
                copy = state->offset - copy;
3481c110:	e0622001 	rsb	r2, r2, r1
                if (copy > state->write) {
3481c114:	e1520003 	cmp	r2, r3
                    copy -= state->write;
                    from = state->window + (state->wsize - copy);
3481c118:	85941028 	ldrhi	r1, [r4, #40]	; 0x28
            if (left == 0) goto inf_leave;
            copy = out - left;
            if (state->offset > copy) {         /* copy from window */
                copy = state->offset - copy;
                if (copy > state->write) {
                    copy -= state->write;
3481c11c:	80632002 	rsbhi	r2, r3, r2
                    from = state->window + (state->wsize - copy);
                }
                else
                    from = state->window + (state->write - copy);
3481c120:	90621003 	rsbls	r1, r2, r3
3481c124:	e5940034 	ldr	r0, [r4, #52]	; 0x34
                if (copy > state->length) copy = state->length;
3481c128:	e5943040 	ldr	r3, [r4, #64]	; 0x40
            copy = out - left;
            if (state->offset > copy) {         /* copy from window */
                copy = state->offset - copy;
                if (copy > state->write) {
                    copy -= state->write;
                    from = state->window + (state->wsize - copy);
3481c12c:	80621001 	rsbhi	r1, r2, r1
                }
                else
                    from = state->window + (state->write - copy);
3481c130:	e0801001 	add	r1, r0, r1
                if (copy > state->length) copy = state->length;
3481c134:	e1520003 	cmp	r2, r3
3481c138:	21a02003 	movcs	r2, r3
                from = put - state->offset;
                copy = state->length;
            }
            if (copy > left) copy = left;
            left -= copy;
            state->length -= copy;
3481c13c:	e5943040 	ldr	r3, [r4, #64]	; 0x40
                    from = state->window + (state->write - copy);
                if (copy > state->length) copy = state->length;
            }
            else {                              /* copy from output */
                from = put - state->offset;
                copy = state->length;
3481c140:	e152000b 	cmp	r2, fp
3481c144:	21a0200b 	movcs	r2, fp
            }
            if (copy > left) copy = left;
            left -= copy;
            state->length -= copy;
3481c148:	e0623003 	rsb	r3, r2, r3
3481c14c:	e5843040 	str	r3, [r4, #64]	; 0x40
            else {                              /* copy from output */
                from = put - state->offset;
                copy = state->length;
            }
            if (copy > left) copy = left;
            left -= copy;
3481c150:	e062b00b 	rsb	fp, r2, fp
            state->length -= copy;
3481c154:	e3a03000 	mov	r3, #0
            do {
                *put++ = *from++;
3481c158:	e7d10003 	ldrb	r0, [r1, r3]
3481c15c:	e59dc020 	ldr	ip, [sp, #32]
3481c160:	e7cc0003 	strb	r0, [ip, r3]
3481c164:	e2833001 	add	r3, r3, #1
            } while (--copy);
3481c168:	e1520003 	cmp	r2, r3
3481c16c:	1afffff9 	bne	3481c158 <inflate+0x1218>
            if (state->length == 0) state->mode = LEN;
3481c170:	e5943040 	ldr	r3, [r4, #64]	; 0x40
            if (copy > left) copy = left;
            left -= copy;
            state->length -= copy;
            do {
                *put++ = *from++;
            } while (--copy);
3481c174:	e08cc002 	add	ip, ip, r2
            if (state->length == 0) state->mode = LEN;
3481c178:	e3530000 	cmp	r3, #0
            if (copy > left) copy = left;
            left -= copy;
            state->length -= copy;
            do {
                *put++ = *from++;
            } while (--copy);
3481c17c:	e58dc020 	str	ip, [sp, #32]
            if (state->length == 0) state->mode = LEN;
3481c180:	02833012 	addeq	r3, r3, #18
3481c184:	0a00005f 	beq	3481c308 <inflate+0x13c8>
3481c188:	eafffb8b 	b	3481afbc <inflate+0x7c>
            break;
        case LIT:
            if (left == 0) goto inf_leave;
3481c18c:	e35b0000 	cmp	fp, #0
3481c190:	0a00006a 	beq	3481c340 <inflate+0x1400>
            *put++ = (unsigned char)(state->length);
3481c194:	e5943040 	ldr	r3, [r4, #64]	; 0x40
3481c198:	e59d0020 	ldr	r0, [sp, #32]
            left--;
3481c19c:	e24bb001 	sub	fp, fp, #1
            } while (--copy);
            if (state->length == 0) state->mode = LEN;
            break;
        case LIT:
            if (left == 0) goto inf_leave;
            *put++ = (unsigned char)(state->length);
3481c1a0:	e4c03001 	strb	r3, [r0], #1
3481c1a4:	e58d0020 	str	r0, [sp, #32]
            left--;
            state->mode = LEN;
3481c1a8:	e3a03012 	mov	r3, #18
3481c1ac:	ea000055 	b	3481c308 <inflate+0x13c8>
            break;
        case CHECK:
            if (state->wrap) {
3481c1b0:	e5943008 	ldr	r3, [r4, #8]
3481c1b4:	e3530000 	cmp	r3, #0
3481c1b8:	11a03009 	movne	r3, r9
3481c1bc:	1a000006 	bne	3481c1dc <inflate+0x129c>
3481c1c0:	ea000037 	b	3481c2a4 <inflate+0x1364>
                NEEDBITS(32);
3481c1c4:	e3570000 	cmp	r7, #0
3481c1c8:	0a00005c 	beq	3481c340 <inflate+0x1400>
3481c1cc:	e4d32001 	ldrb	r2, [r3], #1
3481c1d0:	e2477001 	sub	r7, r7, #1
3481c1d4:	e0866512 	add	r6, r6, r2, lsl r5
3481c1d8:	e2855008 	add	r5, r5, #8
3481c1dc:	e355001f 	cmp	r5, #31
3481c1e0:	e1a09003 	mov	r9, r3
3481c1e4:	9afffff6 	bls	3481c1c4 <inflate+0x1284>
                out -= left;
3481c1e8:	e59d102c 	ldr	r1, [sp, #44]	; 0x2c
                strm->total_out += out;
3481c1ec:	e59a3014 	ldr	r3, [sl, #20]
            state->mode = LEN;
            break;
        case CHECK:
            if (state->wrap) {
                NEEDBITS(32);
                out -= left;
3481c1f0:	e06b2001 	rsb	r2, fp, r1
                strm->total_out += out;
3481c1f4:	e0833002 	add	r3, r3, r2
3481c1f8:	e58a3014 	str	r3, [sl, #20]
                state->total += out;
3481c1fc:	e594301c 	ldr	r3, [r4, #28]
                if (out)
3481c200:	e3520000 	cmp	r2, #0
        case CHECK:
            if (state->wrap) {
                NEEDBITS(32);
                out -= left;
                strm->total_out += out;
                state->total += out;
3481c204:	e0833002 	add	r3, r3, r2
3481c208:	e584301c 	str	r3, [r4, #28]
                if (out)
3481c20c:	0a00000e 	beq	3481c24c <inflate+0x130c>
                    strm->adler = state->check =
                        UPDATE(state->check, put - out, out);
3481c210:	e5943010 	ldr	r3, [r4, #16]
3481c214:	e2621000 	rsb	r1, r2, #0
3481c218:	e3530000 	cmp	r3, #0
3481c21c:	0a000004 	beq	3481c234 <inflate+0x12f4>
3481c220:	e59d3020 	ldr	r3, [sp, #32]
3481c224:	e5940018 	ldr	r0, [r4, #24]
3481c228:	e0831001 	add	r1, r3, r1
3481c22c:	ebffeb95 	bl	34817088 <crc32>
3481c230:	ea000003 	b	3481c244 <inflate+0x1304>
3481c234:	e59dc020 	ldr	ip, [sp, #32]
3481c238:	e5940018 	ldr	r0, [r4, #24]
3481c23c:	e08c1001 	add	r1, ip, r1
3481c240:	ebfffa84 	bl	3481ac58 <adler32>
                NEEDBITS(32);
                out -= left;
                strm->total_out += out;
                state->total += out;
                if (out)
                    strm->adler = state->check =
3481c244:	e5840018 	str	r0, [r4, #24]
3481c248:	e58a0034 	str	r0, [sl, #52]	; 0x34
                        UPDATE(state->check, put - out, out);
                out = left;
                if ((
#ifdef GUNZIP
                     state->flags ? hold :
3481c24c:	e5943010 	ldr	r3, [r4, #16]
3481c250:	e3530000 	cmp	r3, #0
#endif
                     REVERSE(hold)) != state->check) {
3481c254:	01a02426 	lsreq	r2, r6, #8
3481c258:	01a01c26 	lsreq	r1, r6, #24
3481c25c:	02022cff 	andeq	r2, r2, #65280	; 0xff00
3481c260:	00811c06 	addeq	r1, r1, r6, lsl #24
3481c264:	02063cff 	andeq	r3, r6, #65280	; 0xff00
3481c268:	00812002 	addeq	r2, r1, r2
                    strm->adler = state->check =
                        UPDATE(state->check, put - out, out);
                out = left;
                if ((
#ifdef GUNZIP
                     state->flags ? hold :
3481c26c:	00823403 	addeq	r3, r2, r3, lsl #8
                state->total += out;
                if (out)
                    strm->adler = state->check =
                        UPDATE(state->check, put - out, out);
                out = left;
                if ((
3481c270:	e5942018 	ldr	r2, [r4, #24]
#ifdef GUNZIP
                     state->flags ? hold :
3481c274:	11a03006 	movne	r3, r6
                state->total += out;
                if (out)
                    strm->adler = state->check =
                        UPDATE(state->check, put - out, out);
                out = left;
                if ((
3481c278:	e1530002 	cmp	r3, r2
                     REVERSE(hold)) != state->check) {
                    strm->msg = (char *)"incorrect data check";
                    state->mode = BAD;
                    break;
                }
                INITBITS();
3481c27c:	03a05000 	moveq	r5, #0
                state->total += out;
                if (out)
                    strm->adler = state->check =
                        UPDATE(state->check, put - out, out);
                out = left;
                if ((
3481c280:	058db02c 	streq	fp, [sp, #44]	; 0x2c
                     REVERSE(hold)) != state->check) {
                    strm->msg = (char *)"incorrect data check";
                    state->mode = BAD;
                    break;
                }
                INITBITS();
3481c284:	01a06005 	moveq	r6, r5
                state->total += out;
                if (out)
                    strm->adler = state->check =
                        UPDATE(state->check, put - out, out);
                out = left;
                if ((
3481c288:	0a000005 	beq	3481c2a4 <inflate+0x1364>
#ifdef GUNZIP
                     state->flags ? hold :
#endif
                     REVERSE(hold)) != state->check) {
                    strm->msg = (char *)"incorrect data check";
3481c28c:	e51f3228 	ldr	r3, [pc, #-552]	; 3481c06c <inflate+0x112c>
                    state->mode = BAD;
                    break;
3481c290:	e58db02c 	str	fp, [sp, #44]	; 0x2c
                if ((
#ifdef GUNZIP
                     state->flags ? hold :
#endif
                     REVERSE(hold)) != state->check) {
                    strm->msg = (char *)"incorrect data check";
3481c294:	e58a3018 	str	r3, [sl, #24]
                    state->mode = BAD;
3481c298:	e3a0301b 	mov	r3, #27
3481c29c:	e5843000 	str	r3, [r4]
                    break;
3481c2a0:	eafffb45 	b	3481afbc <inflate+0x7c>
                }
                INITBITS();
                Tracev((stderr, "inflate:   check matches trailer\n"));
            }
#ifdef GUNZIP
            state->mode = LENGTH;
3481c2a4:	e3a03019 	mov	r3, #25
3481c2a8:	e5843000 	str	r3, [r4]
        case LENGTH:
            if (state->wrap && state->flags) {
3481c2ac:	e5943008 	ldr	r3, [r4, #8]
3481c2b0:	e3530000 	cmp	r3, #0
3481c2b4:	0a000017 	beq	3481c318 <inflate+0x13d8>
3481c2b8:	e5943010 	ldr	r3, [r4, #16]
3481c2bc:	e3530000 	cmp	r3, #0
3481c2c0:	0a000014 	beq	3481c318 <inflate+0x13d8>
3481c2c4:	e1a03009 	mov	r3, r9
3481c2c8:	ea000005 	b	3481c2e4 <inflate+0x13a4>
                NEEDBITS(32);
3481c2cc:	e3570000 	cmp	r7, #0
3481c2d0:	0a00001a 	beq	3481c340 <inflate+0x1400>
3481c2d4:	e4d32001 	ldrb	r2, [r3], #1
3481c2d8:	e2477001 	sub	r7, r7, #1
3481c2dc:	e0866512 	add	r6, r6, r2, lsl r5
3481c2e0:	e2855008 	add	r5, r5, #8
3481c2e4:	e355001f 	cmp	r5, #31
3481c2e8:	e1a09003 	mov	r9, r3
3481c2ec:	9afffff6 	bls	3481c2cc <inflate+0x138c>
                if (hold != (state->total & 0xffffffffUL)) {
3481c2f0:	e594301c 	ldr	r3, [r4, #28]
3481c2f4:	e1560003 	cmp	r6, r3
3481c2f8:	0a000004 	beq	3481c310 <inflate+0x13d0>
                    strm->msg = (char *)"incorrect length check";
3481c2fc:	e51f3294 	ldr	r3, [pc, #-660]	; 3481c070 <inflate+0x1130>
3481c300:	e58a3018 	str	r3, [sl, #24]
                    state->mode = BAD;
3481c304:	e3a0301b 	mov	r3, #27
3481c308:	e5843000 	str	r3, [r4]
3481c30c:	eafffb2a 	b	3481afbc <inflate+0x7c>
                    break;
                }
                INITBITS();
3481c310:	e3a05000 	mov	r5, #0
3481c314:	e1a06005 	mov	r6, r5
                Tracev((stderr, "inflate:   length matches trailer\n"));
            }
#endif
            state->mode = DONE;
3481c318:	e3a0301a 	mov	r3, #26
        case DONE:
            ret = Z_STREAM_END;
3481c31c:	e3a00001 	mov	r0, #1
                }
                INITBITS();
                Tracev((stderr, "inflate:   length matches trailer\n"));
            }
#endif
            state->mode = DONE;
3481c320:	e5843000 	str	r3, [r4]
        case DONE:
            ret = Z_STREAM_END;
3481c324:	e58d001c 	str	r0, [sp, #28]
3481c328:	ea000004 	b	3481c340 <inflate+0x1400>
            goto inf_leave;
        case BAD:
            ret = Z_DATA_ERROR;
3481c32c:	e3e01002 	mvn	r1, #2
3481c330:	e58d101c 	str	r1, [sp, #28]
3481c334:	ea000001 	b	3481c340 <inflate+0x1400>
                Tracev((stderr, "inflate:   length matches trailer\n"));
            }
#endif
            state->mode = DONE;
        case DONE:
            ret = Z_STREAM_END;
3481c338:	e3a02001 	mov	r2, #1
3481c33c:	e58d201c 	str	r2, [sp, #28]
       If there was no progress during the inflate() call, return a buffer
       error.  Call updatewindow() to create and/or update the window state.
       Note: a memory error from inflate() is non-recoverable.
     */
  inf_leave:
    RESTORE();
3481c340:	e59d3020 	ldr	r3, [sp, #32]
3481c344:	e58ab010 	str	fp, [sl, #16]
3481c348:	e58a300c 	str	r3, [sl, #12]
    if (state->wsize || (state->mode < CHECK && out != strm->avail_out))
3481c34c:	e5943028 	ldr	r3, [r4, #40]	; 0x28
       If there was no progress during the inflate() call, return a buffer
       error.  Call updatewindow() to create and/or update the window state.
       Note: a memory error from inflate() is non-recoverable.
     */
  inf_leave:
    RESTORE();
3481c350:	e58a9000 	str	r9, [sl]
    if (state->wsize || (state->mode < CHECK && out != strm->avail_out))
3481c354:	e3530000 	cmp	r3, #0
       If there was no progress during the inflate() call, return a buffer
       error.  Call updatewindow() to create and/or update the window state.
       Note: a memory error from inflate() is non-recoverable.
     */
  inf_leave:
    RESTORE();
3481c358:	e58a7004 	str	r7, [sl, #4]
3481c35c:	e5846038 	str	r6, [r4, #56]	; 0x38
3481c360:	e584503c 	str	r5, [r4, #60]	; 0x3c
    if (state->wsize || (state->mode < CHECK && out != strm->avail_out))
3481c364:	1a000005 	bne	3481c380 <inflate+0x1440>
3481c368:	e5943000 	ldr	r3, [r4]
3481c36c:	e3530017 	cmp	r3, #23
3481c370:	8a000048 	bhi	3481c498 <inflate+0x1558>
3481c374:	e59dc02c 	ldr	ip, [sp, #44]	; 0x2c
3481c378:	e15c000b 	cmp	ip, fp
3481c37c:	0a000045 	beq	3481c498 <inflate+0x1558>
unsigned out;
{
    struct inflate_state FAR *state;
    unsigned copy, dist;

    state = (struct inflate_state FAR *)strm->state;
3481c380:	e59a501c 	ldr	r5, [sl, #28]

    /* if it hasn't been done already, allocate space for the window */
    if (state->window == Z_NULL) {
3481c384:	e5953034 	ldr	r3, [r5, #52]	; 0x34
3481c388:	e3530000 	cmp	r3, #0
3481c38c:	1a000008 	bne	3481c3b4 <inflate+0x1474>
        state->window = (unsigned char FAR *)
                        ZALLOC(strm, 1U << state->wbits,
3481c390:	e5951024 	ldr	r1, [r5, #36]	; 0x24
3481c394:	e3a02001 	mov	r2, #1
3481c398:	e59a3020 	ldr	r3, [sl, #32]
3481c39c:	e59a0028 	ldr	r0, [sl, #40]	; 0x28
3481c3a0:	e1a01112 	lsl	r1, r2, r1
3481c3a4:	e12fff33 	blx	r3
                               sizeof(unsigned char));
        if (state->window == Z_NULL) return 1;
3481c3a8:	e3500000 	cmp	r0, #0

    state = (struct inflate_state FAR *)strm->state;

    /* if it hasn't been done already, allocate space for the window */
    if (state->window == Z_NULL) {
        state->window = (unsigned char FAR *)
3481c3ac:	e5850034 	str	r0, [r5, #52]	; 0x34
                        ZALLOC(strm, 1U << state->wbits,
                               sizeof(unsigned char));
        if (state->window == Z_NULL) return 1;
3481c3b0:	0a000034 	beq	3481c488 <inflate+0x1548>
    }

    /* if window not in use yet, initialize */
    if (state->wsize == 0) {
3481c3b4:	e5953028 	ldr	r3, [r5, #40]	; 0x28
3481c3b8:	e3530000 	cmp	r3, #0
3481c3bc:	1a000005 	bne	3481c3d8 <inflate+0x1498>
        state->wsize = 1U << state->wbits;
3481c3c0:	e5952024 	ldr	r2, [r5, #36]	; 0x24
3481c3c4:	e3a01001 	mov	r1, #1
3481c3c8:	e1a02211 	lsl	r2, r1, r2
        state->write = 0;
3481c3cc:	e5853030 	str	r3, [r5, #48]	; 0x30
        if (state->window == Z_NULL) return 1;
    }

    /* if window not in use yet, initialize */
    if (state->wsize == 0) {
        state->wsize = 1U << state->wbits;
3481c3d0:	e5852028 	str	r2, [r5, #40]	; 0x28
        state->write = 0;
        state->whave = 0;
3481c3d4:	e585302c 	str	r3, [r5, #44]	; 0x2c
    }

    /* copy state->wsize or less output bytes into the circular window */
    copy = out - strm->avail_out;
3481c3d8:	e59a6010 	ldr	r6, [sl, #16]
3481c3dc:	e59d002c 	ldr	r0, [sp, #44]	; 0x2c
    if (copy >= state->wsize) {
3481c3e0:	e5952028 	ldr	r2, [r5, #40]	; 0x28
        state->write = 0;
        state->whave = 0;
    }

    /* copy state->wsize or less output bytes into the circular window */
    copy = out - strm->avail_out;
3481c3e4:	e0666000 	rsb	r6, r6, r0
    if (copy >= state->wsize) {
3481c3e8:	e1560002 	cmp	r6, r2
3481c3ec:	e59a100c 	ldr	r1, [sl, #12]
3481c3f0:	3a000005 	bcc	3481c40c <inflate+0x14cc>
        zmemcpy(state->window, strm->next_out - state->wsize, state->wsize);
3481c3f4:	e5950034 	ldr	r0, [r5, #52]	; 0x34
3481c3f8:	e0621001 	rsb	r1, r2, r1
3481c3fc:	ebfff2a3 	bl	34818e90 <memcpy>
        state->write = 0;
3481c400:	e3a03000 	mov	r3, #0
3481c404:	e5853030 	str	r3, [r5, #48]	; 0x30
3481c408:	ea000010 	b	3481c450 <inflate+0x1510>
        state->whave = state->wsize;
    }
    else {
        dist = state->wsize - state->write;
3481c40c:	e5953030 	ldr	r3, [r5, #48]	; 0x30
        if (dist > copy) dist = copy;
        zmemcpy(state->window + state->write, strm->next_out - copy, dist);
3481c410:	e5950034 	ldr	r0, [r5, #52]	; 0x34
        zmemcpy(state->window, strm->next_out - state->wsize, state->wsize);
        state->write = 0;
        state->whave = state->wsize;
    }
    else {
        dist = state->wsize - state->write;
3481c414:	e0637002 	rsb	r7, r3, r2
3481c418:	e1560007 	cmp	r6, r7
3481c41c:	31a07006 	movcc	r7, r6
        if (dist > copy) dist = copy;
        zmemcpy(state->window + state->write, strm->next_out - copy, dist);
3481c420:	e0661001 	rsb	r1, r6, r1
3481c424:	e0800003 	add	r0, r0, r3
3481c428:	e1a02007 	mov	r2, r7
3481c42c:	ebfff297 	bl	34818e90 <memcpy>
        copy -= dist;
        if (copy) {
3481c430:	e0566007 	subs	r6, r6, r7
3481c434:	0a000008 	beq	3481c45c <inflate+0x151c>
            zmemcpy(state->window, strm->next_out - copy, copy);
3481c438:	e59a100c 	ldr	r1, [sl, #12]
3481c43c:	e5950034 	ldr	r0, [r5, #52]	; 0x34
3481c440:	e0661001 	rsb	r1, r6, r1
3481c444:	e1a02006 	mov	r2, r6
3481c448:	ebfff290 	bl	34818e90 <memcpy>
            state->write = copy;
3481c44c:	e5856030 	str	r6, [r5, #48]	; 0x30
            state->whave = state->wsize;
3481c450:	e5953028 	ldr	r3, [r5, #40]	; 0x28
3481c454:	e585302c 	str	r3, [r5, #44]	; 0x2c
3481c458:	ea00000e 	b	3481c498 <inflate+0x1558>
        }
        else {
            state->write += dist;
3481c45c:	e5953030 	ldr	r3, [r5, #48]	; 0x30
            if (state->write == state->wsize) state->write = 0;
3481c460:	e5952028 	ldr	r2, [r5, #40]	; 0x28
            zmemcpy(state->window, strm->next_out - copy, copy);
            state->write = copy;
            state->whave = state->wsize;
        }
        else {
            state->write += dist;
3481c464:	e0873003 	add	r3, r7, r3
            if (state->write == state->wsize) state->write = 0;
3481c468:	e1530002 	cmp	r3, r2
            zmemcpy(state->window, strm->next_out - copy, copy);
            state->write = copy;
            state->whave = state->wsize;
        }
        else {
            state->write += dist;
3481c46c:	e5853030 	str	r3, [r5, #48]	; 0x30
            if (state->write == state->wsize) state->write = 0;
            if (state->whave < state->wsize) state->whave += dist;
3481c470:	e595302c 	ldr	r3, [r5, #44]	; 0x2c
            state->write = copy;
            state->whave = state->wsize;
        }
        else {
            state->write += dist;
            if (state->write == state->wsize) state->write = 0;
3481c474:	05856030 	streq	r6, [r5, #48]	; 0x30
            if (state->whave < state->wsize) state->whave += dist;
3481c478:	e1530002 	cmp	r3, r2
3481c47c:	30877003 	addcc	r7, r7, r3
3481c480:	3585702c 	strcc	r7, [r5, #44]	; 0x2c
3481c484:	ea000003 	b	3481c498 <inflate+0x1558>
     */
  inf_leave:
    RESTORE();
    if (state->wsize || (state->mode < CHECK && out != strm->avail_out))
        if (updatewindow(strm, out)) {
            state->mode = MEM;
3481c488:	e3a0301c 	mov	r3, #28
3481c48c:	e5843000 	str	r3, [r4]
            return Z_MEM_ERROR;
3481c490:	e3e01003 	mvn	r1, #3
3481c494:	ea00003b 	b	3481c588 <inflate+0x1648>
        }
    in -= strm->avail_in;
    out -= strm->avail_out;
3481c498:	e59a6010 	ldr	r6, [sl, #16]
3481c49c:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
    if (state->wsize || (state->mode < CHECK && out != strm->avail_out))
        if (updatewindow(strm, out)) {
            state->mode = MEM;
            return Z_MEM_ERROR;
        }
    in -= strm->avail_in;
3481c4a0:	e59a5004 	ldr	r5, [sl, #4]
3481c4a4:	e59d2038 	ldr	r2, [sp, #56]	; 0x38
    out -= strm->avail_out;
3481c4a8:	e0666003 	rsb	r6, r6, r3
    strm->total_in += in;
3481c4ac:	e59a3008 	ldr	r3, [sl, #8]
    if (state->wsize || (state->mode < CHECK && out != strm->avail_out))
        if (updatewindow(strm, out)) {
            state->mode = MEM;
            return Z_MEM_ERROR;
        }
    in -= strm->avail_in;
3481c4b0:	e0655002 	rsb	r5, r5, r2
    out -= strm->avail_out;
    strm->total_in += in;
3481c4b4:	e0833005 	add	r3, r3, r5
3481c4b8:	e58a3008 	str	r3, [sl, #8]
    strm->total_out += out;
3481c4bc:	e59a3014 	ldr	r3, [sl, #20]
3481c4c0:	e0833006 	add	r3, r3, r6
3481c4c4:	e58a3014 	str	r3, [sl, #20]
    state->total += out;
3481c4c8:	e594301c 	ldr	r3, [r4, #28]
3481c4cc:	e0833006 	add	r3, r3, r6
3481c4d0:	e584301c 	str	r3, [r4, #28]
    if (state->wrap && out)
3481c4d4:	e5943008 	ldr	r3, [r4, #8]
3481c4d8:	e3560000 	cmp	r6, #0
3481c4dc:	13530000 	cmpne	r3, #0
3481c4e0:	0a00000f 	beq	3481c524 <inflate+0x15e4>
        strm->adler = state->check =
            UPDATE(state->check, strm->next_out - out, out);
3481c4e4:	e5943010 	ldr	r3, [r4, #16]
3481c4e8:	e59a100c 	ldr	r1, [sl, #12]
3481c4ec:	e3530000 	cmp	r3, #0
3481c4f0:	e2663000 	rsb	r3, r6, #0
3481c4f4:	0a000004 	beq	3481c50c <inflate+0x15cc>
3481c4f8:	e5940018 	ldr	r0, [r4, #24]
3481c4fc:	e0811003 	add	r1, r1, r3
3481c500:	e1a02006 	mov	r2, r6
3481c504:	ebffeadf 	bl	34817088 <crc32>
3481c508:	ea000003 	b	3481c51c <inflate+0x15dc>
3481c50c:	e5940018 	ldr	r0, [r4, #24]
3481c510:	e0811003 	add	r1, r1, r3
3481c514:	e1a02006 	mov	r2, r6
3481c518:	ebfff9ce 	bl	3481ac58 <adler32>
    out -= strm->avail_out;
    strm->total_in += in;
    strm->total_out += out;
    state->total += out;
    if (state->wrap && out)
        strm->adler = state->check =
3481c51c:	e5840018 	str	r0, [r4, #24]
3481c520:	e58a0034 	str	r0, [sl, #52]	; 0x34
            UPDATE(state->check, strm->next_out - out, out);
    strm->data_type = state->bits + (state->last ? 64 : 0) +
3481c524:	e5943004 	ldr	r3, [r4, #4]
3481c528:	e594203c 	ldr	r2, [r4, #60]	; 0x3c
3481c52c:	e3530000 	cmp	r3, #0
3481c530:	13a03040 	movne	r3, #64	; 0x40
3481c534:	03a03000 	moveq	r3, #0
3481c538:	e0833002 	add	r3, r3, r2
3481c53c:	e5942000 	ldr	r2, [r4]
                      (state->mode == TYPE ? 128 : 0);
    if (((in == 0 && out == 0) || flush == Z_FINISH) && ret == Z_OK)
3481c540:	e59dc03c 	ldr	ip, [sp, #60]	; 0x3c
    strm->total_out += out;
    state->total += out;
    if (state->wrap && out)
        strm->adler = state->check =
            UPDATE(state->check, strm->next_out - out, out);
    strm->data_type = state->bits + (state->last ? 64 : 0) +
3481c544:	e352000b 	cmp	r2, #11
3481c548:	03a02080 	moveq	r2, #128	; 0x80
3481c54c:	13a02000 	movne	r2, #0
3481c550:	e0833002 	add	r3, r3, r2
                      (state->mode == TYPE ? 128 : 0);
    if (((in == 0 && out == 0) || flush == Z_FINISH) && ret == Z_OK)
3481c554:	e1966005 	orrs	r6, r6, r5
    strm->total_out += out;
    state->total += out;
    if (state->wrap && out)
        strm->adler = state->check =
            UPDATE(state->check, strm->next_out - out, out);
    strm->data_type = state->bits + (state->last ? 64 : 0) +
3481c558:	e58a302c 	str	r3, [sl, #44]	; 0x2c
                      (state->mode == TYPE ? 128 : 0);
    if (((in == 0 && out == 0) || flush == Z_FINISH) && ret == Z_OK)
3481c55c:	13a03000 	movne	r3, #0
3481c560:	03a03001 	moveq	r3, #1
3481c564:	e35c0004 	cmp	ip, #4
3481c568:	03833001 	orreq	r3, r3, #1
3481c56c:	e3530000 	cmp	r3, #0
3481c570:	0a00000d 	beq	3481c5ac <inflate+0x166c>
        ret = Z_BUF_ERROR;
3481c574:	e59d001c 	ldr	r0, [sp, #28]
3481c578:	e3500000 	cmp	r0, #0
3481c57c:	03e00004 	mvneq	r0, #4
3481c580:	e58d001c 	str	r0, [sp, #28]
3481c584:	ea000008 	b	3481c5ac <inflate+0x166c>
    static const unsigned short order[19] = /* permutation of code lengths */
        {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};

    if (strm == Z_NULL || strm->state == Z_NULL ||
        (strm->next_in == Z_NULL && strm->avail_in != 0))
        return Z_STREAM_ERROR;
3481c588:	e58d101c 	str	r1, [sp, #28]
3481c58c:	ea000006 	b	3481c5ac <inflate+0x166c>
3481c590:	e3e02001 	mvn	r2, #1
3481c594:	e58d201c 	str	r2, [sp, #28]
3481c598:	ea000003 	b	3481c5ac <inflate+0x166c>
3481c59c:	e58d301c 	str	r3, [sp, #28]
3481c5a0:	ea000001 	b	3481c5ac <inflate+0x166c>
            goto inf_leave;
        case MEM:
            return Z_MEM_ERROR;
        case SYNC:
        default:
            return Z_STREAM_ERROR;
3481c5a4:	e3e0c001 	mvn	ip, #1
3481c5a8:	e58dc01c 	str	ip, [sp, #28]
    strm->data_type = state->bits + (state->last ? 64 : 0) +
                      (state->mode == TYPE ? 128 : 0);
    if (((in == 0 && out == 0) || flush == Z_FINISH) && ret == Z_OK)
        ret = Z_BUF_ERROR;
    return ret;
}
3481c5ac:	e59d001c 	ldr	r0, [sp, #28]
3481c5b0:	e28dd048 	add	sp, sp, #72	; 0x48
3481c5b4:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}

3481c5b8 <ArpInit>:
uchar		NetArpPacketBuf[PKTSIZE_ALIGN + PKTALIGN];

void ArpInit(void)
{
	/* XXX problem with bss workaround */
	NetArpWaitPacketMAC = NULL;
3481c5b8:	e59f3020 	ldr	r3, [pc, #32]	; 3481c5e0 <ArpInit+0x28>
3481c5bc:	e3a02000 	mov	r2, #0
3481c5c0:	e5832000 	str	r2, [r3]
	NetArpWaitPacketIP = 0;
3481c5c4:	e5832004 	str	r2, [r3, #4]
	NetArpWaitReplyIP = 0;
3481c5c8:	e5832008 	str	r2, [r3, #8]
	NetArpWaitTxPacketSize = 0;
3481c5cc:	e583200c 	str	r2, [r3, #12]
	NetArpTxPacket = &NetArpPacketBuf[0] + (PKTALIGN - 1);
3481c5d0:	e2832053 	add	r2, r3, #83	; 0x53
	NetArpTxPacket -= (ulong)NetArpTxPacket % PKTALIGN;
3481c5d4:	e3c2203f 	bic	r2, r2, #63	; 0x3f
3481c5d8:	e5832010 	str	r2, [r3, #16]
}
3481c5dc:	e12fff1e 	bx	lr
3481c5e0:	3482b358 	.word	0x3482b358

3481c5e4 <arp_raw_request>:

void arp_raw_request(IPaddr_t sourceIP, const uchar *targetEther,
	IPaddr_t targetIP)
{
3481c5e4:	e92d4eff 	push	{r0, r1, r2, r3, r4, r5, r6, r7, r9, sl, fp, lr}
	struct arp_hdr *arp;
	int eth_hdr_size;

	debug_cond(DEBUG_DEV_PKT, "ARP broadcast %d\n", NetArpWaitTry);

	pkt = NetArpTxPacket;
3481c5e8:	e59f90b4 	ldr	r9, [pc, #180]	; 3481c6a4 <arp_raw_request+0xc0>
	NetArpTxPacket -= (ulong)NetArpTxPacket % PKTALIGN;
}

void arp_raw_request(IPaddr_t sourceIP, const uchar *targetEther,
	IPaddr_t targetIP)
{
3481c5ec:	e1a0c002 	mov	ip, r2
	struct arp_hdr *arp;
	int eth_hdr_size;

	debug_cond(DEBUG_DEV_PKT, "ARP broadcast %d\n", NetArpWaitTry);

	pkt = NetArpTxPacket;
3481c5f0:	e5995010 	ldr	r5, [r9, #16]
	NetArpTxPacket -= (ulong)NetArpTxPacket % PKTALIGN;
}

void arp_raw_request(IPaddr_t sourceIP, const uchar *targetEther,
	IPaddr_t targetIP)
{
3481c5f4:	e1a03001 	mov	r3, r1
3481c5f8:	e1a0b000 	mov	fp, r0

	debug_cond(DEBUG_DEV_PKT, "ARP broadcast %d\n", NetArpWaitTry);

	pkt = NetArpTxPacket;

	eth_hdr_size = NetSetEther(pkt, NetBcastAddr, PROT_ARP);
3481c5fc:	e59f10a4 	ldr	r1, [pc, #164]	; 3481c6a8 <arp_raw_request+0xc4>
3481c600:	e1a00005 	mov	r0, r5
3481c604:	e3002806 	movw	r2, #2054	; 0x806
3481c608:	e58dc000 	str	ip, [sp]
3481c60c:	e58d3004 	str	r3, [sp, #4]
3481c610:	eb0005fc 	bl	3481de08 <NetSetEther>

	arp = (struct arp_hdr *) pkt;

	arp->ar_hrd = htons(ARP_ETHER);
	arp->ar_pro = htons(PROT_IP);
	arp->ar_hln = ARP_HLEN;
3481c614:	e3a0a006 	mov	sl, #6
	debug_cond(DEBUG_DEV_PKT, "ARP broadcast %d\n", NetArpWaitTry);

	pkt = NetArpTxPacket;

	eth_hdr_size = NetSetEther(pkt, NetBcastAddr, PROT_ARP);
	pkt += eth_hdr_size;
3481c618:	e0854000 	add	r4, r5, r0
	arp = (struct arp_hdr *) pkt;

	arp->ar_hrd = htons(ARP_ETHER);
	arp->ar_pro = htons(PROT_IP);
	arp->ar_hln = ARP_HLEN;
	arp->ar_pln = ARP_PLEN;
3481c61c:	e3a07004 	mov	r7, #4
	eth_hdr_size = NetSetEther(pkt, NetBcastAddr, PROT_ARP);
	pkt += eth_hdr_size;

	arp = (struct arp_hdr *) pkt;

	arp->ar_hrd = htons(ARP_ETHER);
3481c620:	e3a02c01 	mov	r2, #256	; 0x100
	arp->ar_pro = htons(PROT_IP);
3481c624:	e3a01008 	mov	r1, #8
	eth_hdr_size = NetSetEther(pkt, NetBcastAddr, PROT_ARP);
	pkt += eth_hdr_size;

	arp = (struct arp_hdr *) pkt;

	arp->ar_hrd = htons(ARP_ETHER);
3481c628:	e18520b0 	strh	r2, [r5, r0]

	debug_cond(DEBUG_DEV_PKT, "ARP broadcast %d\n", NetArpWaitTry);

	pkt = NetArpTxPacket;

	eth_hdr_size = NetSetEther(pkt, NetBcastAddr, PROT_ARP);
3481c62c:	e1a06000 	mov	r6, r0
	arp->ar_pro = htons(PROT_IP);
	arp->ar_hln = ARP_HLEN;
	arp->ar_pln = ARP_PLEN;
	arp->ar_op = htons(ARPOP_REQUEST);

	memcpy(&arp->ar_sha, NetOurEther, ARP_HLEN);	/* source ET addr */
3481c630:	e28d5010 	add	r5, sp, #16
	pkt += eth_hdr_size;

	arp = (struct arp_hdr *) pkt;

	arp->ar_hrd = htons(ARP_ETHER);
	arp->ar_pro = htons(PROT_IP);
3481c634:	e1c410b2 	strh	r1, [r4, #2]
	arp->ar_hln = ARP_HLEN;
	arp->ar_pln = ARP_PLEN;
	arp->ar_op = htons(ARPOP_REQUEST);
3481c638:	e1c420b6 	strh	r2, [r4, #6]

	arp = (struct arp_hdr *) pkt;

	arp->ar_hrd = htons(ARP_ETHER);
	arp->ar_pro = htons(PROT_IP);
	arp->ar_hln = ARP_HLEN;
3481c63c:	e5c4a004 	strb	sl, [r4, #4]
	arp->ar_pln = ARP_PLEN;
	arp->ar_op = htons(ARPOP_REQUEST);

	memcpy(&arp->ar_sha, NetOurEther, ARP_HLEN);	/* source ET addr */
3481c640:	e1a0200a 	mov	r2, sl
	arp = (struct arp_hdr *) pkt;

	arp->ar_hrd = htons(ARP_ETHER);
	arp->ar_pro = htons(PROT_IP);
	arp->ar_hln = ARP_HLEN;
	arp->ar_pln = ARP_PLEN;
3481c644:	e5c47005 	strb	r7, [r4, #5]
	arp->ar_op = htons(ARPOP_REQUEST);

	memcpy(&arp->ar_sha, NetOurEther, ARP_HLEN);	/* source ET addr */
3481c648:	e2840008 	add	r0, r4, #8
3481c64c:	e59f1058 	ldr	r1, [pc, #88]	; 3481c6ac <arp_raw_request+0xc8>
3481c650:	ebfff20e 	bl	34818e90 <memcpy>
3481c654:	e525b004 	str	fp, [r5, #-4]!
}

/* write IP *in network byteorder* */
static inline void NetWriteIP(void *to, IPaddr_t ip)
{
	memcpy(to, (void *)&ip, sizeof(ip));
3481c658:	e1a01005 	mov	r1, r5
3481c65c:	e1a02007 	mov	r2, r7
3481c660:	e284000e 	add	r0, r4, #14
3481c664:	ebfff209 	bl	34818e90 <memcpy>
	NetWriteIP(&arp->ar_spa, sourceIP);		/* source IP addr */
	memcpy(&arp->ar_tha, targetEther, ARP_HLEN);	/* target ET addr */
3481c668:	e59d3004 	ldr	r3, [sp, #4]
3481c66c:	e1a0200a 	mov	r2, sl
3481c670:	e1a01003 	mov	r1, r3
3481c674:	e2840012 	add	r0, r4, #18
3481c678:	ebfff204 	bl	34818e90 <memcpy>
3481c67c:	e59dc000 	ldr	ip, [sp]
3481c680:	e1a01005 	mov	r1, r5
3481c684:	e2840018 	add	r0, r4, #24
3481c688:	e1a02007 	mov	r2, r7
3481c68c:	e58dc00c 	str	ip, [sp, #12]
3481c690:	ebfff1fe 	bl	34818e90 <memcpy>
}

/* Transmit a packet */
static inline void NetSendPacket(uchar *pkt, int len)
{
	(void) eth_send(pkt, len);
3481c694:	e5990010 	ldr	r0, [r9, #16]
3481c698:	e286101c 	add	r1, r6, #28
3481c69c:	eb0003e9 	bl	3481d648 <eth_send>
	NetWriteIP(&arp->ar_tpa, targetIP);		/* target IP addr */

	NetSendPacket(NetArpTxPacket, eth_hdr_size + ARP_HDR_SIZE);
}
3481c6a0:	e8bd8eff 	pop	{r0, r1, r2, r3, r4, r5, r6, r7, r9, sl, fp, pc}
3481c6a4:	3482b358 	.word	0x3482b358
3481c6a8:	34828ba4 	.word	0x34828ba4
3481c6ac:	3482ba08 	.word	0x3482ba08

3481c6b0 <ArpRequest>:

void ArpRequest(void)
{
	if ((NetArpWaitPacketIP & NetOurSubnetMask) !=
3481c6b0:	e59f205c 	ldr	r2, [pc, #92]	; 3481c714 <ArpRequest+0x64>

	NetSendPacket(NetArpTxPacket, eth_hdr_size + ARP_HDR_SIZE);
}

void ArpRequest(void)
{
3481c6b4:	e92d4010 	push	{r4, lr}
	if ((NetArpWaitPacketIP & NetOurSubnetMask) !=
3481c6b8:	e59f4058 	ldr	r4, [pc, #88]	; 3481c718 <ArpRequest+0x68>
3481c6bc:	e5921000 	ldr	r1, [r2]
3481c6c0:	e59f2054 	ldr	r2, [pc, #84]	; 3481c71c <ArpRequest+0x6c>
3481c6c4:	e5943004 	ldr	r3, [r4, #4]
3481c6c8:	e5922000 	ldr	r2, [r2]
3481c6cc:	e0231001 	eor	r1, r3, r1
3481c6d0:	e1110002 	tst	r1, r2
3481c6d4:	0a000006 	beq	3481c6f4 <ArpRequest+0x44>
	    (NetOurIP & NetOurSubnetMask)) {
		if (NetOurGatewayIP == 0) {
3481c6d8:	e59f3040 	ldr	r3, [pc, #64]	; 3481c720 <ArpRequest+0x70>
3481c6dc:	e5933000 	ldr	r3, [r3]
3481c6e0:	e3530000 	cmp	r3, #0
3481c6e4:	1a000002 	bne	3481c6f4 <ArpRequest+0x44>
			puts("## Warning: gatewayip needed but not set\n");
3481c6e8:	e59f0034 	ldr	r0, [pc, #52]	; 3481c724 <ArpRequest+0x74>
3481c6ec:	ebffb20c 	bl	34808f24 <puts>
			NetArpWaitReplyIP = NetArpWaitPacketIP;
3481c6f0:	e5943004 	ldr	r3, [r4, #4]
		} else {
			NetArpWaitReplyIP = NetOurGatewayIP;
		}
	} else {
		NetArpWaitReplyIP = NetArpWaitPacketIP;
3481c6f4:	e5843008 	str	r3, [r4, #8]
	}

	arp_raw_request(NetOurIP, NetEtherNullAddr, NetArpWaitReplyIP);
3481c6f8:	e59f3014 	ldr	r3, [pc, #20]	; 3481c714 <ArpRequest+0x64>
3481c6fc:	e59f1024 	ldr	r1, [pc, #36]	; 3481c728 <ArpRequest+0x78>
3481c700:	e5930000 	ldr	r0, [r3]
3481c704:	e59f300c 	ldr	r3, [pc, #12]	; 3481c718 <ArpRequest+0x68>
3481c708:	e5932008 	ldr	r2, [r3, #8]
}
3481c70c:	e8bd4010 	pop	{r4, lr}
		}
	} else {
		NetArpWaitReplyIP = NetArpWaitPacketIP;
	}

	arp_raw_request(NetOurIP, NetEtherNullAddr, NetArpWaitReplyIP);
3481c710:	eaffffb3 	b	3481c5e4 <arp_raw_request>
3481c714:	3482ba04 	.word	0x3482ba04
3481c718:	3482b358 	.word	0x3482b358
3481c71c:	3482ba28 	.word	0x3482ba28
3481c720:	3482ba24 	.word	0x3482ba24
3481c724:	34827ac9 	.word	0x34827ac9
3481c728:	3482ba18 	.word	0x3482ba18

3481c72c <ArpTimeoutCheck>:
}

void ArpTimeoutCheck(void)
{
3481c72c:	e92d4010 	push	{r4, lr}
	ulong t;

	if (!NetArpWaitPacketIP)
3481c730:	e59f405c 	ldr	r4, [pc, #92]	; 3481c794 <ArpTimeoutCheck+0x68>
3481c734:	e5943004 	ldr	r3, [r4, #4]
3481c738:	e3530000 	cmp	r3, #0
3481c73c:	08bd8010 	popeq	{r4, pc}
		return;

	t = get_timer(0);
3481c740:	e3a00000 	mov	r0, #0
3481c744:	ebff92c2 	bl	34801254 <get_timer>

	/* check for arp timeout */
	if ((t - NetArpWaitTimerStart) > ARP_TIMEOUT) {
3481c748:	e5942654 	ldr	r2, [r4, #1620]	; 0x654
3481c74c:	e3013388 	movw	r3, #5000	; 0x1388
3481c750:	e0622000 	rsb	r2, r2, r0
3481c754:	e1520003 	cmp	r2, r3
3481c758:	98bd8010 	popls	{r4, pc}
		NetArpWaitTry++;
3481c75c:	e5943658 	ldr	r3, [r4, #1624]	; 0x658
3481c760:	e2833001 	add	r3, r3, #1

		if (NetArpWaitTry >= ARP_TIMEOUT_COUNT) {
3481c764:	e3530004 	cmp	r3, #4

	t = get_timer(0);

	/* check for arp timeout */
	if ((t - NetArpWaitTimerStart) > ARP_TIMEOUT) {
		NetArpWaitTry++;
3481c768:	e5843658 	str	r3, [r4, #1624]	; 0x658

		if (NetArpWaitTry >= ARP_TIMEOUT_COUNT) {
3481c76c:	da000005 	ble	3481c788 <ArpTimeoutCheck+0x5c>
			puts("\nARP Retry count exceeded; starting again\n");
3481c770:	e59f0020 	ldr	r0, [pc, #32]	; 3481c798 <ArpTimeoutCheck+0x6c>
3481c774:	ebffb1ea 	bl	34808f24 <puts>
			NetArpWaitTry = 0;
3481c778:	e3a03000 	mov	r3, #0
3481c77c:	e5843658 	str	r3, [r4, #1624]	; 0x658
		} else {
			NetArpWaitTimerStart = t;
			ArpRequest();
		}
	}
}
3481c780:	e8bd4010 	pop	{r4, lr}
		NetArpWaitTry++;

		if (NetArpWaitTry >= ARP_TIMEOUT_COUNT) {
			puts("\nARP Retry count exceeded; starting again\n");
			NetArpWaitTry = 0;
			NetStartAgain();
3481c784:	ea00048e 	b	3481d9c4 <NetStartAgain>
		} else {
			NetArpWaitTimerStart = t;
3481c788:	e5840654 	str	r0, [r4, #1620]	; 0x654
			ArpRequest();
		}
	}
}
3481c78c:	e8bd4010 	pop	{r4, lr}
			puts("\nARP Retry count exceeded; starting again\n");
			NetArpWaitTry = 0;
			NetStartAgain();
		} else {
			NetArpWaitTimerStart = t;
			ArpRequest();
3481c790:	eaffffc6 	b	3481c6b0 <ArpRequest>
3481c794:	3482b358 	.word	0x3482b358
3481c798:	34827af3 	.word	0x34827af3

3481c79c <ArpReceive>:
		}
	}
}

void ArpReceive(struct ethernet_hdr *et, struct ip_udp_hdr *ip, int len)
{
3481c79c:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	 *   the server ethernet address
	 */
	debug_cond(DEBUG_NET_PKT, "Got ARP\n");

	arp = (struct arp_hdr *)ip;
	if (len < ARP_HDR_SIZE) {
3481c7a0:	e352001b 	cmp	r2, #27
		}
	}
}

void ArpReceive(struct ethernet_hdr *et, struct ip_udp_hdr *ip, int len)
{
3481c7a4:	e24dd018 	sub	sp, sp, #24
3481c7a8:	e1a09000 	mov	r9, r0
3481c7ac:	e1a05001 	mov	r5, r1
3481c7b0:	e1a0b002 	mov	fp, r2
	 *   the server ethernet address
	 */
	debug_cond(DEBUG_NET_PKT, "Got ARP\n");

	arp = (struct arp_hdr *)ip;
	if (len < ARP_HDR_SIZE) {
3481c7b4:	ca000004 	bgt	3481c7cc <ArpReceive+0x30>
		printf("bad length %d < %d\n", len, ARP_HDR_SIZE);
3481c7b8:	e1a01002 	mov	r1, r2
3481c7bc:	e59f01c8 	ldr	r0, [pc, #456]	; 3481c98c <ArpReceive+0x1f0>
3481c7c0:	e3a0201c 	mov	r2, #28
3481c7c4:	ebffb1e0 	bl	34808f4c <printf>
		return;
3481c7c8:	ea00006d 	b	3481c984 <ArpReceive+0x1e8>
	}
	if (ntohs(arp->ar_hrd) != ARP_ETHER)
3481c7cc:	e1d130b0 	ldrh	r3, [r1]
#endif /* OPTIMIZE */


static __inline__ __attribute__((const)) __u16 __fswab16(__u16 x)
{
	return __arch__swab16(x);
3481c7d0:	e1a02423 	lsr	r2, r3, #8
3481c7d4:	e1823403 	orr	r3, r2, r3, lsl #8
3481c7d8:	e6bf3073 	sxth	r3, r3
3481c7dc:	e3530001 	cmp	r3, #1
3481c7e0:	1a000067 	bne	3481c984 <ArpReceive+0x1e8>
		return;
	if (ntohs(arp->ar_pro) != PROT_IP)
3481c7e4:	e1d130b2 	ldrh	r3, [r1, #2]
3481c7e8:	e1a02423 	lsr	r2, r3, #8
3481c7ec:	e1823403 	orr	r3, r2, r3, lsl #8
3481c7f0:	e6bf3073 	sxth	r3, r3
3481c7f4:	e3530b02 	cmp	r3, #2048	; 0x800
3481c7f8:	1a000061 	bne	3481c984 <ArpReceive+0x1e8>
		return;
	if (arp->ar_hln != ARP_HLEN)
3481c7fc:	e5d1a004 	ldrb	sl, [r1, #4]
3481c800:	e35a0006 	cmp	sl, #6
3481c804:	1a00005e 	bne	3481c984 <ArpReceive+0x1e8>
		return;
	if (arp->ar_pln != ARP_PLEN)
3481c808:	e5d16005 	ldrb	r6, [r1, #5]
3481c80c:	e3560004 	cmp	r6, #4
3481c810:	1a00005b 	bne	3481c984 <ArpReceive+0x1e8>
		return;

	if (NetOurIP == 0)
3481c814:	e59f7174 	ldr	r7, [pc, #372]	; 3481c990 <ArpReceive+0x1f4>
3481c818:	e5973000 	ldr	r3, [r7]
3481c81c:	e3530000 	cmp	r3, #0
3481c820:	0a000057 	beq	3481c984 <ArpReceive+0x1e8>
		return;

	if (NetReadIP(&arp->ar_tpa) != NetOurIP)
3481c824:	e2813018 	add	r3, r1, #24
/* return IP *in network byteorder* */
static inline IPaddr_t NetReadIP(void *from)
{
	IPaddr_t ip;

	memcpy((void *)&ip, (void *)from, sizeof(ip));
3481c828:	e1a02006 	mov	r2, r6
3481c82c:	e2814008 	add	r4, r1, #8
3481c830:	e28d0014 	add	r0, sp, #20
3481c834:	e1a01003 	mov	r1, r3
3481c838:	e58d300c 	str	r3, [sp, #12]
3481c83c:	ebfff193 	bl	34818e90 <memcpy>
3481c840:	e5973000 	ldr	r3, [r7]
3481c844:	e59d2014 	ldr	r2, [sp, #20]
3481c848:	e1520003 	cmp	r2, r3
3481c84c:	1a00004c 	bne	3481c984 <ArpReceive+0x1e8>
		return;

	switch (ntohs(arp->ar_op)) {
3481c850:	e1d530b6 	ldrh	r3, [r5, #6]
3481c854:	e1a02423 	lsr	r2, r3, #8
3481c858:	e1823403 	orr	r3, r2, r3, lsl #8
3481c85c:	e6ff3073 	uxth	r3, r3
3481c860:	e3530001 	cmp	r3, #1
3481c864:	0a000002 	beq	3481c874 <ArpReceive+0xd8>
3481c868:	e3530002 	cmp	r3, #2
3481c86c:	1a000044 	bne	3481c984 <ArpReceive+0x1e8>
3481c870:	ea00001b 	b	3481c8e4 <ArpReceive+0x148>
	case ARPOP_REQUEST:
		/* reply with our IP address */
		debug_cond(DEBUG_DEV_PKT, "Got ARP REQUEST, return our IP\n");
		pkt = (uchar *)et;
		eth_hdr_size = net_update_ether(et, et->et_src, PROT_ARP);
3481c874:	e2891006 	add	r1, r9, #6
3481c878:	e1a00009 	mov	r0, r9
3481c87c:	e3002806 	movw	r2, #2054	; 0x806
3481c880:	eb000588 	bl	3481dea8 <net_update_ether>
		pkt += eth_hdr_size;
		arp->ar_op = htons(ARPOP_REPLY);
3481c884:	e3a03c02 	mov	r3, #512	; 0x200
3481c888:	e1c530b6 	strh	r3, [r5, #6]
	switch (ntohs(arp->ar_op)) {
	case ARPOP_REQUEST:
		/* reply with our IP address */
		debug_cond(DEBUG_DEV_PKT, "Got ARP REQUEST, return our IP\n");
		pkt = (uchar *)et;
		eth_hdr_size = net_update_ether(et, et->et_src, PROT_ARP);
3481c88c:	e1a0b000 	mov	fp, r0
		pkt += eth_hdr_size;
		arp->ar_op = htons(ARPOP_REPLY);
		memcpy(&arp->ar_tha, &arp->ar_sha, ARP_HLEN);
3481c890:	e1a01004 	mov	r1, r4
3481c894:	e1a0200a 	mov	r2, sl
3481c898:	e2850012 	add	r0, r5, #18
		NetCopyIP(&arp->ar_tpa, &arp->ar_spa);
3481c89c:	e285500e 	add	r5, r5, #14
		debug_cond(DEBUG_DEV_PKT, "Got ARP REQUEST, return our IP\n");
		pkt = (uchar *)et;
		eth_hdr_size = net_update_ether(et, et->et_src, PROT_ARP);
		pkt += eth_hdr_size;
		arp->ar_op = htons(ARPOP_REPLY);
		memcpy(&arp->ar_tha, &arp->ar_sha, ARP_HLEN);
3481c8a0:	ebfff17a 	bl	34818e90 <memcpy>
}

/* copy IP */
static inline void NetCopyIP(void *to, void *from)
{
	memcpy((void *)to, from, sizeof(IPaddr_t));
3481c8a4:	e1a01005 	mov	r1, r5
3481c8a8:	e1a02006 	mov	r2, r6
3481c8ac:	e59d000c 	ldr	r0, [sp, #12]
3481c8b0:	ebfff176 	bl	34818e90 <memcpy>
		NetCopyIP(&arp->ar_tpa, &arp->ar_spa);
		memcpy(&arp->ar_sha, NetOurEther, ARP_HLEN);
3481c8b4:	e1a0200a 	mov	r2, sl
3481c8b8:	e1a00004 	mov	r0, r4
3481c8bc:	e59f10d0 	ldr	r1, [pc, #208]	; 3481c994 <ArpReceive+0x1f8>
3481c8c0:	ebfff172 	bl	34818e90 <memcpy>
3481c8c4:	e1a01007 	mov	r1, r7
3481c8c8:	e1a00005 	mov	r0, r5
3481c8cc:	e1a02006 	mov	r2, r6
3481c8d0:	ebfff16e 	bl	34818e90 <memcpy>
}

/* Transmit a packet */
static inline void NetSendPacket(uchar *pkt, int len)
{
	(void) eth_send(pkt, len);
3481c8d4:	e1a00009 	mov	r0, r9
3481c8d8:	e28b101c 	add	r1, fp, #28
3481c8dc:	eb000359 	bl	3481d648 <eth_send>
3481c8e0:	ea000027 	b	3481c984 <ArpReceive+0x1e8>
		NetSendPacket((uchar *)et, eth_hdr_size + ARP_HDR_SIZE);
		return;

	case ARPOP_REPLY:		/* arp reply */
		/* are we waiting for a reply */
		if (!NetArpWaitPacketIP)
3481c8e4:	e59f30ac 	ldr	r3, [pc, #172]	; 3481c998 <ArpReceive+0x1fc>
3481c8e8:	e5933004 	ldr	r3, [r3, #4]
3481c8ec:	e3530000 	cmp	r3, #0
3481c8f0:	0a000023 	beq	3481c984 <ArpReceive+0x1e8>
/* return IP *in network byteorder* */
static inline IPaddr_t NetReadIP(void *from)
{
	IPaddr_t ip;

	memcpy((void *)&ip, (void *)from, sizeof(ip));
3481c8f4:	e3a02004 	mov	r2, #4
3481c8f8:	e28d0014 	add	r0, sp, #20
3481c8fc:	e2841006 	add	r1, r4, #6
3481c900:	ebfff162 	bl	34818e90 <memcpy>
#endif

		reply_ip_addr = NetReadIP(&arp->ar_spa);

		/* matched waiting packet's address */
		if (reply_ip_addr == NetArpWaitReplyIP) {
3481c904:	e59f308c 	ldr	r3, [pc, #140]	; 3481c998 <ArpReceive+0x1fc>
	return ip;
3481c908:	e59d6014 	ldr	r6, [sp, #20]
3481c90c:	e5932008 	ldr	r2, [r3, #8]
3481c910:	e1560002 	cmp	r6, r2
3481c914:	1a00001a 	bne	3481c984 <ArpReceive+0x1e8>
			debug_cond(DEBUG_DEV_PKT,
				"Got ARP REPLY, set eth addr (%pM)\n",
				arp->ar_data);

			/* save address for later use */
			if (NetArpWaitPacketMAC != NULL)
3481c918:	e5930000 	ldr	r0, [r3]
3481c91c:	e3500000 	cmp	r0, #0
3481c920:	0a000002 	beq	3481c930 <ArpReceive+0x194>
				memcpy(NetArpWaitPacketMAC,
3481c924:	e1a01004 	mov	r1, r4
3481c928:	e3a02006 	mov	r2, #6
3481c92c:	ebfff157 	bl	34818e90 <memcpy>
				       &arp->ar_sha, ARP_HLEN);

			net_get_arp_handler()((uchar *)arp, 0, reply_ip_addr,
3481c930:	eb000408 	bl	3481d958 <net_get_arp_handler>
3481c934:	e3a01000 	mov	r1, #0
3481c938:	e1a03001 	mov	r3, r1
3481c93c:	e1a0c000 	mov	ip, r0
3481c940:	e1a02006 	mov	r2, r6
3481c944:	e1a00005 	mov	r0, r5
3481c948:	e58db000 	str	fp, [sp]
				0, len);

			/* set the mac address in the waiting packet's header
			   and transmit it */
			memcpy(((struct ethernet_hdr *)NetTxPacket)->et_dest,
3481c94c:	e59f5048 	ldr	r5, [pc, #72]	; 3481c99c <ArpReceive+0x200>
			/* save address for later use */
			if (NetArpWaitPacketMAC != NULL)
				memcpy(NetArpWaitPacketMAC,
				       &arp->ar_sha, ARP_HLEN);

			net_get_arp_handler()((uchar *)arp, 0, reply_ip_addr,
3481c950:	e12fff3c 	blx	ip
				0, len);

			/* set the mac address in the waiting packet's header
			   and transmit it */
			memcpy(((struct ethernet_hdr *)NetTxPacket)->et_dest,
3481c954:	e1a01004 	mov	r1, r4
}

/* Transmit a packet */
static inline void NetSendPacket(uchar *pkt, int len)
{
	(void) eth_send(pkt, len);
3481c958:	e59f4038 	ldr	r4, [pc, #56]	; 3481c998 <ArpReceive+0x1fc>
3481c95c:	e3a02006 	mov	r2, #6
3481c960:	e5950000 	ldr	r0, [r5]
3481c964:	ebfff149 	bl	34818e90 <memcpy>
3481c968:	e5950000 	ldr	r0, [r5]
3481c96c:	e594100c 	ldr	r1, [r4, #12]
3481c970:	eb000334 	bl	3481d648 <eth_send>
				&arp->ar_sha, ARP_HLEN);
			NetSendPacket(NetTxPacket, NetArpWaitTxPacketSize);

			/* no arp request pending now */
			NetArpWaitPacketIP = 0;
3481c974:	e3a03000 	mov	r3, #0
3481c978:	e5843004 	str	r3, [r4, #4]
			NetArpWaitTxPacketSize = 0;
3481c97c:	e584300c 	str	r3, [r4, #12]
			NetArpWaitPacketMAC = NULL;
3481c980:	e5843000 	str	r3, [r4]
	default:
		debug("Unexpected ARP opcode 0x%x\n",
		      ntohs(arp->ar_op));
		return;
	}
}
3481c984:	e28dd018 	add	sp, sp, #24
3481c988:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
3481c98c:	34827b1e 	.word	0x34827b1e
3481c990:	3482ba04 	.word	0x3482ba04
3481c994:	3482ba08 	.word	0x3482ba08
3481c998:	3482b358 	.word	0x3482b358
3481c99c:	3482ba14 	.word	0x3482ba14

3481c9a0 <__fswab32>:
}

static __inline__ __attribute__((const)) __u32 __fswab32(__u32 x)
{
	return __arch__swab32(x);
}
3481c9a0:	e6bf0f30 	rev	r0, r0
3481c9a4:	e12fff1e 	bx	lr

3481c9a8 <NetCopyIP>:
}

/* copy IP */
static inline void NetCopyIP(void *to, void *from)
{
	memcpy((void *)to, from, sizeof(IPaddr_t));
3481c9a8:	e3a02004 	mov	r2, #4
3481c9ac:	eafff137 	b	34818e90 <memcpy>

3481c9b0 <BootpHandler>:
 *	Handle a BOOTP received packet.
 */
static void
BootpHandler(uchar *pkt, unsigned dest, IPaddr_t sip, unsigned src,
	     unsigned len)
{
3481c9b0:	e92d4ef3 	push	{r0, r1, r4, r5, r6, r7, r9, sl, fp, lr}
static int BootpCheckPkt(uchar *pkt, unsigned dest, unsigned src, unsigned len)
{
	struct Bootp_t *bp = (struct Bootp_t *) pkt;
	int retval = 0;

	if (dest != PORT_BOOTPC || src != PORT_BOOTPS)
3481c9b4:	e3510044 	cmp	r1, #68	; 0x44
3481c9b8:	03530043 	cmpeq	r3, #67	; 0x43
 *	Handle a BOOTP received packet.
 */
static void
BootpHandler(uchar *pkt, unsigned dest, IPaddr_t sip, unsigned src,
	     unsigned len)
{
3481c9bc:	e1a04000 	mov	r4, r0
3481c9c0:	e59d9028 	ldr	r9, [sp, #40]	; 0x28
static int BootpCheckPkt(uchar *pkt, unsigned dest, unsigned src, unsigned len)
{
	struct Bootp_t *bp = (struct Bootp_t *) pkt;
	int retval = 0;

	if (dest != PORT_BOOTPC || src != PORT_BOOTPS)
3481c9c4:	1a0000c0 	bne	3481cccc <BootpHandler+0x31c>
		retval = -1;
	else if (len < sizeof(struct Bootp_t) - OPT_FIELD_SIZE)
3481c9c8:	e35900eb 	cmp	r9, #235	; 0xeb
3481c9cc:	9a0000be 	bls	3481cccc <BootpHandler+0x31c>
		retval = -2;
	else if (bp->bp_op != OP_BOOTREQUEST &&
3481c9d0:	e5d03000 	ldrb	r3, [r0]
			bp->bp_op != OP_BOOTREPLY &&
			bp->bp_op != DHCP_OFFER &&
3481c9d4:	e2432001 	sub	r2, r3, #1
3481c9d8:	e6ef2072 	uxtb	r2, r2

	if (dest != PORT_BOOTPC || src != PORT_BOOTPS)
		retval = -1;
	else if (len < sizeof(struct Bootp_t) - OPT_FIELD_SIZE)
		retval = -2;
	else if (bp->bp_op != OP_BOOTREQUEST &&
3481c9dc:	e3530005 	cmp	r3, #5
3481c9e0:	13520001 	cmpne	r2, #1
3481c9e4:	9a000001 	bls	3481c9f0 <BootpHandler+0x40>
			bp->bp_op != OP_BOOTREPLY &&
			bp->bp_op != DHCP_OFFER &&
			bp->bp_op != DHCP_ACK &&
3481c9e8:	e3530006 	cmp	r3, #6
3481c9ec:	1a0000b6 	bne	3481cccc <BootpHandler+0x31c>
			bp->bp_op != DHCP_NAK)
		retval = -3;
	else if (bp->bp_htype != HWT_ETHER)
3481c9f0:	e5d43001 	ldrb	r3, [r4, #1]
3481c9f4:	e3530001 	cmp	r3, #1
3481c9f8:	1a0000b3 	bne	3481cccc <BootpHandler+0x31c>
		retval = -4;
	else if (bp->bp_hlen != HWL_ETHER)
3481c9fc:	e5d43002 	ldrb	r3, [r4, #2]
3481ca00:	e3530006 	cmp	r3, #6
3481ca04:	1a0000b0 	bne	3481cccc <BootpHandler+0x31c>
/* return ulong *in network byteorder* */
static inline ulong NetReadLong(ulong *from)
{
	ulong l;

	memcpy((void *)&l, (void *)from, sizeof(l));
3481ca08:	e3a02004 	mov	r2, #4
3481ca0c:	e1a0000d 	mov	r0, sp
3481ca10:	e2841004 	add	r1, r4, #4
3481ca14:	ebfff11d 	bl	34818e90 <memcpy>
		retval = -5;
	else if (NetReadLong((ulong *)&bp->bp_id) != BootpID)
3481ca18:	e59f32b0 	ldr	r3, [pc, #688]	; 3481ccd0 <BootpHandler+0x320>
3481ca1c:	e59d2000 	ldr	r2, [sp]
3481ca20:	e5933000 	ldr	r3, [r3]
3481ca24:	e1520003 	cmp	r2, r3
3481ca28:	1a0000a7 	bne	3481cccc <BootpHandler+0x31c>
3481ca2c:	ea00009e 	b	3481ccac <BootpHandler+0x2fc>
#if !defined(CONFIG_BOOTP_SERVERIP)
	IPaddr_t tmp_ip;

	NetCopyIP(&tmp_ip, &bp->bp_siaddr);
	if (tmp_ip != 0)
		NetCopyIP(&NetServerIP, &bp->bp_siaddr);
3481ca30:	e59f029c 	ldr	r0, [pc, #668]	; 3481ccd4 <BootpHandler+0x324>
3481ca34:	e1a01005 	mov	r1, r5
3481ca38:	ebffffda 	bl	3481c9a8 <NetCopyIP>
	memcpy(NetServerEther, ((struct ethernet_hdr *)NetRxPacket)->et_src, 6);
3481ca3c:	e59f3294 	ldr	r3, [pc, #660]	; 3481ccd8 <BootpHandler+0x328>
3481ca40:	e3a02006 	mov	r2, #6
3481ca44:	e5931000 	ldr	r1, [r3]
3481ca48:	e59f028c 	ldr	r0, [pc, #652]	; 3481ccdc <BootpHandler+0x32c>
3481ca4c:	e2811006 	add	r1, r1, #6
3481ca50:	ebfff10e 	bl	34818e90 <memcpy>
#endif
	NetCopyIP(&NetOurIP, &bp->bp_yiaddr);
	if (strlen(bp->bp_file) > 0)
3481ca54:	e284506c 	add	r5, r4, #108	; 0x6c
	NetCopyIP(&tmp_ip, &bp->bp_siaddr);
	if (tmp_ip != 0)
		NetCopyIP(&NetServerIP, &bp->bp_siaddr);
	memcpy(NetServerEther, ((struct ethernet_hdr *)NetRxPacket)->et_src, 6);
#endif
	NetCopyIP(&NetOurIP, &bp->bp_yiaddr);
3481ca58:	e59f0280 	ldr	r0, [pc, #640]	; 3481cce0 <BootpHandler+0x330>
3481ca5c:	e2841010 	add	r1, r4, #16
3481ca60:	ebffffd0 	bl	3481c9a8 <NetCopyIP>
	if (strlen(bp->bp_file) > 0)
3481ca64:	e1a00005 	mov	r0, r5
3481ca68:	ebfff044 	bl	34818b80 <strlen>
3481ca6c:	e3500000 	cmp	r0, #0
3481ca70:	0a000003 	beq	3481ca84 <BootpHandler+0xd4>
		copy_filename(BootFile, bp->bp_file, sizeof(BootFile));
3481ca74:	e59f0268 	ldr	r0, [pc, #616]	; 3481cce4 <BootpHandler+0x334>
3481ca78:	e1a01005 	mov	r1, r5
3481ca7c:	e3a02080 	mov	r2, #128	; 0x80
3481ca80:	eb0005b6 	bl	3481e160 <copy_filename>

	/* Propagate to environment:
	 * don't delete exising entry when BOOTP / DHCP reply does
	 * not contain a new value
	 */
	if (*BootFile)
3481ca84:	e59f1258 	ldr	r1, [pc, #600]	; 3481cce4 <BootpHandler+0x334>
3481ca88:	e5d13000 	ldrb	r3, [r1]
3481ca8c:	e3530000 	cmp	r3, #0
3481ca90:	0a000001 	beq	3481ca9c <BootpHandler+0xec>
		setenv("bootfile", BootFile);
3481ca94:	e59f024c 	ldr	r0, [pc, #588]	; 3481cce8 <BootpHandler+0x338>
3481ca98:	ebffacdf 	bl	34807e1c <setenv>
3481ca9c:	e3a02004 	mov	r2, #4
3481caa0:	e1a0000d 	mov	r0, sp
3481caa4:	e28410ec 	add	r1, r4, #236	; 0xec
3481caa8:	ebfff0f8 	bl	34818e90 <memcpy>
#endif

	BootpCopyNetParams(bp);		/* Store net parameters from reply */

	/* Retrieve extended information (we must parse the vendor area) */
	if (NetReadLong((ulong *)&bp->bp_vend[0]) == htonl(BOOTP_VENDOR_MAGIC))
3481caac:	e59d2000 	ldr	r2, [sp]
3481cab0:	e59f3234 	ldr	r3, [pc, #564]	; 3481ccec <BootpHandler+0x33c>
3481cab4:	e1520003 	cmp	r2, r3
3481cab8:	1a000076 	bne	3481cc98 <BootpHandler+0x2e8>
		BootpVendorProcess((uchar *)&bp->bp_vend[4], len);
3481cabc:	e28440f0 	add	r4, r4, #240	; 0xf0
	}
}

static void BootpVendorProcess(u8 *ext, int size)
{
	u8 *end = ext + size;
3481cac0:	e0849009 	add	r9, r4, r9
	int size = *(ext + 1);

	debug("[BOOTP] Processing extension %d... (%d bytes)\n", *ext,
		*(ext + 1));

	NetBootFileSize = 0;
3481cac4:	e59f5224 	ldr	r5, [pc, #548]	; 3481ccf0 <BootpHandler+0x340>
	case 10:		/* Impress server - Not yet supported */
		break;
	case 11:		/* RPL server - Not yet supported */
		break;
	case 12:		/* Host name */
		if (NetOurHostName[0] == 0) {
3481cac8:	e59fb224 	ldr	fp, [pc, #548]	; 3481ccf4 <BootpHandler+0x344>
			size = truncate_sz("Host Name",
				sizeof(NetOurHostName), size);
			memcpy(&NetOurHostName, ext + 2, size);
			NetOurHostName[size] = 0;
3481cacc:	e3a07000 	mov	r7, #0
3481cad0:	ea00006b 	b	3481cc84 <BootpHandler+0x2d4>
	u8 *end = ext + size;

	debug("[BOOTP] Checking extension (%d bytes)...\n", size);

	while ((ext < end) && (*ext != 0xff)) {
		if (*ext == 0) {
3481cad4:	e3530000 	cmp	r3, #0
			ext++;
3481cad8:	0284a001 	addeq	sl, r4, #1
	u8 *end = ext + size;

	debug("[BOOTP] Checking extension (%d bytes)...\n", size);

	while ((ext < end) && (*ext != 0xff)) {
		if (*ext == 0) {
3481cadc:	0a000067 	beq	3481cc80 <BootpHandler+0x2d0>
			ext++;
		} else {
			u8 *opt = ext;

			ext += ext[1] + 2;
3481cae0:	e5d42001 	ldrb	r2, [r4, #1]
3481cae4:	e282a002 	add	sl, r2, #2
3481cae8:	e084a00a 	add	sl, r4, sl
			if (ext <= end)
3481caec:	e15a0009 	cmp	sl, r9
3481caf0:	8a000062 	bhi	3481cc80 <BootpHandler+0x2d0>
	int size = *(ext + 1);

	debug("[BOOTP] Processing extension %d... (%d bytes)\n", *ext,
		*(ext + 1));

	NetBootFileSize = 0;
3481caf4:	e3a01000 	mov	r1, #0
3481caf8:	e1c510b0 	strh	r1, [r5]

	switch (*ext) {
3481cafc:	e5d43000 	ldrb	r3, [r4]

#if !defined(CONFIG_CMD_DHCP)

static void BootpVendorFieldProcess(u8 *ext)
{
	int size = *(ext + 1);
3481cb00:	e1a06002 	mov	r6, r2
	debug("[BOOTP] Processing extension %d... (%d bytes)\n", *ext,
		*(ext + 1));

	NetBootFileSize = 0;

	switch (*ext) {
3481cb04:	e353000c 	cmp	r3, #12
3481cb08:	0a00001e 	beq	3481cb88 <BootpHandler+0x1d8>
3481cb0c:	8a000006 	bhi	3481cb2c <BootpHandler+0x17c>
3481cb10:	e3530003 	cmp	r3, #3
3481cb14:	0a00000d 	beq	3481cb50 <BootpHandler+0x1a0>
3481cb18:	e3530006 	cmp	r3, #6
3481cb1c:	0a000011 	beq	3481cb68 <BootpHandler+0x1b8>
3481cb20:	e3530001 	cmp	r3, #1
3481cb24:	1a000055 	bne	3481cc80 <BootpHandler+0x2d0>
3481cb28:	ea000006 	b	3481cb48 <BootpHandler+0x198>
3481cb2c:	e3530011 	cmp	r3, #17
3481cb30:	0a000030 	beq	3481cbf8 <BootpHandler+0x248>
3481cb34:	e3530028 	cmp	r3, #40	; 0x28
3481cb38:	0a00003f 	beq	3481cc3c <BootpHandler+0x28c>
3481cb3c:	e353000d 	cmp	r3, #13
3481cb40:	1a00004e 	bne	3481cc80 <BootpHandler+0x2d0>
3481cb44:	ea00001f 	b	3481cbc8 <BootpHandler+0x218>
		/* Fixed length fields */
	case 1:			/* Subnet mask */
		if (NetOurSubnetMask == 0)
3481cb48:	e59f21a8 	ldr	r2, [pc, #424]	; 3481ccf8 <BootpHandler+0x348>
3481cb4c:	ea000006 	b	3481cb6c <BootpHandler+0x1bc>
		break;
	case 2:			/* Time offset - Not yet supported */
		break;
		/* Variable length fields */
	case 3:			/* Gateways list */
		if (NetOurGatewayIP == 0)
3481cb50:	e59f11a4 	ldr	r1, [pc, #420]	; 3481ccfc <BootpHandler+0x34c>
3481cb54:	e5913000 	ldr	r3, [r1]
3481cb58:	e3530000 	cmp	r3, #0
			NetCopyIP(&NetOurGatewayIP, (IPaddr_t *) (ext + 2));
3481cb5c:	01a00001 	moveq	r0, r1
		break;
	case 2:			/* Time offset - Not yet supported */
		break;
		/* Variable length fields */
	case 3:			/* Gateways list */
		if (NetOurGatewayIP == 0)
3481cb60:	1a000046 	bne	3481cc80 <BootpHandler+0x2d0>
3481cb64:	ea000004 	b	3481cb7c <BootpHandler+0x1cc>
	case 4:			/* Time server - Not yet supported */
		break;
	case 5:			/* IEN-116 name server - Not yet supported */
		break;
	case 6:
		if (NetOurDNSIP == 0)
3481cb68:	e59f2190 	ldr	r2, [pc, #400]	; 3481cd00 <BootpHandler+0x350>
3481cb6c:	e5923000 	ldr	r3, [r2]
3481cb70:	e3530000 	cmp	r3, #0
3481cb74:	1a000041 	bne	3481cc80 <BootpHandler+0x2d0>
			NetCopyIP(&NetOurDNSIP, (IPaddr_t *) (ext + 2));
3481cb78:	e1a00002 	mov	r0, r2
3481cb7c:	e2841002 	add	r1, r4, #2
3481cb80:	ebffff88 	bl	3481c9a8 <NetCopyIP>
3481cb84:	ea00003d 	b	3481cc80 <BootpHandler+0x2d0>
	case 10:		/* Impress server - Not yet supported */
		break;
	case 11:		/* RPL server - Not yet supported */
		break;
	case 12:		/* Host name */
		if (NetOurHostName[0] == 0) {
3481cb88:	e5db3000 	ldrb	r3, [fp]
3481cb8c:	e3530000 	cmp	r3, #0
3481cb90:	1a00003a 	bne	3481cc80 <BootpHandler+0x2d0>
		setenv("bootfile", BootFile);
}

static int truncate_sz(const char *name, int maxlen, int curlen)
{
	if (curlen >= maxlen) {
3481cb94:	e352001f 	cmp	r2, #31
3481cb98:	da000004 	ble	3481cbb0 <BootpHandler+0x200>
		printf("*** WARNING: %s is too long (%d - max: %d)"
3481cb9c:	e59f0160 	ldr	r0, [pc, #352]	; 3481cd04 <BootpHandler+0x354>
3481cba0:	e59f1160 	ldr	r1, [pc, #352]	; 3481cd08 <BootpHandler+0x358>
3481cba4:	e2833020 	add	r3, r3, #32
3481cba8:	ebffb0e7 	bl	34808f4c <printf>
			" - truncated\n", name, curlen, maxlen);
		curlen = maxlen - 1;
3481cbac:	e3a0601f 	mov	r6, #31
		break;
	case 12:		/* Host name */
		if (NetOurHostName[0] == 0) {
			size = truncate_sz("Host Name",
				sizeof(NetOurHostName), size);
			memcpy(&NetOurHostName, ext + 2, size);
3481cbb0:	e59f013c 	ldr	r0, [pc, #316]	; 3481ccf4 <BootpHandler+0x344>
3481cbb4:	e2841002 	add	r1, r4, #2
3481cbb8:	e1a02006 	mov	r2, r6
3481cbbc:	ebfff0b3 	bl	34818e90 <memcpy>
			NetOurHostName[size] = 0;
3481cbc0:	e7cb7006 	strb	r7, [fp, r6]
3481cbc4:	ea00002d 	b	3481cc80 <BootpHandler+0x2d0>
		}
		break;
	case 13:		/* Boot file size */
		if (size == 2)
3481cbc8:	e3520002 	cmp	r2, #2
			NetBootFileSize = ntohs(*(ushort *) (ext + 2));
3481cbcc:	01d430b2 	ldrheq	r3, [r4, #2]
#endif /* OPTIMIZE */


static __inline__ __attribute__((const)) __u16 __fswab16(__u16 x)
{
	return __arch__swab16(x);
3481cbd0:	01a02423 	lsreq	r2, r3, #8
3481cbd4:	01823403 	orreq	r3, r2, r3, lsl #8
3481cbd8:	01c530b0 	strheq	r3, [r5]
3481cbdc:	0a000027 	beq	3481cc80 <BootpHandler+0x2d0>
		else if (size == 4)
3481cbe0:	e3520004 	cmp	r2, #4
3481cbe4:	1a000025 	bne	3481cc80 <BootpHandler+0x2d0>
			NetBootFileSize = ntohl(*(ulong *) (ext + 2));
3481cbe8:	e5940002 	ldr	r0, [r4, #2]
3481cbec:	ebffff6b 	bl	3481c9a0 <__fswab32>
3481cbf0:	e1c500b0 	strh	r0, [r5]
3481cbf4:	ea000021 	b	3481cc80 <BootpHandler+0x2d0>
	case 15:		/* Domain name - Not yet supported */
		break;
	case 16:		/* Swap server - Not yet supported */
		break;
	case 17:		/* Root path */
		if (NetOurRootPath[0] == 0) {
3481cbf8:	e59f110c 	ldr	r1, [pc, #268]	; 3481cd0c <BootpHandler+0x35c>
3481cbfc:	e5d13000 	ldrb	r3, [r1]
3481cc00:	e3530000 	cmp	r3, #0
3481cc04:	1a00001d 	bne	3481cc80 <BootpHandler+0x2d0>
		setenv("bootfile", BootFile);
}

static int truncate_sz(const char *name, int maxlen, int curlen)
{
	if (curlen >= maxlen) {
3481cc08:	e352003f 	cmp	r2, #63	; 0x3f
3481cc0c:	da000004 	ble	3481cc24 <BootpHandler+0x274>
		printf("*** WARNING: %s is too long (%d - max: %d)"
3481cc10:	e59f00ec 	ldr	r0, [pc, #236]	; 3481cd04 <BootpHandler+0x354>
3481cc14:	e59f10f4 	ldr	r1, [pc, #244]	; 3481cd10 <BootpHandler+0x360>
3481cc18:	e2833040 	add	r3, r3, #64	; 0x40
3481cc1c:	ebffb0ca 	bl	34808f4c <printf>
			" - truncated\n", name, curlen, maxlen);
		curlen = maxlen - 1;
3481cc20:	e3a0603f 	mov	r6, #63	; 0x3f
		break;
	case 17:		/* Root path */
		if (NetOurRootPath[0] == 0) {
			size = truncate_sz("Root Path",
				sizeof(NetOurRootPath), size);
			memcpy(&NetOurRootPath, ext + 2, size);
3481cc24:	e1a02006 	mov	r2, r6
3481cc28:	e59f00dc 	ldr	r0, [pc, #220]	; 3481cd0c <BootpHandler+0x35c>
3481cc2c:	e2841002 	add	r1, r4, #2
3481cc30:	ebfff096 	bl	34818e90 <memcpy>
			NetOurRootPath[size] = 0;
3481cc34:	e59f20d0 	ldr	r2, [pc, #208]	; 3481cd0c <BootpHandler+0x35c>
3481cc38:	ea00000f 	b	3481cc7c <BootpHandler+0x2cc>
		 * access via TFTP.
		 */
		break;
		/* IP host layer fields */
	case 40:		/* NIS Domain name */
		if (NetOurNISDomain[0] == 0) {
3481cc3c:	e59f10d0 	ldr	r1, [pc, #208]	; 3481cd14 <BootpHandler+0x364>
3481cc40:	e5d13000 	ldrb	r3, [r1]
3481cc44:	e3530000 	cmp	r3, #0
3481cc48:	1a00000c 	bne	3481cc80 <BootpHandler+0x2d0>
		setenv("bootfile", BootFile);
}

static int truncate_sz(const char *name, int maxlen, int curlen)
{
	if (curlen >= maxlen) {
3481cc4c:	e352001f 	cmp	r2, #31
3481cc50:	da000004 	ble	3481cc68 <BootpHandler+0x2b8>
		printf("*** WARNING: %s is too long (%d - max: %d)"
3481cc54:	e59f00a8 	ldr	r0, [pc, #168]	; 3481cd04 <BootpHandler+0x354>
3481cc58:	e59f10b8 	ldr	r1, [pc, #184]	; 3481cd18 <BootpHandler+0x368>
3481cc5c:	e2833020 	add	r3, r3, #32
3481cc60:	ebffb0b9 	bl	34808f4c <printf>
			" - truncated\n", name, curlen, maxlen);
		curlen = maxlen - 1;
3481cc64:	e3a0601f 	mov	r6, #31
		/* IP host layer fields */
	case 40:		/* NIS Domain name */
		if (NetOurNISDomain[0] == 0) {
			size = truncate_sz("NIS Domain Name",
				sizeof(NetOurNISDomain), size);
			memcpy(&NetOurNISDomain, ext + 2, size);
3481cc68:	e1a02006 	mov	r2, r6
3481cc6c:	e59f00a0 	ldr	r0, [pc, #160]	; 3481cd14 <BootpHandler+0x364>
3481cc70:	e2841002 	add	r1, r4, #2
3481cc74:	ebfff085 	bl	34818e90 <memcpy>
			NetOurNISDomain[size] = 0;
3481cc78:	e59f2094 	ldr	r2, [pc, #148]	; 3481cd14 <BootpHandler+0x364>
3481cc7c:	e7c27006 	strb	r7, [r2, r6]
static int truncate_sz(const char *name, int maxlen, int curlen)
{
	if (curlen >= maxlen) {
		printf("*** WARNING: %s is too long (%d - max: %d)"
			" - truncated\n", name, curlen, maxlen);
		curlen = maxlen - 1;
3481cc80:	e1a0400a 	mov	r4, sl
{
	u8 *end = ext + size;

	debug("[BOOTP] Checking extension (%d bytes)...\n", size);

	while ((ext < end) && (*ext != 0xff)) {
3481cc84:	e1540009 	cmp	r4, r9
3481cc88:	2a000002 	bcs	3481cc98 <BootpHandler+0x2e8>
3481cc8c:	e5d43000 	ldrb	r3, [r4]
3481cc90:	e35300ff 	cmp	r3, #255	; 0xff
3481cc94:	1affff8e 	bne	3481cad4 <BootpHandler+0x124>

	/* Retrieve extended information (we must parse the vendor area) */
	if (NetReadLong((ulong *)&bp->bp_vend[0]) == htonl(BOOTP_VENDOR_MAGIC))
		BootpVendorProcess((uchar *)&bp->bp_vend[4], len);

	NetSetTimeout(0, (thand_f *)0);
3481cc98:	e3a00000 	mov	r0, #0
3481cc9c:	e1a01000 	mov	r1, r0
3481cca0:	eb000338 	bl	3481d988 <NetSetTimeout>
	bootstage_mark_name(BOOTSTAGE_ID_BOOTP_STOP, "bootp_stop");

	debug("Got good BOOTP\n");

	net_auto_load();
3481cca4:	eb000307 	bl	3481d8c8 <net_auto_load>
3481cca8:	ea000007 	b	3481cccc <BootpHandler+0x31c>
static void BootpCopyNetParams(struct Bootp_t *bp)
{
#if !defined(CONFIG_BOOTP_SERVERIP)
	IPaddr_t tmp_ip;

	NetCopyIP(&tmp_ip, &bp->bp_siaddr);
3481ccac:	e2845014 	add	r5, r4, #20
3481ccb0:	e28d0004 	add	r0, sp, #4
3481ccb4:	e1a01005 	mov	r1, r5
3481ccb8:	ebffff3a 	bl	3481c9a8 <NetCopyIP>
	if (tmp_ip != 0)
3481ccbc:	e59d3004 	ldr	r3, [sp, #4]
3481ccc0:	e3530000 	cmp	r3, #0
3481ccc4:	0affff5c 	beq	3481ca3c <BootpHandler+0x8c>
3481ccc8:	eaffff58 	b	3481ca30 <BootpHandler+0x80>
	bootstage_mark_name(BOOTSTAGE_ID_BOOTP_STOP, "bootp_stop");

	debug("Got good BOOTP\n");

	net_auto_load();
}
3481cccc:	e8bd8efc 	pop	{r2, r3, r4, r5, r6, r7, r9, sl, fp, pc}
3481ccd0:	3482b9b4 	.word	0x3482b9b4
3481ccd4:	3482ba2c 	.word	0x3482ba2c
3481ccd8:	3482b9fc 	.word	0x3482b9fc
3481ccdc:	3482d90c 	.word	0x3482d90c
3481cce0:	3482ba04 	.word	0x3482ba04
3481cce4:	3482d914 	.word	0x3482d914
3481cce8:	3482575a 	.word	0x3482575a
3481ccec:	63538263 	.word	0x63538263
3481ccf0:	3482d908 	.word	0x3482d908
3481ccf4:	3482d8a4 	.word	0x3482d8a4
3481ccf8:	3482ba28 	.word	0x3482ba28
3481ccfc:	3482ba24 	.word	0x3482ba24
3481cd00:	3482d904 	.word	0x3482d904
3481cd04:	34827b32 	.word	0x34827b32
3481cd08:	34827b6a 	.word	0x34827b6a
3481cd0c:	3482d8c4 	.word	0x3482d8c4
3481cd10:	34827b74 	.word	0x34827b74
3481cd14:	3482d884 	.word	0x3482d884
3481cd18:	34827b7e 	.word	0x34827b7e

3481cd1c <NetWriteIP.clone.1>:
	return l;
}

/* write IP *in network byteorder* */
static inline void NetWriteIP(void *to, IPaddr_t ip)
3481cd1c:	e92d4007 	push	{r0, r1, r2, lr}
3481cd20:	e3a03000 	mov	r3, #0
3481cd24:	e28d1008 	add	r1, sp, #8
3481cd28:	e5213004 	str	r3, [r1, #-4]!
{
	memcpy(to, (void *)&ip, sizeof(ip));
3481cd2c:	e3a02004 	mov	r2, #4
3481cd30:	ebfff056 	bl	34818e90 <memcpy>
}
3481cd34:	e8bd800e 	pop	{r1, r2, r3, pc}

3481cd38 <BootpRequest>:
}
#endif

void
BootpRequest(void)
{
3481cd38:	e92d4eff 	push	{r0, r1, r2, r3, r4, r5, r6, r7, r9, sl, fp, lr}
	for (i = 0; i < rand_ms; i++)
		udelay(1000); /*Wait 1ms*/

#endif	/* CONFIG_BOOTP_RANDOM_DELAY */

	printf("BOOTP broadcast %d\n", ++BootpTry);
3481cd3c:	e59f6188 	ldr	r6, [pc, #392]	; 3481cecc <BootpRequest+0x194>
	pkt = NetTxPacket;
3481cd40:	e59fb188 	ldr	fp, [pc, #392]	; 3481ced0 <BootpRequest+0x198>
	for (i = 0; i < rand_ms; i++)
		udelay(1000); /*Wait 1ms*/

#endif	/* CONFIG_BOOTP_RANDOM_DELAY */

	printf("BOOTP broadcast %d\n", ++BootpTry);
3481cd44:	e5961004 	ldr	r1, [r6, #4]
3481cd48:	e59f0184 	ldr	r0, [pc, #388]	; 3481ced4 <BootpRequest+0x19c>
3481cd4c:	e2811001 	add	r1, r1, #1
3481cd50:	e5861004 	str	r1, [r6, #4]
3481cd54:	ebffb07c 	bl	34808f4c <printf>
	pkt = NetTxPacket;
3481cd58:	e59b4000 	ldr	r4, [fp]
	memset((void *)pkt, 0, PKTSIZE);
3481cd5c:	e3a01000 	mov	r1, #0
3481cd60:	e1a00004 	mov	r0, r4
3481cd64:	e30025ee 	movw	r2, #1518	; 0x5ee
3481cd68:	ebfff024 	bl	34818e00 <memset>

	eth_hdr_size = NetSetEther(pkt, NetBcastAddr, PROT_IP);
3481cd6c:	e3a02b02 	mov	r2, #2048	; 0x800
3481cd70:	e59f1160 	ldr	r1, [pc, #352]	; 3481ced8 <BootpRequest+0x1a0>
3481cd74:	e1a00004 	mov	r0, r4
3481cd78:	eb000422 	bl	3481de08 <NetSetEther>
	pkt += eth_hdr_size;
3481cd7c:	e0844000 	add	r4, r4, r0
	 * C. Hallinan, DS4.COM, Inc.
	 */
	/* net_set_udp_header(pkt, 0xFFFFFFFFL, PORT_BOOTPS, PORT_BOOTPC,
		sizeof (struct Bootp_t)); */
	iphdr = pkt;	/* We need this later for net_set_udp_header() */
	pkt += IP_UDP_HDR_SIZE;
3481cd80:	e284501c 	add	r5, r4, #28

	bp = (struct Bootp_t *)pkt;
	bp->bp_op = OP_BOOTREQUEST;
3481cd84:	e3a03001 	mov	r3, #1
	bp->bp_htype = HWT_ETHER;
	bp->bp_hlen = HWL_ETHER;
	bp->bp_hops = 0;
3481cd88:	e3a0a000 	mov	sl, #0
	pkt += IP_UDP_HDR_SIZE;

	bp = (struct Bootp_t *)pkt;
	bp->bp_op = OP_BOOTREQUEST;
	bp->bp_htype = HWT_ETHER;
	bp->bp_hlen = HWL_ETHER;
3481cd8c:	e3a09006 	mov	r9, #6

	printf("BOOTP broadcast %d\n", ++BootpTry);
	pkt = NetTxPacket;
	memset((void *)pkt, 0, PKTSIZE);

	eth_hdr_size = NetSetEther(pkt, NetBcastAddr, PROT_IP);
3481cd90:	e1a0c000 	mov	ip, r0
		sizeof (struct Bootp_t)); */
	iphdr = pkt;	/* We need this later for net_set_udp_header() */
	pkt += IP_UDP_HDR_SIZE;

	bp = (struct Bootp_t *)pkt;
	bp->bp_op = OP_BOOTREQUEST;
3481cd94:	e5c4301c 	strb	r3, [r4, #28]
	bp->bp_htype = HWT_ETHER;
3481cd98:	e5c53001 	strb	r3, [r5, #1]
	bp->bp_hlen = HWL_ETHER;
3481cd9c:	e5c59002 	strb	r9, [r5, #2]
	bp->bp_hops = 0;
3481cda0:	e5c5a003 	strb	sl, [r5, #3]
	bp->bp_secs = htons(get_timer(0) / 1000);
3481cda4:	e1a0000a 	mov	r0, sl
3481cda8:	e58dc00c 	str	ip, [sp, #12]
3481cdac:	ebff9128 	bl	34801254 <get_timer>
3481cdb0:	e3a01ffa 	mov	r1, #1000	; 0x3e8
3481cdb4:	eb000c3a 	bl	3481fea4 <__udivsi3>
3481cdb8:	e6ff0070 	uxth	r0, r0
3481cdbc:	e1a03420 	lsr	r3, r0, #8
3481cdc0:	e1830400 	orr	r0, r3, r0, lsl #8
3481cdc4:	e1c500b8 	strh	r0, [r5, #8]
	NetWriteIP(&bp->bp_ciaddr, 0);
3481cdc8:	e2840028 	add	r0, r4, #40	; 0x28
3481cdcc:	ebffffd2 	bl	3481cd1c <NetWriteIP.clone.1>
	NetWriteIP(&bp->bp_yiaddr, 0);
3481cdd0:	e284002c 	add	r0, r4, #44	; 0x2c
3481cdd4:	ebffffd0 	bl	3481cd1c <NetWriteIP.clone.1>
	NetWriteIP(&bp->bp_siaddr, 0);
	NetWriteIP(&bp->bp_giaddr, 0);
	memcpy(bp->bp_chaddr, NetOurEther, 6);
3481cdd8:	e59f70fc 	ldr	r7, [pc, #252]	; 3481cedc <BootpRequest+0x1a4>
	bp->bp_hlen = HWL_ETHER;
	bp->bp_hops = 0;
	bp->bp_secs = htons(get_timer(0) / 1000);
	NetWriteIP(&bp->bp_ciaddr, 0);
	NetWriteIP(&bp->bp_yiaddr, 0);
	NetWriteIP(&bp->bp_siaddr, 0);
3481cddc:	e2840030 	add	r0, r4, #48	; 0x30
3481cde0:	ebffffcd 	bl	3481cd1c <NetWriteIP.clone.1>
	NetWriteIP(&bp->bp_giaddr, 0);
3481cde4:	e2840034 	add	r0, r4, #52	; 0x34
3481cde8:	ebffffcb 	bl	3481cd1c <NetWriteIP.clone.1>
	memcpy(bp->bp_chaddr, NetOurEther, 6);
3481cdec:	e1a01007 	mov	r1, r7
3481cdf0:	e1a02009 	mov	r2, r9
3481cdf4:	e2840038 	add	r0, r4, #56	; 0x38
3481cdf8:	ebfff024 	bl	34818e90 <memcpy>
	copy_filename(bp->bp_file, BootFile, sizeof(bp->bp_file));
3481cdfc:	e59f10dc 	ldr	r1, [pc, #220]	; 3481cee0 <BootpRequest+0x1a8>
3481ce00:	e2840088 	add	r0, r4, #136	; 0x88
3481ce04:	e3a02080 	mov	r2, #128	; 0x80
3481ce08:	eb0004d4 	bl	3481e160 <copy_filename>
 */
static int BootpExtended(u8 *e)
{
	u8 *start = e;

	*e++ = 99;		/* RFC1048 Magic Cookie */
3481ce0c:	e3a03063 	mov	r3, #99	; 0x63
	*e++ = 130;
3481ce10:	e3e0207d 	mvn	r2, #125	; 0x7d
 */
static int BootpExtended(u8 *e)
{
	u8 *start = e;

	*e++ = 99;		/* RFC1048 Magic Cookie */
3481ce14:	e5c530ec 	strb	r3, [r5, #236]	; 0xec
	*e++ = 42;
	*e++ = 4;
	e   += 4;
#endif

	*e++ = 255;		/* End of the list */
3481ce18:	e3e09000 	mvn	r9, #0
static int BootpExtended(u8 *e)
{
	u8 *start = e;

	*e++ = 99;		/* RFC1048 Magic Cookie */
	*e++ = 130;
3481ce1c:	e5c42109 	strb	r2, [r4, #265]	; 0x109
	*e++ = 83;
3481ce20:	e28220d1 	add	r2, r2, #209	; 0xd1
3481ce24:	e5c4210a 	strb	r2, [r4, #266]	; 0x10a
	*e++ = 99;
3481ce28:	e5c4310b 	strb	r3, [r4, #267]	; 0x10b
	*e++ = 42;
	*e++ = 4;
	e   += 4;
#endif

	*e++ = 255;		/* End of the list */
3481ce2c:	e5c590f0 	strb	r9, [r5, #240]	; 0xf0
	/*
	 *	Bootp ID is the lower 4 bytes of our ethernet address
	 *	plus the current time in ms.
	 */
	BootpID = ((ulong)NetOurEther[2] << 24)
		| ((ulong)NetOurEther[3] << 16)
3481ce30:	e5d73003 	ldrb	r3, [r7, #3]

	/*
	 *	Bootp ID is the lower 4 bytes of our ethernet address
	 *	plus the current time in ms.
	 */
	BootpID = ((ulong)NetOurEther[2] << 24)
3481ce34:	e5d72002 	ldrb	r2, [r7, #2]
		| ((ulong)NetOurEther[3] << 16)
3481ce38:	e1a03803 	lsl	r3, r3, #16
3481ce3c:	e1833c02 	orr	r3, r3, r2, lsl #24
		| ((ulong)NetOurEther[4] << 8)
		| (ulong)NetOurEther[5];
3481ce40:	e5d72005 	ldrb	r2, [r7, #5]
	 *	Bootp ID is the lower 4 bytes of our ethernet address
	 *	plus the current time in ms.
	 */
	BootpID = ((ulong)NetOurEther[2] << 24)
		| ((ulong)NetOurEther[3] << 16)
		| ((ulong)NetOurEther[4] << 8)
3481ce44:	e5d77004 	ldrb	r7, [r7, #4]
3481ce48:	e1833002 	orr	r3, r3, r2
		| (ulong)NetOurEther[5];
3481ce4c:	e1837407 	orr	r7, r3, r7, lsl #8
	BootpID += get_timer(0);
3481ce50:	e1a0000a 	mov	r0, sl

	/*
	 *	Bootp ID is the lower 4 bytes of our ethernet address
	 *	plus the current time in ms.
	 */
	BootpID = ((ulong)NetOurEther[2] << 24)
3481ce54:	e5867000 	str	r7, [r6]
		| ((ulong)NetOurEther[3] << 16)
		| ((ulong)NetOurEther[4] << 8)
		| (ulong)NetOurEther[5];
	BootpID += get_timer(0);
3481ce58:	ebff90fd 	bl	34801254 <get_timer>
	BootpID	 = htonl(BootpID);
3481ce5c:	e0800007 	add	r0, r0, r7
3481ce60:	ebfffece 	bl	3481c9a0 <__fswab32>

	/* Request additional information from the BOOTP/DHCP server */
#if defined(CONFIG_CMD_DHCP)
	extlen = DhcpExtended((u8 *)bp->bp_vend, DHCP_DISCOVER, 0, 0);
#else
	extlen = BootpExtended((u8 *)bp->bp_vend);
3481ce64:	e0645005 	rsb	r5, r4, r5
	BootpID = ((ulong)NetOurEther[2] << 24)
		| ((ulong)NetOurEther[3] << 16)
		| ((ulong)NetOurEther[4] << 8)
		| (ulong)NetOurEther[5];
	BootpID += get_timer(0);
	BootpID	 = htonl(BootpID);
3481ce68:	e5860000 	str	r0, [r6]
}

/* copy ulong */
static inline void NetCopyLong(ulong *to, ulong *from)
{
	memcpy((void *)to, (void *)from, sizeof(ulong));
3481ce6c:	e1a01006 	mov	r1, r6
3481ce70:	e2840020 	add	r0, r4, #32
3481ce74:	e3a02004 	mov	r2, #4
	e   += 4;
#endif

	*e++ = 255;		/* End of the list */

	return e - start;
3481ce78:	e2455017 	sub	r5, r5, #23
3481ce7c:	ebfff003 	bl	34818e90 <memcpy>

	/*
	 * Calculate proper packet lengths taking into account the
	 * variable size of the options field
	 */
	iplen = BOOTP_HDR_SIZE - OPT_FIELD_SIZE + extlen;
3481ce80:	e28530ec 	add	r3, r5, #236	; 0xec
	pktlen = eth_hdr_size + IP_UDP_HDR_SIZE + iplen;
	net_set_udp_header(iphdr, 0xFFFFFFFFL, PORT_BOOTPS, PORT_BOOTPC, iplen);
3481ce84:	e3a02043 	mov	r2, #67	; 0x43
3481ce88:	e58d3000 	str	r3, [sp]
3481ce8c:	e1a00004 	mov	r0, r4
3481ce90:	e3a03044 	mov	r3, #68	; 0x44
3481ce94:	e1a01009 	mov	r1, r9
3481ce98:	eb000446 	bl	3481dfb8 <net_set_udp_header>
	NetSetTimeout(SELECT_TIMEOUT, BootpTimeout);
3481ce9c:	e59f1040 	ldr	r1, [pc, #64]	; 3481cee4 <BootpRequest+0x1ac>
3481cea0:	e3000bb8 	movw	r0, #3000	; 0xbb8
3481cea4:	eb0002b7 	bl	3481d988 <NetSetTimeout>

#if defined(CONFIG_CMD_DHCP)
	dhcp_state = SELECTING;
	net_set_udp_handler(DhcpHandler);
#else
	net_set_udp_handler(BootpHandler);
3481cea8:	e59f0038 	ldr	r0, [pc, #56]	; 3481cee8 <BootpRequest+0x1b0>
3481ceac:	eb0002a1 	bl	3481d938 <net_set_udp_handler>
}

/* Transmit a packet */
static inline void NetSendPacket(uchar *pkt, int len)
{
	(void) eth_send(pkt, len);
3481ceb0:	e59dc00c 	ldr	ip, [sp, #12]
	/*
	 * Calculate proper packet lengths taking into account the
	 * variable size of the options field
	 */
	iplen = BOOTP_HDR_SIZE - OPT_FIELD_SIZE + extlen;
	pktlen = eth_hdr_size + IP_UDP_HDR_SIZE + iplen;
3481ceb4:	e2855f42 	add	r5, r5, #264	; 0x108
3481ceb8:	e59b0000 	ldr	r0, [fp]
3481cebc:	e085100c 	add	r1, r5, ip
	net_set_udp_handler(DhcpHandler);
#else
	net_set_udp_handler(BootpHandler);
#endif
	NetSendPacket(NetTxPacket, pktlen);
}
3481cec0:	e28dd010 	add	sp, sp, #16
3481cec4:	e8bd4ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, lr}
3481cec8:	ea0001de 	b	3481d648 <eth_send>
3481cecc:	3482b9b4 	.word	0x3482b9b4
3481ced0:	3482ba14 	.word	0x3482ba14
3481ced4:	34827b8e 	.word	0x34827b8e
3481ced8:	34828ba4 	.word	0x34828ba4
3481cedc:	3482ba08 	.word	0x3482ba08
3481cee0:	3482d914 	.word	0x3482d914
3481cee4:	3481ceec 	.word	0x3481ceec
3481cee8:	3481c9b0 	.word	0x3481c9b0

3481ceec <BootpTimeout>:
 *	Timeout on BOOTP/DHCP request.
 */
static void
BootpTimeout(void)
{
	if (BootpTry >= TIMEOUT_COUNT) {
3481ceec:	e59f3030 	ldr	r3, [pc, #48]	; 3481cf24 <BootpTimeout+0x38>
/*
 *	Timeout on BOOTP/DHCP request.
 */
static void
BootpTimeout(void)
{
3481cef0:	e92d4010 	push	{r4, lr}
	if (BootpTry >= TIMEOUT_COUNT) {
3481cef4:	e5933004 	ldr	r3, [r3, #4]
3481cef8:	e3530004 	cmp	r3, #4
3481cefc:	da000003 	ble	3481cf10 <BootpTimeout+0x24>
#ifdef CONFIG_BOOTP_MAY_FAIL
		puts("\nRetry count exceeded\n");
		net_set_state(NETLOOP_FAIL);
#else
		puts("\nRetry count exceeded; starting again\n");
3481cf00:	e59f0020 	ldr	r0, [pc, #32]	; 3481cf28 <BootpTimeout+0x3c>
3481cf04:	ebffb006 	bl	34808f24 <puts>
#endif
	} else {
		NetSetTimeout(TIMEOUT, BootpTimeout);
		BootpRequest();
	}
}
3481cf08:	e8bd4010 	pop	{r4, lr}
#ifdef CONFIG_BOOTP_MAY_FAIL
		puts("\nRetry count exceeded\n");
		net_set_state(NETLOOP_FAIL);
#else
		puts("\nRetry count exceeded; starting again\n");
		NetStartAgain();
3481cf0c:	ea0002ac 	b	3481d9c4 <NetStartAgain>
#endif
	} else {
		NetSetTimeout(TIMEOUT, BootpTimeout);
3481cf10:	e3010388 	movw	r0, #5000	; 0x1388
3481cf14:	e59f1010 	ldr	r1, [pc, #16]	; 3481cf2c <BootpTimeout+0x40>
3481cf18:	eb00029a 	bl	3481d988 <NetSetTimeout>
		BootpRequest();
	}
}
3481cf1c:	e8bd4010 	pop	{r4, lr}
		puts("\nRetry count exceeded; starting again\n");
		NetStartAgain();
#endif
	} else {
		NetSetTimeout(TIMEOUT, BootpTimeout);
		BootpRequest();
3481cf20:	eaffff84 	b	3481cd38 <BootpRequest>
3481cf24:	3482b9b4 	.word	0x3482b9b4
3481cf28:	34827ba2 	.word	0x34827ba2
3481cf2c:	3481ceec 	.word	0x3481ceec

3481cf30 <is_valid_ether_addr>:
}

char *eth_get_name(void)
{
	return eth_current ? eth_current->name : "unknown";
}
3481cf30:	e5d03000 	ldrb	r3, [r0]
 */
static inline int is_valid_ether_addr(const u8 *addr)
{
	/* FF:FF:FF:FF:FF:FF is a multicast address so we don't need to
	 * explicitly check for it here. */
	return !is_multicast_ether_addr(addr) && !is_zero_ether_addr(addr);
3481cf34:	e3130001 	tst	r3, #1
3481cf38:	1a00000c 	bne	3481cf70 <is_valid_ether_addr+0x40>
 *
 * Return true if the address is all zeroes.
 */
static inline int is_zero_ether_addr(const u8 *addr)
{
	return !(addr[0] | addr[1] | addr[2] | addr[3] | addr[4] | addr[5]);
3481cf3c:	e5d01001 	ldrb	r1, [r0, #1]
3481cf40:	e5d02002 	ldrb	r2, [r0, #2]
3481cf44:	e1812002 	orr	r2, r1, r2
3481cf48:	e1833002 	orr	r3, r3, r2
3481cf4c:	e5d02003 	ldrb	r2, [r0, #3]
3481cf50:	e1833002 	orr	r3, r3, r2
3481cf54:	e5d02004 	ldrb	r2, [r0, #4]
3481cf58:	e1833002 	orr	r3, r3, r2
3481cf5c:	e5d02005 	ldrb	r2, [r0, #5]
 */
static inline int is_valid_ether_addr(const u8 *addr)
{
	/* FF:FF:FF:FF:FF:FF is a multicast address so we don't need to
	 * explicitly check for it here. */
	return !is_multicast_ether_addr(addr) && !is_zero_ether_addr(addr);
3481cf60:	e1932002 	orrs	r2, r3, r2
3481cf64:	03a00000 	moveq	r0, #0
3481cf68:	13a00001 	movne	r0, #1
3481cf6c:	e12fff1e 	bx	lr
3481cf70:	e3a00000 	mov	r0, #0
}
3481cf74:	e12fff1e 	bx	lr

3481cf78 <cpu_eth_init>:
 * signals caller to move on
 */
static int __def_eth_init(bd_t *bis)
{
	return -1;
}
3481cf78:	e3e00000 	mvn	r0, #0
3481cf7c:	e12fff1e 	bx	lr

3481cf80 <eth_current_changed>:

	return eth_current->index;
}

static void eth_current_changed(void)
{
3481cf80:	e92d4010 	push	{r4, lr}
	char *act = getenv("ethact");
3481cf84:	e59f0048 	ldr	r0, [pc, #72]	; 3481cfd4 <eth_current_changed+0x54>
3481cf88:	ebffacab 	bl	3480823c <getenv>
	/* update current ethernet name */
	if (eth_current) {
3481cf8c:	e59f2044 	ldr	r2, [pc, #68]	; 3481cfd8 <eth_current_changed+0x58>
3481cf90:	e5921000 	ldr	r1, [r2]
3481cf94:	e3510000 	cmp	r1, #0
3481cf98:	0a000008 	beq	3481cfc0 <eth_current_changed+0x40>
		if (act == NULL || strcmp(act, eth_current->name) != 0)
3481cf9c:	e3500000 	cmp	r0, #0
3481cfa0:	0a000002 	beq	3481cfb0 <eth_current_changed+0x30>
3481cfa4:	ebffeec1 	bl	34818ab0 <strcmp>
3481cfa8:	e3500000 	cmp	r0, #0
3481cfac:	08bd8010 	popeq	{r4, pc}
			setenv("ethact", eth_current->name);
3481cfb0:	e59f3020 	ldr	r3, [pc, #32]	; 3481cfd8 <eth_current_changed+0x58>
3481cfb4:	e59f0018 	ldr	r0, [pc, #24]	; 3481cfd4 <eth_current_changed+0x54>
3481cfb8:	e5931000 	ldr	r1, [r3]
3481cfbc:	ea000002 	b	3481cfcc <eth_current_changed+0x4c>
	}
	/*
	 * remove the variable completely if there is no active
	 * interface
	 */
	else if (act != NULL)
3481cfc0:	e3500000 	cmp	r0, #0
3481cfc4:	08bd8010 	popeq	{r4, pc}
		setenv("ethact", NULL);
3481cfc8:	e59f0004 	ldr	r0, [pc, #4]	; 3481cfd4 <eth_current_changed+0x54>
}
3481cfcc:	e8bd4010 	pop	{r4, lr}
	/*
	 * remove the variable completely if there is no active
	 * interface
	 */
	else if (act != NULL)
		setenv("ethact", NULL);
3481cfd0:	eaffab91 	b	34807e1c <setenv>
3481cfd4:	34827bc9 	.word	0x34827bc9
3481cfd8:	3482b9bc 	.word	0x3482b9bc

3481cfdc <eth_parse_enetaddr>:
#include <net.h>
#include <miiphy.h>
#include <phy.h>

void eth_parse_enetaddr(const char *addr, uchar *enetaddr)
{
3481cfdc:	e92d40f7 	push	{r0, r1, r2, r4, r5, r6, r7, lr}
3481cfe0:	e1a04000 	mov	r4, r0
3481cfe4:	e1a06001 	mov	r6, r1
3481cfe8:	e3a05006 	mov	r5, #6
	char *end;
	int i;

	for (i = 0; i < 6; ++i) {
		enetaddr[i] = addr ? simple_strtoul(addr, &end, 16) : 0;
3481cfec:	e28d7004 	add	r7, sp, #4
3481cff0:	e3540000 	cmp	r4, #0
3481cff4:	01a00004 	moveq	r0, r4
3481cff8:	0a000004 	beq	3481d010 <eth_parse_enetaddr+0x34>
3481cffc:	e1a00004 	mov	r0, r4
3481d000:	e1a01007 	mov	r1, r7
3481d004:	e3a02010 	mov	r2, #16
3481d008:	ebfff2fa 	bl	34819bf8 <simple_strtoul>
3481d00c:	e6ef0070 	uxtb	r0, r0
		if (addr)
3481d010:	e3540000 	cmp	r4, #0
{
	char *end;
	int i;

	for (i = 0; i < 6; ++i) {
		enetaddr[i] = addr ? simple_strtoul(addr, &end, 16) : 0;
3481d014:	e4c60001 	strb	r0, [r6], #1
		if (addr)
3481d018:	0a000003 	beq	3481d02c <eth_parse_enetaddr+0x50>
			addr = (*end) ? end + 1 : end;
3481d01c:	e59d4004 	ldr	r4, [sp, #4]
3481d020:	e5d43000 	ldrb	r3, [r4]
3481d024:	e3530000 	cmp	r3, #0
3481d028:	12844001 	addne	r4, r4, #1
void eth_parse_enetaddr(const char *addr, uchar *enetaddr)
{
	char *end;
	int i;

	for (i = 0; i < 6; ++i) {
3481d02c:	e2555001 	subs	r5, r5, #1
3481d030:	1affffee 	bne	3481cff0 <eth_parse_enetaddr+0x14>
		enetaddr[i] = addr ? simple_strtoul(addr, &end, 16) : 0;
		if (addr)
			addr = (*end) ? end + 1 : end;
	}
}
3481d034:	e8bd80fe 	pop	{r1, r2, r3, r4, r5, r6, r7, pc}

3481d038 <eth_getenv_enetaddr>:

int eth_getenv_enetaddr(char *name, uchar *enetaddr)
{
3481d038:	e92d4010 	push	{r4, lr}
3481d03c:	e1a04001 	mov	r4, r1
	eth_parse_enetaddr(getenv(name), enetaddr);
3481d040:	ebffac7d 	bl	3480823c <getenv>
3481d044:	e1a01004 	mov	r1, r4
3481d048:	ebffffe3 	bl	3481cfdc <eth_parse_enetaddr>
	return is_valid_ether_addr(enetaddr);
3481d04c:	e1a00004 	mov	r0, r4
}
3481d050:	e8bd4010 	pop	{r4, lr}
}

int eth_getenv_enetaddr(char *name, uchar *enetaddr)
{
	eth_parse_enetaddr(getenv(name), enetaddr);
	return is_valid_ether_addr(enetaddr);
3481d054:	eaffffb5 	b	3481cf30 <is_valid_ether_addr>

3481d058 <eth_setenv_enetaddr>:
}

int eth_setenv_enetaddr(char *name, const uchar *enetaddr)
{
3481d058:	e92d4030 	push	{r4, r5, lr}
3481d05c:	e24dd01c 	sub	sp, sp, #28
	char buf[20];

	sprintf(buf, "%pM", enetaddr);
3481d060:	e28d4004 	add	r4, sp, #4
	eth_parse_enetaddr(getenv(name), enetaddr);
	return is_valid_ether_addr(enetaddr);
}

int eth_setenv_enetaddr(char *name, const uchar *enetaddr)
{
3481d064:	e1a05000 	mov	r5, r0
3481d068:	e1a02001 	mov	r2, r1
	char buf[20];

	sprintf(buf, "%pM", enetaddr);
3481d06c:	e1a00004 	mov	r0, r4
3481d070:	e59f1014 	ldr	r1, [pc, #20]	; 3481d08c <eth_setenv_enetaddr+0x34>
3481d074:	ebfff385 	bl	34819e90 <sprintf>

	return setenv(name, buf);
3481d078:	e1a00005 	mov	r0, r5
3481d07c:	e1a01004 	mov	r1, r4
3481d080:	ebffab65 	bl	34807e1c <setenv>
}
3481d084:	e28dd01c 	add	sp, sp, #28
3481d088:	e8bd8030 	pop	{r4, r5, pc}
3481d08c:	34827bd0 	.word	0x34827bd0

3481d090 <eth_getenv_enetaddr_by_index>:

int eth_getenv_enetaddr_by_index(const char *base_name, int index,
				 uchar *enetaddr)
{
3481d090:	e92d4030 	push	{r4, r5, lr}
3481d094:	e1a05002 	mov	r5, r2
	char enetvar[32];
	sprintf(enetvar, index ? "%s%daddr" : "%saddr", base_name, index);
3481d098:	e59fe03c 	ldr	lr, [pc, #60]	; 3481d0dc <eth_getenv_enetaddr_by_index+0x4c>
3481d09c:	e59f203c 	ldr	r2, [pc, #60]	; 3481d0e0 <eth_getenv_enetaddr_by_index+0x50>
	return setenv(name, buf);
}

int eth_getenv_enetaddr_by_index(const char *base_name, int index,
				 uchar *enetaddr)
{
3481d0a0:	e24dd024 	sub	sp, sp, #36	; 0x24
	char enetvar[32];
	sprintf(enetvar, index ? "%s%daddr" : "%saddr", base_name, index);
3481d0a4:	e3510000 	cmp	r1, #0
	return setenv(name, buf);
}

int eth_getenv_enetaddr_by_index(const char *base_name, int index,
				 uchar *enetaddr)
{
3481d0a8:	e1a0c000 	mov	ip, r0
	char enetvar[32];
	sprintf(enetvar, index ? "%s%daddr" : "%saddr", base_name, index);
3481d0ac:	e1a03001 	mov	r3, r1
3481d0b0:	e1a0000d 	mov	r0, sp
3481d0b4:	11a01002 	movne	r1, r2
3481d0b8:	01a0100e 	moveq	r1, lr
3481d0bc:	e1a0200c 	mov	r2, ip
3481d0c0:	ebfff372 	bl	34819e90 <sprintf>
	return eth_getenv_enetaddr(enetvar, enetaddr);
3481d0c4:	e1a0000d 	mov	r0, sp
3481d0c8:	e1a01005 	mov	r1, r5

int eth_getenv_enetaddr_by_index(const char *base_name, int index,
				 uchar *enetaddr)
{
	char enetvar[32];
	sprintf(enetvar, index ? "%s%daddr" : "%saddr", base_name, index);
3481d0cc:	e1a0400d 	mov	r4, sp
	return eth_getenv_enetaddr(enetvar, enetaddr);
3481d0d0:	ebffffd8 	bl	3481d038 <eth_getenv_enetaddr>
}
3481d0d4:	e28dd024 	add	sp, sp, #36	; 0x24
3481d0d8:	e8bd8030 	pop	{r4, r5, pc}
3481d0dc:	34827bdd 	.word	0x34827bdd
3481d0e0:	34827bd4 	.word	0x34827bd4

3481d0e4 <eth_get_dev_by_name>:

static struct eth_device *eth_devices;
struct eth_device *eth_current;

struct eth_device *eth_get_dev_by_name(const char *devname)
{
3481d0e4:	e92d4070 	push	{r4, r5, r6, lr}
	struct eth_device *dev, *target_dev;

	BUG_ON(devname == NULL);
3481d0e8:	e2506000 	subs	r6, r0, #0
3481d0ec:	1a000006 	bne	3481d10c <eth_get_dev_by_name+0x28>
3481d0f0:	e59f005c 	ldr	r0, [pc, #92]	; 3481d154 <eth_get_dev_by_name+0x70>
3481d0f4:	e59f105c 	ldr	r1, [pc, #92]	; 3481d158 <eth_get_dev_by_name+0x74>
3481d0f8:	e3a02083 	mov	r2, #131	; 0x83
3481d0fc:	e59f3058 	ldr	r3, [pc, #88]	; 3481d15c <eth_get_dev_by_name+0x78>
3481d100:	ebffaf91 	bl	34808f4c <printf>
3481d104:	e59f0054 	ldr	r0, [pc, #84]	; 3481d160 <eth_get_dev_by_name+0x7c>
3481d108:	ebfff369 	bl	34819eb4 <panic>

	if (!eth_devices)
3481d10c:	e59f5050 	ldr	r5, [pc, #80]	; 3481d164 <eth_get_dev_by_name+0x80>
3481d110:	e5954004 	ldr	r4, [r5, #4]
3481d114:	e3540000 	cmp	r4, #0
		return NULL;
3481d118:	01a00004 	moveq	r0, r4
{
	struct eth_device *dev, *target_dev;

	BUG_ON(devname == NULL);

	if (!eth_devices)
3481d11c:	08bd8070 	popeq	{r4, r5, r6, pc}
		return NULL;

	dev = eth_devices;
	target_dev = NULL;
	do {
		if (strcmp(devname, dev->name) == 0) {
3481d120:	e1a00006 	mov	r0, r6
3481d124:	e1a01004 	mov	r1, r4
3481d128:	ebffee60 	bl	34818ab0 <strcmp>
3481d12c:	e3500000 	cmp	r0, #0
3481d130:	0a000005 	beq	3481d14c <eth_get_dev_by_name+0x68>
			target_dev = dev;
			break;
		}
		dev = dev->next;
3481d134:	e5944034 	ldr	r4, [r4, #52]	; 0x34
	} while (dev != eth_devices);
3481d138:	e5953004 	ldr	r3, [r5, #4]
3481d13c:	e1540003 	cmp	r4, r3
3481d140:	1afffff6 	bne	3481d120 <eth_get_dev_by_name+0x3c>

	if (!eth_devices)
		return NULL;

	dev = eth_devices;
	target_dev = NULL;
3481d144:	e3a00000 	mov	r0, #0
3481d148:	e8bd8070 	pop	{r4, r5, r6, pc}
	do {
		if (strcmp(devname, dev->name) == 0) {
3481d14c:	e1a00004 	mov	r0, r4
		}
		dev = dev->next;
	} while (dev != eth_devices);

	return target_dev;
}
3481d150:	e8bd8070 	pop	{r4, r5, r6, pc}
3481d154:	3482729e 	.word	0x3482729e
3481d158:	34827be4 	.word	0x34827be4
3481d15c:	34822ad0 	.word	0x34822ad0
3481d160:	348272c5 	.word	0x348272c5
3481d164:	3482b9bc 	.word	0x3482b9bc

3481d168 <eth_get_dev_by_index>:

struct eth_device *eth_get_dev_by_index(int index)
{
	struct eth_device *dev, *target_dev;

	if (!eth_devices)
3481d168:	e59f3038 	ldr	r3, [pc, #56]	; 3481d1a8 <eth_get_dev_by_index+0x40>
3481d16c:	e5932004 	ldr	r2, [r3, #4]
3481d170:	e3520000 	cmp	r2, #0
		return NULL;
3481d174:	01a00002 	moveq	r0, r2

struct eth_device *eth_get_dev_by_index(int index)
{
	struct eth_device *dev, *target_dev;

	if (!eth_devices)
3481d178:	012fff1e 	bxeq	lr
3481d17c:	e1a03002 	mov	r3, r2
		return NULL;

	dev = eth_devices;
	target_dev = NULL;
	do {
		if (dev->index == index) {
3481d180:	e5931038 	ldr	r1, [r3, #56]	; 0x38
3481d184:	e1510000 	cmp	r1, r0
3481d188:	0a000004 	beq	3481d1a0 <eth_get_dev_by_index+0x38>
			target_dev = dev;
			break;
		}
		dev = dev->next;
3481d18c:	e5933034 	ldr	r3, [r3, #52]	; 0x34
	} while (dev != eth_devices);
3481d190:	e1530002 	cmp	r3, r2
3481d194:	1afffff9 	bne	3481d180 <eth_get_dev_by_index+0x18>

	if (!eth_devices)
		return NULL;

	dev = eth_devices;
	target_dev = NULL;
3481d198:	e3a00000 	mov	r0, #0
3481d19c:	e12fff1e 	bx	lr
	do {
		if (dev->index == index) {
3481d1a0:	e1a00003 	mov	r0, r3
		}
		dev = dev->next;
	} while (dev != eth_devices);

	return target_dev;
}
3481d1a4:	e12fff1e 	bx	lr
3481d1a8:	3482b9bc 	.word	0x3482b9bc

3481d1ac <eth_get_dev_index>:

int eth_get_dev_index(void)
{
	if (!eth_current)
3481d1ac:	e59f3010 	ldr	r3, [pc, #16]	; 3481d1c4 <eth_get_dev_index+0x18>
3481d1b0:	e5933000 	ldr	r3, [r3]
3481d1b4:	e3530000 	cmp	r3, #0
		return -1;

	return eth_current->index;
3481d1b8:	15930038 	ldrne	r0, [r3, #56]	; 0x38
}

int eth_get_dev_index(void)
{
	if (!eth_current)
		return -1;
3481d1bc:	03e00000 	mvneq	r0, #0

	return eth_current->index;
}
3481d1c0:	e12fff1e 	bx	lr
3481d1c4:	3482b9bc 	.word	0x3482b9bc

3481d1c8 <eth_write_hwaddr>:
		setenv("ethact", NULL);
}

int eth_write_hwaddr(struct eth_device *dev, const char *base_name,
		   int eth_number)
{
3481d1c8:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
3481d1cc:	e24dd028 	sub	sp, sp, #40	; 0x28
	unsigned char env_enetaddr[6];
	int ret = 0;

	eth_getenv_enetaddr_by_index(base_name, eth_number, env_enetaddr);
3481d1d0:	e28d7020 	add	r7, sp, #32
		setenv("ethact", NULL);
}

int eth_write_hwaddr(struct eth_device *dev, const char *base_name,
		   int eth_number)
{
3481d1d4:	e1a04000 	mov	r4, r0
3481d1d8:	e1a0a001 	mov	sl, r1
	unsigned char env_enetaddr[6];
	int ret = 0;

	eth_getenv_enetaddr_by_index(base_name, eth_number, env_enetaddr);
3481d1dc:	e1a00001 	mov	r0, r1
		setenv("ethact", NULL);
}

int eth_write_hwaddr(struct eth_device *dev, const char *base_name,
		   int eth_number)
{
3481d1e0:	e1a06002 	mov	r6, r2
	unsigned char env_enetaddr[6];
	int ret = 0;

	eth_getenv_enetaddr_by_index(base_name, eth_number, env_enetaddr);
3481d1e4:	e1a01002 	mov	r1, r2
3481d1e8:	e1a02007 	mov	r2, r7
3481d1ec:	ebffffa7 	bl	3481d090 <eth_getenv_enetaddr_by_index>

	if (memcmp(env_enetaddr, "\0\0\0\0\0\0", 6)) {
3481d1f0:	e1a00007 	mov	r0, r7
3481d1f4:	e59f112c 	ldr	r1, [pc, #300]	; 3481d328 <eth_write_hwaddr+0x160>
3481d1f8:	e3a02006 	mov	r2, #6
3481d1fc:	ebffef56 	bl	34818f5c <memcmp>
3481d200:	e3500000 	cmp	r0, #0
3481d204:	e2845010 	add	r5, r4, #16
3481d208:	0a000019 	beq	3481d274 <eth_write_hwaddr+0xac>
		if (memcmp(dev->enetaddr, "\0\0\0\0\0\0", 6) &&
3481d20c:	e1a00005 	mov	r0, r5
3481d210:	e59f1110 	ldr	r1, [pc, #272]	; 3481d328 <eth_write_hwaddr+0x160>
3481d214:	e3a02006 	mov	r2, #6
3481d218:	ebffef4f 	bl	34818f5c <memcmp>
3481d21c:	e3500000 	cmp	r0, #0
3481d220:	0a00000e 	beq	3481d260 <eth_write_hwaddr+0x98>
				memcmp(dev->enetaddr, env_enetaddr, 6)) {
3481d224:	e1a00005 	mov	r0, r5
3481d228:	e1a01007 	mov	r1, r7
3481d22c:	e3a02006 	mov	r2, #6
3481d230:	ebffef49 	bl	34818f5c <memcmp>
	int ret = 0;

	eth_getenv_enetaddr_by_index(base_name, eth_number, env_enetaddr);

	if (memcmp(env_enetaddr, "\0\0\0\0\0\0", 6)) {
		if (memcmp(dev->enetaddr, "\0\0\0\0\0\0", 6) &&
3481d234:	e3500000 	cmp	r0, #0
3481d238:	0a000008 	beq	3481d260 <eth_write_hwaddr+0x98>
				memcmp(dev->enetaddr, env_enetaddr, 6)) {
			printf("\nWarning: %s MAC addresses don't match:\n",
3481d23c:	e1a01004 	mov	r1, r4
3481d240:	e59f00e4 	ldr	r0, [pc, #228]	; 3481d32c <eth_write_hwaddr+0x164>
3481d244:	ebffaf40 	bl	34808f4c <printf>
				dev->name);
			printf("Address in SROM is         %pM\n",
3481d248:	e1a01005 	mov	r1, r5
3481d24c:	e59f00dc 	ldr	r0, [pc, #220]	; 3481d330 <eth_write_hwaddr+0x168>
3481d250:	ebffaf3d 	bl	34808f4c <printf>
				dev->enetaddr);
			printf("Address in environment is  %pM\n",
3481d254:	e59f00d8 	ldr	r0, [pc, #216]	; 3481d334 <eth_write_hwaddr+0x16c>
3481d258:	e1a01007 	mov	r1, r7
3481d25c:	ebffaf3a 	bl	34808f4c <printf>
				env_enetaddr);
		}

		memcpy(dev->enetaddr, env_enetaddr, 6);
3481d260:	e1a00005 	mov	r0, r5
3481d264:	e28d1020 	add	r1, sp, #32
3481d268:	e3a02006 	mov	r2, #6
3481d26c:	ebffef07 	bl	34818e90 <memcpy>
3481d270:	ea000012 	b	3481d2c0 <eth_write_hwaddr+0xf8>
	} else if (is_valid_ether_addr(dev->enetaddr)) {
3481d274:	e1a00005 	mov	r0, r5
3481d278:	ebffff2c 	bl	3481cf30 <is_valid_ether_addr>
3481d27c:	e3500000 	cmp	r0, #0
3481d280:	0a00000e 	beq	3481d2c0 <eth_write_hwaddr+0xf8>

static inline int eth_setenv_enetaddr_by_index(const char *base_name, int index,
				 uchar *enetaddr)
{
	char enetvar[32];
	sprintf(enetvar, index ? "%s%daddr" : "%saddr", base_name, index);
3481d284:	e59f30ac 	ldr	r3, [pc, #172]	; 3481d338 <eth_write_hwaddr+0x170>
3481d288:	e3560000 	cmp	r6, #0
3481d28c:	e59f10a8 	ldr	r1, [pc, #168]	; 3481d33c <eth_write_hwaddr+0x174>
3481d290:	e1a0200a 	mov	r2, sl
3481d294:	11a01003 	movne	r1, r3
3481d298:	e1a0000d 	mov	r0, sp
3481d29c:	e1a03006 	mov	r3, r6
3481d2a0:	ebfff2fa 	bl	34819e90 <sprintf>
	return eth_setenv_enetaddr(enetvar, enetaddr);
3481d2a4:	e1a01005 	mov	r1, r5
3481d2a8:	e1a0000d 	mov	r0, sp
3481d2ac:	ebffff69 	bl	3481d058 <eth_setenv_enetaddr>

		memcpy(dev->enetaddr, env_enetaddr, 6);
	} else if (is_valid_ether_addr(dev->enetaddr)) {
		eth_setenv_enetaddr_by_index(base_name, eth_number,
					     dev->enetaddr);
		printf("\nWarning: %s using MAC address from net device\n",
3481d2b0:	e59f0088 	ldr	r0, [pc, #136]	; 3481d340 <eth_write_hwaddr+0x178>
3481d2b4:	e1a01004 	mov	r1, r4

static inline int eth_setenv_enetaddr_by_index(const char *base_name, int index,
				 uchar *enetaddr)
{
	char enetvar[32];
	sprintf(enetvar, index ? "%s%daddr" : "%saddr", base_name, index);
3481d2b8:	e1a0700d 	mov	r7, sp

		memcpy(dev->enetaddr, env_enetaddr, 6);
	} else if (is_valid_ether_addr(dev->enetaddr)) {
		eth_setenv_enetaddr_by_index(base_name, eth_number,
					     dev->enetaddr);
		printf("\nWarning: %s using MAC address from net device\n",
3481d2bc:	ebffaf22 	bl	34808f4c <printf>
			dev->name);
	}

	if (dev->write_hwaddr &&
3481d2c0:	e5940030 	ldr	r0, [r4, #48]	; 0x30
3481d2c4:	e3500000 	cmp	r0, #0
3481d2c8:	0a000014 	beq	3481d320 <eth_write_hwaddr+0x158>

static int eth_mac_skip(int index)
{
	char enetvar[15];
	char *skip_state;
	sprintf(enetvar, index ? "eth%dmacskip" : "ethmacskip", index);
3481d2cc:	e59f3070 	ldr	r3, [pc, #112]	; 3481d344 <eth_write_hwaddr+0x17c>
3481d2d0:	e3560000 	cmp	r6, #0
3481d2d4:	e59f106c 	ldr	r1, [pc, #108]	; 3481d348 <eth_write_hwaddr+0x180>
3481d2d8:	e1a02006 	mov	r2, r6
3481d2dc:	11a01003 	movne	r1, r3
3481d2e0:	e1a0000d 	mov	r0, sp
3481d2e4:	ebfff2e9 	bl	34819e90 <sprintf>
	return ((skip_state = getenv(enetvar)) != NULL);
3481d2e8:	e1a0000d 	mov	r0, sp
3481d2ec:	ebffabd2 	bl	3480823c <getenv>
					     dev->enetaddr);
		printf("\nWarning: %s using MAC address from net device\n",
			dev->name);
	}

	if (dev->write_hwaddr &&
3481d2f0:	e3500000 	cmp	r0, #0

static int eth_mac_skip(int index)
{
	char enetvar[15];
	char *skip_state;
	sprintf(enetvar, index ? "eth%dmacskip" : "ethmacskip", index);
3481d2f4:	e1a0500d 	mov	r5, sp

int eth_write_hwaddr(struct eth_device *dev, const char *base_name,
		   int eth_number)
{
	unsigned char env_enetaddr[6];
	int ret = 0;
3481d2f8:	13a00000 	movne	r0, #0
					     dev->enetaddr);
		printf("\nWarning: %s using MAC address from net device\n",
			dev->name);
	}

	if (dev->write_hwaddr &&
3481d2fc:	1a000007 	bne	3481d320 <eth_write_hwaddr+0x158>
			!eth_mac_skip(eth_number)) {
		if (!is_valid_ether_addr(dev->enetaddr))
3481d300:	e2840010 	add	r0, r4, #16
3481d304:	ebffff09 	bl	3481cf30 <is_valid_ether_addr>
3481d308:	e3500000 	cmp	r0, #0
			return -1;
3481d30c:	03e00000 	mvneq	r0, #0
			dev->name);
	}

	if (dev->write_hwaddr &&
			!eth_mac_skip(eth_number)) {
		if (!is_valid_ether_addr(dev->enetaddr))
3481d310:	0a000002 	beq	3481d320 <eth_write_hwaddr+0x158>
			return -1;

		ret = dev->write_hwaddr(dev);
3481d314:	e5943030 	ldr	r3, [r4, #48]	; 0x30
3481d318:	e1a00004 	mov	r0, r4
3481d31c:	e12fff33 	blx	r3
	}

	return ret;
}
3481d320:	e28dd028 	add	sp, sp, #40	; 0x28
3481d324:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
3481d328:	34822ae4 	.word	0x34822ae4
3481d32c:	34827c02 	.word	0x34827c02
3481d330:	34827c2b 	.word	0x34827c2b
3481d334:	34827c4b 	.word	0x34827c4b
3481d338:	34827bd4 	.word	0x34827bd4
3481d33c:	34827bdd 	.word	0x34827bdd
3481d340:	34827c6b 	.word	0x34827c6b
3481d344:	34827bea 	.word	0x34827bea
3481d348:	34827bf7 	.word	0x34827bf7

3481d34c <eth_register>:

int eth_register(struct eth_device *dev)
{
3481d34c:	e92d4010 	push	{r4, lr}
3481d350:	e1a04000 	mov	r4, r0
	struct eth_device *d;
	static int index;

	assert(strlen(dev->name) < sizeof(dev->name));
3481d354:	ebffee09 	bl	34818b80 <strlen>

	if (!eth_devices) {
3481d358:	e59f3058 	ldr	r3, [pc, #88]	; 3481d3b8 <eth_register+0x6c>
3481d35c:	e5932004 	ldr	r2, [r3, #4]
3481d360:	e3520000 	cmp	r2, #0
3481d364:	11a03002 	movne	r3, r2
3481d368:	1a000004 	bne	3481d380 <eth_register+0x34>
		eth_current = eth_devices = dev;
3481d36c:	e5834004 	str	r4, [r3, #4]
3481d370:	e5834000 	str	r4, [r3]
		eth_current_changed();
3481d374:	ebffff01 	bl	3481cf80 <eth_current_changed>
3481d378:	ea000004 	b	3481d390 <eth_register+0x44>
	} else {
		for (d = eth_devices; d->next != eth_devices; d = d->next)
3481d37c:	e1a03001 	mov	r3, r1
3481d380:	e5931034 	ldr	r1, [r3, #52]	; 0x34
3481d384:	e1510002 	cmp	r1, r2
3481d388:	1afffffb 	bne	3481d37c <eth_register+0x30>
			;
		d->next = dev;
3481d38c:	e5834034 	str	r4, [r3, #52]	; 0x34
	}

	dev->state = ETH_STATE_INIT;
	dev->next  = eth_devices;
3481d390:	e59f3020 	ldr	r3, [pc, #32]	; 3481d3b8 <eth_register+0x6c>
		for (d = eth_devices; d->next != eth_devices; d = d->next)
			;
		d->next = dev;
	}

	dev->state = ETH_STATE_INIT;
3481d394:	e3a00000 	mov	r0, #0
	dev->next  = eth_devices;
3481d398:	e5932004 	ldr	r2, [r3, #4]
		for (d = eth_devices; d->next != eth_devices; d = d->next)
			;
		d->next = dev;
	}

	dev->state = ETH_STATE_INIT;
3481d39c:	e584001c 	str	r0, [r4, #28]
	dev->next  = eth_devices;
3481d3a0:	e5842034 	str	r2, [r4, #52]	; 0x34
	dev->index = index++;
3481d3a4:	e5932008 	ldr	r2, [r3, #8]
3481d3a8:	e5842038 	str	r2, [r4, #56]	; 0x38
3481d3ac:	e2822001 	add	r2, r2, #1
3481d3b0:	e5832008 	str	r2, [r3, #8]

	return 0;
}
3481d3b4:	e8bd8010 	pop	{r4, pc}
3481d3b8:	3482b9bc 	.word	0x3482b9bc

3481d3bc <eth_unregister>:

int eth_unregister(struct eth_device *dev)
{
3481d3bc:	e92d4008 	push	{r3, lr}
	struct eth_device *cur;

	/* No device */
	if (!eth_devices)
3481d3c0:	e59f308c 	ldr	r3, [pc, #140]	; 3481d454 <eth_unregister+0x98>
3481d3c4:	e5933004 	ldr	r3, [r3, #4]
3481d3c8:	e3530000 	cmp	r3, #0
3481d3cc:	11a01003 	movne	r1, r3
3481d3d0:	0a00001b 	beq	3481d444 <eth_unregister+0x88>
3481d3d4:	ea000000 	b	3481d3dc <eth_unregister+0x20>
		return -1;

	for (cur = eth_devices; cur->next != eth_devices && cur->next != dev;
3481d3d8:	e1a01002 	mov	r1, r2
3481d3dc:	e5912034 	ldr	r2, [r1, #52]	; 0x34
3481d3e0:	e1520003 	cmp	r2, r3
3481d3e4:	0a000002 	beq	3481d3f4 <eth_unregister+0x38>
3481d3e8:	e1520000 	cmp	r2, r0
3481d3ec:	1afffff9 	bne	3481d3d8 <eth_unregister+0x1c>
3481d3f0:	ea000001 	b	3481d3fc <eth_unregister+0x40>
	     cur = cur->next)
		;

	/* Device not found */
	if (cur->next != dev)
3481d3f4:	e1530000 	cmp	r3, r0
3481d3f8:	1a000011 	bne	3481d444 <eth_unregister+0x88>
		return -1;

	cur->next = dev->next;
3481d3fc:	e592c034 	ldr	ip, [r2, #52]	; 0x34

	if (eth_devices == dev)
3481d400:	e1530002 	cmp	r3, r2

	/* Device not found */
	if (cur->next != dev)
		return -1;

	cur->next = dev->next;
3481d404:	e581c034 	str	ip, [r1, #52]	; 0x34

	if (eth_devices == dev)
3481d408:	1a000004 	bne	3481d420 <eth_unregister+0x64>
		eth_devices = dev->next == eth_devices ? NULL : dev->next;
3481d40c:	e5932034 	ldr	r2, [r3, #52]	; 0x34
3481d410:	e1520003 	cmp	r2, r3
3481d414:	e59f3038 	ldr	r3, [pc, #56]	; 3481d454 <eth_unregister+0x98>
3481d418:	03a02000 	moveq	r2, #0
3481d41c:	e5832004 	str	r2, [r3, #4]

	if (eth_current == dev) {
3481d420:	e59f302c 	ldr	r3, [pc, #44]	; 3481d454 <eth_unregister+0x98>
3481d424:	e5932000 	ldr	r2, [r3]
3481d428:	e1520000 	cmp	r2, r0
3481d42c:	1a000006 	bne	3481d44c <eth_unregister+0x90>
		eth_current = eth_devices;
3481d430:	e5932004 	ldr	r2, [r3, #4]
3481d434:	e5832000 	str	r2, [r3]
		eth_current_changed();
3481d438:	ebfffed0 	bl	3481cf80 <eth_current_changed>
	}

	return 0;
3481d43c:	e3a00000 	mov	r0, #0
3481d440:	e8bd8008 	pop	{r3, pc}
	     cur = cur->next)
		;

	/* Device not found */
	if (cur->next != dev)
		return -1;
3481d444:	e3e00000 	mvn	r0, #0
3481d448:	e8bd8008 	pop	{r3, pc}
	if (eth_current == dev) {
		eth_current = eth_devices;
		eth_current_changed();
	}

	return 0;
3481d44c:	e3a00000 	mov	r0, #0
}
3481d450:	e8bd8008 	pop	{r3, pc}
3481d454:	3482b9bc 	.word	0x3482b9bc

3481d458 <eth_initialize>:
	if ((s = getenv("bootfile")) != NULL)
		copy_filename(BootFile, s, sizeof(BootFile));
}

int eth_initialize(bd_t *bis)
{
3481d458:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
	int num_devices = 0;
	eth_devices = NULL;
3481d45c:	e59f3170 	ldr	r3, [pc, #368]	; 3481d5d4 <eth_initialize+0x17c>
3481d460:	e3a02000 	mov	r2, #0
3481d464:	e5832004 	str	r2, [r3, #4]
	eth_current = NULL;
3481d468:	e5832000 	str	r2, [r3]
	if ((s = getenv("bootfile")) != NULL)
		copy_filename(BootFile, s, sizeof(BootFile));
}

int eth_initialize(bd_t *bis)
{
3481d46c:	e1a04000 	mov	r4, r0
3481d470:	e3a00040 	mov	r0, #64	; 0x40
3481d474:	ebffbf2b 	bl	3480d128 <__show_boot_progress>

static void eth_env_init(bd_t *bis)
{
	const char *s;

	if ((s = getenv("bootfile")) != NULL)
3481d478:	e59f0158 	ldr	r0, [pc, #344]	; 3481d5d8 <eth_initialize+0x180>
3481d47c:	ebffab6e 	bl	3480823c <getenv>
3481d480:	e2501000 	subs	r1, r0, #0
3481d484:	0a000002 	beq	3481d494 <eth_initialize+0x3c>
		copy_filename(BootFile, s, sizeof(BootFile));
3481d488:	e59f014c 	ldr	r0, [pc, #332]	; 3481d5dc <eth_initialize+0x184>
3481d48c:	e3a02080 	mov	r2, #128	; 0x80
3481d490:	eb000332 	bl	3481e160 <copy_filename>

	/*
	 * If board-specific initialization exists, call it.
	 * If not, call a CPU-specific one
	 */
	if (board_eth_init != __def_eth_init) {
3481d494:	e59f3144 	ldr	r3, [pc, #324]	; 3481d5e0 <eth_initialize+0x188>
3481d498:	e59f2144 	ldr	r2, [pc, #324]	; 3481d5e4 <eth_initialize+0x18c>
3481d49c:	e1530002 	cmp	r3, r2
3481d4a0:	0a000005 	beq	3481d4bc <eth_initialize+0x64>
		if (board_eth_init(bis) < 0)
3481d4a4:	e1a00004 	mov	r0, r4
3481d4a8:	ebff8e20 	bl	34800d30 <board_eth_init>
3481d4ac:	e3500000 	cmp	r0, #0
			printf("Board Net Initialization Failed\n");
3481d4b0:	b59f0130 	ldrlt	r0, [pc, #304]	; 3481d5e8 <eth_initialize+0x190>
	/*
	 * If board-specific initialization exists, call it.
	 * If not, call a CPU-specific one
	 */
	if (board_eth_init != __def_eth_init) {
		if (board_eth_init(bis) < 0)
3481d4b4:	aa00000b 	bge	3481d4e8 <eth_initialize+0x90>
3481d4b8:	ea000009 	b	3481d4e4 <eth_initialize+0x8c>
			printf("Board Net Initialization Failed\n");
	} else if (cpu_eth_init != __def_eth_init) {
3481d4bc:	e59f2128 	ldr	r2, [pc, #296]	; 3481d5ec <eth_initialize+0x194>
3481d4c0:	e1520003 	cmp	r2, r3
3481d4c4:	0a000005 	beq	3481d4e0 <eth_initialize+0x88>
		if (cpu_eth_init(bis) < 0)
3481d4c8:	e1a00004 	mov	r0, r4
3481d4cc:	ebfffea9 	bl	3481cf78 <cpu_eth_init>
3481d4d0:	e3500000 	cmp	r0, #0
			printf("CPU Net Initialization Failed\n");
3481d4d4:	b59f0114 	ldrlt	r0, [pc, #276]	; 3481d5f0 <eth_initialize+0x198>
	 */
	if (board_eth_init != __def_eth_init) {
		if (board_eth_init(bis) < 0)
			printf("Board Net Initialization Failed\n");
	} else if (cpu_eth_init != __def_eth_init) {
		if (cpu_eth_init(bis) < 0)
3481d4d8:	aa000002 	bge	3481d4e8 <eth_initialize+0x90>
3481d4dc:	ea000000 	b	3481d4e4 <eth_initialize+0x8c>
			printf("CPU Net Initialization Failed\n");
	} else
		printf("Net Initialization Skipped\n");
3481d4e0:	e59f010c 	ldr	r0, [pc, #268]	; 3481d5f4 <eth_initialize+0x19c>
3481d4e4:	ebffae98 	bl	34808f4c <printf>

	if (!eth_devices) {
3481d4e8:	e59f60e4 	ldr	r6, [pc, #228]	; 3481d5d4 <eth_initialize+0x17c>
3481d4ec:	e5964004 	ldr	r4, [r6, #4]
3481d4f0:	e3540000 	cmp	r4, #0
3481d4f4:	1a000005 	bne	3481d510 <eth_initialize+0xb8>
		puts("No ethernet found.\n");
3481d4f8:	e59f00f8 	ldr	r0, [pc, #248]	; 3481d5f8 <eth_initialize+0x1a0>
3481d4fc:	ebffae88 	bl	34808f24 <puts>
	return 0;
}

static inline ulong bootstage_error(enum bootstage_id id)
{
	show_boot_progress(-id);
3481d500:	e3e0003f 	mvn	r0, #63	; 0x3f
3481d504:	ebffbf07 	bl	3480d128 <__show_boot_progress>
		copy_filename(BootFile, s, sizeof(BootFile));
}

int eth_initialize(bd_t *bis)
{
	int num_devices = 0;
3481d508:	e1a05004 	mov	r5, r4
3481d50c:	ea00002e 	b	3481d5cc <eth_initialize+0x174>
	if (!eth_devices) {
		puts("No ethernet found.\n");
		bootstage_error(BOOTSTAGE_ID_NET_ETH_START);
	} else {
		struct eth_device *dev = eth_devices;
		char *ethprime = getenv("ethprime");
3481d510:	e59f00e4 	ldr	r0, [pc, #228]	; 3481d5fc <eth_initialize+0x1a4>
3481d514:	ebffab48 	bl	3480823c <getenv>
3481d518:	e1a07000 	mov	r7, r0
 * and won't even do that unless CONFIG_SHOW_BOOT_PROGRESS is defined
 */

static inline ulong bootstage_mark(enum bootstage_id id)
{
	show_boot_progress(id);
3481d51c:	e3a00041 	mov	r0, #65	; 0x41
3481d520:	ebffbf00 	bl	3480d128 <__show_boot_progress>
		copy_filename(BootFile, s, sizeof(BootFile));
}

int eth_initialize(bd_t *bis)
{
	int num_devices = 0;
3481d524:	e3a05000 	mov	r5, #0
		struct eth_device *dev = eth_devices;
		char *ethprime = getenv("ethprime");

		bootstage_mark(BOOTSTAGE_ID_NET_ETH_INIT);
		do {
			if (dev->index)
3481d528:	e5943038 	ldr	r3, [r4, #56]	; 0x38
3481d52c:	e3530000 	cmp	r3, #0
3481d530:	0a000001 	beq	3481d53c <eth_initialize+0xe4>
				puts(", ");
3481d534:	e59f00c4 	ldr	r0, [pc, #196]	; 3481d600 <eth_initialize+0x1a8>
3481d538:	ebffae79 	bl	34808f24 <puts>

			printf("%s", dev->name);
3481d53c:	e59f00c0 	ldr	r0, [pc, #192]	; 3481d604 <eth_initialize+0x1ac>
3481d540:	e1a01004 	mov	r1, r4
3481d544:	ebffae80 	bl	34808f4c <printf>

			if (ethprime && strcmp(dev->name, ethprime) == 0) {
3481d548:	e3570000 	cmp	r7, #0
3481d54c:	0a000007 	beq	3481d570 <eth_initialize+0x118>
3481d550:	e1a00004 	mov	r0, r4
3481d554:	e1a01007 	mov	r1, r7
3481d558:	ebffed54 	bl	34818ab0 <strcmp>
3481d55c:	e3500000 	cmp	r0, #0
3481d560:	1a000002 	bne	3481d570 <eth_initialize+0x118>
				eth_current = dev;
				puts(" [PRIME]");
3481d564:	e59f009c 	ldr	r0, [pc, #156]	; 3481d608 <eth_initialize+0x1b0>
				puts(", ");

			printf("%s", dev->name);

			if (ethprime && strcmp(dev->name, ethprime) == 0) {
				eth_current = dev;
3481d568:	e5864000 	str	r4, [r6]
				puts(" [PRIME]");
3481d56c:	ebffae6c 	bl	34808f24 <puts>
			}

			if (strchr(dev->name, ' '))
3481d570:	e1a00004 	mov	r0, r4
3481d574:	e3a01020 	mov	r1, #32
3481d578:	ebffed6a 	bl	34818b28 <strchr>
3481d57c:	e3500000 	cmp	r0, #0
3481d580:	0a000001 	beq	3481d58c <eth_initialize+0x134>
				puts("\nWarning: eth device name has a space!"
3481d584:	e59f0080 	ldr	r0, [pc, #128]	; 3481d60c <eth_initialize+0x1b4>
3481d588:	ebffae65 	bl	34808f24 <puts>
					"\n");

			if (eth_write_hwaddr(dev, "eth", dev->index))
3481d58c:	e1a00004 	mov	r0, r4
3481d590:	e59f1078 	ldr	r1, [pc, #120]	; 3481d610 <eth_initialize+0x1b8>
3481d594:	e5942038 	ldr	r2, [r4, #56]	; 0x38
3481d598:	ebffff0a 	bl	3481d1c8 <eth_write_hwaddr>
3481d59c:	e3500000 	cmp	r0, #0
3481d5a0:	0a000001 	beq	3481d5ac <eth_initialize+0x154>
				puts("\nWarning: failed to set MAC address\n");
3481d5a4:	e59f0068 	ldr	r0, [pc, #104]	; 3481d614 <eth_initialize+0x1bc>
3481d5a8:	ebffae5d 	bl	34808f24 <puts>

			dev = dev->next;
3481d5ac:	e5944034 	ldr	r4, [r4, #52]	; 0x34
			num_devices++;
		} while (dev != eth_devices);
3481d5b0:	e5963004 	ldr	r3, [r6, #4]

			if (eth_write_hwaddr(dev, "eth", dev->index))
				puts("\nWarning: failed to set MAC address\n");

			dev = dev->next;
			num_devices++;
3481d5b4:	e2855001 	add	r5, r5, #1
		} while (dev != eth_devices);
3481d5b8:	e1540003 	cmp	r4, r3
3481d5bc:	1affffd9 	bne	3481d528 <eth_initialize+0xd0>

		eth_current_changed();
3481d5c0:	ebfffe6e 	bl	3481cf80 <eth_current_changed>
		putc('\n');
3481d5c4:	e3a0000a 	mov	r0, #10
3481d5c8:	ebffae4b 	bl	34808efc <putc>
	}

	return num_devices;
}
3481d5cc:	e1a00005 	mov	r0, r5
3481d5d0:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
3481d5d4:	3482b9bc 	.word	0x3482b9bc
3481d5d8:	3482575a 	.word	0x3482575a
3481d5dc:	3482d914 	.word	0x3482d914
3481d5e0:	34800d30 	.word	0x34800d30
3481d5e4:	3481cf78 	.word	0x3481cf78
3481d5e8:	34827c9b 	.word	0x34827c9b
3481d5ec:	3481cf78 	.word	0x3481cf78
3481d5f0:	34827cbc 	.word	0x34827cbc
3481d5f4:	34827cdb 	.word	0x34827cdb
3481d5f8:	34827e23 	.word	0x34827e23
3481d5fc:	34827cf7 	.word	0x34827cf7
3481d600:	34827d00 	.word	0x34827d00
3481d604:	34824dd1 	.word	0x34824dd1
3481d608:	34827d03 	.word	0x34827d03
3481d60c:	34827d0c 	.word	0x34827d0c
3481d610:	34827d34 	.word	0x34827d34
3481d614:	34827d38 	.word	0x34827d38

3481d618 <eth_halt>:

	return -1;
}

void eth_halt(void)
{
3481d618:	e92d4010 	push	{r4, lr}
	if (!eth_current)
3481d61c:	e59f4020 	ldr	r4, [pc, #32]	; 3481d644 <eth_halt+0x2c>
3481d620:	e5940000 	ldr	r0, [r4]
3481d624:	e3500000 	cmp	r0, #0
3481d628:	08bd8010 	popeq	{r4, pc}
		return;

	eth_current->halt(eth_current);
3481d62c:	e590302c 	ldr	r3, [r0, #44]	; 0x2c
3481d630:	e12fff33 	blx	r3

	eth_current->state = ETH_STATE_PASSIVE;
3481d634:	e5943000 	ldr	r3, [r4]
3481d638:	e3a02001 	mov	r2, #1
3481d63c:	e583201c 	str	r2, [r3, #28]
3481d640:	e8bd8010 	pop	{r4, pc}
3481d644:	3482b9bc 	.word	0x3482b9bc

3481d648 <eth_send>:
}

int eth_send(void *packet, int length)
{
3481d648:	e92d4008 	push	{r3, lr}
	if (!eth_current)
3481d64c:	e59f3028 	ldr	r3, [pc, #40]	; 3481d67c <eth_send+0x34>

	eth_current->state = ETH_STATE_PASSIVE;
}

int eth_send(void *packet, int length)
{
3481d650:	e1a0c000 	mov	ip, r0
	if (!eth_current)
3481d654:	e5930000 	ldr	r0, [r3]

	eth_current->state = ETH_STATE_PASSIVE;
}

int eth_send(void *packet, int length)
{
3481d658:	e1a02001 	mov	r2, r1
	if (!eth_current)
3481d65c:	e3500000 	cmp	r0, #0
3481d660:	0a000003 	beq	3481d674 <eth_send+0x2c>
		return -1;

	return eth_current->send(eth_current, packet, length);
3481d664:	e5903024 	ldr	r3, [r0, #36]	; 0x24
3481d668:	e1a0100c 	mov	r1, ip
3481d66c:	e12fff33 	blx	r3
3481d670:	e8bd8008 	pop	{r3, pc}
}

int eth_send(void *packet, int length)
{
	if (!eth_current)
		return -1;
3481d674:	e3e00000 	mvn	r0, #0

	return eth_current->send(eth_current, packet, length);
}
3481d678:	e8bd8008 	pop	{r3, pc}
3481d67c:	3482b9bc 	.word	0x3482b9bc

3481d680 <eth_rx>:

int eth_rx(void)
{
3481d680:	e92d4008 	push	{r3, lr}
	if (!eth_current)
3481d684:	e59f301c 	ldr	r3, [pc, #28]	; 3481d6a8 <eth_rx+0x28>
3481d688:	e5930000 	ldr	r0, [r3]
3481d68c:	e3500000 	cmp	r0, #0
3481d690:	0a000002 	beq	3481d6a0 <eth_rx+0x20>
		return -1;

	return eth_current->recv(eth_current);
3481d694:	e5903028 	ldr	r3, [r0, #40]	; 0x28
3481d698:	e12fff33 	blx	r3
3481d69c:	e8bd8008 	pop	{r3, pc}
}

int eth_rx(void)
{
	if (!eth_current)
		return -1;
3481d6a0:	e3e00000 	mvn	r0, #0

	return eth_current->recv(eth_current);
}
3481d6a4:	e8bd8008 	pop	{r3, pc}
3481d6a8:	3482b9bc 	.word	0x3482b9bc

3481d6ac <eth_try_another>:
	return length;
}
#endif /* CONFIG_API */

void eth_try_another(int first_restart)
{
3481d6ac:	e92d4010 	push	{r4, lr}
3481d6b0:	e1a04000 	mov	r4, r0

	/*
	 * Do not rotate between network interfaces when
	 * 'ethrotate' variable is set to 'no'.
	 */
	ethrotate = getenv("ethrotate");
3481d6b4:	e59f005c 	ldr	r0, [pc, #92]	; 3481d718 <eth_try_another+0x6c>
3481d6b8:	ebffaadf 	bl	3480823c <getenv>
	if ((ethrotate != NULL) && (strcmp(ethrotate, "no") == 0))
3481d6bc:	e3500000 	cmp	r0, #0
3481d6c0:	0a000003 	beq	3481d6d4 <eth_try_another+0x28>
3481d6c4:	e59f1050 	ldr	r1, [pc, #80]	; 3481d71c <eth_try_another+0x70>
3481d6c8:	ebffecf8 	bl	34818ab0 <strcmp>
3481d6cc:	e3500000 	cmp	r0, #0
3481d6d0:	08bd8010 	popeq	{r4, pc}
		return;

	if (!eth_current)
3481d6d4:	e59f2044 	ldr	r2, [pc, #68]	; 3481d720 <eth_try_another+0x74>
3481d6d8:	e5923000 	ldr	r3, [r2]
3481d6dc:	e3530000 	cmp	r3, #0
3481d6e0:	08bd8010 	popeq	{r4, pc}
		return;

	if (first_restart)
3481d6e4:	e3540000 	cmp	r4, #0
		first_failed = eth_current;
3481d6e8:	1582300c 	strne	r3, [r2, #12]

	eth_current = eth_current->next;
3481d6ec:	e59f402c 	ldr	r4, [pc, #44]	; 3481d720 <eth_try_another+0x74>
3481d6f0:	e5933034 	ldr	r3, [r3, #52]	; 0x34
3481d6f4:	e5843000 	str	r3, [r4]

	eth_current_changed();
3481d6f8:	ebfffe20 	bl	3481cf80 <eth_current_changed>

	if (first_failed == eth_current)
3481d6fc:	e594200c 	ldr	r2, [r4, #12]
3481d700:	e5943000 	ldr	r3, [r4]
3481d704:	e1520003 	cmp	r2, r3
		NetRestartWrap = 1;
3481d708:	059f3014 	ldreq	r3, [pc, #20]	; 3481d724 <eth_try_another+0x78>
3481d70c:	03a02001 	moveq	r2, #1
3481d710:	05832000 	streq	r2, [r3]
3481d714:	e8bd8010 	pop	{r4, pc}
3481d718:	34827d5d 	.word	0x34827d5d
3481d71c:	3482350b 	.word	0x3482350b
3481d720:	3482b9bc 	.word	0x3482b9bc
3481d724:	3482b9f4 	.word	0x3482b9f4

3481d728 <eth_init>:

#endif


int eth_init(bd_t *bis)
{
3481d728:	e92d40f7 	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	struct eth_device *old_current, *dev;

	if (!eth_current) {
3481d72c:	e59f70ac 	ldr	r7, [pc, #172]	; 3481d7e0 <eth_init+0xb8>

#endif


int eth_init(bd_t *bis)
{
3481d730:	e1a06000 	mov	r6, r0
	struct eth_device *old_current, *dev;

	if (!eth_current) {
3481d734:	e5973000 	ldr	r3, [r7]
3481d738:	e3530000 	cmp	r3, #0
		puts("No ethernet found.\n");
		return -1;
	}

	/* Sync environment with network devices */
	dev = eth_devices;
3481d73c:	15974004 	ldrne	r4, [r7, #4]

int eth_init(bd_t *bis)
{
	struct eth_device *old_current, *dev;

	if (!eth_current) {
3481d740:	1a000002 	bne	3481d750 <eth_init+0x28>
		puts("No ethernet found.\n");
3481d744:	e59f0098 	ldr	r0, [pc, #152]	; 3481d7e4 <eth_init+0xbc>
3481d748:	ebffadf5 	bl	34808f24 <puts>
3481d74c:	ea000021 	b	3481d7d8 <eth_init+0xb0>
	/* Sync environment with network devices */
	dev = eth_devices;
	do {
		uchar env_enetaddr[6];

		if (eth_getenv_enetaddr_by_index("eth", dev->index,
3481d750:	e59f0090 	ldr	r0, [pc, #144]	; 3481d7e8 <eth_init+0xc0>
3481d754:	e5941038 	ldr	r1, [r4, #56]	; 0x38
3481d758:	e1a0200d 	mov	r2, sp
3481d75c:	ebfffe4b 	bl	3481d090 <eth_getenv_enetaddr_by_index>
3481d760:	e3500000 	cmp	r0, #0
3481d764:	0a000003 	beq	3481d778 <eth_init+0x50>
						 env_enetaddr))
			memcpy(dev->enetaddr, env_enetaddr, 6);
3481d768:	e2840010 	add	r0, r4, #16
3481d76c:	e1a0100d 	mov	r1, sp
3481d770:	e3a02006 	mov	r2, #6
3481d774:	ebffedc5 	bl	34818e90 <memcpy>

		dev = dev->next;
3481d778:	e5944034 	ldr	r4, [r4, #52]	; 0x34
	} while (dev != eth_devices);
3481d77c:	e5972004 	ldr	r2, [r7, #4]
3481d780:	e59f3058 	ldr	r3, [pc, #88]	; 3481d7e0 <eth_init+0xb8>
3481d784:	e1540002 	cmp	r4, r2
3481d788:	1afffff0 	bne	3481d750 <eth_init+0x28>

	old_current = eth_current;
3481d78c:	e5935000 	ldr	r5, [r3]
	do {
		debug("Trying %s\n", eth_current->name);

		if (eth_current->init(eth_current, bis) >= 0) {
3481d790:	e1a04003 	mov	r4, r3
3481d794:	e5940000 	ldr	r0, [r4]
3481d798:	e1a01006 	mov	r1, r6
3481d79c:	e5903020 	ldr	r3, [r0, #32]
3481d7a0:	e12fff33 	blx	r3
3481d7a4:	e3500000 	cmp	r0, #0
3481d7a8:	ba000005 	blt	3481d7c4 <eth_init+0x9c>
			eth_current->state = ETH_STATE_ACTIVE;
3481d7ac:	e59f302c 	ldr	r3, [pc, #44]	; 3481d7e0 <eth_init+0xb8>
3481d7b0:	e3a02002 	mov	r2, #2
3481d7b4:	e5933000 	ldr	r3, [r3]

			return 0;
3481d7b8:	e3a00000 	mov	r0, #0
	old_current = eth_current;
	do {
		debug("Trying %s\n", eth_current->name);

		if (eth_current->init(eth_current, bis) >= 0) {
			eth_current->state = ETH_STATE_ACTIVE;
3481d7bc:	e583201c 	str	r2, [r3, #28]

			return 0;
3481d7c0:	ea000005 	b	3481d7dc <eth_init+0xb4>
		}
		debug("FAIL\n");

		eth_try_another(0);
3481d7c4:	e3a00000 	mov	r0, #0
3481d7c8:	ebffffb7 	bl	3481d6ac <eth_try_another>
	} while (old_current != eth_current);
3481d7cc:	e5943000 	ldr	r3, [r4]
3481d7d0:	e1550003 	cmp	r5, r3
3481d7d4:	1affffee 	bne	3481d794 <eth_init+0x6c>

	return -1;
3481d7d8:	e3e00000 	mvn	r0, #0
}
3481d7dc:	e8bd80fe 	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
3481d7e0:	3482b9bc 	.word	0x3482b9bc
3481d7e4:	34827e23 	.word	0x34827e23
3481d7e8:	34827d34 	.word	0x34827d34

3481d7ec <eth_set_current>:
	if (first_failed == eth_current)
		NetRestartWrap = 1;
}

void eth_set_current(void)
{
3481d7ec:	e92d4070 	push	{r4, r5, r6, lr}
	static char *act;
	static int  env_changed_id;
	struct eth_device *old_current;
	int	env_id;

	if (!eth_current)	/* XXX no current */
3481d7f0:	e59f4080 	ldr	r4, [pc, #128]	; 3481d878 <eth_set_current+0x8c>
3481d7f4:	e5943000 	ldr	r3, [r4]
3481d7f8:	e3530000 	cmp	r3, #0
3481d7fc:	08bd8070 	popeq	{r4, r5, r6, pc}
		return;

	env_id = get_env_id();
3481d800:	ebffa88f 	bl	34807a44 <get_env_id>
	if ((act == NULL) || (env_changed_id != env_id)) {
3481d804:	e5943010 	ldr	r3, [r4, #16]
	int	env_id;

	if (!eth_current)	/* XXX no current */
		return;

	env_id = get_env_id();
3481d808:	e1a05000 	mov	r5, r0
	if ((act == NULL) || (env_changed_id != env_id)) {
3481d80c:	e3530000 	cmp	r3, #0
3481d810:	0a000002 	beq	3481d820 <eth_set_current+0x34>
3481d814:	e5943014 	ldr	r3, [r4, #20]
3481d818:	e1530000 	cmp	r3, r0
3481d81c:	0a000004 	beq	3481d834 <eth_set_current+0x48>
		act = getenv("ethact");
3481d820:	e59f0054 	ldr	r0, [pc, #84]	; 3481d87c <eth_set_current+0x90>
3481d824:	ebffaa84 	bl	3480823c <getenv>
3481d828:	e59f3048 	ldr	r3, [pc, #72]	; 3481d878 <eth_set_current+0x8c>
3481d82c:	e5830010 	str	r0, [r3, #16]
		env_changed_id = env_id;
3481d830:	e5835014 	str	r5, [r3, #20]
	}
	if (act != NULL) {
3481d834:	e59f403c 	ldr	r4, [pc, #60]	; 3481d878 <eth_set_current+0x8c>
3481d838:	e5943010 	ldr	r3, [r4, #16]
3481d83c:	e3530000 	cmp	r3, #0
3481d840:	0a00000a 	beq	3481d870 <eth_set_current+0x84>
		old_current = eth_current;
3481d844:	e5945000 	ldr	r5, [r4]
		do {
			if (strcmp(eth_current->name, act) == 0)
3481d848:	e5940000 	ldr	r0, [r4]
3481d84c:	e5941010 	ldr	r1, [r4, #16]
3481d850:	ebffec96 	bl	34818ab0 <strcmp>
3481d854:	e3500000 	cmp	r0, #0
3481d858:	08bd8070 	popeq	{r4, r5, r6, pc}
				return;
			eth_current = eth_current->next;
3481d85c:	e5943000 	ldr	r3, [r4]
3481d860:	e5933034 	ldr	r3, [r3, #52]	; 0x34
		} while (old_current != eth_current);
3481d864:	e1550003 	cmp	r5, r3
	if (act != NULL) {
		old_current = eth_current;
		do {
			if (strcmp(eth_current->name, act) == 0)
				return;
			eth_current = eth_current->next;
3481d868:	e5843000 	str	r3, [r4]
		} while (old_current != eth_current);
3481d86c:	1afffff5 	bne	3481d848 <eth_set_current+0x5c>
	}

	eth_current_changed();
}
3481d870:	e8bd4070 	pop	{r4, r5, r6, lr}
				return;
			eth_current = eth_current->next;
		} while (old_current != eth_current);
	}

	eth_current_changed();
3481d874:	eafffdc1 	b	3481cf80 <eth_current_changed>
3481d878:	3482b9bc 	.word	0x3482b9bc
3481d87c:	34827bc9 	.word	0x34827bc9

3481d880 <eth_get_name>:
}

char *eth_get_name(void)
{
	return eth_current ? eth_current->name : "unknown";
3481d880:	e59f3010 	ldr	r3, [pc, #16]	; 3481d898 <eth_get_name+0x18>
3481d884:	e5930000 	ldr	r0, [r3]
}
3481d888:	e59f300c 	ldr	r3, [pc, #12]	; 3481d89c <eth_get_name+0x1c>
3481d88c:	e3500000 	cmp	r0, #0
3481d890:	01a00003 	moveq	r0, r3
3481d894:	e12fff1e 	bx	lr
3481d898:	3482b9bc 	.word	0x3482b9bc
3481d89c:	34827d67 	.word	0x34827d67

3481d8a0 <startAgainTimeout>:
static inline void net_set_state(enum net_loop_state state)
{
	extern enum net_loop_state net_state;

	debug_cond(DEBUG_INT_STATE, "--- NetState set to %d\n", state);
	net_state = state;
3481d8a0:	e59f3008 	ldr	r3, [pc, #8]	; 3481d8b0 <startAgainTimeout+0x10>
3481d8a4:	e3a02001 	mov	r2, #1
3481d8a8:	e5832000 	str	r2, [r3]

static void
startAgainTimeout(void)
{
	net_set_state(NETLOOP_RESTART);
}
3481d8ac:	e12fff1e 	bx	lr
3481d8b0:	3482b9d4 	.word	0x3482b9d4

3481d8b4 <dummy_handler>:

static void dummy_handler(uchar *pkt, unsigned dport,
			IPaddr_t sip, unsigned sport,
			unsigned len)
{
}
3481d8b4:	e12fff1e 	bx	lr

3481d8b8 <getenv_IPaddr>:
		int (*func)(unsigned long, unsigned long));

/* lib/net_utils.c */
#include <net.h>
static inline IPaddr_t getenv_IPaddr(char *var)
{
3481d8b8:	e92d4010 	push	{r4, lr}
	return string_to_ip(getenv(var));
3481d8bc:	ebffaa5e 	bl	3480823c <getenv>
}
3481d8c0:	e8bd4010 	pop	{r4, lr}

/* lib/net_utils.c */
#include <net.h>
static inline IPaddr_t getenv_IPaddr(char *var)
{
	return string_to_ip(getenv(var));
3481d8c4:	eaffebf0 	b	3481888c <string_to_ip>

3481d8c8 <net_auto_load>:
/*
 * Check if autoload is enabled. If so, use either NFS or TFTP to download
 * the boot file.
 */
void net_auto_load(void)
{
3481d8c8:	e92d4010 	push	{r4, lr}
	const char *s = getenv("autoload");
3481d8cc:	e59f0048 	ldr	r0, [pc, #72]	; 3481d91c <net_auto_load+0x54>
3481d8d0:	ebffaa59 	bl	3480823c <getenv>

	if (s != NULL) {
3481d8d4:	e2503000 	subs	r3, r0, #0
3481d8d8:	0a00000c 	beq	3481d910 <net_auto_load+0x48>
		if (*s == 'n') {
3481d8dc:	e5d33000 	ldrb	r3, [r3]
3481d8e0:	e353006e 	cmp	r3, #110	; 0x6e
3481d8e4:	1a000003 	bne	3481d8f8 <net_auto_load+0x30>
3481d8e8:	e59f3030 	ldr	r3, [pc, #48]	; 3481d920 <net_auto_load+0x58>
3481d8ec:	e3a02002 	mov	r2, #2
3481d8f0:	e5832000 	str	r2, [r3]
			return;
		}
#endif
	}
	TftpStart(TFTPGET);
}
3481d8f4:	e8bd8010 	pop	{r4, pc}
			 */
			net_set_state(NETLOOP_SUCCESS);
			return;
		}
#if defined(CONFIG_CMD_NFS)
		if (strcmp(s, "NFS") == 0) {
3481d8f8:	e59f1024 	ldr	r1, [pc, #36]	; 3481d924 <net_auto_load+0x5c>
3481d8fc:	ebffec6b 	bl	34818ab0 <strcmp>
3481d900:	e3500000 	cmp	r0, #0
3481d904:	1a000001 	bne	3481d910 <net_auto_load+0x48>
			return;
		}
#endif
	}
	TftpStart(TFTPGET);
}
3481d908:	e8bd4010 	pop	{r4, lr}
#if defined(CONFIG_CMD_NFS)
		if (strcmp(s, "NFS") == 0) {
			/*
			 * Use NFS to load the bootfile.
			 */
			NfsStart();
3481d90c:	ea00064a 	b	3481f23c <NfsStart>
			return;
		}
#endif
	}
	TftpStart(TFTPGET);
3481d910:	e3a00003 	mov	r0, #3
}
3481d914:	e8bd4010 	pop	{r4, lr}
			NfsStart();
			return;
		}
#endif
	}
	TftpStart(TFTPGET);
3481d918:	ea00089f 	b	3481fb9c <TftpStart>
3481d91c:	34827d6f 	.word	0x34827d6f
3481d920:	3482b9d4 	.word	0x3482b9d4
3481d924:	34827d78 	.word	0x34827d78

3481d928 <net_get_udp_handler>:
}

rxhand_f *net_get_udp_handler(void)
{
	return udp_packet_handler;
}
3481d928:	e59f3004 	ldr	r3, [pc, #4]	; 3481d934 <net_get_udp_handler+0xc>
3481d92c:	e5930004 	ldr	r0, [r3, #4]
3481d930:	e12fff1e 	bx	lr
3481d934:	3482b9d4 	.word	0x3482b9d4

3481d938 <net_set_udp_handler>:

void net_set_udp_handler(rxhand_f *f)
{
	debug_cond(DEBUG_INT_STATE, "--- NetLoop UDP handler set (%p)\n", f);
	if (f == NULL)
3481d938:	e3500000 	cmp	r0, #0
3481d93c:	e59f300c 	ldr	r3, [pc, #12]	; 3481d950 <net_set_udp_handler+0x18>
		udp_packet_handler = dummy_handler;
3481d940:	059f200c 	ldreq	r2, [pc, #12]	; 3481d954 <net_set_udp_handler+0x1c>
	else
		udp_packet_handler = f;
3481d944:	15830004 	strne	r0, [r3, #4]

void net_set_udp_handler(rxhand_f *f)
{
	debug_cond(DEBUG_INT_STATE, "--- NetLoop UDP handler set (%p)\n", f);
	if (f == NULL)
		udp_packet_handler = dummy_handler;
3481d948:	05832004 	streq	r2, [r3, #4]
3481d94c:	e12fff1e 	bx	lr
3481d950:	3482b9d4 	.word	0x3482b9d4
3481d954:	3481d8b4 	.word	0x3481d8b4

3481d958 <net_get_arp_handler>:
}

rxhand_f *net_get_arp_handler(void)
{
	return arp_packet_handler;
}
3481d958:	e59f3004 	ldr	r3, [pc, #4]	; 3481d964 <net_get_arp_handler+0xc>
3481d95c:	e5930008 	ldr	r0, [r3, #8]
3481d960:	e12fff1e 	bx	lr
3481d964:	3482b9d4 	.word	0x3482b9d4

3481d968 <net_set_arp_handler>:

void net_set_arp_handler(rxhand_f *f)
{
	debug_cond(DEBUG_INT_STATE, "--- NetLoop ARP handler set (%p)\n", f);
	if (f == NULL)
3481d968:	e3500000 	cmp	r0, #0
3481d96c:	e59f300c 	ldr	r3, [pc, #12]	; 3481d980 <net_set_arp_handler+0x18>
		arp_packet_handler = dummy_handler;
3481d970:	059f200c 	ldreq	r2, [pc, #12]	; 3481d984 <net_set_arp_handler+0x1c>
	else
		arp_packet_handler = f;
3481d974:	15830008 	strne	r0, [r3, #8]

void net_set_arp_handler(rxhand_f *f)
{
	debug_cond(DEBUG_INT_STATE, "--- NetLoop ARP handler set (%p)\n", f);
	if (f == NULL)
		arp_packet_handler = dummy_handler;
3481d978:	05832008 	streq	r2, [r3, #8]
3481d97c:	e12fff1e 	bx	lr
3481d980:	3482b9d4 	.word	0x3482b9d4
3481d984:	3481d8b4 	.word	0x3481d8b4

3481d988 <NetSetTimeout>:
}
#endif

void
NetSetTimeout(ulong iv, thand_f *f)
{
3481d988:	e92d4038 	push	{r3, r4, r5, lr}
3481d98c:	e59f402c 	ldr	r4, [pc, #44]	; 3481d9c0 <NetSetTimeout+0x38>
	if (iv == 0) {
3481d990:	e2505000 	subs	r5, r0, #0
		debug_cond(DEBUG_INT_STATE,
			"--- NetLoop timeout handler cancelled\n");
		timeHandler = (thand_f *)0;
3481d994:	0584500c 	streq	r5, [r4, #12]
#endif

void
NetSetTimeout(ulong iv, thand_f *f)
{
	if (iv == 0) {
3481d998:	08bd8038 	popeq	{r3, r4, r5, pc}
		timeHandler = (thand_f *)0;
	} else {
		debug_cond(DEBUG_INT_STATE,
			"--- NetLoop timeout handler set (%p)\n", f);
		timeHandler = f;
		timeStart = get_timer(0);
3481d99c:	e3a00000 	mov	r0, #0
			"--- NetLoop timeout handler cancelled\n");
		timeHandler = (thand_f *)0;
	} else {
		debug_cond(DEBUG_INT_STATE,
			"--- NetLoop timeout handler set (%p)\n", f);
		timeHandler = f;
3481d9a0:	e584100c 	str	r1, [r4, #12]
		timeStart = get_timer(0);
3481d9a4:	ebff8e2a 	bl	34801254 <get_timer>
		timeDelta = iv * CONFIG_SYS_HZ / 1000;
3481d9a8:	e3a01ffa 	mov	r1, #1000	; 0x3e8
		timeHandler = (thand_f *)0;
	} else {
		debug_cond(DEBUG_INT_STATE,
			"--- NetLoop timeout handler set (%p)\n", f);
		timeHandler = f;
		timeStart = get_timer(0);
3481d9ac:	e5840010 	str	r0, [r4, #16]
		timeDelta = iv * CONFIG_SYS_HZ / 1000;
3481d9b0:	e0000591 	mul	r0, r1, r5
3481d9b4:	eb00093a 	bl	3481fea4 <__udivsi3>
3481d9b8:	e5840014 	str	r0, [r4, #20]
3481d9bc:	e8bd8038 	pop	{r3, r4, r5, pc}
3481d9c0:	3482b9d4 	.word	0x3482b9d4

3481d9c4 <NetStartAgain>:
{
	net_set_state(NETLOOP_RESTART);
}

void NetStartAgain(void)
{
3481d9c4:	e92d4070 	push	{r4, r5, r6, lr}
	char *nretry;
	int retry_forever = 0;
	unsigned long retrycnt = 0;

	nretry = getenv("netretry");
3481d9c8:	e59f00e8 	ldr	r0, [pc, #232]	; 3481dab8 <NetStartAgain+0xf4>
3481d9cc:	ebffaa1a 	bl	3480823c <getenv>
	if (nretry) {
3481d9d0:	e2504000 	subs	r4, r0, #0
3481d9d4:	0a00001a 	beq	3481da44 <NetStartAgain+0x80>
		if (!strcmp(nretry, "yes"))
3481d9d8:	e59f10dc 	ldr	r1, [pc, #220]	; 3481dabc <NetStartAgain+0xf8>
3481d9dc:	ebffec33 	bl	34818ab0 <strcmp>
3481d9e0:	e3500000 	cmp	r0, #0
3481d9e4:	0a000016 	beq	3481da44 <NetStartAgain+0x80>
			retry_forever = 1;
		else if (!strcmp(nretry, "no"))
3481d9e8:	e1a00004 	mov	r0, r4
3481d9ec:	e59f10cc 	ldr	r1, [pc, #204]	; 3481dac0 <NetStartAgain+0xfc>
3481d9f0:	ebffec2e 	bl	34818ab0 <strcmp>
3481d9f4:	e3500000 	cmp	r0, #0
3481d9f8:	0a000009 	beq	3481da24 <NetStartAgain+0x60>
			retrycnt = 0;
		else if (!strcmp(nretry, "once"))
3481d9fc:	e1a00004 	mov	r0, r4
3481da00:	e59f10bc 	ldr	r1, [pc, #188]	; 3481dac4 <NetStartAgain+0x100>
3481da04:	ebffec29 	bl	34818ab0 <strcmp>
3481da08:	e3500000 	cmp	r0, #0
			retrycnt = 1;
3481da0c:	03a00001 	moveq	r0, #1
	if (nretry) {
		if (!strcmp(nretry, "yes"))
			retry_forever = 1;
		else if (!strcmp(nretry, "no"))
			retrycnt = 0;
		else if (!strcmp(nretry, "once"))
3481da10:	0a000003 	beq	3481da24 <NetStartAgain+0x60>
			retrycnt = 1;
		else
			retrycnt = simple_strtoul(nretry, NULL, 0);
3481da14:	e3a01000 	mov	r1, #0
3481da18:	e1a00004 	mov	r0, r4
3481da1c:	e1a02001 	mov	r2, r1
3481da20:	ebfff074 	bl	34819bf8 <simple_strtoul>
	} else
		retry_forever = 1;

	if ((!retry_forever) && (NetTryCount >= retrycnt)) {
3481da24:	e59f409c 	ldr	r4, [pc, #156]	; 3481dac8 <NetStartAgain+0x104>
3481da28:	e5943018 	ldr	r3, [r4, #24]
3481da2c:	e1530000 	cmp	r3, r0
3481da30:	3a000003 	bcc	3481da44 <NetStartAgain+0x80>
		eth_halt();
3481da34:	ebfffef7 	bl	3481d618 <eth_halt>
3481da38:	e3a03003 	mov	r3, #3
3481da3c:	e5843000 	str	r3, [r4]
3481da40:	e8bd8070 	pop	{r4, r5, r6, pc}
		net_set_state(NETLOOP_FAIL);
		return;
	}

	NetTryCount++;
3481da44:	e59f507c 	ldr	r5, [pc, #124]	; 3481dac8 <NetStartAgain+0x104>
3481da48:	e5953018 	ldr	r3, [r5, #24]
3481da4c:	e2833001 	add	r3, r3, #1
3481da50:	e5853018 	str	r3, [r5, #24]

	eth_halt();
3481da54:	ebfffeef 	bl	3481d618 <eth_halt>
#if !defined(CONFIG_NET_DO_NOT_TRY_ANOTHER)
	eth_try_another(!NetRestarted);
3481da58:	e595001c 	ldr	r0, [r5, #28]
3481da5c:	e2700001 	rsbs	r0, r0, #1
3481da60:	33a00000 	movcc	r0, #0
3481da64:	ebffff10 	bl	3481d6ac <eth_try_another>
#endif
	eth_init(gd->bd);
3481da68:	e5980000 	ldr	r0, [r8]
3481da6c:	ebffff2d 	bl	3481d728 <eth_init>
	if (NetRestartWrap) {
3481da70:	e5953020 	ldr	r3, [r5, #32]
3481da74:	e3530000 	cmp	r3, #0
3481da78:	03a03001 	moveq	r3, #1
3481da7c:	0a00000b 	beq	3481dab0 <NetStartAgain+0xec>
		NetRestartWrap = 0;
		if (NetDevExists) {
3481da80:	e5953024 	ldr	r3, [r5, #36]	; 0x24
#if !defined(CONFIG_NET_DO_NOT_TRY_ANOTHER)
	eth_try_another(!NetRestarted);
#endif
	eth_init(gd->bd);
	if (NetRestartWrap) {
		NetRestartWrap = 0;
3481da84:	e3a04000 	mov	r4, #0
		if (NetDevExists) {
3481da88:	e1530004 	cmp	r3, r4
#if !defined(CONFIG_NET_DO_NOT_TRY_ANOTHER)
	eth_try_another(!NetRestarted);
#endif
	eth_init(gd->bd);
	if (NetRestartWrap) {
		NetRestartWrap = 0;
3481da8c:	e5854020 	str	r4, [r5, #32]
3481da90:	03a03003 	moveq	r3, #3
		if (NetDevExists) {
3481da94:	0a000005 	beq	3481dab0 <NetStartAgain+0xec>
			NetSetTimeout(10000UL, startAgainTimeout);
3481da98:	e3020710 	movw	r0, #10000	; 0x2710
3481da9c:	e59f1028 	ldr	r1, [pc, #40]	; 3481dacc <NetStartAgain+0x108>
3481daa0:	ebffffb8 	bl	3481d988 <NetSetTimeout>
			net_set_udp_handler(NULL);
3481daa4:	e1a00004 	mov	r0, r4
			net_set_state(NETLOOP_FAIL);
		}
	} else {
		net_set_state(NETLOOP_RESTART);
	}
}
3481daa8:	e8bd4070 	pop	{r4, r5, r6, lr}
	eth_init(gd->bd);
	if (NetRestartWrap) {
		NetRestartWrap = 0;
		if (NetDevExists) {
			NetSetTimeout(10000UL, startAgainTimeout);
			net_set_udp_handler(NULL);
3481daac:	eaffffa1 	b	3481d938 <net_set_udp_handler>
3481dab0:	e5853000 	str	r3, [r5]
3481dab4:	e8bd8070 	pop	{r4, r5, r6, pc}
3481dab8:	34827d7c 	.word	0x34827d7c
3481dabc:	34823549 	.word	0x34823549
3481dac0:	3482350b 	.word	0x3482350b
3481dac4:	34827d85 	.word	0x34827d85
3481dac8:	3482b9d4 	.word	0x3482b9d4
3481dacc:	3481d8a0 	.word	0x3481d8a0

3481dad0 <net_clear_handlers>:

	return;
}

static void net_clear_handlers(void)
{
3481dad0:	e92d4010 	push	{r4, lr}
	net_set_udp_handler(NULL);
3481dad4:	e3a00000 	mov	r0, #0
3481dad8:	ebffff96 	bl	3481d938 <net_set_udp_handler>
	net_set_arp_handler(NULL);
3481dadc:	e3a00000 	mov	r0, #0
3481dae0:	ebffffa0 	bl	3481d968 <net_set_arp_handler>
	NetSetTimeout(0, NULL);
3481dae4:	e3a00000 	mov	r0, #0
3481dae8:	e1a01000 	mov	r1, r0
}
3481daec:	e8bd4010 	pop	{r4, lr}

static void net_clear_handlers(void)
{
	net_set_udp_handler(NULL);
	net_set_arp_handler(NULL);
	NetSetTimeout(0, NULL);
3481daf0:	eaffffa4 	b	3481d988 <NetSetTimeout>

3481daf4 <NetCksum>:
NetCksum(uchar *ptr, int len)
{
	ulong	xsum;
	ushort *p = (ushort *)ptr;

	xsum = 0;
3481daf4:	e3a03000 	mov	r3, #0
	while (len-- > 0)
3481daf8:	ea000002 	b	3481db08 <NetCksum+0x14>
		xsum += *p++;
3481dafc:	e0d020b2 	ldrh	r2, [r0], #2
3481db00:	e2411001 	sub	r1, r1, #1
3481db04:	e0833002 	add	r3, r3, r2
{
	ulong	xsum;
	ushort *p = (ushort *)ptr;

	xsum = 0;
	while (len-- > 0)
3481db08:	e3510000 	cmp	r1, #0
3481db0c:	cafffffa 	bgt	3481dafc <NetCksum+0x8>
		xsum += *p++;
	xsum = (xsum & 0xffff) + (xsum >> 16);
3481db10:	e1a02823 	lsr	r2, r3, #16
3481db14:	e6f23073 	uxtah	r3, r2, r3
	xsum = (xsum & 0xffff) + (xsum >> 16);
3481db18:	e1a02823 	lsr	r2, r3, #16
3481db1c:	e6f23073 	uxtah	r3, r2, r3
	return xsum & 0xffff;
}
3481db20:	e6ff0073 	uxth	r0, r3
3481db24:	e12fff1e 	bx	lr

3481db28 <NetCksumOk>:
}
/**********************************************************************/

int
NetCksumOk(uchar *ptr, int len)
{
3481db28:	e92d4008 	push	{r3, lr}
	return !((NetCksum(ptr, len) + 1) & 0xfffe);
3481db2c:	ebfffff0 	bl	3481daf4 <NetCksum>
3481db30:	e30f3ffe 	movw	r3, #65534	; 0xfffe
3481db34:	e2800001 	add	r0, r0, #1
3481db38:	e0003003 	and	r3, r0, r3
}
3481db3c:	e2730001 	rsbs	r0, r3, #1
3481db40:	33a00000 	movcc	r0, #0
3481db44:	e8bd8008 	pop	{r3, pc}

3481db48 <NetReceive>:
	}
}

void
NetReceive(uchar *inpkt, int len)
{
3481db48:	e92d407f 	push	{r0, r1, r2, r3, r4, r5, r6, lr}
#endif
	ushort cti = 0, vlanid = VLAN_NONE, myvlanid, mynvlanid;

	debug_cond(DEBUG_NET_PKT, "packet received\n");

	NetRxPacket = inpkt;
3481db4c:	e59f326c 	ldr	r3, [pc, #620]	; 3481ddc0 <NetReceive+0x278>
	NetRxPacketLen = len;
	et = (struct ethernet_hdr *)inpkt;

	/* too small packet? */
	if (len < ETHER_HDR_SIZE)
3481db50:	e351000d 	cmp	r1, #13
	}
}

void
NetReceive(uchar *inpkt, int len)
{
3481db54:	e1a05000 	mov	r5, r0
#endif
	ushort cti = 0, vlanid = VLAN_NONE, myvlanid, mynvlanid;

	debug_cond(DEBUG_NET_PKT, "packet received\n");

	NetRxPacket = inpkt;
3481db58:	e5830028 	str	r0, [r3, #40]	; 0x28
	NetRxPacketLen = len;
3481db5c:	e583102c 	str	r1, [r3, #44]	; 0x2c
	et = (struct ethernet_hdr *)inpkt;

	/* too small packet? */
	if (len < ETHER_HDR_SIZE)
3481db60:	9a000095 	bls	3481ddbc <NetReceive+0x274>
#if defined(CONFIG_CMD_CDP)
	/* keep track if packet is CDP */
	iscdp = is_cdp_packet(et->et_dest);
#endif

	myvlanid = ntohs(NetOurVLAN);
3481db64:	e59fc258 	ldr	ip, [pc, #600]	; 3481ddc4 <NetReceive+0x27c>
	if (myvlanid == (ushort)-1)
3481db68:	e3000fff 	movw	r0, #4095	; 0xfff
#if defined(CONFIG_CMD_CDP)
	/* keep track if packet is CDP */
	iscdp = is_cdp_packet(et->et_dest);
#endif

	myvlanid = ntohs(NetOurVLAN);
3481db6c:	e1dc30b0 	ldrh	r3, [ip]
	if (myvlanid == (ushort)-1)
		myvlanid = VLAN_NONE;
	mynvlanid = ntohs(NetOurNativeVLAN);
3481db70:	e1dcc0b2 	ldrh	ip, [ip, #2]
3481db74:	e1a02423 	lsr	r2, r3, #8
3481db78:	e1822403 	orr	r2, r2, r3, lsl #8
3481db7c:	e1a0442c 	lsr	r4, ip, #8
	/* keep track if packet is CDP */
	iscdp = is_cdp_packet(et->et_dest);
#endif

	myvlanid = ntohs(NetOurVLAN);
	if (myvlanid == (ushort)-1)
3481db80:	e30f3fff 	movw	r3, #65535	; 0xffff
3481db84:	e6ff2072 	uxth	r2, r2
3481db88:	e184c40c 	orr	ip, r4, ip, lsl #8
3481db8c:	e1520003 	cmp	r2, r3
3481db90:	e6ffc07c 	uxth	ip, ip
3481db94:	11a06002 	movne	r6, r2
3481db98:	01a06000 	moveq	r6, r0
		myvlanid = VLAN_NONE;
	mynvlanid = ntohs(NetOurNativeVLAN);
	if (mynvlanid == (ushort)-1)
		mynvlanid = VLAN_NONE;
3481db9c:	e15c0003 	cmp	ip, r3

	eth_proto = ntohs(et->et_protlen);
3481dba0:	e1d530bc 	ldrh	r3, [r5, #12]
	myvlanid = ntohs(NetOurVLAN);
	if (myvlanid == (ushort)-1)
		myvlanid = VLAN_NONE;
	mynvlanid = ntohs(NetOurNativeVLAN);
	if (mynvlanid == (ushort)-1)
		mynvlanid = VLAN_NONE;
3481dba4:	01a0c000 	moveq	ip, r0
3481dba8:	e1a04423 	lsr	r4, r3, #8
3481dbac:	e1843403 	orr	r3, r4, r3, lsl #8

	eth_proto = ntohs(et->et_protlen);
3481dbb0:	e6ff3073 	uxth	r3, r3

	if (eth_proto < 1514) {
3481dbb4:	e30045e9 	movw	r4, #1513	; 0x5e9
3481dbb8:	e1530004 	cmp	r3, r4
3481dbbc:	ca000006 	bgt	3481dbdc <NetReceive+0x94>
		struct e802_hdr *et802 = (struct e802_hdr *)et;
		/*
		 *	Got a 802.2 packet.  Check the other protocol field.
		 *	XXX VLAN over 802.2+SNAP not implemented!
		 */
		eth_proto = ntohs(et802->et_prot);
3481dbc0:	e1d531b4 	ldrh	r3, [r5, #20]

		ip = (struct ip_udp_hdr *)(inpkt + E802_HDR_SIZE);
3481dbc4:	e2854016 	add	r4, r5, #22
3481dbc8:	e1a02423 	lsr	r2, r3, #8
3481dbcc:	e1823403 	orr	r3, r2, r3, lsl #8
		struct e802_hdr *et802 = (struct e802_hdr *)et;
		/*
		 *	Got a 802.2 packet.  Check the other protocol field.
		 *	XXX VLAN over 802.2+SNAP not implemented!
		 */
		eth_proto = ntohs(et802->et_prot);
3481dbd0:	e6ff3073 	uxth	r3, r3

		ip = (struct ip_udp_hdr *)(inpkt + E802_HDR_SIZE);
		len -= E802_HDR_SIZE;
3481dbd4:	e2412016 	sub	r2, r1, #22
3481dbd8:	ea000013 	b	3481dc2c <NetReceive+0xe4>

	} else if (eth_proto != PROT_VLAN) {	/* normal packet */
3481dbdc:	e3530c81 	cmp	r3, #33024	; 0x8100
		ip = (struct ip_udp_hdr *)(inpkt + ETHER_HDR_SIZE);
3481dbe0:	1285400e 	addne	r4, r5, #14
		len -= ETHER_HDR_SIZE;
3481dbe4:	1241200e 	subne	r2, r1, #14
		eth_proto = ntohs(et802->et_prot);

		ip = (struct ip_udp_hdr *)(inpkt + E802_HDR_SIZE);
		len -= E802_HDR_SIZE;

	} else if (eth_proto != PROT_VLAN) {	/* normal packet */
3481dbe8:	1a00000f 	bne	3481dc2c <NetReceive+0xe4>
			(struct vlan_ethernet_hdr *)et;

		debug_cond(DEBUG_NET_PKT, "VLAN packet received\n");

		/* too small packet? */
		if (len < VLAN_ETHER_HDR_SIZE)
3481dbec:	e3510011 	cmp	r1, #17
3481dbf0:	9a000071 	bls	3481ddbc <NetReceive+0x274>
			return;

		/* if no VLAN active */
		if ((ntohs(NetOurVLAN) & VLAN_IDMASK) == VLAN_NONE
3481dbf4:	e1a02a02 	lsl	r2, r2, #20
3481dbf8:	e1500a22 	cmp	r0, r2, lsr #20
3481dbfc:	0a00006e 	beq	3481ddbc <NetReceive+0x274>
				&& iscdp == 0
#endif
				)
			return;

		cti = ntohs(vet->vet_tag);
3481dc00:	e1d530be 	ldrh	r3, [r5, #14]
		vlanid = cti & VLAN_IDMASK;
		eth_proto = ntohs(vet->vet_type);

		ip = (struct ip_udp_hdr *)(inpkt + VLAN_ETHER_HDR_SIZE);
3481dc04:	e2854012 	add	r4, r5, #18
3481dc08:	e1a00423 	lsr	r0, r3, #8
3481dc0c:	e1800403 	orr	r0, r0, r3, lsl #8
				)
			return;

		cti = ntohs(vet->vet_tag);
		vlanid = cti & VLAN_IDMASK;
		eth_proto = ntohs(vet->vet_type);
3481dc10:	e1d531b0 	ldrh	r3, [r5, #16]
#endif
				)
			return;

		cti = ntohs(vet->vet_tag);
		vlanid = cti & VLAN_IDMASK;
3481dc14:	e1a00a00 	lsl	r0, r0, #20
3481dc18:	e1a02423 	lsr	r2, r3, #8
3481dc1c:	e1823403 	orr	r3, r2, r3, lsl #8
3481dc20:	e1a00a20 	lsr	r0, r0, #20
		eth_proto = ntohs(vet->vet_type);
3481dc24:	e6ff3073 	uxth	r3, r3

		ip = (struct ip_udp_hdr *)(inpkt + VLAN_ETHER_HDR_SIZE);
		len -= VLAN_ETHER_HDR_SIZE;
3481dc28:	e2412012 	sub	r2, r1, #18
		cdp_receive((uchar *)ip, len);
		return;
	}
#endif

	if ((myvlanid & VLAN_IDMASK) != VLAN_NONE) {
3481dc2c:	e1a01a06 	lsl	r1, r6, #20
3481dc30:	e1a01a21 	lsr	r1, r1, #20
3481dc34:	e3006fff 	movw	r6, #4095	; 0xfff
3481dc38:	e1510006 	cmp	r1, r6
3481dc3c:	0a000004 	beq	3481dc54 <NetReceive+0x10c>
		if (vlanid == VLAN_NONE)
3481dc40:	e1500006 	cmp	r0, r6
			vlanid = (mynvlanid & VLAN_IDMASK);
3481dc44:	01a00a0c 	lsleq	r0, ip, #20
3481dc48:	01a00a20 	lsreq	r0, r0, #20
		/* not matched? */
		if (vlanid != (myvlanid & VLAN_IDMASK))
3481dc4c:	e1500001 	cmp	r0, r1
3481dc50:	1a000059 	bne	3481ddbc <NetReceive+0x274>
			return;
	}

	switch (eth_proto) {
3481dc54:	e3530b02 	cmp	r3, #2048	; 0x800
3481dc58:	0a000006 	beq	3481dc78 <NetReceive+0x130>
3481dc5c:	e3001806 	movw	r1, #2054	; 0x806
3481dc60:	e1530001 	cmp	r3, r1
3481dc64:	1a000054 	bne	3481ddbc <NetReceive+0x274>

	case PROT_ARP:
		ArpReceive(et, ip, len);
3481dc68:	e1a00005 	mov	r0, r5
3481dc6c:	e1a01004 	mov	r1, r4
3481dc70:	ebfffac9 	bl	3481c79c <ArpReceive>
		break;
3481dc74:	ea000050 	b	3481ddbc <NetReceive+0x274>
		break;
#endif
	case PROT_IP:
		debug_cond(DEBUG_NET_PKT, "Got IP\n");
		/* Before we start poking the header, make sure it is there */
		if (len < IP_UDP_HDR_SIZE) {
3481dc78:	e352001b 	cmp	r2, #27
3481dc7c:	9a00004e 	bls	3481ddbc <NetReceive+0x274>
			debug("len bad %d < %lu\n", len,
				(ulong)IP_UDP_HDR_SIZE);
			return;
		}
		/* Check the packet length */
		if (len < ntohs(ip->ip_len)) {
3481dc80:	e1d430b2 	ldrh	r3, [r4, #2]
3481dc84:	e1a06423 	lsr	r6, r3, #8
3481dc88:	e1866403 	orr	r6, r6, r3, lsl #8
3481dc8c:	e6ff6076 	uxth	r6, r6
3481dc90:	e1520006 	cmp	r2, r6
3481dc94:	ba000048 	blt	3481ddbc <NetReceive+0x274>
		len = ntohs(ip->ip_len);
		debug_cond(DEBUG_NET_PKT, "len=%d, v=%02x\n",
			len, ip->ip_hl_v & 0xff);

		/* Can't deal with anything except IPv4 */
		if ((ip->ip_hl_v & 0xf0) != 0x40)
3481dc98:	e5d43000 	ldrb	r3, [r4]
3481dc9c:	e20320f0 	and	r2, r3, #240	; 0xf0
3481dca0:	e3520040 	cmp	r2, #64	; 0x40
3481dca4:	1a000044 	bne	3481ddbc <NetReceive+0x274>
			return;
		/* Can't deal with IP options (headers != 20 bytes) */
		if ((ip->ip_hl_v & 0x0f) > 0x05)
3481dca8:	e203300f 	and	r3, r3, #15
3481dcac:	e3530005 	cmp	r3, #5
3481dcb0:	ca000041 	bgt	3481ddbc <NetReceive+0x274>
			return;
		/* Check the Checksum of the header */
		if (!NetCksumOk((uchar *)ip, IP_HDR_SIZE / 2)) {
3481dcb4:	e1a00004 	mov	r0, r4
3481dcb8:	e3a0100a 	mov	r1, #10
3481dcbc:	ebffff99 	bl	3481db28 <NetCksumOk>
3481dcc0:	e3500000 	cmp	r0, #0
3481dcc4:	0a00003c 	beq	3481ddbc <NetReceive+0x274>
/* return IP *in network byteorder* */
static inline IPaddr_t NetReadIP(void *from)
{
	IPaddr_t ip;

	memcpy((void *)&ip, (void *)from, sizeof(ip));
3481dcc8:	e3a02004 	mov	r2, #4
3481dccc:	e28d000c 	add	r0, sp, #12
3481dcd0:	e2841010 	add	r1, r4, #16
3481dcd4:	ebffec6d 	bl	34818e90 <memcpy>
			debug("checksum bad\n");
			return;
		}
		/* If it is not for us, ignore it */
		dst_ip = NetReadIP(&ip->ip_dst);
		if (NetOurIP && dst_ip != NetOurIP && dst_ip != 0xFFFFFFFF) {
3481dcd8:	e59f20e0 	ldr	r2, [pc, #224]	; 3481ddc0 <NetReceive+0x278>
	return ip;
3481dcdc:	e59d300c 	ldr	r3, [sp, #12]
3481dce0:	e5922030 	ldr	r2, [r2, #48]	; 0x30
3481dce4:	e3520000 	cmp	r2, #0
3481dce8:	0a000002 	beq	3481dcf8 <NetReceive+0x1b0>
3481dcec:	e1530002 	cmp	r3, r2
3481dcf0:	13730001 	cmnne	r3, #1
3481dcf4:	1a000030 	bne	3481ddbc <NetReceive+0x274>
/* return IP *in network byteorder* */
static inline IPaddr_t NetReadIP(void *from)
{
	IPaddr_t ip;

	memcpy((void *)&ip, (void *)from, sizeof(ip));
3481dcf8:	e284100c 	add	r1, r4, #12
3481dcfc:	e3a02004 	mov	r2, #4
3481dd00:	e28d000c 	add	r0, sp, #12
3481dd04:	ebffec61 	bl	34818e90 <memcpy>

#else /* !CONFIG_IP_DEFRAG */

static inline struct ip_udp_hdr *NetDefragment(struct ip_udp_hdr *ip, int *lenp)
{
	u16 ip_off = ntohs(ip->ip_off);
3481dd08:	e1d430b6 	ldrh	r3, [r4, #6]
	return ip;
3481dd0c:	e59d200c 	ldr	r2, [sp, #12]
3481dd10:	e1a01423 	lsr	r1, r3, #8
3481dd14:	e1813403 	orr	r3, r1, r3, lsl #8
	if (!(ip_off & (IP_OFFS | IP_FLAGS_MFRAG)))
3481dd18:	e1b03903 	lsls	r3, r3, #18
3481dd1c:	1a000026 	bne	3481ddbc <NetReceive+0x274>
		 *
		 * Simon Glass <sjg@chromium.org>: We get an ICMP when
		 * we send a tftp packet to a dead connection, or when
		 * there is no server at the other end.
		 */
		if (ip->ip_p == IPPROTO_ICMP) {
3481dd20:	e5d43009 	ldrb	r3, [r4, #9]
3481dd24:	e3530001 	cmp	r3, #1
3481dd28:	1a00000f 	bne	3481dd6c <NetReceive+0x224>
static void receive_icmp(struct ip_udp_hdr *ip, int len,
			IPaddr_t src_ip, struct ethernet_hdr *et)
{
	struct icmp_hdr *icmph = (struct icmp_hdr *)&ip->udp_src;

	switch (icmph->type) {
3481dd2c:	e5d42014 	ldrb	r2, [r4, #20]
 * @parma ip	IP packet containing the ICMP
 */
static void receive_icmp(struct ip_udp_hdr *ip, int len,
			IPaddr_t src_ip, struct ethernet_hdr *et)
{
	struct icmp_hdr *icmph = (struct icmp_hdr *)&ip->udp_src;
3481dd30:	e2843014 	add	r3, r4, #20

	switch (icmph->type) {
3481dd34:	e3520005 	cmp	r2, #5
3481dd38:	1a000006 	bne	3481dd58 <NetReceive+0x210>
	case ICMP_REDIRECT:
		if (icmph->code != ICMP_REDIR_HOST)
3481dd3c:	e5d33001 	ldrb	r3, [r3, #1]
3481dd40:	e3530001 	cmp	r3, #1
3481dd44:	1a00001c 	bne	3481ddbc <NetReceive+0x274>
			return;
		printf(" ICMP Host Redirect to %pI4 ",
3481dd48:	e2841018 	add	r1, r4, #24
3481dd4c:	e59f0074 	ldr	r0, [pc, #116]	; 3481ddc8 <NetReceive+0x280>
3481dd50:	ebffac7d 	bl	34808f4c <printf>
3481dd54:	ea000018 	b	3481ddbc <NetReceive+0x274>
			&icmph->un.gateway);
		break;
	default:
#if defined(CONFIG_CMD_PING)
		ping_receive(et, ip, len);
3481dd58:	e1a00005 	mov	r0, r5
3481dd5c:	e1a01004 	mov	r1, r4
3481dd60:	e1a02006 	mov	r2, r6
3481dd64:	eb00060f 	bl	3481f5a8 <ping_receive>
3481dd68:	ea000013 	b	3481ddbc <NetReceive+0x274>
		 * there is no server at the other end.
		 */
		if (ip->ip_p == IPPROTO_ICMP) {
			receive_icmp(ip, len, src_ip, et);
			return;
		} else if (ip->ip_p != IPPROTO_UDP) {	/* Only UDP packets */
3481dd6c:	e3530011 	cmp	r3, #17
3481dd70:	1a000011 	bne	3481ddbc <NetReceive+0x274>
#endif
		/*
		 *	IP header OK.  Pass the packet to the current handler.
		 */
		(*udp_packet_handler)((uchar *)ip + IP_UDP_HDR_SIZE,
				ntohs(ip->udp_dst),
3481dd74:	e1d411b6 	ldrh	r1, [r4, #22]
				src_ip,
				ntohs(ip->udp_src),
3481dd78:	e1d431b4 	ldrh	r3, [r4, #20]
				ntohs(ip->udp_len) - UDP_HDR_SIZE);
3481dd7c:	e1d401b8 	ldrh	r0, [r4, #24]
3481dd80:	e1a0c421 	lsr	ip, r1, #8
3481dd84:	e18c1401 	orr	r1, ip, r1, lsl #8
3481dd88:	e1a0c423 	lsr	ip, r3, #8
3481dd8c:	e18c3403 	orr	r3, ip, r3, lsl #8
3481dd90:	e1a0c420 	lsr	ip, r0, #8
3481dd94:	e18c0400 	orr	r0, ip, r0, lsl #8
3481dd98:	e6ff0070 	uxth	r0, r0
					ntohs(ip->udp_len) - UDP_HDR_SIZE);
#endif
		/*
		 *	IP header OK.  Pass the packet to the current handler.
		 */
		(*udp_packet_handler)((uchar *)ip + IP_UDP_HDR_SIZE,
3481dd9c:	e2400008 	sub	r0, r0, #8
3481dda0:	e58d0000 	str	r0, [sp]
3481dda4:	e59f0014 	ldr	r0, [pc, #20]	; 3481ddc0 <NetReceive+0x278>
3481dda8:	e6ff1071 	uxth	r1, r1
3481ddac:	e590c004 	ldr	ip, [r0, #4]
3481ddb0:	e6ff3073 	uxth	r3, r3
3481ddb4:	e284001c 	add	r0, r4, #28
3481ddb8:	e12fff3c 	blx	ip
				src_ip,
				ntohs(ip->udp_src),
				ntohs(ip->udp_len) - UDP_HDR_SIZE);
		break;
	}
}
3481ddbc:	e8bd807f 	pop	{r0, r1, r2, r3, r4, r5, r6, pc}
3481ddc0:	3482b9d4 	.word	0x3482b9d4
3481ddc4:	34828ba0 	.word	0x34828ba0
3481ddc8:	34827d8a 	.word	0x34827d8a

3481ddcc <NetEthHdrSize>:
int
NetEthHdrSize(void)
{
	ushort myvlanid;

	myvlanid = ntohs(NetOurVLAN);
3481ddcc:	e59f3030 	ldr	r3, [pc, #48]	; 3481de04 <NetEthHdrSize+0x38>
	if (myvlanid == (ushort)-1)
		myvlanid = VLAN_NONE;
3481ddd0:	e30f1fff 	movw	r1, #65535	; 0xffff
int
NetEthHdrSize(void)
{
	ushort myvlanid;

	myvlanid = ntohs(NetOurVLAN);
3481ddd4:	e1d330b0 	ldrh	r3, [r3]
3481ddd8:	e1a02423 	lsr	r2, r3, #8
3481dddc:	e1823403 	orr	r3, r2, r3, lsl #8
3481dde0:	e6ff3073 	uxth	r3, r3
	if (myvlanid == (ushort)-1)
		myvlanid = VLAN_NONE;
3481dde4:	e1530001 	cmp	r3, r1
3481dde8:	e3002fff 	movw	r2, #4095	; 0xfff
3481ddec:	01a03002 	moveq	r3, r2

	return ((myvlanid & VLAN_IDMASK) == VLAN_NONE) ? ETHER_HDR_SIZE :
3481ddf0:	e1a03a03 	lsl	r3, r3, #20
3481ddf4:	e1520a23 	cmp	r2, r3, lsr #20
		VLAN_ETHER_HDR_SIZE;
}
3481ddf8:	13a00012 	movne	r0, #18
3481ddfc:	03a0000e 	moveq	r0, #14
3481de00:	e12fff1e 	bx	lr
3481de04:	34828ba0 	.word	0x34828ba0

3481de08 <NetSetEther>:

int
NetSetEther(uchar *xet, uchar * addr, uint prot)
{
3481de08:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
	struct ethernet_hdr *et = (struct ethernet_hdr *)xet;
	ushort myvlanid;

	myvlanid = ntohs(NetOurVLAN);
3481de0c:	e59f308c 	ldr	r3, [pc, #140]	; 3481dea0 <NetSetEther+0x98>
	if (myvlanid == (ushort)-1)
		myvlanid = VLAN_NONE;
3481de10:	e3006fff 	movw	r6, #4095	; 0xfff
NetSetEther(uchar *xet, uchar * addr, uint prot)
{
	struct ethernet_hdr *et = (struct ethernet_hdr *)xet;
	ushort myvlanid;

	myvlanid = ntohs(NetOurVLAN);
3481de14:	e1d330b0 	ldrh	r3, [r3]
		VLAN_ETHER_HDR_SIZE;
}

int
NetSetEther(uchar *xet, uchar * addr, uint prot)
{
3481de18:	e1a04000 	mov	r4, r0
3481de1c:	e1a05423 	lsr	r5, r3, #8
3481de20:	e1855403 	orr	r5, r5, r3, lsl #8
3481de24:	e6ff5075 	uxth	r5, r5
	struct ethernet_hdr *et = (struct ethernet_hdr *)xet;
	ushort myvlanid;

	myvlanid = ntohs(NetOurVLAN);
	if (myvlanid == (ushort)-1)
		myvlanid = VLAN_NONE;
3481de28:	e30f3fff 	movw	r3, #65535	; 0xffff
3481de2c:	e1550003 	cmp	r5, r3
3481de30:	01a05006 	moveq	r5, r6
		VLAN_ETHER_HDR_SIZE;
}

int
NetSetEther(uchar *xet, uchar * addr, uint prot)
{
3481de34:	e1a07002 	mov	r7, r2
	if (myvlanid == (ushort)-1)
		myvlanid = VLAN_NONE;

	memcpy(et->et_dest, addr, 6);
	memcpy(et->et_src, NetOurEther, 6);
	if ((myvlanid & VLAN_IDMASK) == VLAN_NONE) {
3481de38:	e1a05a05 	lsl	r5, r5, #20

	myvlanid = ntohs(NetOurVLAN);
	if (myvlanid == (ushort)-1)
		myvlanid = VLAN_NONE;

	memcpy(et->et_dest, addr, 6);
3481de3c:	e3a02006 	mov	r2, #6
3481de40:	ebffec12 	bl	34818e90 <memcpy>
	memcpy(et->et_src, NetOurEther, 6);
	if ((myvlanid & VLAN_IDMASK) == VLAN_NONE) {
3481de44:	e1a05a25 	lsr	r5, r5, #20
	myvlanid = ntohs(NetOurVLAN);
	if (myvlanid == (ushort)-1)
		myvlanid = VLAN_NONE;

	memcpy(et->et_dest, addr, 6);
	memcpy(et->et_src, NetOurEther, 6);
3481de48:	e2840006 	add	r0, r4, #6
3481de4c:	e59f1050 	ldr	r1, [pc, #80]	; 3481dea4 <NetSetEther+0x9c>
3481de50:	e3a02006 	mov	r2, #6
3481de54:	ebffec0d 	bl	34818e90 <memcpy>
	if ((myvlanid & VLAN_IDMASK) == VLAN_NONE) {
3481de58:	e1550006 	cmp	r5, r6
3481de5c:	e6ff7077 	uxth	r7, r7
3481de60:	1a000004 	bne	3481de78 <NetSetEther+0x70>
3481de64:	e1a03427 	lsr	r3, r7, #8
3481de68:	e1837407 	orr	r7, r3, r7, lsl #8
		et->et_protlen = htons(prot);
3481de6c:	e1c470bc 	strh	r7, [r4, #12]
		return ETHER_HDR_SIZE;
3481de70:	e3a0000e 	mov	r0, #14
3481de74:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
	} else {
		struct vlan_ethernet_hdr *vet =
			(struct vlan_ethernet_hdr *)xet;

		vet->vet_vlan_type = htons(PROT_VLAN);
3481de78:	e3a03081 	mov	r3, #129	; 0x81
3481de7c:	e1c430bc 	strh	r3, [r4, #12]
3481de80:	e1a03425 	lsr	r3, r5, #8
3481de84:	e1835405 	orr	r5, r3, r5, lsl #8
3481de88:	e1a03427 	lsr	r3, r7, #8
3481de8c:	e1837407 	orr	r7, r3, r7, lsl #8
		vet->vet_tag = htons((0 << 5) | (myvlanid & VLAN_IDMASK));
3481de90:	e1c450be 	strh	r5, [r4, #14]
		vet->vet_type = htons(prot);
3481de94:	e1c471b0 	strh	r7, [r4, #16]
		return VLAN_ETHER_HDR_SIZE;
3481de98:	e3a00012 	mov	r0, #18
	}
}
3481de9c:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
3481dea0:	34828ba0 	.word	0x34828ba0
3481dea4:	3482ba08 	.word	0x3482ba08

3481dea8 <net_update_ether>:

int net_update_ether(struct ethernet_hdr *et, uchar *addr, uint prot)
{
3481dea8:	e92d4038 	push	{r3, r4, r5, lr}
3481deac:	e1a04000 	mov	r4, r0
3481deb0:	e1a05002 	mov	r5, r2
	ushort protlen;

	memcpy(et->et_dest, addr, 6);
3481deb4:	e3a02006 	mov	r2, #6
3481deb8:	ebffebf4 	bl	34818e90 <memcpy>
	memcpy(et->et_src, NetOurEther, 6);
3481debc:	e3a02006 	mov	r2, #6
3481dec0:	e2840006 	add	r0, r4, #6
3481dec4:	e59f1060 	ldr	r1, [pc, #96]	; 3481df2c <net_update_ether+0x84>
3481dec8:	ebffebf0 	bl	34818e90 <memcpy>
	protlen = ntohs(et->et_protlen);
3481decc:	e1d430bc 	ldrh	r3, [r4, #12]
3481ded0:	e1a02423 	lsr	r2, r3, #8
3481ded4:	e1823403 	orr	r3, r2, r3, lsl #8
3481ded8:	e6ff3073 	uxth	r3, r3
	if (protlen == PROT_VLAN) {
3481dedc:	e3530c81 	cmp	r3, #33024	; 0x8100
3481dee0:	1a000005 	bne	3481defc <net_update_ether+0x54>
		struct vlan_ethernet_hdr *vet =
			(struct vlan_ethernet_hdr *)et;
		vet->vet_type = htons(prot);
3481dee4:	e6ff5075 	uxth	r5, r5
3481dee8:	e1a03425 	lsr	r3, r5, #8
3481deec:	e1835405 	orr	r5, r3, r5, lsl #8
3481def0:	e1c451b0 	strh	r5, [r4, #16]
		return VLAN_ETHER_HDR_SIZE;
3481def4:	e3a00012 	mov	r0, #18
3481def8:	e8bd8038 	pop	{r3, r4, r5, pc}
	} else if (protlen > 1514) {
3481defc:	e30025ea 	movw	r2, #1514	; 0x5ea
3481df00:	e1530002 	cmp	r3, r2
3481df04:	e6ff5075 	uxth	r5, r5
3481df08:	81a03425 	lsrhi	r3, r5, #8
3481df0c:	91a03425 	lsrls	r3, r5, #8
3481df10:	81835405 	orrhi	r5, r3, r5, lsl #8
3481df14:	91835405 	orrls	r5, r3, r5, lsl #8
		et->et_protlen = htons(prot);
3481df18:	81c450bc 	strhhi	r5, [r4, #12]
		return ETHER_HDR_SIZE;
3481df1c:	83a0000e 	movhi	r0, #14
	} else {
		/* 802.2 + SNAP */
		struct e802_hdr *et802 = (struct e802_hdr *)et;
		et802->et_prot = htons(prot);
3481df20:	91c451b4 	strhls	r5, [r4, #20]
		return E802_HDR_SIZE;
3481df24:	93a00016 	movls	r0, #22
	}
}
3481df28:	e8bd8038 	pop	{r3, r4, r5, pc}
3481df2c:	3482ba08 	.word	0x3482ba08

3481df30 <net_set_ip_header>:

void net_set_ip_header(uchar *pkt, IPaddr_t dest, IPaddr_t source)
{
3481df30:	e92d4013 	push	{r0, r1, r4, lr}

	/*
	 *	Construct an IP header.
	 */
	/* IP_HDR_SIZE / 4 (not including UDP) */
	ip->ip_hl_v  = 0x45;
3481df34:	e3a03045 	mov	r3, #69	; 0x45
		return E802_HDR_SIZE;
	}
}

void net_set_ip_header(uchar *pkt, IPaddr_t dest, IPaddr_t source)
{
3481df38:	e58d1004 	str	r1, [sp, #4]
3481df3c:	e28d1008 	add	r1, sp, #8
3481df40:	e5212008 	str	r2, [r1, #-8]!

	/*
	 *	Construct an IP header.
	 */
	/* IP_HDR_SIZE / 4 (not including UDP) */
	ip->ip_hl_v  = 0x45;
3481df44:	e5c03000 	strb	r3, [r0]
	ip->ip_tos   = 0;
	ip->ip_len   = htons(IP_HDR_SIZE);
3481df48:	e3a02b05 	mov	r2, #5120	; 0x1400
	/*
	 *	Construct an IP header.
	 */
	/* IP_HDR_SIZE / 4 (not including UDP) */
	ip->ip_hl_v  = 0x45;
	ip->ip_tos   = 0;
3481df4c:	e3a03000 	mov	r3, #0
		return E802_HDR_SIZE;
	}
}

void net_set_ip_header(uchar *pkt, IPaddr_t dest, IPaddr_t source)
{
3481df50:	e1a04000 	mov	r4, r0
	/*
	 *	Construct an IP header.
	 */
	/* IP_HDR_SIZE / 4 (not including UDP) */
	ip->ip_hl_v  = 0x45;
	ip->ip_tos   = 0;
3481df54:	e5c03001 	strb	r3, [r0, #1]
	ip->ip_len   = htons(IP_HDR_SIZE);
3481df58:	e1c020b2 	strh	r2, [r0, #2]
	ip->ip_id    = htons(NetIPID++);
3481df5c:	e59f0050 	ldr	r0, [pc, #80]	; 3481dfb4 <net_set_ip_header+0x84>
}

/* copy IP */
static inline void NetCopyIP(void *to, void *from)
{
	memcpy((void *)to, from, sizeof(IPaddr_t));
3481df60:	e1a0100d 	mov	r1, sp
3481df64:	e590c03c 	ldr	ip, [r0, #60]	; 0x3c
	ip->ip_off   = htons(IP_FLAGS_DFRAG);	/* Don't fragment */
	ip->ip_ttl   = 255;
	ip->ip_sum   = 0;
3481df68:	e1c430ba 	strh	r3, [r4, #10]
	 */
	/* IP_HDR_SIZE / 4 (not including UDP) */
	ip->ip_hl_v  = 0x45;
	ip->ip_tos   = 0;
	ip->ip_len   = htons(IP_HDR_SIZE);
	ip->ip_id    = htons(NetIPID++);
3481df6c:	e6ff207c 	uxth	r2, ip
3481df70:	e28cc001 	add	ip, ip, #1
3481df74:	e580c03c 	str	ip, [r0, #60]	; 0x3c
3481df78:	e1a00422 	lsr	r0, r2, #8
3481df7c:	e1802402 	orr	r2, r0, r2, lsl #8
3481df80:	e1c420b4 	strh	r2, [r4, #4]
	ip->ip_off   = htons(IP_FLAGS_DFRAG);	/* Don't fragment */
3481df84:	e3a02040 	mov	r2, #64	; 0x40
3481df88:	e1c420b6 	strh	r2, [r4, #6]
	ip->ip_ttl   = 255;
3481df8c:	e3e02000 	mvn	r2, #0
3481df90:	e5c42008 	strb	r2, [r4, #8]
3481df94:	e284000c 	add	r0, r4, #12
3481df98:	e2822005 	add	r2, r2, #5
3481df9c:	ebffebbb 	bl	34818e90 <memcpy>
3481dfa0:	e2840010 	add	r0, r4, #16
3481dfa4:	e28d1004 	add	r1, sp, #4
3481dfa8:	e3a02004 	mov	r2, #4
3481dfac:	ebffebb7 	bl	34818e90 <memcpy>
	ip->ip_sum   = 0;
	/* already in network byte order */
	NetCopyIP((void *)&ip->ip_src, &source);
	/* already in network byte order */
	NetCopyIP((void *)&ip->ip_dst, &dest);
}
3481dfb0:	e8bd801c 	pop	{r2, r3, r4, pc}
3481dfb4:	3482b9d4 	.word	0x3482b9d4

3481dfb8 <net_set_udp_header>:

void net_set_udp_header(uchar *pkt, IPaddr_t dest, int dport, int sport,
			int len)
{
3481dfb8:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
3481dfbc:	e59d6018 	ldr	r6, [sp, #24]
3481dfc0:	e1a05002 	mov	r5, r2
	/*
	 *	If the data is an odd number of bytes, zero the
	 *	byte after the last byte so that the checksum
	 *	will work.
	 */
	if (len & 1)
3481dfc4:	e3160001 	tst	r6, #1
		pkt[IP_UDP_HDR_SIZE + len] = 0;
3481dfc8:	13a02000 	movne	r2, #0
	NetCopyIP((void *)&ip->ip_dst, &dest);
}

void net_set_udp_header(uchar *pkt, IPaddr_t dest, int dport, int sport,
			int len)
{
3481dfcc:	e1a07003 	mov	r7, r3
	 *	If the data is an odd number of bytes, zero the
	 *	byte after the last byte so that the checksum
	 *	will work.
	 */
	if (len & 1)
		pkt[IP_UDP_HDR_SIZE + len] = 0;
3481dfd0:	10803006 	addne	r3, r0, r6
3481dfd4:	15c3201c 	strbne	r2, [r3, #28]

	net_set_ip_header(pkt, dest, NetOurIP);
3481dfd8:	e59f307c 	ldr	r3, [pc, #124]	; 3481e05c <net_set_udp_header+0xa4>
	ip->ip_len   = htons(IP_UDP_HDR_SIZE + len);
3481dfdc:	e6ff6076 	uxth	r6, r6
	 *	will work.
	 */
	if (len & 1)
		pkt[IP_UDP_HDR_SIZE + len] = 0;

	net_set_ip_header(pkt, dest, NetOurIP);
3481dfe0:	e5932030 	ldr	r2, [r3, #48]	; 0x30
	NetCopyIP((void *)&ip->ip_dst, &dest);
}

void net_set_udp_header(uchar *pkt, IPaddr_t dest, int dport, int sport,
			int len)
{
3481dfe4:	e1a04000 	mov	r4, r0
	 *	will work.
	 */
	if (len & 1)
		pkt[IP_UDP_HDR_SIZE + len] = 0;

	net_set_ip_header(pkt, dest, NetOurIP);
3481dfe8:	ebffffd0 	bl	3481df30 <net_set_ip_header>
	ip->ip_len   = htons(IP_UDP_HDR_SIZE + len);
3481dfec:	e286301c 	add	r3, r6, #28
3481dff0:	e6ff3073 	uxth	r3, r3
3481dff4:	e1a02423 	lsr	r2, r3, #8
3481dff8:	e1823403 	orr	r3, r2, r3, lsl #8
3481dffc:	e1c430b2 	strh	r3, [r4, #2]
	ip->ip_p     = IPPROTO_UDP;
3481e000:	e3a03011 	mov	r3, #17
3481e004:	e5c43009 	strb	r3, [r4, #9]
	ip->ip_sum   = ~NetCksum((uchar *)ip, IP_HDR_SIZE >> 1);
3481e008:	e1a00004 	mov	r0, r4
3481e00c:	e3a0100a 	mov	r1, #10
3481e010:	ebfffeb7 	bl	3481daf4 <NetCksum>

	ip->udp_src  = htons(sport);
3481e014:	e6ff7077 	uxth	r7, r7
3481e018:	e1a03427 	lsr	r3, r7, #8
	ip->udp_dst  = htons(dport);
3481e01c:	e6ff5075 	uxth	r5, r5
	ip->udp_len  = htons(UDP_HDR_SIZE + len);
3481e020:	e2866008 	add	r6, r6, #8
3481e024:	e1837407 	orr	r7, r3, r7, lsl #8
3481e028:	e6ff6076 	uxth	r6, r6
3481e02c:	e1a03425 	lsr	r3, r5, #8
3481e030:	e1835405 	orr	r5, r3, r5, lsl #8
3481e034:	e1a03426 	lsr	r3, r6, #8
3481e038:	e1836406 	orr	r6, r3, r6, lsl #8
		pkt[IP_UDP_HDR_SIZE + len] = 0;

	net_set_ip_header(pkt, dest, NetOurIP);
	ip->ip_len   = htons(IP_UDP_HDR_SIZE + len);
	ip->ip_p     = IPPROTO_UDP;
	ip->ip_sum   = ~NetCksum((uchar *)ip, IP_HDR_SIZE >> 1);
3481e03c:	e1e00000 	mvn	r0, r0

	ip->udp_src  = htons(sport);
	ip->udp_dst  = htons(dport);
	ip->udp_len  = htons(UDP_HDR_SIZE + len);
	ip->udp_xsum = 0;
3481e040:	e3a03000 	mov	r3, #0
		pkt[IP_UDP_HDR_SIZE + len] = 0;

	net_set_ip_header(pkt, dest, NetOurIP);
	ip->ip_len   = htons(IP_UDP_HDR_SIZE + len);
	ip->ip_p     = IPPROTO_UDP;
	ip->ip_sum   = ~NetCksum((uchar *)ip, IP_HDR_SIZE >> 1);
3481e044:	e1c400ba 	strh	r0, [r4, #10]

	ip->udp_src  = htons(sport);
3481e048:	e1c471b4 	strh	r7, [r4, #20]
	ip->udp_dst  = htons(dport);
3481e04c:	e1c451b6 	strh	r5, [r4, #22]
	ip->udp_len  = htons(UDP_HDR_SIZE + len);
3481e050:	e1c461b8 	strh	r6, [r4, #24]
	ip->udp_xsum = 0;
3481e054:	e1c431ba 	strh	r3, [r4, #26]
}
3481e058:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
3481e05c:	3482b9d4 	.word	0x3482b9d4

3481e060 <NetSendUDPPacket>:
	}
}

int NetSendUDPPacket(uchar *ether, IPaddr_t dest, int dport, int sport,
		int payload_len)
{
3481e060:	e92d4ef3 	push	{r0, r1, r4, r5, r6, r7, r9, sl, fp, lr}
3481e064:	e1a0a003 	mov	sl, r3
	int eth_hdr_size;
	int pkt_hdr_size;

	/* make sure the NetTxPacket is initialized (NetInit() was called) */
	assert(NetTxPacket != NULL);
	if (NetTxPacket == NULL)
3481e068:	e59f30d4 	ldr	r3, [pc, #212]	; 3481e144 <NetSendUDPPacket+0xe4>
	}
}

int NetSendUDPPacket(uchar *ether, IPaddr_t dest, int dport, int sport,
		int payload_len)
{
3481e06c:	e1a04000 	mov	r4, r0
	int eth_hdr_size;
	int pkt_hdr_size;

	/* make sure the NetTxPacket is initialized (NetInit() was called) */
	assert(NetTxPacket != NULL);
	if (NetTxPacket == NULL)
3481e070:	e5937040 	ldr	r7, [r3, #64]	; 0x40
	}
}

int NetSendUDPPacket(uchar *ether, IPaddr_t dest, int dport, int sport,
		int payload_len)
{
3481e074:	e1a05001 	mov	r5, r1
	int eth_hdr_size;
	int pkt_hdr_size;

	/* make sure the NetTxPacket is initialized (NetInit() was called) */
	assert(NetTxPacket != NULL);
	if (NetTxPacket == NULL)
3481e078:	e3570000 	cmp	r7, #0
	}
}

int NetSendUDPPacket(uchar *ether, IPaddr_t dest, int dport, int sport,
		int payload_len)
{
3481e07c:	e1a09002 	mov	r9, r2
3481e080:	e59db028 	ldr	fp, [sp, #40]	; 0x28
	int pkt_hdr_size;

	/* make sure the NetTxPacket is initialized (NetInit() was called) */
	assert(NetTxPacket != NULL);
	if (NetTxPacket == NULL)
		return -1;
3481e084:	03e00000 	mvneq	r0, #0
	int eth_hdr_size;
	int pkt_hdr_size;

	/* make sure the NetTxPacket is initialized (NetInit() was called) */
	assert(NetTxPacket != NULL);
	if (NetTxPacket == NULL)
3481e088:	0a00002c 	beq	3481e140 <NetSendUDPPacket+0xe0>
		return -1;

	/* convert to new style broadcast */
	if (dest == 0)
3481e08c:	e3510000 	cmp	r1, #0
		dest = 0xFFFFFFFF;
3481e090:	03e05000 	mvneq	r5, #0

	/* if broadcast, make the ether address a broadcast and don't do ARP */
	if (dest == 0xFFFFFFFF)
		ether = NetBcastAddr;
3481e094:	059f40ac 	ldreq	r4, [pc, #172]	; 3481e148 <NetSendUDPPacket+0xe8>
	assert(NetTxPacket != NULL);
	if (NetTxPacket == NULL)
		return -1;

	/* convert to new style broadcast */
	if (dest == 0)
3481e098:	0a000002 	beq	3481e0a8 <NetSendUDPPacket+0x48>
		dest = 0xFFFFFFFF;

	/* if broadcast, make the ether address a broadcast and don't do ARP */
	if (dest == 0xFFFFFFFF)
		ether = NetBcastAddr;
3481e09c:	e59f30a4 	ldr	r3, [pc, #164]	; 3481e148 <NetSendUDPPacket+0xe8>
3481e0a0:	e3750001 	cmn	r5, #1
3481e0a4:	01a04003 	moveq	r4, r3

	pkt = (uchar *)NetTxPacket;

	eth_hdr_size = NetSetEther(pkt, ether, PROT_IP);
3481e0a8:	e1a00007 	mov	r0, r7
3481e0ac:	e1a01004 	mov	r1, r4
3481e0b0:	e3a02b02 	mov	r2, #2048	; 0x800
3481e0b4:	ebffff53 	bl	3481de08 <NetSetEther>
3481e0b8:	e1a06000 	mov	r6, r0
	pkt += eth_hdr_size;
	net_set_udp_header(pkt, dest, dport, sport, payload_len);
3481e0bc:	e0870000 	add	r0, r7, r0
	pkt_hdr_size = eth_hdr_size + IP_UDP_HDR_SIZE;

	/* if MAC address was not discovered yet, do an ARP request */
	if (memcmp(ether, NetEtherNullAddr, 6) == 0) {
3481e0c0:	e59f707c 	ldr	r7, [pc, #124]	; 3481e144 <NetSendUDPPacket+0xe4>

	pkt = (uchar *)NetTxPacket;

	eth_hdr_size = NetSetEther(pkt, ether, PROT_IP);
	pkt += eth_hdr_size;
	net_set_udp_header(pkt, dest, dport, sport, payload_len);
3481e0c4:	e1a01005 	mov	r1, r5
3481e0c8:	e1a02009 	mov	r2, r9
3481e0cc:	e1a0300a 	mov	r3, sl
3481e0d0:	e58db000 	str	fp, [sp]
3481e0d4:	ebffffb7 	bl	3481dfb8 <net_set_udp_header>
	pkt_hdr_size = eth_hdr_size + IP_UDP_HDR_SIZE;

	/* if MAC address was not discovered yet, do an ARP request */
	if (memcmp(ether, NetEtherNullAddr, 6) == 0) {
3481e0d8:	e2871044 	add	r1, r7, #68	; 0x44
3481e0dc:	e1a00004 	mov	r0, r4
3481e0e0:	e3a02006 	mov	r2, #6
3481e0e4:	ebffeb9c 	bl	34818f5c <memcmp>
	pkt = (uchar *)NetTxPacket;

	eth_hdr_size = NetSetEther(pkt, ether, PROT_IP);
	pkt += eth_hdr_size;
	net_set_udp_header(pkt, dest, dport, sport, payload_len);
	pkt_hdr_size = eth_hdr_size + IP_UDP_HDR_SIZE;
3481e0e8:	e286601c 	add	r6, r6, #28

	/* if MAC address was not discovered yet, do an ARP request */
	if (memcmp(ether, NetEtherNullAddr, 6) == 0) {
3481e0ec:	e3500000 	cmp	r0, #0
3481e0f0:	e086100b 	add	r1, r6, fp
3481e0f4:	1a00000e 	bne	3481e134 <NetSendUDPPacket+0xd4>
		debug_cond(DEBUG_DEV_PKT, "sending ARP for %pI4\n", &dest);

		/* save the ip and eth addr for the packet to send after arp */
		NetArpWaitPacketIP = dest;
3481e0f8:	e59f304c 	ldr	r3, [pc, #76]	; 3481e14c <NetSendUDPPacket+0xec>
3481e0fc:	e5835000 	str	r5, [r3]
		NetArpWaitPacketMAC = ether;
3481e100:	e59f3048 	ldr	r3, [pc, #72]	; 3481e150 <NetSendUDPPacket+0xf0>
3481e104:	e5834000 	str	r4, [r3]

		/* size of the waiting packet */
		NetArpWaitTxPacketSize = pkt_hdr_size + payload_len;
3481e108:	e59f3044 	ldr	r3, [pc, #68]	; 3481e154 <NetSendUDPPacket+0xf4>

		/* and do the ARP request */
		NetArpWaitTry = 1;
3481e10c:	e3a04001 	mov	r4, #1
		/* save the ip and eth addr for the packet to send after arp */
		NetArpWaitPacketIP = dest;
		NetArpWaitPacketMAC = ether;

		/* size of the waiting packet */
		NetArpWaitTxPacketSize = pkt_hdr_size + payload_len;
3481e110:	e5831000 	str	r1, [r3]

		/* and do the ARP request */
		NetArpWaitTry = 1;
3481e114:	e59f303c 	ldr	r3, [pc, #60]	; 3481e158 <NetSendUDPPacket+0xf8>
3481e118:	e5834000 	str	r4, [r3]
		NetArpWaitTimerStart = get_timer(0);
3481e11c:	ebff8c4c 	bl	34801254 <get_timer>
3481e120:	e59f3034 	ldr	r3, [pc, #52]	; 3481e15c <NetSendUDPPacket+0xfc>
3481e124:	e5830000 	str	r0, [r3]
		ArpRequest();
3481e128:	ebfff960 	bl	3481c6b0 <ArpRequest>
		return 1;	/* waiting */
3481e12c:	e1a00004 	mov	r0, r4
3481e130:	ea000002 	b	3481e140 <NetSendUDPPacket+0xe0>
}

/* Transmit a packet */
static inline void NetSendPacket(uchar *pkt, int len)
{
	(void) eth_send(pkt, len);
3481e134:	e5970040 	ldr	r0, [r7, #64]	; 0x40
3481e138:	ebfffd42 	bl	3481d648 <eth_send>
	} else {
		debug_cond(DEBUG_DEV_PKT, "sending UDP to %pI4/%pM\n",
			&dest, ether);
		NetSendPacket(NetTxPacket, pkt_hdr_size + payload_len);
		return 0;	/* transmitted */
3481e13c:	e3a00000 	mov	r0, #0
	}
}
3481e140:	e8bd8efc 	pop	{r2, r3, r4, r5, r6, r7, r9, sl, fp, pc}
3481e144:	3482b9d4 	.word	0x3482b9d4
3481e148:	34828ba4 	.word	0x34828ba4
3481e14c:	3482b35c 	.word	0x3482b35c
3481e150:	3482b358 	.word	0x3482b358
3481e154:	3482b364 	.word	0x3482b364
3481e158:	3482b9b0 	.word	0x3482b9b0
3481e15c:	3482b9ac 	.word	0x3482b9ac

3481e160 <copy_filename>:
	ip->udp_xsum = 0;
}

void copy_filename(char *dst, const char *src, int size)
{
	if (*src && (*src == '"')) {
3481e160:	e5d13000 	ldrb	r3, [r1]
3481e164:	e3530022 	cmp	r3, #34	; 0x22
		++src;
3481e168:	02811001 	addeq	r1, r1, #1
		--size;
3481e16c:	02422001 	subeq	r2, r2, #1
3481e170:	ea000000 	b	3481e178 <copy_filename+0x18>
	}

	while ((--size > 0) && *src && (*src != '"'))
		*dst++ = *src++;
3481e174:	e4c03001 	strb	r3, [r0], #1
	if (*src && (*src == '"')) {
		++src;
		--size;
	}

	while ((--size > 0) && *src && (*src != '"'))
3481e178:	e2422001 	sub	r2, r2, #1
3481e17c:	e3520000 	cmp	r2, #0
3481e180:	da000004 	ble	3481e198 <copy_filename+0x38>
3481e184:	e4d13001 	ldrb	r3, [r1], #1
3481e188:	e3530000 	cmp	r3, #0
3481e18c:	0a000001 	beq	3481e198 <copy_filename+0x38>
3481e190:	e3530022 	cmp	r3, #34	; 0x22
3481e194:	1afffff6 	bne	3481e174 <copy_filename+0x14>
		*dst++ = *src++;
	*dst = '\0';
3481e198:	e3a03000 	mov	r3, #0
3481e19c:	e5c03000 	strb	r3, [r0]
}
3481e1a0:	e12fff1e 	bx	lr

3481e1a4 <random_port>:
 * make port a little random (1024-17407)
 * This keeps the math somewhat trivial to compute, and seems to work with
 * all supported protocols/clients/servers
 */
unsigned int random_port(void)
{
3481e1a4:	e92d4008 	push	{r3, lr}
	return 1024 + (get_timer(0) % 0x4000);
3481e1a8:	e3a00000 	mov	r0, #0
3481e1ac:	ebff8c28 	bl	34801254 <get_timer>
3481e1b0:	e1a00900 	lsl	r0, r0, #18
3481e1b4:	e1a00920 	lsr	r0, r0, #18
}
3481e1b8:	e2800b01 	add	r0, r0, #1024	; 0x400
3481e1bc:	e8bd8008 	pop	{r3, pc}

3481e1c0 <ip_to_string>:
#endif

void ip_to_string(IPaddr_t x, char *s)
{
3481e1c0:	e92d4007 	push	{r0, r1, r2, lr}
3481e1c4:	e6bf3f30 	rev	r3, r0
	x = ntohl(x);
	sprintf(s, "%d.%d.%d.%d",
3481e1c8:	e7e72453 	ubfx	r2, r3, #8, #8
3481e1cc:	e58d2000 	str	r2, [sp]
3481e1d0:	e20320ff 	and	r2, r3, #255	; 0xff
3481e1d4:	e58d2004 	str	r2, [sp, #4]
3481e1d8:	e1a00001 	mov	r0, r1
3481e1dc:	e1a02c23 	lsr	r2, r3, #24
3481e1e0:	e59f1008 	ldr	r1, [pc, #8]	; 3481e1f0 <ip_to_string+0x30>
3481e1e4:	e7e73853 	ubfx	r3, r3, #16, #8
3481e1e8:	ebffef28 	bl	34819e90 <sprintf>
		(int) ((x >> 24) & 0xff),
		(int) ((x >> 16) & 0xff),
		(int) ((x >> 8) & 0xff), (int) ((x >> 0) & 0xff)
	);
}
3481e1ec:	e8bd800e 	pop	{r1, r2, r3, pc}
3481e1f0:	34827da7 	.word	0x34827da7

3481e1f4 <VLAN_to_string>:
3481e1f4:	e1a02420 	lsr	r2, r0, #8
3481e1f8:	e1822400 	orr	r2, r2, r0, lsl #8
3481e1fc:	e6ff2072 	uxth	r2, r2

void VLAN_to_string(ushort x, char *s)
{
	x = ntohs(x);

	if (x == (ushort)-1)
3481e200:	e30f3fff 	movw	r3, #65535	; 0xffff
3481e204:	e1520003 	cmp	r2, r3
3481e208:	0a000002 	beq	3481e218 <VLAN_to_string+0x24>
		x = VLAN_NONE;

	if (x == VLAN_NONE)
3481e20c:	e2433a0f 	sub	r3, r3, #61440	; 0xf000
3481e210:	e1520003 	cmp	r2, r3
3481e214:	1a000002 	bne	3481e224 <VLAN_to_string+0x30>
		strcpy(s, "none");
3481e218:	e1a00001 	mov	r0, r1
3481e21c:	e59f1014 	ldr	r1, [pc, #20]	; 3481e238 <VLAN_to_string+0x44>
3481e220:	eaffe9f1 	b	348189ec <strcpy>
	else
		sprintf(s, "%d", x & VLAN_IDMASK);
3481e224:	e1a00001 	mov	r0, r1
3481e228:	e1a02a02 	lsl	r2, r2, #20
3481e22c:	e59f1008 	ldr	r1, [pc, #8]	; 3481e23c <VLAN_to_string+0x48>
3481e230:	e1a02a22 	lsr	r2, r2, #20
3481e234:	eaffef15 	b	34819e90 <sprintf>
3481e238:	3482647c 	.word	0x3482647c
3481e23c:	34826e39 	.word	0x34826e39

3481e240 <string_to_VLAN>:
}

ushort string_to_VLAN(const char *s)
{
3481e240:	e92d4008 	push	{r3, lr}
	ushort id;

	if (s == NULL)
3481e244:	e2503000 	subs	r3, r0, #0
3481e248:	0a00000d 	beq	3481e284 <string_to_VLAN+0x44>
		return htons(VLAN_NONE);

	if (*s < '0' || *s > '9')
3481e24c:	e5d33000 	ldrb	r3, [r3]
3481e250:	e2433030 	sub	r3, r3, #48	; 0x30
3481e254:	e6ef3073 	uxtb	r3, r3
3481e258:	e3530009 	cmp	r3, #9
		id = VLAN_NONE;
3481e25c:	83000fff 	movwhi	r0, #4095	; 0xfff
	ushort id;

	if (s == NULL)
		return htons(VLAN_NONE);

	if (*s < '0' || *s > '9')
3481e260:	8a000003 	bhi	3481e274 <string_to_VLAN+0x34>
		id = VLAN_NONE;
	else
		id = (ushort)simple_strtoul(s, NULL, 10);
3481e264:	e3a01000 	mov	r1, #0
3481e268:	e3a0200a 	mov	r2, #10
3481e26c:	ebffee61 	bl	34819bf8 <simple_strtoul>
3481e270:	e6ff0070 	uxth	r0, r0
3481e274:	e1a03420 	lsr	r3, r0, #8
3481e278:	e1830400 	orr	r0, r3, r0, lsl #8
3481e27c:	e6ff0070 	uxth	r0, r0
3481e280:	e8bd8008 	pop	{r3, pc}
ushort string_to_VLAN(const char *s)
{
	ushort id;

	if (s == NULL)
		return htons(VLAN_NONE);
3481e284:	e30f0f0f 	movw	r0, #65295	; 0xff0f
		id = VLAN_NONE;
	else
		id = (ushort)simple_strtoul(s, NULL, 10);

	return htons(id);
}
3481e288:	e8bd8008 	pop	{r3, pc}

3481e28c <getenv_VLAN>:

ushort getenv_VLAN(char *var)
{
3481e28c:	e92d4010 	push	{r4, lr}
	return string_to_VLAN(getenv(var));
3481e290:	ebffa7e9 	bl	3480823c <getenv>
}
3481e294:	e8bd4010 	pop	{r4, lr}
	return htons(id);
}

ushort getenv_VLAN(char *var)
{
	return string_to_VLAN(getenv(var));
3481e298:	eaffffe8 	b	3481e240 <string_to_VLAN>

3481e29c <NetInitLoop>:
	}
	TftpStart(TFTPGET);
}

static void NetInitLoop(void)
{
3481e29c:	e92d4070 	push	{r4, r5, r6, lr}
	static int env_changed_id;
	int env_id = get_env_id();
3481e2a0:	ebffa5e7 	bl	34807a44 <get_env_id>

	/* update only when the environment has changed */
	if (env_changed_id != env_id) {
3481e2a4:	e59f4078 	ldr	r4, [pc, #120]	; 3481e324 <NetInitLoop+0x88>
}

static void NetInitLoop(void)
{
	static int env_changed_id;
	int env_id = get_env_id();
3481e2a8:	e1a05000 	mov	r5, r0

	/* update only when the environment has changed */
	if (env_changed_id != env_id) {
3481e2ac:	e594304c 	ldr	r3, [r4, #76]	; 0x4c
3481e2b0:	e1530000 	cmp	r3, r0
3481e2b4:	0a000013 	beq	3481e308 <NetInitLoop+0x6c>
		NetOurIP = getenv_IPaddr("ipaddr");
3481e2b8:	e59f0068 	ldr	r0, [pc, #104]	; 3481e328 <NetInitLoop+0x8c>
3481e2bc:	ebfffd7d 	bl	3481d8b8 <getenv_IPaddr>
3481e2c0:	e5840030 	str	r0, [r4, #48]	; 0x30
		NetOurGatewayIP = getenv_IPaddr("gatewayip");
3481e2c4:	e59f0060 	ldr	r0, [pc, #96]	; 3481e32c <NetInitLoop+0x90>
3481e2c8:	ebfffd7a 	bl	3481d8b8 <getenv_IPaddr>
3481e2cc:	e5840050 	str	r0, [r4, #80]	; 0x50
		NetOurSubnetMask = getenv_IPaddr("netmask");
3481e2d0:	e59f0058 	ldr	r0, [pc, #88]	; 3481e330 <NetInitLoop+0x94>
3481e2d4:	ebfffd77 	bl	3481d8b8 <getenv_IPaddr>
3481e2d8:	e5840054 	str	r0, [r4, #84]	; 0x54
		NetServerIP = getenv_IPaddr("serverip");
3481e2dc:	e59f0050 	ldr	r0, [pc, #80]	; 3481e334 <NetInitLoop+0x98>
3481e2e0:	ebfffd74 	bl	3481d8b8 <getenv_IPaddr>
3481e2e4:	e5840058 	str	r0, [r4, #88]	; 0x58
		NetOurNativeVLAN = getenv_VLAN("nvlan");
3481e2e8:	e59f0048 	ldr	r0, [pc, #72]	; 3481e338 <NetInitLoop+0x9c>
3481e2ec:	ebffffe6 	bl	3481e28c <getenv_VLAN>
3481e2f0:	e59f6044 	ldr	r6, [pc, #68]	; 3481e33c <NetInitLoop+0xa0>
3481e2f4:	e1c600b2 	strh	r0, [r6, #2]
		NetOurVLAN = getenv_VLAN("vlan");
3481e2f8:	e59f0040 	ldr	r0, [pc, #64]	; 3481e340 <NetInitLoop+0xa4>
3481e2fc:	ebffffe2 	bl	3481e28c <getenv_VLAN>
#if defined(CONFIG_CMD_DNS)
		NetOurDNSIP = getenv_IPaddr("dnsip");
#endif
		env_changed_id = env_id;
3481e300:	e584504c 	str	r5, [r4, #76]	; 0x4c
		NetOurIP = getenv_IPaddr("ipaddr");
		NetOurGatewayIP = getenv_IPaddr("gatewayip");
		NetOurSubnetMask = getenv_IPaddr("netmask");
		NetServerIP = getenv_IPaddr("serverip");
		NetOurNativeVLAN = getenv_VLAN("nvlan");
		NetOurVLAN = getenv_VLAN("vlan");
3481e304:	e1c600b0 	strh	r0, [r6]
#if defined(CONFIG_CMD_DNS)
		NetOurDNSIP = getenv_IPaddr("dnsip");
#endif
		env_changed_id = env_id;
	}
	memcpy(NetOurEther, eth_get_dev()->enetaddr, 6);
3481e308:	e59f3034 	ldr	r3, [pc, #52]	; 3481e344 <NetInitLoop+0xa8>
3481e30c:	e59f0034 	ldr	r0, [pc, #52]	; 3481e348 <NetInitLoop+0xac>
3481e310:	e5931000 	ldr	r1, [r3]
3481e314:	e3a02006 	mov	r2, #6
3481e318:	e2811010 	add	r1, r1, #16

	return;
}
3481e31c:	e8bd4070 	pop	{r4, r5, r6, lr}
#if defined(CONFIG_CMD_DNS)
		NetOurDNSIP = getenv_IPaddr("dnsip");
#endif
		env_changed_id = env_id;
	}
	memcpy(NetOurEther, eth_get_dev()->enetaddr, 6);
3481e320:	eaffeada 	b	34818e90 <memcpy>
3481e324:	3482b9d4 	.word	0x3482b9d4
3481e328:	34822f56 	.word	0x34822f56
3481e32c:	3482540e 	.word	0x3482540e
3481e330:	34825418 	.word	0x34825418
3481e334:	34825432 	.word	0x34825432
3481e338:	34827db3 	.word	0x34827db3
3481e33c:	34828ba0 	.word	0x34828ba0
3481e340:	34827db4 	.word	0x34827db4
3481e344:	3482b9bc 	.word	0x3482b9bc
3481e348:	3482ba08 	.word	0x3482ba08

3481e34c <net_init>:
{
	net_clear_handlers();
}

void net_init(void)
{
3481e34c:	e92d4010 	push	{r4, lr}
	static int first_call = 1;

	if (first_call) {
3481e350:	e59f4054 	ldr	r4, [pc, #84]	; 3481e3ac <net_init+0x60>
3481e354:	e594300c 	ldr	r3, [r4, #12]
3481e358:	e3530000 	cmp	r3, #0
3481e35c:	0a000010 	beq	3481e3a4 <net_init+0x58>
		/*
		 *	Setup packet buffers, aligned correctly.
		 */
		int i;

		NetTxPacket = &PktBuf[0] + (PKTALIGN - 1);
3481e360:	e59f2048 	ldr	r2, [pc, #72]	; 3481e3b0 <net_init+0x64>
3481e364:	e282309b 	add	r3, r2, #155	; 0x9b
		NetTxPacket -= (ulong)NetTxPacket % PKTALIGN;
3481e368:	e3c3303f 	bic	r3, r3, #63	; 0x3f
3481e36c:	e5823040 	str	r3, [r2, #64]	; 0x40
		for (i = 0; i < PKTBUFSRX; i++)
			NetRxPackets[i] = NetTxPacket + (i + 1) * PKTSIZE_ALIGN;
3481e370:	e59f203c 	ldr	r2, [pc, #60]	; 3481e3b4 <net_init+0x68>
3481e374:	e2831c06 	add	r1, r3, #1536	; 0x600
3481e378:	e502115c 	str	r1, [r2, #-348]	; 0x15c
3481e37c:	e2831b03 	add	r1, r3, #3072	; 0xc00
3481e380:	e5021158 	str	r1, [r2, #-344]	; 0x158
3481e384:	e2831c12 	add	r1, r3, #4608	; 0x1200
3481e388:	e2833b06 	add	r3, r3, #6144	; 0x1800
3481e38c:	e5023150 	str	r3, [r2, #-336]	; 0x150
3481e390:	e5021154 	str	r1, [r2, #-340]	; 0x154

		ArpInit();
3481e394:	ebfff887 	bl	3481c5b8 <ArpInit>
		net_clear_handlers();
3481e398:	ebfffdcc 	bl	3481dad0 <net_clear_handlers>

		/* Only need to setup buffer pointers once. */
		first_call = 0;
3481e39c:	e3a03000 	mov	r3, #0
3481e3a0:	e584300c 	str	r3, [r4, #12]
	}

	NetInitLoop();
}
3481e3a4:	e8bd4010 	pop	{r4, lr}

		/* Only need to setup buffer pointers once. */
		first_call = 0;
	}

	NetInitLoop();
3481e3a8:	eaffffbb 	b	3481e29c <NetInitLoop>
3481e3ac:	34828ba0 	.word	0x34828ba0
3481e3b0:	3482b9d4 	.word	0x3482b9d4
3481e3b4:	3482d9cc 	.word	0x3482d9cc

3481e3b8 <NetLoop>:
/*
 *	Main network processing loop.
 */

int NetLoop(enum proto_t protocol)
{
3481e3b8:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	bd_t *bd = gd->bd;
	int ret = -1;

	NetRestarted = 0;
3481e3bc:	e59f42bc 	ldr	r4, [pc, #700]	; 3481e680 <NetLoop+0x2c8>
3481e3c0:	e3a06000 	mov	r6, #0
	NetDevExists = 0;
	NetTryCount = 1;
3481e3c4:	e3a09001 	mov	r9, #1
/*
 *	Main network processing loop.
 */

int NetLoop(enum proto_t protocol)
{
3481e3c8:	e24dd020 	sub	sp, sp, #32
	bd_t *bd = gd->bd;
	int ret = -1;

	NetRestarted = 0;
3481e3cc:	e584601c 	str	r6, [r4, #28]
	NetDevExists = 0;
3481e3d0:	e5846024 	str	r6, [r4, #36]	; 0x24
	NetTryCount = 1;
3481e3d4:	e5849018 	str	r9, [r4, #24]
/*
 *	Main network processing loop.
 */

int NetLoop(enum proto_t protocol)
{
3481e3d8:	e1a05000 	mov	r5, r0
	bd_t *bd = gd->bd;
3481e3dc:	e5987000 	ldr	r7, [r8]
	NetDevExists = 0;
	NetTryCount = 1;
	debug_cond(DEBUG_INT_STATE, "--- NetLoop Entry\n");

	bootstage_mark_name(BOOTSTAGE_ID_ETH_START, "eth_start");
	net_init();
3481e3e0:	ebffffd9 	bl	3481e34c <net_init>
	if (eth_is_on_demand_init() || protocol != NETCONS) {
		eth_halt();
3481e3e4:	ebfffc8b 	bl	3481d618 <eth_halt>
		eth_set_current();
3481e3e8:	ebfffcff 	bl	3481d7ec <eth_set_current>
		if (eth_init(bd) < 0) {
3481e3ec:	e1a00007 	mov	r0, r7
3481e3f0:	ebfffccc 	bl	3481d728 <eth_init>
3481e3f4:	e1500006 	cmp	r0, r6
3481e3f8:	ba00009e 	blt	3481e678 <NetLoop+0x2c0>
{
	switch (protocol) {
		/* Fall through */
#if defined(CONFIG_CMD_PING)
	case PING:
		if (NetPingIP == 0) {
3481e3fc:	e59f7280 	ldr	r7, [pc, #640]	; 3481e684 <NetLoop+0x2cc>
		/* network device not configured */
		break;

	case 0:
		NetDevExists = 1;
		NetBootFileXferSize = 0;
3481e400:	e59fb280 	ldr	fp, [pc, #640]	; 3481e688 <NetLoop+0x2d0>
static inline void net_set_state(enum net_loop_state state)
{
	extern enum net_loop_state net_state;

	debug_cond(DEBUG_INT_STATE, "--- NetState set to %d\n", state);
	net_state = state;
3481e404:	e1a0a006 	mov	sl, r6
3481e408:	e584a000 	str	sl, [r4]
	 *	Start the ball rolling with the given start function.  From
	 *	here on, this code is a state machine driven by received
	 *	packets and timer events.
	 */
	debug_cond(DEBUG_INT_STATE, "--- NetLoop Init\n");
	NetInitLoop();
3481e40c:	ebffffa2 	bl	3481e29c <NetInitLoop>

/**********************************************************************/

static int net_check_prereq(enum proto_t protocol)
{
	switch (protocol) {
3481e410:	e355000d 	cmp	r5, #13
3481e414:	979ff105 	ldrls	pc, [pc, r5, lsl #2]
3481e418:	ea000031 	b	3481e4e4 <NetLoop+0x12c>
3481e41c:	3481e488 	.word	0x3481e488
3481e420:	3481e4e4 	.word	0x3481e4e4
3481e424:	3481e4e4 	.word	0x3481e4e4
3481e428:	3481e468 	.word	0x3481e468
3481e42c:	3481e488 	.word	0x3481e488
3481e430:	3481e454 	.word	0x3481e454
3481e434:	3481e4e4 	.word	0x3481e4e4
3481e438:	3481e468 	.word	0x3481e468
3481e43c:	3481e488 	.word	0x3481e488
3481e440:	3481e478 	.word	0x3481e478
3481e444:	3481e4e4 	.word	0x3481e4e4
3481e448:	3481e478 	.word	0x3481e478
3481e44c:	3481e468 	.word	0x3481e468
3481e450:	3481e488 	.word	0x3481e488
		/* Fall through */
#if defined(CONFIG_CMD_PING)
	case PING:
		if (NetPingIP == 0) {
3481e454:	e5973000 	ldr	r3, [r7]
3481e458:	e3530000 	cmp	r3, #0
3481e45c:	1a000005 	bne	3481e478 <NetLoop+0xc0>
			puts("*** ERROR: ping address not given\n");
3481e460:	e59f0224 	ldr	r0, [pc, #548]	; 3481e68c <NetLoop+0x2d4>
3481e464:	ea000015 	b	3481e4c0 <NetLoop+0x108>
#if defined(CONFIG_CMD_NFS)
	case NFS:
#endif
	case TFTPGET:
	case TFTPPUT:
		if (NetServerIP == 0) {
3481e468:	e5943058 	ldr	r3, [r4, #88]	; 0x58
3481e46c:	e3530000 	cmp	r3, #0
			puts("*** ERROR: `serverip' not set\n");
3481e470:	059f0218 	ldreq	r0, [pc, #536]	; 3481e690 <NetLoop+0x2d8>
3481e474:	0a000011 	beq	3481e4c0 <NetLoop+0x108>
#endif
		/* Fall through */

	case NETCONS:
	case TFTPSRV:
		if (NetOurIP == 0) {
3481e478:	e5943030 	ldr	r3, [r4, #48]	; 0x30
3481e47c:	e3530000 	cmp	r3, #0
			puts("*** ERROR: `ipaddr' not set\n");
3481e480:	059f020c 	ldreq	r0, [pc, #524]	; 3481e694 <NetLoop+0x2dc>
3481e484:	0a00000d 	beq	3481e4c0 <NetLoop+0x108>
#endif
	case BOOTP:
	case CDP:
	case DHCP:
	case LINKLOCAL:
		if (memcmp(NetOurEther, "\0\0\0\0\0\0", 6) == 0) {
3481e488:	e59f0208 	ldr	r0, [pc, #520]	; 3481e698 <NetLoop+0x2e0>
3481e48c:	e59f1208 	ldr	r1, [pc, #520]	; 3481e69c <NetLoop+0x2e4>
3481e490:	e3a02006 	mov	r2, #6
3481e494:	ebffeab0 	bl	34818f5c <memcmp>
3481e498:	e3500000 	cmp	r0, #0
3481e49c:	1a000010 	bne	3481e4e4 <NetLoop+0x12c>
			int num = eth_get_dev_index();
3481e4a0:	ebfffb41 	bl	3481d1ac <eth_get_dev_index>

			switch (num) {
3481e4a4:	e3700001 	cmn	r0, #1
	case BOOTP:
	case CDP:
	case DHCP:
	case LINKLOCAL:
		if (memcmp(NetOurEther, "\0\0\0\0\0\0", 6) == 0) {
			int num = eth_get_dev_index();
3481e4a8:	e1a01000 	mov	r1, r0

			switch (num) {
3481e4ac:	0a000002 	beq	3481e4bc <NetLoop+0x104>
3481e4b0:	e3500000 	cmp	r0, #0
3481e4b4:	0a000003 	beq	3481e4c8 <NetLoop+0x110>
3481e4b8:	ea000005 	b	3481e4d4 <NetLoop+0x11c>
			case -1:
				puts("*** ERROR: No ethernet found.\n");
3481e4bc:	e59f01dc 	ldr	r0, [pc, #476]	; 3481e6a0 <NetLoop+0x2e8>
3481e4c0:	ebffaa97 	bl	34808f24 <puts>
3481e4c4:	ea00006b 	b	3481e678 <NetLoop+0x2c0>
				return 1;
			case 0:
				puts("*** ERROR: `ethaddr' not set\n");
3481e4c8:	e59f01d4 	ldr	r0, [pc, #468]	; 3481e6a4 <NetLoop+0x2ec>
3481e4cc:	ebffaa94 	bl	34808f24 <puts>
3481e4d0:	ea000001 	b	3481e4dc <NetLoop+0x124>
				break;
			default:
				printf("*** ERROR: `eth%daddr' not set\n",
3481e4d4:	e59f01cc 	ldr	r0, [pc, #460]	; 3481e6a8 <NetLoop+0x2f0>
3481e4d8:	ebffaa9b 	bl	34808f4c <printf>
					num);
				break;
			}

			NetStartAgain();
3481e4dc:	ebfffd38 	bl	3481d9c4 <NetStartAgain>
3481e4e0:	ea000017 	b	3481e544 <NetLoop+0x18c>
	case 2:
		/* network device not configured */
		break;

	case 0:
		NetDevExists = 1;
3481e4e4:	e5849024 	str	r9, [r4, #36]	; 0x24
		NetBootFileXferSize = 0;
3481e4e8:	e50b614c 	str	r6, [fp, #-332]	; 0x14c
		switch (protocol) {
3481e4ec:	e3550007 	cmp	r5, #7
3481e4f0:	979ff105 	ldrls	pc, [pc, r5, lsl #2]
3481e4f4:	ea000012 	b	3481e544 <NetLoop+0x18c>
3481e4f8:	3481e524 	.word	0x3481e524
3481e4fc:	3481e544 	.word	0x3481e544
3481e500:	3481e544 	.word	0x3481e544
3481e504:	3481e518 	.word	0x3481e518
3481e508:	3481e544 	.word	0x3481e544
3481e50c:	3481e538 	.word	0x3481e538
3481e510:	3481e544 	.word	0x3481e544
3481e514:	3481e540 	.word	0x3481e540
		case TFTPGET:
#ifdef CONFIG_CMD_TFTPPUT
		case TFTPPUT:
#endif
			/* always use ARP to get server ethernet address */
			TftpStart(protocol);
3481e518:	e3a00003 	mov	r0, #3
3481e51c:	eb00059e 	bl	3481fb9c <TftpStart>
			break;
3481e520:	ea000007 	b	3481e544 <NetLoop+0x18c>
			DhcpRequest();		/* Basically same as BOOTP */
			break;
#endif

		case BOOTP:
			BootpTry = 0;
3481e524:	e59f2180 	ldr	r2, [pc, #384]	; 3481e6ac <NetLoop+0x2f4>
			NetOurIP = 0;
3481e528:	e5846030 	str	r6, [r4, #48]	; 0x30
			DhcpRequest();		/* Basically same as BOOTP */
			break;
#endif

		case BOOTP:
			BootpTry = 0;
3481e52c:	e5826000 	str	r6, [r2]
			NetOurIP = 0;
			BootpRequest();
3481e530:	ebfffa00 	bl	3481cd38 <BootpRequest>
			break;
3481e534:	ea000002 	b	3481e544 <NetLoop+0x18c>
			RarpRequest();
			break;
#endif
#if defined(CONFIG_CMD_PING)
		case PING:
			ping_start();
3481e538:	eb0003d1 	bl	3481f484 <ping_start>
			break;
3481e53c:	ea000000 	b	3481e544 <NetLoop+0x18c>
#endif
#if defined(CONFIG_CMD_NFS)
		case NFS:
			NfsStart();
3481e540:	eb00033d 	bl	3481f23c <NfsStart>
#endif
		/*
		 *	Check the ethernet for a new packet.  The ethernet
		 *	receive routine will process it.
		 */
		eth_rx();
3481e544:	ebfffc4d 	bl	3481d680 <eth_rx>

		/*
		 *	Abort if ctrl-c was pressed.
		 */
		if (ctrlc()) {
3481e548:	ebffaaa4 	bl	34808fe0 <ctrlc>
3481e54c:	e3500000 	cmp	r0, #0
3481e550:	e58d0004 	str	r0, [sp, #4]
3481e554:	0a000007 	beq	3481e578 <NetLoop+0x1c0>
			/* cancel any ARP that may not have completed */
			NetArpWaitPacketIP = 0;
3481e558:	e59f3150 	ldr	r3, [pc, #336]	; 3481e6b0 <NetLoop+0x2f8>
3481e55c:	e3a02000 	mov	r2, #0
3481e560:	e5832000 	str	r2, [r3]
	NetSetTimeout(0, NULL);
}

static void net_cleanup_loop(void)
{
	net_clear_handlers();
3481e564:	ebfffd59 	bl	3481dad0 <net_clear_handlers>
		if (ctrlc()) {
			/* cancel any ARP that may not have completed */
			NetArpWaitPacketIP = 0;

			net_cleanup_loop();
			eth_halt();
3481e568:	ebfffc2a 	bl	3481d618 <eth_halt>
			/* Invalidate the last protocol */
			eth_set_last_protocol(BOOTP);

			puts("\nAbort\n");
3481e56c:	e59f0140 	ldr	r0, [pc, #320]	; 3481e6b4 <NetLoop+0x2fc>
3481e570:	ebffaa6b 	bl	34808f24 <puts>
3481e574:	ea00003c 	b	3481e66c <NetLoop+0x2b4>
			   messages are directed to stderr */
			debug_cond(DEBUG_INT_STATE, "--- NetLoop Abort!\n");
			goto done;
		}

		ArpTimeoutCheck();
3481e578:	ebfff86b 	bl	3481c72c <ArpTimeoutCheck>

		/*
		 *	Check for a timeout, and run the timeout handler
		 *	if we have one.
		 */
		if (timeHandler && ((get_timer(0) - timeStart) > timeDelta)) {
3481e57c:	e594300c 	ldr	r3, [r4, #12]
3481e580:	e3530000 	cmp	r3, #0
3481e584:	0a00000a 	beq	3481e5b4 <NetLoop+0x1fc>
3481e588:	e59d0004 	ldr	r0, [sp, #4]
3481e58c:	ebff8b30 	bl	34801254 <get_timer>
3481e590:	e5943010 	ldr	r3, [r4, #16]
3481e594:	e5942014 	ldr	r2, [r4, #20]
3481e598:	e0633000 	rsb	r3, r3, r0
3481e59c:	e1530002 	cmp	r3, r2
3481e5a0:	9a000003 	bls	3481e5b4 <NetLoop+0x1fc>
			}
#endif /* CONFIG_SYS_FAULT_ECHO_LINK_DOWN, ... */
#endif /* CONFIG_MII, ... */
			debug_cond(DEBUG_INT_STATE, "--- NetLoop timeout\n");
			x = timeHandler;
			timeHandler = (thand_f *)0;
3481e5a4:	e59d2004 	ldr	r2, [sp, #4]
				status_led_set(STATUS_LED_RED, STATUS_LED_ON);
			}
#endif /* CONFIG_SYS_FAULT_ECHO_LINK_DOWN, ... */
#endif /* CONFIG_MII, ... */
			debug_cond(DEBUG_INT_STATE, "--- NetLoop timeout\n");
			x = timeHandler;
3481e5a8:	e594300c 	ldr	r3, [r4, #12]
			timeHandler = (thand_f *)0;
3481e5ac:	e584200c 	str	r2, [r4, #12]
			(*x)();
3481e5b0:	e12fff33 	blx	r3
		}


		switch (net_state) {
3481e5b4:	e5943000 	ldr	r3, [r4]
3481e5b8:	e3530002 	cmp	r3, #2
3481e5bc:	0a000006 	beq	3481e5dc <NetLoop+0x224>
3481e5c0:	e3530003 	cmp	r3, #3
3481e5c4:	0a000027 	beq	3481e668 <NetLoop+0x2b0>
3481e5c8:	e3530001 	cmp	r3, #1
3481e5cc:	1affffdc 	bne	3481e544 <NetLoop+0x18c>

		case NETLOOP_RESTART:
			NetRestarted = 1;
3481e5d0:	e59f20a8 	ldr	r2, [pc, #168]	; 3481e680 <NetLoop+0x2c8>
3481e5d4:	e582301c 	str	r3, [r2, #28]
			goto restart;
3481e5d8:	eaffff8a 	b	3481e408 <NetLoop+0x50>

		case NETLOOP_SUCCESS:
			net_cleanup_loop();
			if (NetBootFileXferSize > 0) {
3481e5dc:	e59f60a4 	ldr	r6, [pc, #164]	; 3481e688 <NetLoop+0x2d0>
	NetSetTimeout(0, NULL);
}

static void net_cleanup_loop(void)
{
	net_clear_handlers();
3481e5e0:	ebfffd3a 	bl	3481dad0 <net_clear_handlers>
			NetRestarted = 1;
			goto restart;

		case NETLOOP_SUCCESS:
			net_cleanup_loop();
			if (NetBootFileXferSize > 0) {
3481e5e4:	e516114c 	ldr	r1, [r6, #-332]	; 0x14c
3481e5e8:	e3510000 	cmp	r1, #0
3481e5ec:	0a000012 	beq	3481e63c <NetLoop+0x284>
				char buf[20];
				printf("Bytes transferred = %ld (%lx hex)\n",
					NetBootFileXferSize,
					NetBootFileXferSize);
				sprintf(buf, "%lX", NetBootFileXferSize);
3481e5f0:	e28d400c 	add	r4, sp, #12

		case NETLOOP_SUCCESS:
			net_cleanup_loop();
			if (NetBootFileXferSize > 0) {
				char buf[20];
				printf("Bytes transferred = %ld (%lx hex)\n",
3481e5f4:	e1a02001 	mov	r2, r1
3481e5f8:	e59f00b8 	ldr	r0, [pc, #184]	; 3481e6b8 <NetLoop+0x300>
3481e5fc:	ebffaa52 	bl	34808f4c <printf>
					NetBootFileXferSize,
					NetBootFileXferSize);
				sprintf(buf, "%lX", NetBootFileXferSize);
3481e600:	e516214c 	ldr	r2, [r6, #-332]	; 0x14c
3481e604:	e59f10b0 	ldr	r1, [pc, #176]	; 3481e6bc <NetLoop+0x304>
3481e608:	e1a00004 	mov	r0, r4
3481e60c:	ebffee1f 	bl	34819e90 <sprintf>
				setenv("filesize", buf);
3481e610:	e1a01004 	mov	r1, r4
3481e614:	e59f00a4 	ldr	r0, [pc, #164]	; 3481e6c0 <NetLoop+0x308>
3481e618:	ebffa5ff 	bl	34807e1c <setenv>

				sprintf(buf, "%lX", (unsigned long)load_addr);
3481e61c:	e59f30a0 	ldr	r3, [pc, #160]	; 3481e6c4 <NetLoop+0x30c>
3481e620:	e59f1094 	ldr	r1, [pc, #148]	; 3481e6bc <NetLoop+0x304>
3481e624:	e1a00004 	mov	r0, r4
3481e628:	e5932000 	ldr	r2, [r3]
3481e62c:	ebffee17 	bl	34819e90 <sprintf>
				setenv("fileaddr", buf);
3481e630:	e59f0090 	ldr	r0, [pc, #144]	; 3481e6c8 <NetLoop+0x310>
3481e634:	e1a01004 	mov	r1, r4
3481e638:	ebffa5f7 	bl	34807e1c <setenv>
			}
			if (protocol != NETCONS)
3481e63c:	e3550009 	cmp	r5, #9
3481e640:	0a000001 	beq	3481e64c <NetLoop+0x294>
				eth_halt();
3481e644:	ebfffbf3 	bl	3481d618 <eth_halt>
3481e648:	ea000003 	b	3481e65c <NetLoop+0x2a4>
	return 0;
}
/* Set passive state */
static inline __attribute__((always_inline)) void eth_halt_state_only(void)
{
	eth_get_dev()->state = ETH_STATE_PASSIVE;
3481e64c:	e59f3078 	ldr	r3, [pc, #120]	; 3481e6cc <NetLoop+0x314>
3481e650:	e3a02001 	mov	r2, #1
3481e654:	e5933000 	ldr	r3, [r3]
3481e658:	e583201c 	str	r2, [r3, #28]
			else
				eth_halt_state_only();

			eth_set_last_protocol(protocol);

			ret = NetBootFileXferSize;
3481e65c:	e59f3024 	ldr	r3, [pc, #36]	; 3481e688 <NetLoop+0x2d0>
3481e660:	e513014c 	ldr	r0, [r3, #-332]	; 0x14c
			debug_cond(DEBUG_INT_STATE, "--- NetLoop Success!\n");
			goto done;
3481e664:	ea000001 	b	3481e670 <NetLoop+0x2b8>
	NetSetTimeout(0, NULL);
}

static void net_cleanup_loop(void)
{
	net_clear_handlers();
3481e668:	ebfffd18 	bl	3481dad0 <net_clear_handlers>
 */

int NetLoop(enum proto_t protocol)
{
	bd_t *bd = gd->bd;
	int ret = -1;
3481e66c:	e3e00000 	mvn	r0, #0
	/* Clear out the handlers */
	net_set_udp_handler(NULL);
	net_set_icmp_handler(NULL);
#endif
	return ret;
}
3481e670:	e28dd020 	add	sp, sp, #32
3481e674:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
	NetInitLoop();

	switch (net_check_prereq(protocol)) {
	case 1:
		/* network not configured */
		eth_halt();
3481e678:	ebfffbe6 	bl	3481d618 <eth_halt>
3481e67c:	eafffffa 	b	3481e66c <NetLoop+0x2b4>
3481e680:	3482b9d4 	.word	0x3482b9d4
3481e684:	3482e244 	.word	0x3482e244
3481e688:	3482d9cc 	.word	0x3482d9cc
3481e68c:	34827db9 	.word	0x34827db9
3481e690:	34827ddc 	.word	0x34827ddc
3481e694:	34827dfb 	.word	0x34827dfb
3481e698:	3482ba08 	.word	0x3482ba08
3481e69c:	34822aec 	.word	0x34822aec
3481e6a0:	34827e18 	.word	0x34827e18
3481e6a4:	34827e37 	.word	0x34827e37
3481e6a8:	34827e55 	.word	0x34827e55
3481e6ac:	3482b9b8 	.word	0x3482b9b8
3481e6b0:	3482b35c 	.word	0x3482b35c
3481e6b4:	34827e75 	.word	0x34827e75
3481e6b8:	34827e7d 	.word	0x34827e7d
3481e6bc:	3482350e 	.word	0x3482350e
3481e6c0:	34823512 	.word	0x34823512
3481e6c4:	348283c4 	.word	0x348283c4
3481e6c8:	34827ea0 	.word	0x34827ea0
3481e6cc:	3482b9bc 	.word	0x3482b9bc

3481e6d0 <__fswab32>:
}

static __inline__ __attribute__((const)) __u32 __fswab32(__u32 x)
{
	return __arch__swab32(x);
}
3481e6d0:	e6bf0f30 	rev	r0, r0
3481e6d4:	e12fff1e 	bx	lr

3481e6d8 <basename>:
	return 0;
}

static char*
basename(char *path)
{
3481e6d8:	e92d4010 	push	{r4, lr}
3481e6dc:	e1a04000 	mov	r4, r0
	char *fname;

	fname = path + strlen(path) - 1;
3481e6e0:	ebffe926 	bl	34818b80 <strlen>
3481e6e4:	e2403001 	sub	r3, r0, #1
3481e6e8:	e0843003 	add	r3, r4, r3
	while (fname >= path) {
3481e6ec:	ea000005 	b	3481e708 <basename+0x30>
		if (*fname == '/') {
3481e6f0:	e5d32000 	ldrb	r2, [r3]
3481e6f4:	e2403001 	sub	r3, r0, #1
3481e6f8:	e352002f 	cmp	r2, #47	; 0x2f
3481e6fc:	1a000001 	bne	3481e708 <basename+0x30>
			fname++;
3481e700:	e2800001 	add	r0, r0, #1
			break;
3481e704:	e8bd8010 	pop	{r4, pc}
basename(char *path)
{
	char *fname;

	fname = path + strlen(path) - 1;
	while (fname >= path) {
3481e708:	e1530004 	cmp	r3, r4
		if (*fname == '/') {
			fname++;
			break;
3481e70c:	e1a00003 	mov	r0, r3
basename(char *path)
{
	char *fname;

	fname = path + strlen(path) - 1;
	while (fname >= path) {
3481e710:	2afffff6 	bcs	3481e6f0 <basename+0x18>
			break;
		}
		fname--;
	}
	return fname;
}
3481e714:	e8bd8010 	pop	{r4, pc}

3481e718 <rpc_add_credentials>:

/**************************************************************************
RPC_ADD_CREDENTIALS - Add RPC authentication/verifier entries
**************************************************************************/
static long *rpc_add_credentials(long *p)
{
3481e718:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
3481e71c:	e24ddc01 	sub	sp, sp, #256	; 0x100
3481e720:	e1a04000 	mov	r4, r0
	int hl;
	int hostnamelen;
	char hostname[256];

	strcpy(hostname, "");
3481e724:	e59f10bc 	ldr	r1, [pc, #188]	; 3481e7e8 <rpc_add_credentials+0xd0>
3481e728:	e1a0000d 	mov	r0, sp
3481e72c:	ebffe8ae 	bl	348189ec <strcpy>
	hostnamelen = strlen(hostname);
3481e730:	e1a0000d 	mov	r0, sp
3481e734:	ebffe911 	bl	34818b80 <strlen>
	 * AUTH_UNIX (also accepts an empty hostname field in the AUTH_UNIX
	 * scheme).  To be safe, use AUTH_UNIX and pass the hostname if we have
	 * it (if the BOOTP/DHCP reply didn't give one, just use an empty
	 * hostname).  */

	hl = (hostnamelen + 3) & ~3;
3481e738:	e2809003 	add	r9, r0, #3

	/* Provide an AUTH_UNIX credential.  */
	*p++ = htonl(1);		/* AUTH_UNIX */
3481e73c:	e1a07004 	mov	r7, r4
3481e740:	e3a03401 	mov	r3, #16777216	; 0x1000000
	 * AUTH_UNIX (also accepts an empty hostname field in the AUTH_UNIX
	 * scheme).  To be safe, use AUTH_UNIX and pass the hostname if we have
	 * it (if the BOOTP/DHCP reply didn't give one, just use an empty
	 * hostname).  */

	hl = (hostnamelen + 3) & ~3;
3481e744:	e3c95003 	bic	r5, r9, #3

	/* Provide an AUTH_UNIX credential.  */
	*p++ = htonl(1);		/* AUTH_UNIX */
3481e748:	e4873004 	str	r3, [r7], #4
	int hl;
	int hostnamelen;
	char hostname[256];

	strcpy(hostname, "");
	hostnamelen = strlen(hostname);
3481e74c:	e1a06000 	mov	r6, r0

	hl = (hostnamelen + 3) & ~3;

	/* Provide an AUTH_UNIX credential.  */
	*p++ = htonl(1);		/* AUTH_UNIX */
	*p++ = htonl(hl+20);		/* auth length */
3481e750:	e2850014 	add	r0, r5, #20
3481e754:	ebffffdd 	bl	3481e6d0 <__fswab32>
	*p++ = htonl(0);		/* stamp */
3481e758:	e3a0a000 	mov	sl, #0

	hl = (hostnamelen + 3) & ~3;

	/* Provide an AUTH_UNIX credential.  */
	*p++ = htonl(1);		/* AUTH_UNIX */
	*p++ = htonl(hl+20);		/* auth length */
3481e75c:	e5840004 	str	r0, [r4, #4]
	*p++ = htonl(0);		/* stamp */
3481e760:	e587a004 	str	sl, [r7, #4]
	*p++ = htonl(hostnamelen);	/* hostname string */
3481e764:	e1a00006 	mov	r0, r6
3481e768:	ebffffd8 	bl	3481e6d0 <__fswab32>

	hl = (hostnamelen + 3) & ~3;

	/* Provide an AUTH_UNIX credential.  */
	*p++ = htonl(1);		/* AUTH_UNIX */
	*p++ = htonl(hl+20);		/* auth length */
3481e76c:	e287b004 	add	fp, r7, #4
	*p++ = htonl(0);		/* stamp */
3481e770:	e28b4004 	add	r4, fp, #4
	*p++ = htonl(hostnamelen);	/* hostname string */
	if (hostnamelen & 3)
3481e774:	e3160003 	tst	r6, #3

	/* Provide an AUTH_UNIX credential.  */
	*p++ = htonl(1);		/* AUTH_UNIX */
	*p++ = htonl(hl+20);		/* auth length */
	*p++ = htonl(0);		/* stamp */
	*p++ = htonl(hostnamelen);	/* hostname string */
3481e778:	e58b0004 	str	r0, [fp, #4]
3481e77c:	e2844004 	add	r4, r4, #4
	if (hostnamelen & 3)
3481e780:	0a000003 	beq	3481e794 <rpc_add_credentials+0x7c>
		*(p + hostnamelen / 4) = 0; /* add zero padding */
3481e784:	e156000a 	cmp	r6, sl
3481e788:	a1a09006 	movge	r9, r6
3481e78c:	e1a09149 	asr	r9, r9, #2
3481e790:	e784a109 	str	sl, [r4, r9, lsl #2]
	memcpy(p, hostname, hostnamelen);
3481e794:	e1a0100d 	mov	r1, sp
3481e798:	e1a02006 	mov	r2, r6
3481e79c:	e1a00004 	mov	r0, r4
3481e7a0:	ebffe9ba 	bl	34818e90 <memcpy>
	p += hl / 4;
3481e7a4:	e2853003 	add	r3, r5, #3
3481e7a8:	e3550000 	cmp	r5, #0
3481e7ac:	b1a05003 	movlt	r5, r3
3481e7b0:	e1a05145 	asr	r5, r5, #2
3481e7b4:	e0842105 	add	r2, r4, r5, lsl #2
	*p++ = 0;			/* uid */
3481e7b8:	e3a03000 	mov	r3, #0
3481e7bc:	e2821004 	add	r1, r2, #4
3481e7c0:	e7843105 	str	r3, [r4, r5, lsl #2]
	*p++ = 0;			/* gid */
3481e7c4:	e5823004 	str	r3, [r2, #4]
3481e7c8:	e2812004 	add	r2, r1, #4
	*p++ = 0;			/* auxiliary gid list */
3481e7cc:	e2820004 	add	r0, r2, #4
3481e7d0:	e5813004 	str	r3, [r1, #4]

	/* Provide an AUTH_NONE verifier.  */
	*p++ = 0;			/* AUTH_NONE */
3481e7d4:	e5823004 	str	r3, [r2, #4]
	*p++ = 0;			/* auth length */
3481e7d8:	e5803004 	str	r3, [r0, #4]

	return p;
}
3481e7dc:	e2800008 	add	r0, r0, #8
3481e7e0:	e28ddc01 	add	sp, sp, #256	; 0x100
3481e7e4:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
3481e7e8:	34824054 	.word	0x34824054

3481e7ec <rpc_lookup_reply>:
Handlers for the reply from server
**************************************************************************/

static int
rpc_lookup_reply(int prog, uchar *pkt, unsigned len)
{
3481e7ec:	e92d4070 	push	{r4, r5, r6, lr}
3481e7f0:	e24ddb02 	sub	sp, sp, #2048	; 0x800
3481e7f4:	e1a04000 	mov	r4, r0
	struct rpc_t rpc_pkt;

	memcpy((unsigned char *)&rpc_pkt, pkt, len);
3481e7f8:	e1a0000d 	mov	r0, sp
3481e7fc:	ebffe9a3 	bl	34818e90 <memcpy>

	debug("%s\n", __func__);

	if (ntohl(rpc_pkt.u.reply.id) != rpc_id)
3481e800:	e59d0000 	ldr	r0, [sp]
3481e804:	ebffffb1 	bl	3481e6d0 <__fswab32>
3481e808:	e59f6074 	ldr	r6, [pc, #116]	; 3481e884 <rpc_lookup_reply+0x98>
3481e80c:	e5963000 	ldr	r3, [r6]
3481e810:	e1500003 	cmp	r0, r3
3481e814:	1a000016 	bne	3481e874 <rpc_lookup_reply+0x88>
		return -1;

	if (rpc_pkt.u.reply.rstatus  ||
3481e818:	e59d3008 	ldr	r3, [sp, #8]
3481e81c:	e3530000 	cmp	r3, #0
3481e820:	1a000013 	bne	3481e874 <rpc_lookup_reply+0x88>
3481e824:	e59d300c 	ldr	r3, [sp, #12]
3481e828:	e3530000 	cmp	r3, #0
3481e82c:	1a000010 	bne	3481e874 <rpc_lookup_reply+0x88>
	    rpc_pkt.u.reply.verifier ||
3481e830:	e59d5014 	ldr	r5, [sp, #20]
3481e834:	e3550000 	cmp	r5, #0
3481e838:	1a00000d 	bne	3481e874 <rpc_lookup_reply+0x88>
	    rpc_pkt.u.reply.astatus)
		return -1;

	switch (prog) {
3481e83c:	e59f3044 	ldr	r3, [pc, #68]	; 3481e888 <rpc_lookup_reply+0x9c>
3481e840:	e1540003 	cmp	r4, r3
3481e844:	0a000006 	beq	3481e864 <rpc_lookup_reply+0x78>
3481e848:	e2833002 	add	r3, r3, #2
3481e84c:	e1540003 	cmp	r4, r3
3481e850:	1a000008 	bne	3481e878 <rpc_lookup_reply+0x8c>
	case PROG_MOUNT:
		NfsSrvMountPort = ntohl(rpc_pkt.u.reply.data[0]);
3481e854:	e59d0018 	ldr	r0, [sp, #24]
3481e858:	ebffff9c 	bl	3481e6d0 <__fswab32>
3481e85c:	e5860004 	str	r0, [r6, #4]
		break;
3481e860:	ea000004 	b	3481e878 <rpc_lookup_reply+0x8c>
	case PROG_NFS:
		NfsSrvNfsPort = ntohl(rpc_pkt.u.reply.data[0]);
3481e864:	e59d0018 	ldr	r0, [sp, #24]
3481e868:	ebffff98 	bl	3481e6d0 <__fswab32>
3481e86c:	e5860008 	str	r0, [r6, #8]
		break;
3481e870:	ea000000 	b	3481e878 <rpc_lookup_reply+0x8c>
		return -1;

	if (rpc_pkt.u.reply.rstatus  ||
	    rpc_pkt.u.reply.verifier ||
	    rpc_pkt.u.reply.astatus)
		return -1;
3481e874:	e3e05000 	mvn	r5, #0
		NfsSrvNfsPort = ntohl(rpc_pkt.u.reply.data[0]);
		break;
	}

	return 0;
}
3481e878:	e1a00005 	mov	r0, r5
3481e87c:	e28ddb02 	add	sp, sp, #2048	; 0x800
3481e880:	e8bd8070 	pop	{r4, r5, r6, pc}
3481e884:	3482d994 	.word	0x3482d994
3481e888:	000186a3 	.word	0x000186a3

3481e88c <rpc_req>:
/**************************************************************************
RPC_LOOKUP - Lookup RPC Port numbers
**************************************************************************/
static void
rpc_req(int rpc_prog, int rpc_proc, uint32_t *data, int datalen)
{
3481e88c:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
3481e890:	e1a05003 	mov	r5, r3
	unsigned long id;
	uint32_t *p;
	int pktlen;
	int sport;

	id = ++rpc_id;
3481e894:	e59f30dc 	ldr	r3, [pc, #220]	; 3481e978 <rpc_req+0xec>
/**************************************************************************
RPC_LOOKUP - Lookup RPC Port numbers
**************************************************************************/
static void
rpc_req(int rpc_prog, int rpc_proc, uint32_t *data, int datalen)
{
3481e898:	e1a04000 	mov	r4, r0
	unsigned long id;
	uint32_t *p;
	int pktlen;
	int sport;

	id = ++rpc_id;
3481e89c:	e5930000 	ldr	r0, [r3]
/**************************************************************************
RPC_LOOKUP - Lookup RPC Port numbers
**************************************************************************/
static void
rpc_req(int rpc_prog, int rpc_proc, uint32_t *data, int datalen)
{
3481e8a0:	e24ddb02 	sub	sp, sp, #2048	; 0x800
	unsigned long id;
	uint32_t *p;
	int pktlen;
	int sport;

	id = ++rpc_id;
3481e8a4:	e2800001 	add	r0, r0, #1
/**************************************************************************
RPC_LOOKUP - Lookup RPC Port numbers
**************************************************************************/
static void
rpc_req(int rpc_prog, int rpc_proc, uint32_t *data, int datalen)
{
3481e8a8:	e24dd008 	sub	sp, sp, #8
	unsigned long id;
	uint32_t *p;
	int pktlen;
	int sport;

	id = ++rpc_id;
3481e8ac:	e5830000 	str	r0, [r3]
/**************************************************************************
RPC_LOOKUP - Lookup RPC Port numbers
**************************************************************************/
static void
rpc_req(int rpc_prog, int rpc_proc, uint32_t *data, int datalen)
{
3481e8b0:	e1a06001 	mov	r6, r1
3481e8b4:	e1a07002 	mov	r7, r2
	uint32_t *p;
	int pktlen;
	int sport;

	id = ++rpc_id;
	pkt.u.call.id = htonl(id);
3481e8b8:	ebffff84 	bl	3481e6d0 <__fswab32>
	pkt.u.call.type = htonl(MSG_CALL);
	pkt.u.call.rpcvers = htonl(2);	/* use RPC version 2 */
3481e8bc:	e3a0a402 	mov	sl, #33554432	; 0x2000000
	int pktlen;
	int sport;

	id = ++rpc_id;
	pkt.u.call.id = htonl(id);
	pkt.u.call.type = htonl(MSG_CALL);
3481e8c0:	e3a03000 	mov	r3, #0
	uint32_t *p;
	int pktlen;
	int sport;

	id = ++rpc_id;
	pkt.u.call.id = htonl(id);
3481e8c4:	e58d0008 	str	r0, [sp, #8]
	pkt.u.call.type = htonl(MSG_CALL);
	pkt.u.call.rpcvers = htonl(2);	/* use RPC version 2 */
	pkt.u.call.prog = htonl(rpc_prog);
3481e8c8:	e1a00004 	mov	r0, r4
	int pktlen;
	int sport;

	id = ++rpc_id;
	pkt.u.call.id = htonl(id);
	pkt.u.call.type = htonl(MSG_CALL);
3481e8cc:	e58d300c 	str	r3, [sp, #12]
	pkt.u.call.rpcvers = htonl(2);	/* use RPC version 2 */
3481e8d0:	e58da010 	str	sl, [sp, #16]
	pkt.u.call.prog = htonl(rpc_prog);
3481e8d4:	ebffff7d 	bl	3481e6d0 <__fswab32>
3481e8d8:	e58d0014 	str	r0, [sp, #20]
	pkt.u.call.vers = htonl(2);	/* portmapper is version 2 */
	pkt.u.call.proc = htonl(rpc_proc);
3481e8dc:	e1a00006 	mov	r0, r6
	id = ++rpc_id;
	pkt.u.call.id = htonl(id);
	pkt.u.call.type = htonl(MSG_CALL);
	pkt.u.call.rpcvers = htonl(2);	/* use RPC version 2 */
	pkt.u.call.prog = htonl(rpc_prog);
	pkt.u.call.vers = htonl(2);	/* portmapper is version 2 */
3481e8e0:	e58da018 	str	sl, [sp, #24]
	pkt.u.call.proc = htonl(rpc_proc);
3481e8e4:	ebffff79 	bl	3481e6d0 <__fswab32>
	p = (uint32_t *)&(pkt.u.call.data);

	if (datalen)
3481e8e8:	e3550000 	cmp	r5, #0
	pkt.u.call.id = htonl(id);
	pkt.u.call.type = htonl(MSG_CALL);
	pkt.u.call.rpcvers = htonl(2);	/* use RPC version 2 */
	pkt.u.call.prog = htonl(rpc_prog);
	pkt.u.call.vers = htonl(2);	/* portmapper is version 2 */
	pkt.u.call.proc = htonl(rpc_proc);
3481e8ec:	e58d001c 	str	r0, [sp, #28]
	p = (uint32_t *)&(pkt.u.call.data);

	if (datalen)
3481e8f0:	0a000004 	beq	3481e908 <rpc_req+0x7c>
		memcpy((char *)p, (char *)data, datalen*sizeof(uint32_t));
3481e8f4:	e28d0008 	add	r0, sp, #8
3481e8f8:	e2800018 	add	r0, r0, #24
3481e8fc:	e1a01007 	mov	r1, r7
3481e900:	e1a02105 	lsl	r2, r5, #2
3481e904:	ebffe961 	bl	34818e90 <memcpy>

	pktlen = (char *)p + datalen*sizeof(uint32_t) - (char *)&pkt;

	memcpy((char *)NetTxPacket + NetEthHdrSize() + IP_UDP_HDR_SIZE,
3481e908:	e59f306c 	ldr	r3, [pc, #108]	; 3481e97c <rpc_req+0xf0>
	p = (uint32_t *)&(pkt.u.call.data);

	if (datalen)
		memcpy((char *)p, (char *)data, datalen*sizeof(uint32_t));

	pktlen = (char *)p + datalen*sizeof(uint32_t) - (char *)&pkt;
3481e90c:	e1a05105 	lsl	r5, r5, #2

	memcpy((char *)NetTxPacket + NetEthHdrSize() + IP_UDP_HDR_SIZE,
3481e910:	e5936000 	ldr	r6, [r3]
3481e914:	ebfffd2c 	bl	3481ddcc <NetEthHdrSize>
	p = (uint32_t *)&(pkt.u.call.data);

	if (datalen)
		memcpy((char *)p, (char *)data, datalen*sizeof(uint32_t));

	pktlen = (char *)p + datalen*sizeof(uint32_t) - (char *)&pkt;
3481e918:	e2855018 	add	r5, r5, #24

	memcpy((char *)NetTxPacket + NetEthHdrSize() + IP_UDP_HDR_SIZE,
3481e91c:	e280001c 	add	r0, r0, #28
3481e920:	e1a02005 	mov	r2, r5
3481e924:	e0860000 	add	r0, r6, r0
3481e928:	e28d1008 	add	r1, sp, #8
3481e92c:	ebffe957 	bl	34818e90 <memcpy>
		(char *)&pkt, pktlen);

	if (rpc_prog == PROG_PORTMAP)
3481e930:	e59f3048 	ldr	r3, [pc, #72]	; 3481e980 <rpc_req+0xf4>
3481e934:	e1540003 	cmp	r4, r3
		sport = SUNRPC_PORT;
3481e938:	03a0206f 	moveq	r2, #111	; 0x6f
	pktlen = (char *)p + datalen*sizeof(uint32_t) - (char *)&pkt;

	memcpy((char *)NetTxPacket + NetEthHdrSize() + IP_UDP_HDR_SIZE,
		(char *)&pkt, pktlen);

	if (rpc_prog == PROG_PORTMAP)
3481e93c:	0a000004 	beq	3481e954 <rpc_req+0xc8>
		sport = SUNRPC_PORT;
	else if (rpc_prog == PROG_MOUNT)
3481e940:	e2833005 	add	r3, r3, #5
3481e944:	e1540003 	cmp	r4, r3
3481e948:	e59f3028 	ldr	r3, [pc, #40]	; 3481e978 <rpc_req+0xec>
		sport = NfsSrvMountPort;
3481e94c:	05932004 	ldreq	r2, [r3, #4]
	else
		sport = NfsSrvNfsPort;
3481e950:	15932008 	ldrne	r2, [r3, #8]

	NetSendUDPPacket(NetServerEther, NfsServerIP, sport, NfsOurPort,
3481e954:	e59f301c 	ldr	r3, [pc, #28]	; 3481e978 <rpc_req+0xec>
3481e958:	e58d5000 	str	r5, [sp]
3481e95c:	e593100c 	ldr	r1, [r3, #12]
3481e960:	e59f001c 	ldr	r0, [pc, #28]	; 3481e984 <rpc_req+0xf8>
3481e964:	e5933010 	ldr	r3, [r3, #16]
3481e968:	ebfffdbc 	bl	3481e060 <NetSendUDPPacket>
		pktlen);
}
3481e96c:	e28dd008 	add	sp, sp, #8
3481e970:	e28ddb02 	add	sp, sp, #2048	; 0x800
3481e974:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
3481e978:	3482d994 	.word	0x3482d994
3481e97c:	3482ba14 	.word	0x3482ba14
3481e980:	000186a0 	.word	0x000186a0
3481e984:	3482d90c 	.word	0x3482d90c

3481e988 <rpc_lookup_req>:
/**************************************************************************
RPC_LOOKUP - Lookup RPC Port numbers
**************************************************************************/
static void
rpc_lookup_req(int prog, int ver)
{
3481e988:	e92d4030 	push	{r4, r5, lr}
	uint32_t data[16];

	data[0] = 0; data[1] = 0;	/* auth credential */
3481e98c:	e3a04000 	mov	r4, #0
/**************************************************************************
RPC_LOOKUP - Lookup RPC Port numbers
**************************************************************************/
static void
rpc_lookup_req(int prog, int ver)
{
3481e990:	e24dd044 	sub	sp, sp, #68	; 0x44
3481e994:	e1a05001 	mov	r5, r1
	uint32_t data[16];

	data[0] = 0; data[1] = 0;	/* auth credential */
3481e998:	e58d4000 	str	r4, [sp]
3481e99c:	e58d4004 	str	r4, [sp, #4]
	data[2] = 0; data[3] = 0;	/* auth verifier */
3481e9a0:	e58d4008 	str	r4, [sp, #8]
3481e9a4:	e58d400c 	str	r4, [sp, #12]
	data[4] = htonl(prog);
3481e9a8:	ebffff48 	bl	3481e6d0 <__fswab32>
3481e9ac:	e58d0010 	str	r0, [sp, #16]
	data[5] = htonl(ver);
3481e9b0:	e1a00005 	mov	r0, r5
3481e9b4:	ebffff45 	bl	3481e6d0 <__fswab32>
	data[6] = htonl(17);	/* IP_UDP */
3481e9b8:	e3a03411 	mov	r3, #285212672	; 0x11000000
	uint32_t data[16];

	data[0] = 0; data[1] = 0;	/* auth credential */
	data[2] = 0; data[3] = 0;	/* auth verifier */
	data[4] = htonl(prog);
	data[5] = htonl(ver);
3481e9bc:	e58d0014 	str	r0, [sp, #20]
	data[6] = htonl(17);	/* IP_UDP */
3481e9c0:	e58d3018 	str	r3, [sp, #24]
	data[7] = 0;

	rpc_req(PROG_PORTMAP, PORTMAP_GETPORT, data, 8);
3481e9c4:	e59f0018 	ldr	r0, [pc, #24]	; 3481e9e4 <rpc_lookup_req+0x5c>
3481e9c8:	e3a01003 	mov	r1, #3
3481e9cc:	e1a0200d 	mov	r2, sp
3481e9d0:	e3a03008 	mov	r3, #8
	data[0] = 0; data[1] = 0;	/* auth credential */
	data[2] = 0; data[3] = 0;	/* auth verifier */
	data[4] = htonl(prog);
	data[5] = htonl(ver);
	data[6] = htonl(17);	/* IP_UDP */
	data[7] = 0;
3481e9d4:	e58d401c 	str	r4, [sp, #28]

	rpc_req(PROG_PORTMAP, PORTMAP_GETPORT, data, 8);
3481e9d8:	ebffffab 	bl	3481e88c <rpc_req>
}
3481e9dc:	e28dd044 	add	sp, sp, #68	; 0x44
3481e9e0:	e8bd8030 	pop	{r4, r5, pc}
3481e9e4:	000186a0 	.word	0x000186a0

3481e9e8 <nfs_mount_req>:
/**************************************************************************
NFS_MOUNT - Mount an NFS Filesystem
**************************************************************************/
static void
nfs_mount_req(char *path)
{
3481e9e8:	e92d4070 	push	{r4, r5, r6, lr}
3481e9ec:	e24dda01 	sub	sp, sp, #4096	; 0x1000
3481e9f0:	e1a06000 	mov	r6, r0
	uint32_t data[1024];
	uint32_t *p;
	int len;
	int pathlen;

	pathlen = strlen(path);
3481e9f4:	ebffe861 	bl	34818b80 <strlen>
3481e9f8:	e1a04000 	mov	r4, r0

	p = &(data[0]);
	p = (uint32_t *)rpc_add_credentials((long *)p);
3481e9fc:	e1a0000d 	mov	r0, sp
3481ea00:	ebffff44 	bl	3481e718 <rpc_add_credentials>
3481ea04:	e1a05000 	mov	r5, r0

	*p++ = htonl(pathlen);
3481ea08:	e1a00004 	mov	r0, r4
3481ea0c:	ebffff2f 	bl	3481e6d0 <__fswab32>
	if (pathlen & 3)
3481ea10:	e3140003 	tst	r4, #3
	pathlen = strlen(path);

	p = &(data[0]);
	p = (uint32_t *)rpc_add_credentials((long *)p);

	*p++ = htonl(pathlen);
3481ea14:	e4850004 	str	r0, [r5], #4
	if (pathlen & 3)
3481ea18:	0a000005 	beq	3481ea34 <nfs_mount_req+0x4c>
		*(p + pathlen / 4) = 0;
3481ea1c:	e3540000 	cmp	r4, #0
3481ea20:	e2843003 	add	r3, r4, #3
3481ea24:	a1a03004 	movge	r3, r4
3481ea28:	e1a03143 	asr	r3, r3, #2
3481ea2c:	e3a02000 	mov	r2, #0
3481ea30:	e7852103 	str	r2, [r5, r3, lsl #2]
	memcpy(p, path, pathlen);
3481ea34:	e1a01006 	mov	r1, r6
3481ea38:	e1a02004 	mov	r2, r4
3481ea3c:	e1a00005 	mov	r0, r5
3481ea40:	ebffe912 	bl	34818e90 <memcpy>
	p += (pathlen + 3) / 4;
3481ea44:	e2943003 	adds	r3, r4, #3
3481ea48:	42844006 	addmi	r4, r4, #6
3481ea4c:	51a04003 	movpl	r4, r3
3481ea50:	e3c44003 	bic	r4, r4, #3

	len = (uint32_t *)p - (uint32_t *)&(data[0]);

	rpc_req(PROG_MOUNT, MOUNT_ADDENTRY, data, len);
3481ea54:	e1a0200d 	mov	r2, sp

	*p++ = htonl(pathlen);
	if (pathlen & 3)
		*(p + pathlen / 4) = 0;
	memcpy(p, path, pathlen);
	p += (pathlen + 3) / 4;
3481ea58:	e0855004 	add	r5, r5, r4

	len = (uint32_t *)p - (uint32_t *)&(data[0]);
3481ea5c:	e0623005 	rsb	r3, r2, r5

	rpc_req(PROG_MOUNT, MOUNT_ADDENTRY, data, len);
3481ea60:	e59f0010 	ldr	r0, [pc, #16]	; 3481ea78 <nfs_mount_req+0x90>
3481ea64:	e3a01001 	mov	r1, #1
3481ea68:	e1a03143 	asr	r3, r3, #2
3481ea6c:	ebffff86 	bl	3481e88c <rpc_req>
}
3481ea70:	e28dda01 	add	sp, sp, #4096	; 0x1000
3481ea74:	e8bd8070 	pop	{r4, r5, r6, pc}
3481ea78:	000186a5 	.word	0x000186a5

3481ea7c <nfs_umountall_req>:
/**************************************************************************
NFS_UMOUNTALL - Unmount all our NFS Filesystems on the Server
**************************************************************************/
static void
nfs_umountall_req(void)
{
3481ea7c:	e92d4010 	push	{r4, lr}
	uint32_t data[1024];
	uint32_t *p;
	int len;

	if ((NfsSrvMountPort == -1) || (!fs_mounted))
3481ea80:	e59f3044 	ldr	r3, [pc, #68]	; 3481eacc <nfs_umountall_req+0x50>
/**************************************************************************
NFS_UMOUNTALL - Unmount all our NFS Filesystems on the Server
**************************************************************************/
static void
nfs_umountall_req(void)
{
3481ea84:	e24dda01 	sub	sp, sp, #4096	; 0x1000
	uint32_t data[1024];
	uint32_t *p;
	int len;

	if ((NfsSrvMountPort == -1) || (!fs_mounted))
3481ea88:	e5932004 	ldr	r2, [r3, #4]
3481ea8c:	e3720001 	cmn	r2, #1
3481ea90:	0a00000b 	beq	3481eac4 <nfs_umountall_req+0x48>
3481ea94:	e5933014 	ldr	r3, [r3, #20]
3481ea98:	e3530000 	cmp	r3, #0
3481ea9c:	0a000008 	beq	3481eac4 <nfs_umountall_req+0x48>
		/* Nothing mounted, nothing to umount */
		return;

	p = &(data[0]);
	p = (uint32_t *)rpc_add_credentials((long *)p);
3481eaa0:	e1a0000d 	mov	r0, sp
3481eaa4:	ebffff1b 	bl	3481e718 <rpc_add_credentials>

	if ((NfsSrvMountPort == -1) || (!fs_mounted))
		/* Nothing mounted, nothing to umount */
		return;

	p = &(data[0]);
3481eaa8:	e1a0400d 	mov	r4, sp
	p = (uint32_t *)rpc_add_credentials((long *)p);

	len = (uint32_t *)p - (uint32_t *)&(data[0]);
3481eaac:	e0643000 	rsb	r3, r4, r0

	rpc_req(PROG_MOUNT, MOUNT_UMOUNTALL, data, len);
3481eab0:	e3a01004 	mov	r1, #4
3481eab4:	e59f0014 	ldr	r0, [pc, #20]	; 3481ead0 <nfs_umountall_req+0x54>
3481eab8:	e1a0200d 	mov	r2, sp
3481eabc:	e1a03143 	asr	r3, r3, #2
3481eac0:	ebffff71 	bl	3481e88c <rpc_req>
}
3481eac4:	e28dda01 	add	sp, sp, #4096	; 0x1000
3481eac8:	e8bd8010 	pop	{r4, pc}
3481eacc:	3482d994 	.word	0x3482d994
3481ead0:	000186a5 	.word	0x000186a5

3481ead4 <nfs_lookup_req>:
/**************************************************************************
NFS_LOOKUP - Lookup Pathname
**************************************************************************/
static void
nfs_lookup_req(char *fname)
{
3481ead4:	e92d4070 	push	{r4, r5, r6, lr}
3481ead8:	e24dda01 	sub	sp, sp, #4096	; 0x1000
3481eadc:	e1a06000 	mov	r6, r0
	uint32_t data[1024];
	uint32_t *p;
	int len;
	int fnamelen;

	fnamelen = strlen(fname);
3481eae0:	ebffe826 	bl	34818b80 <strlen>
3481eae4:	e1a04000 	mov	r4, r0

	p = &(data[0]);
	p = (uint32_t *)rpc_add_credentials((long *)p);
3481eae8:	e1a0000d 	mov	r0, sp
3481eaec:	ebffff09 	bl	3481e718 <rpc_add_credentials>

	memcpy(p, dirfh, NFS_FHSIZE);
3481eaf0:	e59f107c 	ldr	r1, [pc, #124]	; 3481eb74 <nfs_lookup_req+0xa0>
3481eaf4:	e3a02020 	mov	r2, #32
	int fnamelen;

	fnamelen = strlen(fname);

	p = &(data[0]);
	p = (uint32_t *)rpc_add_credentials((long *)p);
3481eaf8:	e1a05000 	mov	r5, r0

	memcpy(p, dirfh, NFS_FHSIZE);
3481eafc:	ebffe8e3 	bl	34818e90 <memcpy>
	p += (NFS_FHSIZE / 4);
	*p++ = htonl(fnamelen);
3481eb00:	e1a00004 	mov	r0, r4
3481eb04:	ebfffef1 	bl	3481e6d0 <__fswab32>
	if (fnamelen & 3)
3481eb08:	e3140003 	tst	r4, #3
	p = &(data[0]);
	p = (uint32_t *)rpc_add_credentials((long *)p);

	memcpy(p, dirfh, NFS_FHSIZE);
	p += (NFS_FHSIZE / 4);
	*p++ = htonl(fnamelen);
3481eb0c:	e5850020 	str	r0, [r5, #32]
3481eb10:	e2855024 	add	r5, r5, #36	; 0x24
	if (fnamelen & 3)
3481eb14:	0a000005 	beq	3481eb30 <nfs_lookup_req+0x5c>
		*(p + fnamelen / 4) = 0;
3481eb18:	e3540000 	cmp	r4, #0
3481eb1c:	e2843003 	add	r3, r4, #3
3481eb20:	a1a03004 	movge	r3, r4
3481eb24:	e1a03143 	asr	r3, r3, #2
3481eb28:	e3a02000 	mov	r2, #0
3481eb2c:	e7852103 	str	r2, [r5, r3, lsl #2]
	memcpy(p, fname, fnamelen);
3481eb30:	e1a01006 	mov	r1, r6
3481eb34:	e1a02004 	mov	r2, r4
3481eb38:	e1a00005 	mov	r0, r5
3481eb3c:	ebffe8d3 	bl	34818e90 <memcpy>
	p += (fnamelen + 3) / 4;
3481eb40:	e2943003 	adds	r3, r4, #3
3481eb44:	42844006 	addmi	r4, r4, #6
3481eb48:	51a04003 	movpl	r4, r3
3481eb4c:	e3c44003 	bic	r4, r4, #3

	len = (uint32_t *)p - (uint32_t *)&(data[0]);

	rpc_req(PROG_NFS, NFS_LOOKUP, data, len);
3481eb50:	e1a0200d 	mov	r2, sp
	p += (NFS_FHSIZE / 4);
	*p++ = htonl(fnamelen);
	if (fnamelen & 3)
		*(p + fnamelen / 4) = 0;
	memcpy(p, fname, fnamelen);
	p += (fnamelen + 3) / 4;
3481eb54:	e0855004 	add	r5, r5, r4

	len = (uint32_t *)p - (uint32_t *)&(data[0]);
3481eb58:	e0623005 	rsb	r3, r2, r5

	rpc_req(PROG_NFS, NFS_LOOKUP, data, len);
3481eb5c:	e59f0014 	ldr	r0, [pc, #20]	; 3481eb78 <nfs_lookup_req+0xa4>
3481eb60:	e3a01004 	mov	r1, #4
3481eb64:	e1a03143 	asr	r3, r3, #2
3481eb68:	ebffff47 	bl	3481e88c <rpc_req>
}
3481eb6c:	e28dda01 	add	sp, sp, #4096	; 0x1000
3481eb70:	e8bd8070 	pop	{r4, r5, r6, pc}
3481eb74:	3482d9ac 	.word	0x3482d9ac
3481eb78:	000186a3 	.word	0x000186a3

3481eb7c <nfs_read_req>:
/**************************************************************************
NFS_READ - Read File on NFS Server
**************************************************************************/
static void
nfs_read_req(int offset, int readlen)
{
3481eb7c:	e92d40f0 	push	{r4, r5, r6, r7, lr}
3481eb80:	e24dda01 	sub	sp, sp, #4096	; 0x1000
3481eb84:	e24dd004 	sub	sp, sp, #4
3481eb88:	e1a07000 	mov	r7, r0
	uint32_t data[1024];
	uint32_t *p;
	int len;

	p = &(data[0]);
	p = (uint32_t *)rpc_add_credentials((long *)p);
3481eb8c:	e1a0000d 	mov	r0, sp
/**************************************************************************
NFS_READ - Read File on NFS Server
**************************************************************************/
static void
nfs_read_req(int offset, int readlen)
{
3481eb90:	e1a06001 	mov	r6, r1
	uint32_t data[1024];
	uint32_t *p;
	int len;

	p = &(data[0]);
	p = (uint32_t *)rpc_add_credentials((long *)p);
3481eb94:	ebfffedf 	bl	3481e718 <rpc_add_credentials>

	memcpy(p, filefh, NFS_FHSIZE);
3481eb98:	e59f1054 	ldr	r1, [pc, #84]	; 3481ebf4 <nfs_read_req+0x78>
3481eb9c:	e3a02020 	mov	r2, #32
	uint32_t data[1024];
	uint32_t *p;
	int len;

	p = &(data[0]);
	p = (uint32_t *)rpc_add_credentials((long *)p);
3481eba0:	e1a04000 	mov	r4, r0

	memcpy(p, filefh, NFS_FHSIZE);
3481eba4:	ebffe8b9 	bl	34818e90 <memcpy>
	p += (NFS_FHSIZE / 4);
	*p++ = htonl(offset);
3481eba8:	e1a00007 	mov	r0, r7
3481ebac:	ebfffec7 	bl	3481e6d0 <__fswab32>
3481ebb0:	e5840020 	str	r0, [r4, #32]
	*p++ = htonl(readlen);
3481ebb4:	e1a00006 	mov	r0, r6
3481ebb8:	ebfffec4 	bl	3481e6d0 <__fswab32>
	*p++ = 0;
3481ebbc:	e3a03000 	mov	r3, #0
{
	uint32_t data[1024];
	uint32_t *p;
	int len;

	p = &(data[0]);
3481ebc0:	e1a0500d 	mov	r5, sp
	p = (uint32_t *)rpc_add_credentials((long *)p);

	memcpy(p, filefh, NFS_FHSIZE);
	p += (NFS_FHSIZE / 4);
	*p++ = htonl(offset);
	*p++ = htonl(readlen);
3481ebc4:	e5840024 	str	r0, [r4, #36]	; 0x24
	*p++ = 0;
3481ebc8:	e5843028 	str	r3, [r4, #40]	; 0x28
3481ebcc:	e284402c 	add	r4, r4, #44	; 0x2c

	len = (uint32_t *)p - (uint32_t *)&(data[0]);
3481ebd0:	e0653004 	rsb	r3, r5, r4

	rpc_req(PROG_NFS, NFS_READ, data, len);
3481ebd4:	e59f001c 	ldr	r0, [pc, #28]	; 3481ebf8 <nfs_read_req+0x7c>
3481ebd8:	e3a01006 	mov	r1, #6
3481ebdc:	e1a0200d 	mov	r2, sp
3481ebe0:	e1a03143 	asr	r3, r3, #2
3481ebe4:	ebffff28 	bl	3481e88c <rpc_req>
}
3481ebe8:	e28dd004 	add	sp, sp, #4
3481ebec:	e28dda01 	add	sp, sp, #4096	; 0x1000
3481ebf0:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
3481ebf4:	3482d9cc 	.word	0x3482d9cc
3481ebf8:	000186a3 	.word	0x000186a3

3481ebfc <nfs_readlink_req>:
 * In case of successful readlink(), the dirname is manipulated,
 * so that inside the nfs() function a recursion can be done.
 **************************************************************************/
static void
nfs_readlink_req(void)
{
3481ebfc:	e92d4030 	push	{r4, r5, lr}
3481ec00:	e24dda01 	sub	sp, sp, #4096	; 0x1000
3481ec04:	e24dd004 	sub	sp, sp, #4
	uint32_t data[1024];
	uint32_t *p;
	int len;

	p = &(data[0]);
	p = (uint32_t *)rpc_add_credentials((long *)p);
3481ec08:	e1a0000d 	mov	r0, sp
3481ec0c:	ebfffec1 	bl	3481e718 <rpc_add_credentials>
3481ec10:	e1a05000 	mov	r5, r0
{
	uint32_t data[1024];
	uint32_t *p;
	int len;

	p = &(data[0]);
3481ec14:	e1a0400d 	mov	r4, sp
	p = (uint32_t *)rpc_add_credentials((long *)p);

	memcpy(p, filefh, NFS_FHSIZE);
3481ec18:	e59f102c 	ldr	r1, [pc, #44]	; 3481ec4c <nfs_readlink_req+0x50>
3481ec1c:	e3a02020 	mov	r2, #32
	p += (NFS_FHSIZE / 4);
3481ec20:	e2855020 	add	r5, r5, #32
	int len;

	p = &(data[0]);
	p = (uint32_t *)rpc_add_credentials((long *)p);

	memcpy(p, filefh, NFS_FHSIZE);
3481ec24:	ebffe899 	bl	34818e90 <memcpy>
	p += (NFS_FHSIZE / 4);

	len = (uint32_t *)p - (uint32_t *)&(data[0]);
3481ec28:	e0643005 	rsb	r3, r4, r5

	rpc_req(PROG_NFS, NFS_READLINK, data, len);
3481ec2c:	e59f001c 	ldr	r0, [pc, #28]	; 3481ec50 <nfs_readlink_req+0x54>
3481ec30:	e3a01005 	mov	r1, #5
3481ec34:	e1a0200d 	mov	r2, sp
3481ec38:	e1a03143 	asr	r3, r3, #2
3481ec3c:	ebffff12 	bl	3481e88c <rpc_req>
}
3481ec40:	e28dd004 	add	sp, sp, #4
3481ec44:	e28dda01 	add	sp, sp, #4096	; 0x1000
3481ec48:	e8bd8030 	pop	{r4, r5, pc}
3481ec4c:	3482d9cc 	.word	0x3482d9cc
3481ec50:	000186a3 	.word	0x000186a3

3481ec54 <NfsSend>:
static void
NfsSend(void)
{
	debug("%s\n", __func__);

	switch (NfsState) {
3481ec54:	e59f307c 	ldr	r3, [pc, #124]	; 3481ecd8 <NfsSend+0x84>
3481ec58:	e5933058 	ldr	r3, [r3, #88]	; 0x58
3481ec5c:	e2433001 	sub	r3, r3, #1
3481ec60:	e3530006 	cmp	r3, #6
3481ec64:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
3481ec68:	ea000019 	b	3481ecd4 <NfsSend+0x80>
3481ec6c:	3481ec88 	.word	0x3481ec88
3481ec70:	3481ec94 	.word	0x3481ec94
3481ec74:	3481eca0 	.word	0x3481eca0
3481ec78:	3481ecac 	.word	0x3481ecac
3481ec7c:	3481ecb0 	.word	0x3481ecb0
3481ec80:	3481ecbc 	.word	0x3481ecbc
3481ec84:	3481ecd0 	.word	0x3481ecd0
	case STATE_PRCLOOKUP_PROG_MOUNT_REQ:
		rpc_lookup_req(PROG_MOUNT, 1);
3481ec88:	e59f004c 	ldr	r0, [pc, #76]	; 3481ecdc <NfsSend+0x88>
3481ec8c:	e3a01001 	mov	r1, #1
3481ec90:	ea000001 	b	3481ec9c <NfsSend+0x48>
		break;
	case STATE_PRCLOOKUP_PROG_NFS_REQ:
		rpc_lookup_req(PROG_NFS, 2);
3481ec94:	e59f0044 	ldr	r0, [pc, #68]	; 3481ece0 <NfsSend+0x8c>
3481ec98:	e3a01002 	mov	r1, #2
3481ec9c:	eaffff39 	b	3481e988 <rpc_lookup_req>
		break;
	case STATE_MOUNT_REQ:
		nfs_mount_req(nfs_path);
3481eca0:	e59f3030 	ldr	r3, [pc, #48]	; 3481ecd8 <NfsSend+0x84>
3481eca4:	e593005c 	ldr	r0, [r3, #92]	; 0x5c
3481eca8:	eaffff4e 	b	3481e9e8 <nfs_mount_req>
		break;
	case STATE_UMOUNT_REQ:
		nfs_umountall_req();
3481ecac:	eaffff72 	b	3481ea7c <nfs_umountall_req>
		break;
	case STATE_LOOKUP_REQ:
		nfs_lookup_req(nfs_filename);
3481ecb0:	e59f3020 	ldr	r3, [pc, #32]	; 3481ecd8 <NfsSend+0x84>
3481ecb4:	e5930060 	ldr	r0, [r3, #96]	; 0x60
3481ecb8:	eaffff85 	b	3481ead4 <nfs_lookup_req>
		break;
	case STATE_READ_REQ:
		nfs_read_req(nfs_offset, nfs_len);
3481ecbc:	e59f3020 	ldr	r3, [pc, #32]	; 3481ece4 <NfsSend+0x90>
3481ecc0:	e5930000 	ldr	r0, [r3]
3481ecc4:	e59f300c 	ldr	r3, [pc, #12]	; 3481ecd8 <NfsSend+0x84>
3481ecc8:	e5931064 	ldr	r1, [r3, #100]	; 0x64
3481eccc:	eaffffaa 	b	3481eb7c <nfs_read_req>
		break;
	case STATE_READLINK_REQ:
		nfs_readlink_req();
3481ecd0:	eaffffc9 	b	3481ebfc <nfs_readlink_req>
3481ecd4:	e12fff1e 	bx	lr
3481ecd8:	3482d994 	.word	0x3482d994
3481ecdc:	000186a5 	.word	0x000186a5
3481ece0:	000186a3 	.word	0x000186a3
3481ece4:	34828bb0 	.word	0x34828bb0

3481ece8 <NfsTimeout>:
**************************************************************************/

static void
NfsTimeout(void)
{
	if (++NfsTimeoutCount > NFS_RETRY_COUNT) {
3481ece8:	e59f2040 	ldr	r2, [pc, #64]	; 3481ed30 <NfsTimeout+0x48>
Interfaces of U-BOOT
**************************************************************************/

static void
NfsTimeout(void)
{
3481ecec:	e92d4010 	push	{r4, lr}
	if (++NfsTimeoutCount > NFS_RETRY_COUNT) {
3481ecf0:	e5923068 	ldr	r3, [r2, #104]	; 0x68
3481ecf4:	e2833001 	add	r3, r3, #1
3481ecf8:	e353001e 	cmp	r3, #30
3481ecfc:	e5823068 	str	r3, [r2, #104]	; 0x68
3481ed00:	da000003 	ble	3481ed14 <NfsTimeout+0x2c>
		puts("\nRetry count exceeded; starting again\n");
3481ed04:	e59f0028 	ldr	r0, [pc, #40]	; 3481ed34 <NfsTimeout+0x4c>
3481ed08:	ebffa885 	bl	34808f24 <puts>
	} else {
		puts("T ");
		NetSetTimeout(NFS_TIMEOUT, NfsTimeout);
		NfsSend();
	}
}
3481ed0c:	e8bd4010 	pop	{r4, lr}
static void
NfsTimeout(void)
{
	if (++NfsTimeoutCount > NFS_RETRY_COUNT) {
		puts("\nRetry count exceeded; starting again\n");
		NetStartAgain();
3481ed10:	eafffb2b 	b	3481d9c4 <NetStartAgain>
	} else {
		puts("T ");
3481ed14:	e59f001c 	ldr	r0, [pc, #28]	; 3481ed38 <NfsTimeout+0x50>
3481ed18:	ebffa881 	bl	34808f24 <puts>
		NetSetTimeout(NFS_TIMEOUT, NfsTimeout);
3481ed1c:	e3a00e7d 	mov	r0, #2000	; 0x7d0
3481ed20:	e59f1014 	ldr	r1, [pc, #20]	; 3481ed3c <NfsTimeout+0x54>
3481ed24:	ebfffb17 	bl	3481d988 <NetSetTimeout>
		NfsSend();
	}
}
3481ed28:	e8bd4010 	pop	{r4, lr}
		puts("\nRetry count exceeded; starting again\n");
		NetStartAgain();
	} else {
		puts("T ");
		NetSetTimeout(NFS_TIMEOUT, NfsTimeout);
		NfsSend();
3481ed2c:	eaffffc8 	b	3481ec54 <NfsSend>
3481ed30:	3482d994 	.word	0x3482d994
3481ed34:	34827ba2 	.word	0x34827ba2
3481ed38:	34827ea9 	.word	0x34827ea9
3481ed3c:	3481ece8 	.word	0x3481ece8

3481ed40 <NfsHandler>:
	}
}

static void
NfsHandler(uchar *pkt, unsigned dest, IPaddr_t sip, unsigned src, unsigned len)
{
3481ed40:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
3481ed44:	e24ddb0a 	sub	sp, sp, #10240	; 0x2800
3481ed48:	e28d3a02 	add	r3, sp, #8192	; 0x2000
3481ed4c:	e5932818 	ldr	r2, [r3, #2072]	; 0x818
	int rlen;

	debug("%s\n", __func__);

	if (dest != NfsOurPort)
3481ed50:	e59f3490 	ldr	r3, [pc, #1168]	; 3481f1e8 <NfsHandler+0x4a8>
	}
}

static void
NfsHandler(uchar *pkt, unsigned dest, IPaddr_t sip, unsigned src, unsigned len)
{
3481ed54:	e1a05000 	mov	r5, r0
	int rlen;

	debug("%s\n", __func__);

	if (dest != NfsOurPort)
3481ed58:	e5930010 	ldr	r0, [r3, #16]
3481ed5c:	e1510000 	cmp	r1, r0
3481ed60:	1a00011e 	bne	3481f1e0 <NfsHandler+0x4a0>
		return;

	switch (NfsState) {
3481ed64:	e5933058 	ldr	r3, [r3, #88]	; 0x58
3481ed68:	e2433001 	sub	r3, r3, #1
3481ed6c:	e3530006 	cmp	r3, #6
3481ed70:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
3481ed74:	ea000119 	b	3481f1e0 <NfsHandler+0x4a0>
3481ed78:	3481ed94 	.word	0x3481ed94
3481ed7c:	3481eda8 	.word	0x3481eda8
3481ed80:	3481edbc 	.word	0x3481edbc
3481ed84:	3481ee44 	.word	0x3481ee44
3481ed88:	3481eed4 	.word	0x3481eed4
3481ed8c:	3481f044 	.word	0x3481f044
3481ed90:	3481ef6c 	.word	0x3481ef6c
	case STATE_PRCLOOKUP_PROG_MOUNT_REQ:
		rpc_lookup_reply(PROG_MOUNT, pkt, len);
3481ed94:	e59f0450 	ldr	r0, [pc, #1104]	; 3481f1ec <NfsHandler+0x4ac>
3481ed98:	e1a01005 	mov	r1, r5
3481ed9c:	ebfffe92 	bl	3481e7ec <rpc_lookup_reply>
		NfsState = STATE_PRCLOOKUP_PROG_NFS_REQ;
3481eda0:	e3a02002 	mov	r2, #2
3481eda4:	ea0000fd 	b	3481f1a0 <NfsHandler+0x460>
		NfsSend();
		break;

	case STATE_PRCLOOKUP_PROG_NFS_REQ:
		rpc_lookup_reply(PROG_NFS, pkt, len);
3481eda8:	e59f0440 	ldr	r0, [pc, #1088]	; 3481f1f0 <NfsHandler+0x4b0>
3481edac:	e1a01005 	mov	r1, r5
3481edb0:	ebfffe8d 	bl	3481e7ec <rpc_lookup_reply>
		NfsState = STATE_MOUNT_REQ;
3481edb4:	e3a02003 	mov	r2, #3
3481edb8:	ea0000f8 	b	3481f1a0 <NfsHandler+0x460>
{
	struct rpc_t rpc_pkt;

	debug("%s\n", __func__);

	memcpy((unsigned char *)&rpc_pkt, pkt, len);
3481edbc:	e28d6a02 	add	r6, sp, #8192	; 0x2000
3481edc0:	e1a01005 	mov	r1, r5
3481edc4:	e1a00006 	mov	r0, r6
3481edc8:	ebffe830 	bl	34818e90 <memcpy>

	if (ntohl(rpc_pkt.u.reply.id) != rpc_id)
3481edcc:	e28d2a02 	add	r2, sp, #8192	; 0x2000
3481edd0:	e5920000 	ldr	r0, [r2]
3481edd4:	ebfffe3d 	bl	3481e6d0 <__fswab32>
3481edd8:	e59f4408 	ldr	r4, [pc, #1032]	; 3481f1e8 <NfsHandler+0x4a8>
3481eddc:	e5943000 	ldr	r3, [r4]
3481ede0:	e1500003 	cmp	r0, r3
3481ede4:	1a000014 	bne	3481ee3c <NfsHandler+0xfc>
		return -1;

	if (rpc_pkt.u.reply.rstatus  ||
3481ede8:	e28d2a02 	add	r2, sp, #8192	; 0x2000
3481edec:	e5923008 	ldr	r3, [r2, #8]
3481edf0:	e3530000 	cmp	r3, #0
3481edf4:	1a000010 	bne	3481ee3c <NfsHandler+0xfc>
3481edf8:	e592300c 	ldr	r3, [r2, #12]
3481edfc:	e3530000 	cmp	r3, #0
3481ee00:	1a00000d 	bne	3481ee3c <NfsHandler+0xfc>
	    rpc_pkt.u.reply.verifier ||
3481ee04:	e5923014 	ldr	r3, [r2, #20]
3481ee08:	e3530000 	cmp	r3, #0
3481ee0c:	1a00000a 	bne	3481ee3c <NfsHandler+0xfc>
	    rpc_pkt.u.reply.astatus  ||
3481ee10:	e5923018 	ldr	r3, [r2, #24]
3481ee14:	e3530000 	cmp	r3, #0
3481ee18:	1a000007 	bne	3481ee3c <NfsHandler+0xfc>
	    rpc_pkt.u.reply.data[0])
		return -1;

	fs_mounted = 1;
3481ee1c:	e2833001 	add	r3, r3, #1
3481ee20:	e5843014 	str	r3, [r4, #20]
	memcpy(dirfh, rpc_pkt.u.reply.data + 1, NFS_FHSIZE);
3481ee24:	e2840018 	add	r0, r4, #24
3481ee28:	e286101c 	add	r1, r6, #28
3481ee2c:	e3a02020 	mov	r2, #32
3481ee30:	ebffe816 	bl	34818e90 <memcpy>
			puts("*** ERROR: Cannot mount\n");
			/* just to be sure... */
			NfsState = STATE_UMOUNT_REQ;
			NfsSend();
		} else {
			NfsState = STATE_LOOKUP_REQ;
3481ee34:	e3a03005 	mov	r3, #5
3481ee38:	ea0000e6 	b	3481f1d8 <NfsHandler+0x498>
		NfsSend();
		break;

	case STATE_MOUNT_REQ:
		if (nfs_mount_reply(pkt, len)) {
			puts("*** ERROR: Cannot mount\n");
3481ee3c:	e59f03b0 	ldr	r0, [pc, #944]	; 3481f1f4 <NfsHandler+0x4b4>
3481ee40:	ea000047 	b	3481ef64 <NfsHandler+0x224>
{
	struct rpc_t rpc_pkt;

	debug("%s\n", __func__);

	memcpy((unsigned char *)&rpc_pkt, pkt, len);
3481ee44:	e28d6b06 	add	r6, sp, #6144	; 0x1800
3481ee48:	e1a01005 	mov	r1, r5
3481ee4c:	e1a00006 	mov	r0, r6
3481ee50:	ebffe80e 	bl	34818e90 <memcpy>

	if (ntohl(rpc_pkt.u.reply.id) != rpc_id)
3481ee54:	e59f339c 	ldr	r3, [pc, #924]	; 3481f1f8 <NfsHandler+0x4b8>
3481ee58:	e28d2b0a 	add	r2, sp, #10240	; 0x2800
3481ee5c:	e7920003 	ldr	r0, [r2, r3]
3481ee60:	ebfffe1a 	bl	3481e6d0 <__fswab32>
3481ee64:	e59f437c 	ldr	r4, [pc, #892]	; 3481f1e8 <NfsHandler+0x4a8>
3481ee68:	e5943000 	ldr	r3, [r4]
3481ee6c:	e1500003 	cmp	r0, r3
3481ee70:	1a000011 	bne	3481eebc <NfsHandler+0x17c>
		return -1;

	if (rpc_pkt.u.reply.rstatus  ||
3481ee74:	e28d2a01 	add	r2, sp, #4096	; 0x1000
3481ee78:	e5923808 	ldr	r3, [r2, #2056]	; 0x808
3481ee7c:	e3530000 	cmp	r3, #0
3481ee80:	1a00000d 	bne	3481eebc <NfsHandler+0x17c>
3481ee84:	e596300c 	ldr	r3, [r6, #12]
3481ee88:	e3530000 	cmp	r3, #0
3481ee8c:	1a00000a 	bne	3481eebc <NfsHandler+0x17c>
	    rpc_pkt.u.reply.verifier ||
3481ee90:	e5961014 	ldr	r1, [r6, #20]
3481ee94:	e3510000 	cmp	r1, #0
3481ee98:	1a000007 	bne	3481eebc <NfsHandler+0x17c>
	    rpc_pkt.u.reply.astatus)
		return -1;

	fs_mounted = 0;
	memset(dirfh, 0, sizeof(dirfh));
3481ee9c:	e3a02020 	mov	r2, #32
	if (rpc_pkt.u.reply.rstatus  ||
	    rpc_pkt.u.reply.verifier ||
	    rpc_pkt.u.reply.astatus)
		return -1;

	fs_mounted = 0;
3481eea0:	e5841014 	str	r1, [r4, #20]
	memset(dirfh, 0, sizeof(dirfh));
3481eea4:	e2840018 	add	r0, r4, #24
3481eea8:	ebffe7d4 	bl	34818e00 <memset>
	case STATE_UMOUNT_REQ:
		if (nfs_umountall_reply(pkt, len)) {
			puts("*** ERROR: Cannot umount\n");
			net_set_state(NETLOOP_FAIL);
		} else {
			puts("\ndone\n");
3481eeac:	e59f0348 	ldr	r0, [pc, #840]	; 3481f1fc <NfsHandler+0x4bc>
3481eeb0:	ebffa81b 	bl	34808f24 <puts>
static inline void net_set_state(enum net_loop_state state)
{
	extern enum net_loop_state net_state;

	debug_cond(DEBUG_INT_STATE, "--- NetState set to %d\n", state);
	net_state = state;
3481eeb4:	e594206c 	ldr	r2, [r4, #108]	; 0x6c
3481eeb8:	ea000002 	b	3481eec8 <NfsHandler+0x188>
		}
		break;

	case STATE_UMOUNT_REQ:
		if (nfs_umountall_reply(pkt, len)) {
			puts("*** ERROR: Cannot umount\n");
3481eebc:	e59f033c 	ldr	r0, [pc, #828]	; 3481f200 <NfsHandler+0x4c0>
3481eec0:	ebffa817 	bl	34808f24 <puts>
3481eec4:	e3a02003 	mov	r2, #3
3481eec8:	e59f3334 	ldr	r3, [pc, #820]	; 3481f204 <NfsHandler+0x4c4>
3481eecc:	e5832000 	str	r2, [r3]
3481eed0:	ea0000c2 	b	3481f1e0 <NfsHandler+0x4a0>
{
	struct rpc_t rpc_pkt;

	debug("%s\n", __func__);

	memcpy((unsigned char *)&rpc_pkt, pkt, len);
3481eed4:	e28d4a01 	add	r4, sp, #4096	; 0x1000
3481eed8:	e1a01005 	mov	r1, r5
3481eedc:	e1a00004 	mov	r0, r4
3481eee0:	ebffe7ea 	bl	34818e90 <memcpy>

	if (ntohl(rpc_pkt.u.reply.id) != rpc_id)
3481eee4:	e59f331c 	ldr	r3, [pc, #796]	; 3481f208 <NfsHandler+0x4c8>
3481eee8:	e28d2b0a 	add	r2, sp, #10240	; 0x2800
3481eeec:	e7920003 	ldr	r0, [r2, r3]
3481eef0:	ebfffdf6 	bl	3481e6d0 <__fswab32>
3481eef4:	e59f52ec 	ldr	r5, [pc, #748]	; 3481f1e8 <NfsHandler+0x4a8>
3481eef8:	e5953000 	ldr	r3, [r5]
3481eefc:	e1500003 	cmp	r0, r3
3481ef00:	1a000016 	bne	3481ef60 <NfsHandler+0x220>
		return -1;

	if (rpc_pkt.u.reply.rstatus  ||
3481ef04:	e5943008 	ldr	r3, [r4, #8]
3481ef08:	e3530000 	cmp	r3, #0
3481ef0c:	1a000013 	bne	3481ef60 <NfsHandler+0x220>
3481ef10:	e594300c 	ldr	r3, [r4, #12]
3481ef14:	e3530000 	cmp	r3, #0
3481ef18:	1a000010 	bne	3481ef60 <NfsHandler+0x220>
	    rpc_pkt.u.reply.verifier ||
3481ef1c:	e5943014 	ldr	r3, [r4, #20]
3481ef20:	e3530000 	cmp	r3, #0
3481ef24:	1a00000d 	bne	3481ef60 <NfsHandler+0x220>
	    rpc_pkt.u.reply.astatus  ||
3481ef28:	e5946018 	ldr	r6, [r4, #24]
3481ef2c:	e3560000 	cmp	r6, #0
3481ef30:	1a00000a 	bne	3481ef60 <NfsHandler+0x220>
	    rpc_pkt.u.reply.data[0])
		return -1;

	memcpy(filefh, rpc_pkt.u.reply.data + 1, NFS_FHSIZE);
3481ef34:	e2850038 	add	r0, r5, #56	; 0x38
3481ef38:	e284101c 	add	r1, r4, #28
3481ef3c:	e3a02020 	mov	r2, #32
3481ef40:	ebffe7d2 	bl	34818e90 <memcpy>
		if (nfs_lookup_reply(pkt, len)) {
			puts("*** ERROR: File lookup fail\n");
			NfsState = STATE_UMOUNT_REQ;
			NfsSend();
		} else {
			NfsState = STATE_READ_REQ;
3481ef44:	e3a03006 	mov	r3, #6
3481ef48:	e5853058 	str	r3, [r5, #88]	; 0x58
			nfs_offset = 0;
3481ef4c:	e59f32b8 	ldr	r3, [pc, #696]	; 3481f20c <NfsHandler+0x4cc>
3481ef50:	e5836000 	str	r6, [r3]
			nfs_len = NFS_READ_SIZE;
3481ef54:	e3a03b01 	mov	r3, #1024	; 0x400
3481ef58:	e5853064 	str	r3, [r5, #100]	; 0x64
3481ef5c:	ea00009e 	b	3481f1dc <NfsHandler+0x49c>
		}
		break;

	case STATE_LOOKUP_REQ:
		if (nfs_lookup_reply(pkt, len)) {
			puts("*** ERROR: File lookup fail\n");
3481ef60:	e59f02a8 	ldr	r0, [pc, #680]	; 3481f210 <NfsHandler+0x4d0>
3481ef64:	ebffa7ee 	bl	34808f24 <puts>
3481ef68:	ea00008b 	b	3481f19c <NfsHandler+0x45c>
	struct rpc_t rpc_pkt;
	int rlen;

	debug("%s\n", __func__);

	memcpy((unsigned char *)&rpc_pkt, pkt, len);
3481ef6c:	e28d6b02 	add	r6, sp, #2048	; 0x800
3481ef70:	e1a01005 	mov	r1, r5
3481ef74:	e1a00006 	mov	r0, r6
3481ef78:	ebffe7c4 	bl	34818e90 <memcpy>

	if (ntohl(rpc_pkt.u.reply.id) != rpc_id)
3481ef7c:	e59f3290 	ldr	r3, [pc, #656]	; 3481f214 <NfsHandler+0x4d4>
3481ef80:	e28d2b0a 	add	r2, sp, #10240	; 0x2800
3481ef84:	e7920003 	ldr	r0, [r2, r3]
3481ef88:	ebfffdd0 	bl	3481e6d0 <__fswab32>
3481ef8c:	e59f4254 	ldr	r4, [pc, #596]	; 3481f1e8 <NfsHandler+0x4a8>
3481ef90:	e5943000 	ldr	r3, [r4]
3481ef94:	e1500003 	cmp	r0, r3
3481ef98:	1a000027 	bne	3481f03c <NfsHandler+0x2fc>
		return -1;

	if (rpc_pkt.u.reply.rstatus  ||
3481ef9c:	e5963008 	ldr	r3, [r6, #8]
3481efa0:	e3530000 	cmp	r3, #0
3481efa4:	1a000024 	bne	3481f03c <NfsHandler+0x2fc>
3481efa8:	e596300c 	ldr	r3, [r6, #12]
3481efac:	e3530000 	cmp	r3, #0
3481efb0:	1a000021 	bne	3481f03c <NfsHandler+0x2fc>
	    rpc_pkt.u.reply.verifier ||
3481efb4:	e5963014 	ldr	r3, [r6, #20]
3481efb8:	e3530000 	cmp	r3, #0
3481efbc:	1a00001e 	bne	3481f03c <NfsHandler+0x2fc>
	    rpc_pkt.u.reply.astatus  ||
3481efc0:	e5967018 	ldr	r7, [r6, #24]
3481efc4:	e3570000 	cmp	r7, #0
3481efc8:	1a00001b 	bne	3481f03c <NfsHandler+0x2fc>
	    rpc_pkt.u.reply.data[0])
		return -1;

	rlen = ntohl(rpc_pkt.u.reply.data[1]); /* new path length */
3481efcc:	e596001c 	ldr	r0, [r6, #28]
3481efd0:	ebfffdbe 	bl	3481e6d0 <__fswab32>

	if (*((char *)&(rpc_pkt.u.reply.data[2])) != '/') {
3481efd4:	e5f63020 	ldrb	r3, [r6, #32]!
	    rpc_pkt.u.reply.verifier ||
	    rpc_pkt.u.reply.astatus  ||
	    rpc_pkt.u.reply.data[0])
		return -1;

	rlen = ntohl(rpc_pkt.u.reply.data[1]); /* new path length */
3481efd8:	e1a05000 	mov	r5, r0

	if (*((char *)&(rpc_pkt.u.reply.data[2])) != '/') {
3481efdc:	e353002f 	cmp	r3, #47	; 0x2f
3481efe0:	0a00000e 	beq	3481f020 <NfsHandler+0x2e0>
		int pathlen;
		strcat(nfs_path, "/");
3481efe4:	e59f122c 	ldr	r1, [pc, #556]	; 3481f218 <NfsHandler+0x4d8>
3481efe8:	e594005c 	ldr	r0, [r4, #92]	; 0x5c
3481efec:	ebffe68f 	bl	34818a30 <strcat>
		pathlen = strlen(nfs_path);
3481eff0:	e594005c 	ldr	r0, [r4, #92]	; 0x5c
3481eff4:	ebffe6e1 	bl	34818b80 <strlen>
3481eff8:	e1a0a000 	mov	sl, r0
		memcpy(nfs_path + pathlen, (uchar *)&(rpc_pkt.u.reply.data[2]),
3481effc:	e594005c 	ldr	r0, [r4, #92]	; 0x5c
3481f000:	e1a02005 	mov	r2, r5
3481f004:	e080000a 	add	r0, r0, sl
3481f008:	e1a01006 	mov	r1, r6
3481f00c:	ebffe79f 	bl	34818e90 <memcpy>
			rlen);
		nfs_path[pathlen + rlen] = 0;
3481f010:	e594305c 	ldr	r3, [r4, #92]	; 0x5c
3481f014:	e0835005 	add	r5, r3, r5
3481f018:	e7c5700a 	strb	r7, [r5, sl]
3481f01c:	ea000062 	b	3481f1ac <NfsHandler+0x46c>
	} else {
		memcpy(nfs_path, (uchar *)&(rpc_pkt.u.reply.data[2]), rlen);
3481f020:	e594005c 	ldr	r0, [r4, #92]	; 0x5c
3481f024:	e1a01006 	mov	r1, r6
3481f028:	e1a02005 	mov	r2, r5
3481f02c:	ebffe797 	bl	34818e90 <memcpy>
		nfs_path[rlen] = 0;
3481f030:	e594305c 	ldr	r3, [r4, #92]	; 0x5c
3481f034:	e7c37005 	strb	r7, [r3, r5]
3481f038:	ea00005b 	b	3481f1ac <NfsHandler+0x46c>
		}
		break;

	case STATE_READLINK_REQ:
		if (nfs_readlink_reply(pkt, len)) {
			puts("*** ERROR: Symlink fail\n");
3481f03c:	e59f01d8 	ldr	r0, [pc, #472]	; 3481f21c <NfsHandler+0x4dc>
3481f040:	eaffffc7 	b	3481ef64 <NfsHandler+0x224>
	struct rpc_t rpc_pkt;
	int rlen;

	debug("%s\n", __func__);

	memcpy((uchar *)&rpc_pkt, pkt, sizeof(rpc_pkt.u.reply));
3481f044:	e1a01005 	mov	r1, r5
3481f048:	e3a02064 	mov	r2, #100	; 0x64
3481f04c:	e1a0000d 	mov	r0, sp
3481f050:	ebffe78e 	bl	34818e90 <memcpy>

	if (ntohl(rpc_pkt.u.reply.id) != rpc_id)
3481f054:	e59f31c4 	ldr	r3, [pc, #452]	; 3481f220 <NfsHandler+0x4e0>
3481f058:	e28d2b0a 	add	r2, sp, #10240	; 0x2800
3481f05c:	e7920003 	ldr	r0, [r2, r3]
3481f060:	ebfffd9a 	bl	3481e6d0 <__fswab32>
3481f064:	e59f317c 	ldr	r3, [pc, #380]	; 3481f1e8 <NfsHandler+0x4a8>
	struct rpc_t rpc_pkt;
	int rlen;

	debug("%s\n", __func__);

	memcpy((uchar *)&rpc_pkt, pkt, sizeof(rpc_pkt.u.reply));
3481f068:	e1a0400d 	mov	r4, sp

	if (ntohl(rpc_pkt.u.reply.id) != rpc_id)
3481f06c:	e5933000 	ldr	r3, [r3]
3481f070:	e1500003 	cmp	r0, r3
		return -1;
3481f074:	13e04000 	mvnne	r4, #0

	debug("%s\n", __func__);

	memcpy((uchar *)&rpc_pkt, pkt, sizeof(rpc_pkt.u.reply));

	if (ntohl(rpc_pkt.u.reply.id) != rpc_id)
3481f078:	1a000036 	bne	3481f158 <NfsHandler+0x418>
		return -1;

	if (rpc_pkt.u.reply.rstatus  ||
3481f07c:	e5943008 	ldr	r3, [r4, #8]
3481f080:	e3530000 	cmp	r3, #0
3481f084:	1a000032 	bne	3481f154 <NfsHandler+0x414>
3481f088:	e594300c 	ldr	r3, [r4, #12]
3481f08c:	e3530000 	cmp	r3, #0
3481f090:	1a000005 	bne	3481f0ac <NfsHandler+0x36c>
	    rpc_pkt.u.reply.verifier ||
3481f094:	e5943014 	ldr	r3, [r4, #20]
3481f098:	e3530000 	cmp	r3, #0
3481f09c:	1a000002 	bne	3481f0ac <NfsHandler+0x36c>
	    rpc_pkt.u.reply.astatus  ||
3481f0a0:	e5943018 	ldr	r3, [r4, #24]
3481f0a4:	e3530000 	cmp	r3, #0
3481f0a8:	0a000006 	beq	3481f0c8 <NfsHandler+0x388>
	    rpc_pkt.u.reply.data[0]) {
		if (rpc_pkt.u.reply.rstatus)
			return -9999;
		if (rpc_pkt.u.reply.astatus)
3481f0ac:	e59d2014 	ldr	r2, [sp, #20]
3481f0b0:	e3520000 	cmp	r2, #0
3481f0b4:	1a000026 	bne	3481f154 <NfsHandler+0x414>
			return -9999;
		return -ntohl(rpc_pkt.u.reply.data[0]);
3481f0b8:	e59d0018 	ldr	r0, [sp, #24]
3481f0bc:	ebfffd83 	bl	3481e6d0 <__fswab32>
3481f0c0:	e2604000 	rsb	r4, r0, #0
3481f0c4:	ea000023 	b	3481f158 <NfsHandler+0x418>
	}

	if ((nfs_offset != 0) && !((nfs_offset) %
3481f0c8:	e59f313c 	ldr	r3, [pc, #316]	; 3481f20c <NfsHandler+0x4cc>
3481f0cc:	e5930000 	ldr	r0, [r3]
3481f0d0:	e3500000 	cmp	r0, #0
3481f0d4:	0a000005 	beq	3481f0f0 <NfsHandler+0x3b0>
3481f0d8:	e59f1144 	ldr	r1, [pc, #324]	; 3481f224 <NfsHandler+0x4e4>
3481f0dc:	eb00047b 	bl	348202d0 <__aeabi_idivmod>
3481f0e0:	e3510000 	cmp	r1, #0
3481f0e4:	1a000001 	bne	3481f0f0 <NfsHandler+0x3b0>
			(NFS_READ_SIZE / 2 * 10 * HASHES_PER_LINE)))
		puts("\n\t ");
3481f0e8:	e59f0138 	ldr	r0, [pc, #312]	; 3481f228 <NfsHandler+0x4e8>
3481f0ec:	ebffa78c 	bl	34808f24 <puts>
	if (!(nfs_offset % ((NFS_READ_SIZE / 2) * 10)))
3481f0f0:	e59f3114 	ldr	r3, [pc, #276]	; 3481f20c <NfsHandler+0x4cc>
3481f0f4:	e3a01b05 	mov	r1, #5120	; 0x1400
3481f0f8:	e5930000 	ldr	r0, [r3]
3481f0fc:	eb000473 	bl	348202d0 <__aeabi_idivmod>
3481f100:	e3510000 	cmp	r1, #0
3481f104:	1a000001 	bne	3481f110 <NfsHandler+0x3d0>
		putc('#');
3481f108:	e3a00023 	mov	r0, #35	; 0x23
3481f10c:	ebffa77a 	bl	34808efc <putc>

	rlen = ntohl(rpc_pkt.u.reply.data[18]);
3481f110:	e59d0060 	ldr	r0, [sp, #96]	; 0x60
3481f114:	ebfffd6d 	bl	3481e6d0 <__fswab32>
	if (store_block((uchar *)pkt + sizeof(rpc_pkt.u.reply),
3481f118:	e59f30ec 	ldr	r3, [pc, #236]	; 3481f20c <NfsHandler+0x4cc>
			return -1;
		}
	} else
#endif /* CONFIG_SYS_DIRECT_FLASH_NFS */
	{
		(void)memcpy((void *)(load_addr + offset), src, len);
3481f11c:	e59f2108 	ldr	r2, [pc, #264]	; 3481f22c <NfsHandler+0x4ec>
		puts("\n\t ");
	if (!(nfs_offset % ((NFS_READ_SIZE / 2) * 10)))
		putc('#');

	rlen = ntohl(rpc_pkt.u.reply.data[18]);
	if (store_block((uchar *)pkt + sizeof(rpc_pkt.u.reply),
3481f120:	e5933000 	ldr	r3, [r3]
			(NFS_READ_SIZE / 2 * 10 * HASHES_PER_LINE)))
		puts("\n\t ");
	if (!(nfs_offset % ((NFS_READ_SIZE / 2) * 10)))
		putc('#');

	rlen = ntohl(rpc_pkt.u.reply.data[18]);
3481f124:	e1a04000 	mov	r4, r0
static char nfs_path_buff[2048];

static inline int
store_block(uchar *src, unsigned offset, unsigned len)
{
	ulong newsize = offset + len;
3481f128:	e0806003 	add	r6, r0, r3
			return -1;
		}
	} else
#endif /* CONFIG_SYS_DIRECT_FLASH_NFS */
	{
		(void)memcpy((void *)(load_addr + offset), src, len);
3481f12c:	e5920000 	ldr	r0, [r2]
3481f130:	e2851064 	add	r1, r5, #100	; 0x64
3481f134:	e0830000 	add	r0, r3, r0
3481f138:	e1a02004 	mov	r2, r4
3481f13c:	ebffe753 	bl	34818e90 <memcpy>
	}

	if (NetBootFileXferSize < (offset+len))
3481f140:	e59f30e8 	ldr	r3, [pc, #232]	; 3481f230 <NfsHandler+0x4f0>
3481f144:	e5932000 	ldr	r2, [r3]
3481f148:	e1520006 	cmp	r2, r6
		NetBootFileXferSize = newsize;
3481f14c:	35836000 	strcc	r6, [r3]
3481f150:	ea000000 	b	3481f158 <NfsHandler+0x418>
	    rpc_pkt.u.reply.astatus  ||
	    rpc_pkt.u.reply.data[0]) {
		if (rpc_pkt.u.reply.rstatus)
			return -9999;
		if (rpc_pkt.u.reply.astatus)
			return -9999;
3481f154:	e59f40d8 	ldr	r4, [pc, #216]	; 3481f234 <NfsHandler+0x4f4>
		}
		break;

	case STATE_READ_REQ:
		rlen = nfs_read_reply(pkt, len);
		NetSetTimeout(NFS_TIMEOUT, NfsTimeout);
3481f158:	e3a00e7d 	mov	r0, #2000	; 0x7d0
3481f15c:	e59f10d4 	ldr	r1, [pc, #212]	; 3481f238 <NfsHandler+0x4f8>
3481f160:	ebfffa08 	bl	3481d988 <NetSetTimeout>
		if (rlen > 0) {
3481f164:	e3540000 	cmp	r4, #0
			nfs_offset += rlen;
3481f168:	c59f309c 	ldrgt	r3, [pc, #156]	; 3481f20c <NfsHandler+0x4cc>
3481f16c:	c5932000 	ldrgt	r2, [r3]
3481f170:	c0844002 	addgt	r4, r4, r2
3481f174:	c5834000 	strgt	r4, [r3]
3481f178:	ca000017 	bgt	3481f1dc <NfsHandler+0x49c>
			NfsSend();
		} else if ((rlen == -NFSERR_ISDIR) || (rlen == -NFSERR_INVAL)) {
3481f17c:	e2843016 	add	r3, r4, #22
3481f180:	e3530001 	cmp	r3, #1
			/* symbolic link */
			NfsState = STATE_READLINK_REQ;
3481f184:	93a02007 	movls	r2, #7
		rlen = nfs_read_reply(pkt, len);
		NetSetTimeout(NFS_TIMEOUT, NfsTimeout);
		if (rlen > 0) {
			nfs_offset += rlen;
			NfsSend();
		} else if ((rlen == -NFSERR_ISDIR) || (rlen == -NFSERR_INVAL)) {
3481f188:	9a000004 	bls	3481f1a0 <NfsHandler+0x460>
			/* symbolic link */
			NfsState = STATE_READLINK_REQ;
			NfsSend();
		} else {
			if (!rlen)
3481f18c:	e3540000 	cmp	r4, #0
				nfs_download_state = NETLOOP_SUCCESS;
3481f190:	059f3050 	ldreq	r3, [pc, #80]	; 3481f1e8 <NfsHandler+0x4a8>
3481f194:	03a02002 	moveq	r2, #2
3481f198:	0583206c 	streq	r2, [r3, #108]	; 0x6c
			NfsState = STATE_UMOUNT_REQ;
3481f19c:	e3a02004 	mov	r2, #4
3481f1a0:	e59f3040 	ldr	r3, [pc, #64]	; 3481f1e8 <NfsHandler+0x4a8>
3481f1a4:	e5832058 	str	r2, [r3, #88]	; 0x58
3481f1a8:	ea00000b 	b	3481f1dc <NfsHandler+0x49c>
			puts("*** ERROR: Symlink fail\n");
			NfsState = STATE_UMOUNT_REQ;
			NfsSend();
		} else {
			debug("Symlink --> %s\n", nfs_path);
			nfs_filename = basename(nfs_path);
3481f1ac:	e59f4034 	ldr	r4, [pc, #52]	; 3481f1e8 <NfsHandler+0x4a8>
3481f1b0:	e594005c 	ldr	r0, [r4, #92]	; 0x5c
3481f1b4:	ebfffd47 	bl	3481e6d8 <basename>
			nfs_path     = dirname(nfs_path);
3481f1b8:	e594505c 	ldr	r5, [r4, #92]	; 0x5c
			puts("*** ERROR: Symlink fail\n");
			NfsState = STATE_UMOUNT_REQ;
			NfsSend();
		} else {
			debug("Symlink --> %s\n", nfs_path);
			nfs_filename = basename(nfs_path);
3481f1bc:	e5840060 	str	r0, [r4, #96]	; 0x60
static char*
dirname(char *path)
{
	char *fname;

	fname = basename(path);
3481f1c0:	e1a00005 	mov	r0, r5
3481f1c4:	ebfffd43 	bl	3481e6d8 <basename>
	--fname;
	*fname = '\0';
3481f1c8:	e3a03000 	mov	r3, #0
3481f1cc:	e5403001 	strb	r3, [r0, #-1]
			NfsState = STATE_UMOUNT_REQ;
			NfsSend();
		} else {
			debug("Symlink --> %s\n", nfs_path);
			nfs_filename = basename(nfs_path);
			nfs_path     = dirname(nfs_path);
3481f1d0:	e584505c 	str	r5, [r4, #92]	; 0x5c

			NfsState = STATE_MOUNT_REQ;
3481f1d4:	e2833003 	add	r3, r3, #3
3481f1d8:	e5843058 	str	r3, [r4, #88]	; 0x58
			NfsSend();
3481f1dc:	ebfffe9c 	bl	3481ec54 <NfsSend>
			NfsState = STATE_UMOUNT_REQ;
			NfsSend();
		}
		break;
	}
}
3481f1e0:	e28ddb0a 	add	sp, sp, #10240	; 0x2800
3481f1e4:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
3481f1e8:	3482d994 	.word	0x3482d994
3481f1ec:	000186a5 	.word	0x000186a5
3481f1f0:	000186a3 	.word	0x000186a3
3481f1f4:	34827eac 	.word	0x34827eac
3481f1f8:	fffff000 	.word	0xfffff000
3481f1fc:	34827ec5 	.word	0x34827ec5
3481f200:	34827ecc 	.word	0x34827ecc
3481f204:	3482b9d4 	.word	0x3482b9d4
3481f208:	ffffe800 	.word	0xffffe800
3481f20c:	34828bb0 	.word	0x34828bb0
3481f210:	34827ee6 	.word	0x34827ee6
3481f214:	ffffe000 	.word	0xffffe000
3481f218:	34827f03 	.word	0x34827f03
3481f21c:	34827f05 	.word	0x34827f05
3481f220:	ffffd800 	.word	0xffffd800
3481f224:	00051400 	.word	0x00051400
3481f228:	34827f1e 	.word	0x34827f1e
3481f22c:	348283c4 	.word	0x348283c4
3481f230:	3482d880 	.word	0x3482d880
3481f234:	ffffd8f1 	.word	0xffffd8f1
3481f238:	3481ece8 	.word	0x3481ece8

3481f23c <NfsStart>:


void
NfsStart(void)
{
3481f23c:	e92d4073 	push	{r0, r1, r4, r5, r6, lr}
	debug("%s\n", __func__);
	nfs_download_state = NETLOOP_FAIL;
3481f240:	e59f41d0 	ldr	r4, [pc, #464]	; 3481f418 <NfsStart+0x1dc>
3481f244:	e3a03003 	mov	r3, #3
3481f248:	e584306c 	str	r3, [r4, #108]	; 0x6c

	NfsServerIP = NetServerIP;
3481f24c:	e59f31c8 	ldr	r3, [pc, #456]	; 3481f41c <NfsStart+0x1e0>
		net_set_state(NETLOOP_FAIL);
		puts("*** ERROR: Fail allocate memory\n");
		return;
	}

	if (BootFile[0] == '\0') {
3481f250:	e59f51c8 	ldr	r5, [pc, #456]	; 3481f420 <NfsStart+0x1e4>
NfsStart(void)
{
	debug("%s\n", __func__);
	nfs_download_state = NETLOOP_FAIL;

	NfsServerIP = NetServerIP;
3481f254:	e5933000 	ldr	r3, [r3]
3481f258:	e584300c 	str	r3, [r4, #12]
	nfs_path = (char *)nfs_path_buff;
3481f25c:	e2843070 	add	r3, r4, #112	; 0x70
3481f260:	e584305c 	str	r3, [r4, #92]	; 0x5c
		net_set_state(NETLOOP_FAIL);
		puts("*** ERROR: Fail allocate memory\n");
		return;
	}

	if (BootFile[0] == '\0') {
3481f264:	e5d53000 	ldrb	r3, [r5]
3481f268:	e3530000 	cmp	r3, #0
3481f26c:	1a000011 	bne	3481f2b8 <NfsStart+0x7c>
		sprintf(default_filename, "/nfsroot/%02X%02X%02X%02X.img",
3481f270:	e59f31ac 	ldr	r3, [pc, #428]	; 3481f424 <NfsStart+0x1e8>
3481f274:	e2840e87 	add	r0, r4, #2160	; 0x870
3481f278:	e5933000 	ldr	r3, [r3]
3481f27c:	e59f11a4 	ldr	r1, [pc, #420]	; 3481f428 <NfsStart+0x1ec>
3481f280:	e7e72853 	ubfx	r2, r3, #16, #8
3481f284:	e58d2000 	str	r2, [sp]
3481f288:	e1a02c23 	lsr	r2, r3, #24
3481f28c:	e58d2004 	str	r2, [sp, #4]
3481f290:	e6ef2073 	uxtb	r2, r3
3481f294:	e7e73453 	ubfx	r3, r3, #8, #8
3481f298:	ebffeafc 	bl	34819e90 <sprintf>
			NetOurIP & 0xFF,
			(NetOurIP >>  8) & 0xFF,
			(NetOurIP >> 16) & 0xFF,
			(NetOurIP >> 24) & 0xFF);
		strcpy(nfs_path, default_filename);
3481f29c:	e2841e87 	add	r1, r4, #2160	; 0x870
3481f2a0:	e594005c 	ldr	r0, [r4, #92]	; 0x5c
3481f2a4:	ebffe5d0 	bl	348189ec <strcpy>

		printf("*** Warning: no boot file name; using '%s'\n",
3481f2a8:	e594105c 	ldr	r1, [r4, #92]	; 0x5c
3481f2ac:	e59f0178 	ldr	r0, [pc, #376]	; 3481f42c <NfsStart+0x1f0>
3481f2b0:	ebffa725 	bl	34808f4c <printf>
3481f2b4:	ea00000c 	b	3481f2ec <NfsStart+0xb0>
			nfs_path);
	} else {
		char *p = BootFile;

		p = strchr(p, ':');
3481f2b8:	e3a0103a 	mov	r1, #58	; 0x3a
3481f2bc:	e1a00005 	mov	r0, r5
3481f2c0:	ebffe618 	bl	34818b28 <strchr>

		if (p != NULL) {
3481f2c4:	e2506000 	subs	r6, r0, #0
			NfsServerIP = string_to_ip(BootFile);
			++p;
			strcpy(nfs_path, p);
		} else {
			strcpy(nfs_path, BootFile);
3481f2c8:	0594005c 	ldreq	r0, [r4, #92]	; 0x5c
3481f2cc:	01a01005 	moveq	r1, r5
	} else {
		char *p = BootFile;

		p = strchr(p, ':');

		if (p != NULL) {
3481f2d0:	0a000004 	beq	3481f2e8 <NfsStart+0xac>
			NfsServerIP = string_to_ip(BootFile);
3481f2d4:	e1a00005 	mov	r0, r5
3481f2d8:	ebffe56b 	bl	3481888c <string_to_ip>
3481f2dc:	e584000c 	str	r0, [r4, #12]
			++p;
			strcpy(nfs_path, p);
3481f2e0:	e594005c 	ldr	r0, [r4, #92]	; 0x5c
3481f2e4:	e2861001 	add	r1, r6, #1
		} else {
			strcpy(nfs_path, BootFile);
3481f2e8:	ebffe5bf 	bl	348189ec <strcpy>
		}
	}

	nfs_filename = basename(nfs_path);
3481f2ec:	e59f5124 	ldr	r5, [pc, #292]	; 3481f418 <NfsStart+0x1dc>
3481f2f0:	e595005c 	ldr	r0, [r5, #92]	; 0x5c
3481f2f4:	ebfffcf7 	bl	3481e6d8 <basename>
	nfs_path     = dirname(nfs_path);
3481f2f8:	e595405c 	ldr	r4, [r5, #92]	; 0x5c
		} else {
			strcpy(nfs_path, BootFile);
		}
	}

	nfs_filename = basename(nfs_path);
3481f2fc:	e5850060 	str	r0, [r5, #96]	; 0x60
static char*
dirname(char *path)
{
	char *fname;

	fname = basename(path);
3481f300:	e1a00004 	mov	r0, r4
3481f304:	ebfffcf3 	bl	3481e6d8 <basename>
	--fname;
	*fname = '\0';
3481f308:	e3a03000 	mov	r3, #0
3481f30c:	e5403001 	strb	r3, [r0, #-1]
			strcpy(nfs_path, BootFile);
		}
	}

	nfs_filename = basename(nfs_path);
	nfs_path     = dirname(nfs_path);
3481f310:	e585405c 	str	r4, [r5, #92]	; 0x5c

	printf("Using %s device\n", eth_get_name());
3481f314:	ebfff959 	bl	3481d880 <eth_get_name>

	printf("File transfer via NFS from server %pI4"
3481f318:	e59f4104 	ldr	r4, [pc, #260]	; 3481f424 <NfsStart+0x1e8>
	}

	nfs_filename = basename(nfs_path);
	nfs_path     = dirname(nfs_path);

	printf("Using %s device\n", eth_get_name());
3481f31c:	e1a01000 	mov	r1, r0
3481f320:	e59f0108 	ldr	r0, [pc, #264]	; 3481f430 <NfsStart+0x1f4>
3481f324:	ebffa708 	bl	34808f4c <printf>

	printf("File transfer via NFS from server %pI4"
3481f328:	e285100c 	add	r1, r5, #12
3481f32c:	e59f0100 	ldr	r0, [pc, #256]	; 3481f434 <NfsStart+0x1f8>
3481f330:	e1a02004 	mov	r2, r4
3481f334:	ebffa704 	bl	34808f4c <printf>
		"; our IP address is %pI4", &NfsServerIP, &NetOurIP);

	/* Check if we need to send across this subnet */
	if (NetOurGatewayIP && NetOurSubnetMask) {
3481f338:	e59f10f8 	ldr	r1, [pc, #248]	; 3481f438 <NfsStart+0x1fc>
3481f33c:	e5913000 	ldr	r3, [r1]
3481f340:	e3530000 	cmp	r3, #0
3481f344:	0a00000c 	beq	3481f37c <NfsStart+0x140>
3481f348:	e59f30ec 	ldr	r3, [pc, #236]	; 3481f43c <NfsStart+0x200>
3481f34c:	e5933000 	ldr	r3, [r3]
3481f350:	e3530000 	cmp	r3, #0
3481f354:	0a000008 	beq	3481f37c <NfsStart+0x140>
		IPaddr_t OurNet	    = NetOurIP	  & NetOurSubnetMask;
		IPaddr_t ServerNet  = NetServerIP & NetOurSubnetMask;
3481f358:	e59f00bc 	ldr	r0, [pc, #188]	; 3481f41c <NfsStart+0x1e0>
	printf("File transfer via NFS from server %pI4"
		"; our IP address is %pI4", &NfsServerIP, &NetOurIP);

	/* Check if we need to send across this subnet */
	if (NetOurGatewayIP && NetOurSubnetMask) {
		IPaddr_t OurNet	    = NetOurIP	  & NetOurSubnetMask;
3481f35c:	e5942000 	ldr	r2, [r4]
		IPaddr_t ServerNet  = NetServerIP & NetOurSubnetMask;
3481f360:	e5900000 	ldr	r0, [r0]
	printf("File transfer via NFS from server %pI4"
		"; our IP address is %pI4", &NfsServerIP, &NetOurIP);

	/* Check if we need to send across this subnet */
	if (NetOurGatewayIP && NetOurSubnetMask) {
		IPaddr_t OurNet	    = NetOurIP	  & NetOurSubnetMask;
3481f364:	e0032002 	and	r2, r3, r2
		IPaddr_t ServerNet  = NetServerIP & NetOurSubnetMask;
3481f368:	e0033000 	and	r3, r3, r0

		if (OurNet != ServerNet)
3481f36c:	e1520003 	cmp	r2, r3
3481f370:	0a000001 	beq	3481f37c <NfsStart+0x140>
			printf("; sending through gateway %pI4",
3481f374:	e59f00c4 	ldr	r0, [pc, #196]	; 3481f440 <NfsStart+0x204>
3481f378:	ebffa6f3 	bl	34808f4c <printf>
				&NetOurGatewayIP);
	}
	printf("\nFilename '%s/%s'.", nfs_path, nfs_filename);
3481f37c:	e59f3094 	ldr	r3, [pc, #148]	; 3481f418 <NfsStart+0x1dc>

	if (NetBootFileSize) {
3481f380:	e59f40bc 	ldr	r4, [pc, #188]	; 3481f444 <NfsStart+0x208>

		if (OurNet != ServerNet)
			printf("; sending through gateway %pI4",
				&NetOurGatewayIP);
	}
	printf("\nFilename '%s/%s'.", nfs_path, nfs_filename);
3481f384:	e593105c 	ldr	r1, [r3, #92]	; 0x5c
3481f388:	e59f00b8 	ldr	r0, [pc, #184]	; 3481f448 <NfsStart+0x20c>
3481f38c:	e5932060 	ldr	r2, [r3, #96]	; 0x60
3481f390:	ebffa6ed 	bl	34808f4c <printf>

	if (NetBootFileSize) {
3481f394:	e1d410b0 	ldrh	r1, [r4]
3481f398:	e3510000 	cmp	r1, #0
3481f39c:	0a000007 	beq	3481f3c0 <NfsStart+0x184>
		printf(" Size is 0x%x Bytes = ", NetBootFileSize<<9);
3481f3a0:	e1a01481 	lsl	r1, r1, #9
3481f3a4:	e59f00a0 	ldr	r0, [pc, #160]	; 3481f44c <NfsStart+0x210>
3481f3a8:	ebffa6e7 	bl	34808f4c <printf>
		print_size(NetBootFileSize<<9, "");
3481f3ac:	e1d400b0 	ldrh	r0, [r4]
3481f3b0:	e59f2098 	ldr	r2, [pc, #152]	; 3481f450 <NfsStart+0x214>
3481f3b4:	e1a00480 	lsl	r0, r0, #9
3481f3b8:	e1a01fc0 	asr	r1, r0, #31
3481f3bc:	ebffdf49 	bl	348170e8 <print_size>
	}
	printf("\nLoad address: 0x%lx\n"
3481f3c0:	e59f308c 	ldr	r3, [pc, #140]	; 3481f454 <NfsStart+0x218>
3481f3c4:	e59f008c 	ldr	r0, [pc, #140]	; 3481f458 <NfsStart+0x21c>
3481f3c8:	e5931000 	ldr	r1, [r3]
3481f3cc:	ebffa6de 	bl	34808f4c <printf>
		"Loading: *\b", load_addr);

	NetSetTimeout(NFS_TIMEOUT, NfsTimeout);
3481f3d0:	e59f1084 	ldr	r1, [pc, #132]	; 3481f45c <NfsStart+0x220>
3481f3d4:	e3a00e7d 	mov	r0, #2000	; 0x7d0
3481f3d8:	ebfff96a 	bl	3481d988 <NetSetTimeout>
	net_set_udp_handler(NfsHandler);
3481f3dc:	e59f007c 	ldr	r0, [pc, #124]	; 3481f460 <NfsStart+0x224>
3481f3e0:	ebfff954 	bl	3481d938 <net_set_udp_handler>

	NfsTimeoutCount = 0;
3481f3e4:	e59f302c 	ldr	r3, [pc, #44]	; 3481f418 <NfsStart+0x1dc>
	NfsState = STATE_PRCLOOKUP_PROG_MOUNT_REQ;
3481f3e8:	e3a02001 	mov	r2, #1
		"Loading: *\b", load_addr);

	NetSetTimeout(NFS_TIMEOUT, NfsTimeout);
	net_set_udp_handler(NfsHandler);

	NfsTimeoutCount = 0;
3481f3ec:	e3a01000 	mov	r1, #0
	NfsState = STATE_PRCLOOKUP_PROG_MOUNT_REQ;
3481f3f0:	e5832058 	str	r2, [r3, #88]	; 0x58

	/*NfsOurPort = 4096 + (get_ticks() % 3072);*/
	/*FIX ME !!!*/
	NfsOurPort = 1000;
3481f3f4:	e3a02ffa 	mov	r2, #1000	; 0x3e8
3481f3f8:	e5832010 	str	r2, [r3, #16]
		"Loading: *\b", load_addr);

	NetSetTimeout(NFS_TIMEOUT, NfsTimeout);
	net_set_udp_handler(NfsHandler);

	NfsTimeoutCount = 0;
3481f3fc:	e5831068 	str	r1, [r3, #104]	; 0x68
	/*NfsOurPort = 4096 + (get_ticks() % 3072);*/
	/*FIX ME !!!*/
	NfsOurPort = 1000;

	/* zero out server ether in case the server ip has changed */
	memset(NetServerEther, 0, 6);
3481f400:	e3a02006 	mov	r2, #6
3481f404:	e59f0058 	ldr	r0, [pc, #88]	; 3481f464 <NfsStart+0x228>
3481f408:	ebffe67c 	bl	34818e00 <memset>

	NfsSend();
}
3481f40c:	e28dd008 	add	sp, sp, #8
3481f410:	e8bd4070 	pop	{r4, r5, r6, lr}
	NfsOurPort = 1000;

	/* zero out server ether in case the server ip has changed */
	memset(NetServerEther, 0, 6);

	NfsSend();
3481f414:	eafffe0e 	b	3481ec54 <NfsSend>
3481f418:	3482d994 	.word	0x3482d994
3481f41c:	3482ba2c 	.word	0x3482ba2c
3481f420:	3482d914 	.word	0x3482d914
3481f424:	3482ba04 	.word	0x3482ba04
3481f428:	34827f22 	.word	0x34827f22
3481f42c:	34827f40 	.word	0x34827f40
3481f430:	34827f6c 	.word	0x34827f6c
3481f434:	34827f7d 	.word	0x34827f7d
3481f438:	3482ba24 	.word	0x3482ba24
3481f43c:	3482ba28 	.word	0x3482ba28
3481f440:	34827fbc 	.word	0x34827fbc
3481f444:	3482d908 	.word	0x3482d908
3481f448:	34827fdb 	.word	0x34827fdb
3481f44c:	34827fee 	.word	0x34827fee
3481f450:	34824054 	.word	0x34824054
3481f454:	348283c4 	.word	0x348283c4
3481f458:	34828005 	.word	0x34828005
3481f45c:	3481ece8 	.word	0x3481ece8
3481f460:	3481ed40 	.word	0x3481ed40
3481f464:	3482d90c 	.word	0x3482d90c

3481f468 <ping_timeout>:
	ArpRequest();
	return 1;	/* waiting */
}

static void ping_timeout(void)
{
3481f468:	e92d4008 	push	{r3, lr}
	eth_halt();
3481f46c:	ebfff869 	bl	3481d618 <eth_halt>
3481f470:	e59f3008 	ldr	r3, [pc, #8]	; 3481f480 <ping_timeout+0x18>
3481f474:	e3a02003 	mov	r2, #3
3481f478:	e5832000 	str	r2, [r3]
	net_set_state(NETLOOP_FAIL);	/* we did not get the reply */
}
3481f47c:	e8bd8008 	pop	{r3, pc}
3481f480:	3482b9d4 	.word	0x3482b9d4

3481f484 <ping_start>:

void ping_start(void)
{
3481f484:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
	printf("Using %s device\n", eth_get_name());
3481f488:	ebfff8fc 	bl	3481d880 <eth_get_name>

	/* XXX always send arp request */

	debug_cond(DEBUG_DEV_PKT, "sending ARP for %pI4\n", &NetPingIP);

	NetArpWaitPacketIP = NetPingIP;
3481f48c:	e59f60ec 	ldr	r6, [pc, #236]	; 3481f580 <ping_start+0xfc>
	net_set_state(NETLOOP_FAIL);	/* we did not get the reply */
}

void ping_start(void)
{
	printf("Using %s device\n", eth_get_name());
3481f490:	e1a01000 	mov	r1, r0
3481f494:	e59f00e8 	ldr	r0, [pc, #232]	; 3481f584 <ping_start+0x100>
3481f498:	ebffa6ab 	bl	34808f4c <printf>
	NetSetTimeout(10000UL, ping_timeout);
3481f49c:	e3020710 	movw	r0, #10000	; 0x2710
3481f4a0:	e59f10e0 	ldr	r1, [pc, #224]	; 3481f588 <ping_start+0x104>
3481f4a4:	ebfff937 	bl	3481d988 <NetSetTimeout>

	debug_cond(DEBUG_DEV_PKT, "sending ARP for %pI4\n", &NetPingIP);

	NetArpWaitPacketIP = NetPingIP;

	eth_hdr_size = NetSetEther(NetTxPacket, NetEtherNullAddr, PROT_IP);
3481f4a8:	e59f40dc 	ldr	r4, [pc, #220]	; 3481f58c <ping_start+0x108>

	/* XXX always send arp request */

	debug_cond(DEBUG_DEV_PKT, "sending ARP for %pI4\n", &NetPingIP);

	NetArpWaitPacketIP = NetPingIP;
3481f4ac:	e5962000 	ldr	r2, [r6]
3481f4b0:	e59f30d8 	ldr	r3, [pc, #216]	; 3481f590 <ping_start+0x10c>

	eth_hdr_size = NetSetEther(NetTxPacket, NetEtherNullAddr, PROT_IP);
3481f4b4:	e5940000 	ldr	r0, [r4]

	/* XXX always send arp request */

	debug_cond(DEBUG_DEV_PKT, "sending ARP for %pI4\n", &NetPingIP);

	NetArpWaitPacketIP = NetPingIP;
3481f4b8:	e5832000 	str	r2, [r3]

	eth_hdr_size = NetSetEther(NetTxPacket, NetEtherNullAddr, PROT_IP);
3481f4bc:	e59f10d0 	ldr	r1, [pc, #208]	; 3481f594 <ping_start+0x110>
3481f4c0:	e3a02b02 	mov	r2, #2048	; 0x800
3481f4c4:	ebfffa4f 	bl	3481de08 <NetSetEther>
	pkt = (uchar *)NetTxPacket + eth_hdr_size;
3481f4c8:	e5944000 	ldr	r4, [r4]
	 *	Construct an IP and ICMP header.
	 */
	struct ip_hdr *ip = (struct ip_hdr *)pkt;
	struct icmp_hdr *icmp = (struct icmp_hdr *)(pkt + IP_HDR_SIZE);

	net_set_ip_header(pkt, dest, NetOurIP);
3481f4cc:	e59f30c4 	ldr	r3, [pc, #196]	; 3481f598 <ping_start+0x114>
	debug_cond(DEBUG_DEV_PKT, "sending ARP for %pI4\n", &NetPingIP);

	NetArpWaitPacketIP = NetPingIP;

	eth_hdr_size = NetSetEther(NetTxPacket, NetEtherNullAddr, PROT_IP);
	pkt = (uchar *)NetTxPacket + eth_hdr_size;
3481f4d0:	e0844000 	add	r4, r4, r0
	 *	Construct an IP and ICMP header.
	 */
	struct ip_hdr *ip = (struct ip_hdr *)pkt;
	struct icmp_hdr *icmp = (struct icmp_hdr *)(pkt + IP_HDR_SIZE);

	net_set_ip_header(pkt, dest, NetOurIP);
3481f4d4:	e5932000 	ldr	r2, [r3]
3481f4d8:	e5961000 	ldr	r1, [r6]

	debug_cond(DEBUG_DEV_PKT, "sending ARP for %pI4\n", &NetPingIP);

	NetArpWaitPacketIP = NetPingIP;

	eth_hdr_size = NetSetEther(NetTxPacket, NetEtherNullAddr, PROT_IP);
3481f4dc:	e1a07000 	mov	r7, r0
	 *	Construct an IP and ICMP header.
	 */
	struct ip_hdr *ip = (struct ip_hdr *)pkt;
	struct icmp_hdr *icmp = (struct icmp_hdr *)(pkt + IP_HDR_SIZE);

	net_set_ip_header(pkt, dest, NetOurIP);
3481f4e0:	e1a00004 	mov	r0, r4
3481f4e4:	ebfffa91 	bl	3481df30 <net_set_ip_header>

	ip->ip_len   = htons(IP_ICMP_HDR_SIZE);
	ip->ip_p     = IPPROTO_ICMP;
3481f4e8:	e3a0a001 	mov	sl, #1
	struct ip_hdr *ip = (struct ip_hdr *)pkt;
	struct icmp_hdr *icmp = (struct icmp_hdr *)(pkt + IP_HDR_SIZE);

	net_set_ip_header(pkt, dest, NetOurIP);

	ip->ip_len   = htons(IP_ICMP_HDR_SIZE);
3481f4ec:	e3a03b07 	mov	r3, #7168	; 0x1c00
3481f4f0:	e1c430b2 	strh	r3, [r4, #2]
	ip->ip_p     = IPPROTO_ICMP;
3481f4f4:	e5c4a009 	strb	sl, [r4, #9]
	ip->ip_sum   = ~NetCksum((uchar *)ip, IP_HDR_SIZE >> 1);
3481f4f8:	e1a00004 	mov	r0, r4
3481f4fc:	e3a0100a 	mov	r1, #10
3481f500:	ebfff97b 	bl	3481daf4 <NetCksum>

	icmp->type = ICMP_ECHO_REQUEST;
3481f504:	e3a03008 	mov	r3, #8

	net_set_ip_header(pkt, dest, NetOurIP);

	ip->ip_len   = htons(IP_ICMP_HDR_SIZE);
	ip->ip_p     = IPPROTO_ICMP;
	ip->ip_sum   = ~NetCksum((uchar *)ip, IP_HDR_SIZE >> 1);
3481f508:	e1e00000 	mvn	r0, r0
{
	/*
	 *	Construct an IP and ICMP header.
	 */
	struct ip_hdr *ip = (struct ip_hdr *)pkt;
	struct icmp_hdr *icmp = (struct icmp_hdr *)(pkt + IP_HDR_SIZE);
3481f50c:	e2845014 	add	r5, r4, #20

	net_set_ip_header(pkt, dest, NetOurIP);

	ip->ip_len   = htons(IP_ICMP_HDR_SIZE);
	ip->ip_p     = IPPROTO_ICMP;
	ip->ip_sum   = ~NetCksum((uchar *)ip, IP_HDR_SIZE >> 1);
3481f510:	e1c400ba 	strh	r0, [r4, #10]

	icmp->type = ICMP_ECHO_REQUEST;
3481f514:	e5c43014 	strb	r3, [r4, #20]
	icmp->code = 0;
3481f518:	e3a04000 	mov	r4, #0
3481f51c:	e5c54001 	strb	r4, [r5, #1]
	icmp->checksum = 0;
	icmp->un.echo.id = 0;
	icmp->un.echo.sequence = htons(PingSeqNo++);
3481f520:	e1d630b4 	ldrh	r3, [r6, #4]
	icmp->checksum = ~NetCksum((uchar *)icmp, ICMP_HDR_SIZE	>> 1);
3481f524:	e3a01004 	mov	r1, #4

	icmp->type = ICMP_ECHO_REQUEST;
	icmp->code = 0;
	icmp->checksum = 0;
	icmp->un.echo.id = 0;
	icmp->un.echo.sequence = htons(PingSeqNo++);
3481f528:	e083200a 	add	r2, r3, sl
3481f52c:	e1c620b4 	strh	r2, [r6, #4]
#endif /* OPTIMIZE */


static __inline__ __attribute__((const)) __u16 __fswab16(__u16 x)
{
	return __arch__swab16(x);
3481f530:	e1a02423 	lsr	r2, r3, #8
3481f534:	e1823403 	orr	r3, r2, r3, lsl #8
3481f538:	e1c530b6 	strh	r3, [r5, #6]
	ip->ip_p     = IPPROTO_ICMP;
	ip->ip_sum   = ~NetCksum((uchar *)ip, IP_HDR_SIZE >> 1);

	icmp->type = ICMP_ECHO_REQUEST;
	icmp->code = 0;
	icmp->checksum = 0;
3481f53c:	e1c540b2 	strh	r4, [r5, #2]
	icmp->un.echo.id = 0;
3481f540:	e1c540b4 	strh	r4, [r5, #4]
	icmp->un.echo.sequence = htons(PingSeqNo++);
	icmp->checksum = ~NetCksum((uchar *)icmp, ICMP_HDR_SIZE	>> 1);
3481f544:	e1a00005 	mov	r0, r5
3481f548:	ebfff969 	bl	3481daf4 <NetCksum>
	pkt = (uchar *)NetTxPacket + eth_hdr_size;

	set_icmp_header(pkt, NetPingIP);

	/* size of the waiting packet */
	NetArpWaitTxPacketSize = eth_hdr_size + IP_ICMP_HDR_SIZE;
3481f54c:	e59f3048 	ldr	r3, [pc, #72]	; 3481f59c <ping_start+0x118>
	icmp->type = ICMP_ECHO_REQUEST;
	icmp->code = 0;
	icmp->checksum = 0;
	icmp->un.echo.id = 0;
	icmp->un.echo.sequence = htons(PingSeqNo++);
	icmp->checksum = ~NetCksum((uchar *)icmp, ICMP_HDR_SIZE	>> 1);
3481f550:	e1e00000 	mvn	r0, r0
	pkt = (uchar *)NetTxPacket + eth_hdr_size;

	set_icmp_header(pkt, NetPingIP);

	/* size of the waiting packet */
	NetArpWaitTxPacketSize = eth_hdr_size + IP_ICMP_HDR_SIZE;
3481f554:	e287701c 	add	r7, r7, #28
	icmp->type = ICMP_ECHO_REQUEST;
	icmp->code = 0;
	icmp->checksum = 0;
	icmp->un.echo.id = 0;
	icmp->un.echo.sequence = htons(PingSeqNo++);
	icmp->checksum = ~NetCksum((uchar *)icmp, ICMP_HDR_SIZE	>> 1);
3481f558:	e1c500b2 	strh	r0, [r5, #2]
	pkt = (uchar *)NetTxPacket + eth_hdr_size;

	set_icmp_header(pkt, NetPingIP);

	/* size of the waiting packet */
	NetArpWaitTxPacketSize = eth_hdr_size + IP_ICMP_HDR_SIZE;
3481f55c:	e5837000 	str	r7, [r3]

	/* and do the ARP request */
	NetArpWaitTry = 1;
3481f560:	e59f3038 	ldr	r3, [pc, #56]	; 3481f5a0 <ping_start+0x11c>
	NetArpWaitTimerStart = get_timer(0);
3481f564:	e1a00004 	mov	r0, r4

	/* size of the waiting packet */
	NetArpWaitTxPacketSize = eth_hdr_size + IP_ICMP_HDR_SIZE;

	/* and do the ARP request */
	NetArpWaitTry = 1;
3481f568:	e583a000 	str	sl, [r3]
	NetArpWaitTimerStart = get_timer(0);
3481f56c:	ebff8738 	bl	34801254 <get_timer>
3481f570:	e59f302c 	ldr	r3, [pc, #44]	; 3481f5a4 <ping_start+0x120>
3481f574:	e5830000 	str	r0, [r3]
{
	printf("Using %s device\n", eth_get_name());
	NetSetTimeout(10000UL, ping_timeout);

	ping_send();
}
3481f578:	e8bd44f0 	pop	{r4, r5, r6, r7, sl, lr}
	NetArpWaitTxPacketSize = eth_hdr_size + IP_ICMP_HDR_SIZE;

	/* and do the ARP request */
	NetArpWaitTry = 1;
	NetArpWaitTimerStart = get_timer(0);
	ArpRequest();
3481f57c:	eafff44b 	b	3481c6b0 <ArpRequest>
3481f580:	3482e244 	.word	0x3482e244
3481f584:	34827f6c 	.word	0x34827f6c
3481f588:	3481f468 	.word	0x3481f468
3481f58c:	3482ba14 	.word	0x3482ba14
3481f590:	3482b35c 	.word	0x3482b35c
3481f594:	3482ba18 	.word	0x3482ba18
3481f598:	3482ba04 	.word	0x3482ba04
3481f59c:	3482b364 	.word	0x3482b364
3481f5a0:	3482b9b0 	.word	0x3482b9b0
3481f5a4:	3482b9ac 	.word	0x3482b9ac

3481f5a8 <ping_receive>:

	ping_send();
}

void ping_receive(struct ethernet_hdr *et, struct ip_udp_hdr *ip, int len)
{
3481f5a8:	e92d4ef3 	push	{r0, r1, r4, r5, r6, r7, r9, sl, fp, lr}
	struct icmp_hdr *icmph = (struct icmp_hdr *)&ip->udp_src;
	IPaddr_t src_ip;
	int eth_hdr_size;

	switch (icmph->type) {
3481f5ac:	e5d13014 	ldrb	r3, [r1, #20]

	ping_send();
}

void ping_receive(struct ethernet_hdr *et, struct ip_udp_hdr *ip, int len)
{
3481f5b0:	e1a07000 	mov	r7, r0
	struct icmp_hdr *icmph = (struct icmp_hdr *)&ip->udp_src;
	IPaddr_t src_ip;
	int eth_hdr_size;

	switch (icmph->type) {
3481f5b4:	e3530000 	cmp	r3, #0

	ping_send();
}

void ping_receive(struct ethernet_hdr *et, struct ip_udp_hdr *ip, int len)
{
3481f5b8:	e1a04001 	mov	r4, r1
3481f5bc:	e1a09002 	mov	r9, r2
	struct icmp_hdr *icmph = (struct icmp_hdr *)&ip->udp_src;
3481f5c0:	e2816014 	add	r6, r1, #20
	IPaddr_t src_ip;
	int eth_hdr_size;

	switch (icmph->type) {
3481f5c4:	0a000002 	beq	3481f5d4 <ping_receive+0x2c>
3481f5c8:	e3530008 	cmp	r3, #8
3481f5cc:	1a00002c 	bne	3481f684 <ping_receive+0xdc>
3481f5d0:	ea00000b 	b	3481f604 <ping_receive+0x5c>
/* return IP *in network byteorder* */
static inline IPaddr_t NetReadIP(void *from)
{
	IPaddr_t ip;

	memcpy((void *)&ip, (void *)from, sizeof(ip));
3481f5d4:	e3a02004 	mov	r2, #4
3481f5d8:	e28d0004 	add	r0, sp, #4
3481f5dc:	e281100c 	add	r1, r1, #12
3481f5e0:	ebffe62a 	bl	34818e90 <memcpy>
	case ICMP_ECHO_REPLY:
		src_ip = NetReadIP((void *)&ip->ip_src);
		if (src_ip == NetPingIP)
3481f5e4:	e59f309c 	ldr	r3, [pc, #156]	; 3481f688 <ping_receive+0xe0>
3481f5e8:	e59d2004 	ldr	r2, [sp, #4]
3481f5ec:	e5933000 	ldr	r3, [r3]
3481f5f0:	e1520003 	cmp	r2, r3
static inline void net_set_state(enum net_loop_state state)
{
	extern enum net_loop_state net_state;

	debug_cond(DEBUG_INT_STATE, "--- NetState set to %d\n", state);
	net_state = state;
3481f5f4:	059f3090 	ldreq	r3, [pc, #144]	; 3481f68c <ping_receive+0xe4>
3481f5f8:	03a02002 	moveq	r2, #2
3481f5fc:	05832000 	streq	r2, [r3]
3481f600:	ea00001f 	b	3481f684 <ping_receive+0xdc>
			net_set_state(NETLOOP_SUCCESS);
		return;
	case ICMP_ECHO_REQUEST:
		eth_hdr_size = net_update_ether(et, et->et_src, PROT_IP);
3481f604:	e2801006 	add	r1, r0, #6
3481f608:	e3a02b02 	mov	r2, #2048	; 0x800
3481f60c:	ebfffa25 	bl	3481dea8 <net_update_ether>

		debug_cond(DEBUG_DEV_PKT, "Got ICMP ECHO REQUEST, return "
			"%d bytes\n", eth_hdr_size + len);

		ip->ip_sum = 0;
3481f610:	e3a05000 	mov	r5, #0
		ip->ip_off = 0;
		NetCopyIP((void *)&ip->ip_dst, &ip->ip_src);
3481f614:	e284a00c 	add	sl, r4, #12
		src_ip = NetReadIP((void *)&ip->ip_src);
		if (src_ip == NetPingIP)
			net_set_state(NETLOOP_SUCCESS);
		return;
	case ICMP_ECHO_REQUEST:
		eth_hdr_size = net_update_ether(et, et->et_src, PROT_IP);
3481f618:	e1a0b000 	mov	fp, r0
}

/* copy IP */
static inline void NetCopyIP(void *to, void *from)
{
	memcpy((void *)to, from, sizeof(IPaddr_t));
3481f61c:	e1a0100a 	mov	r1, sl
3481f620:	e3a02004 	mov	r2, #4

		debug_cond(DEBUG_DEV_PKT, "Got ICMP ECHO REQUEST, return "
			"%d bytes\n", eth_hdr_size + len);

		ip->ip_sum = 0;
3481f624:	e1c450ba 	strh	r5, [r4, #10]
		ip->ip_off = 0;
3481f628:	e1c450b6 	strh	r5, [r4, #6]
3481f62c:	e2840010 	add	r0, r4, #16
3481f630:	ebffe616 	bl	34818e90 <memcpy>
3481f634:	e3a02004 	mov	r2, #4
3481f638:	e59f1050 	ldr	r1, [pc, #80]	; 3481f690 <ping_receive+0xe8>
3481f63c:	e1a0000a 	mov	r0, sl
3481f640:	ebffe612 	bl	34818e90 <memcpy>
		NetCopyIP((void *)&ip->ip_dst, &ip->ip_src);
		NetCopyIP((void *)&ip->ip_src, &NetOurIP);
		ip->ip_sum = ~NetCksum((uchar *)ip,
3481f644:	e3a0100a 	mov	r1, #10
3481f648:	e1a00004 	mov	r0, r4
3481f64c:	ebfff928 	bl	3481daf4 <NetCksum>
				       IP_HDR_SIZE >> 1);

		icmph->type = ICMP_ECHO_REPLY;
		icmph->checksum = 0;
		icmph->checksum = ~NetCksum((uchar *)icmph,
			(len - IP_HDR_SIZE) >> 1);
3481f650:	e2491014 	sub	r1, r9, #20

		ip->ip_sum = 0;
		ip->ip_off = 0;
		NetCopyIP((void *)&ip->ip_dst, &ip->ip_src);
		NetCopyIP((void *)&ip->ip_src, &NetOurIP);
		ip->ip_sum = ~NetCksum((uchar *)ip,
3481f654:	e1e00000 	mvn	r0, r0
3481f658:	e1c400ba 	strh	r0, [r4, #10]
				       IP_HDR_SIZE >> 1);

		icmph->type = ICMP_ECHO_REPLY;
		icmph->checksum = 0;
		icmph->checksum = ~NetCksum((uchar *)icmph,
3481f65c:	e1a010a1 	lsr	r1, r1, #1
		NetCopyIP((void *)&ip->ip_dst, &ip->ip_src);
		NetCopyIP((void *)&ip->ip_src, &NetOurIP);
		ip->ip_sum = ~NetCksum((uchar *)ip,
				       IP_HDR_SIZE >> 1);

		icmph->type = ICMP_ECHO_REPLY;
3481f660:	e5c45014 	strb	r5, [r4, #20]
		icmph->checksum = 0;
3481f664:	e1c650b2 	strh	r5, [r6, #2]
		icmph->checksum = ~NetCksum((uchar *)icmph,
3481f668:	e1a00006 	mov	r0, r6
3481f66c:	ebfff920 	bl	3481daf4 <NetCksum>
3481f670:	e1e00000 	mvn	r0, r0
3481f674:	e1c600b2 	strh	r0, [r6, #2]
}

/* Transmit a packet */
static inline void NetSendPacket(uchar *pkt, int len)
{
	(void) eth_send(pkt, len);
3481f678:	e08b1009 	add	r1, fp, r9
3481f67c:	e1a00007 	mov	r0, r7
3481f680:	ebfff7f0 	bl	3481d648 <eth_send>
		NetSendPacket((uchar *)et, eth_hdr_size + len);
		return;
/*	default:
		return;*/
	}
}
3481f684:	e8bd8efc 	pop	{r2, r3, r4, r5, r6, r7, r9, sl, fp, pc}
3481f688:	3482e244 	.word	0x3482e244
3481f68c:	3482b9d4 	.word	0x3482b9d4
3481f690:	3482ba04 	.word	0x3482ba04

3481f694 <TftpSend>:
#endif
	/*
	 *	We will always be sending some sort of packet, so
	 *	cobble together the packet headers now.
	 */
	pkt = NetTxPacket + NetEthHdrSize() + IP_UDP_HDR_SIZE;
3481f694:	e59f316c 	ldr	r3, [pc, #364]	; 3481f808 <TftpSend+0x174>
	net_set_state(NETLOOP_SUCCESS);
}

static void
TftpSend(void)
{
3481f698:	e92d4073 	push	{r0, r1, r4, r5, r6, lr}
#endif
	/*
	 *	We will always be sending some sort of packet, so
	 *	cobble together the packet headers now.
	 */
	pkt = NetTxPacket + NetEthHdrSize() + IP_UDP_HDR_SIZE;
3481f69c:	e5935000 	ldr	r5, [r3]
3481f6a0:	ebfff9c9 	bl	3481ddcc <NetEthHdrSize>

	switch (TftpState) {
3481f6a4:	e59f3160 	ldr	r3, [pc, #352]	; 3481f80c <TftpSend+0x178>
#endif
	/*
	 *	We will always be sending some sort of packet, so
	 *	cobble together the packet headers now.
	 */
	pkt = NetTxPacket + NetEthHdrSize() + IP_UDP_HDR_SIZE;
3481f6a8:	e280001c 	add	r0, r0, #28

	switch (TftpState) {
3481f6ac:	e5933000 	ldr	r3, [r3]
#endif
	/*
	 *	We will always be sending some sort of packet, so
	 *	cobble together the packet headers now.
	 */
	pkt = NetTxPacket + NetEthHdrSize() + IP_UDP_HDR_SIZE;
3481f6b0:	e0854000 	add	r4, r5, r0

	switch (TftpState) {
3481f6b4:	e2433001 	sub	r3, r3, #1
3481f6b8:	e3530006 	cmp	r3, #6
3481f6bc:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
3481f6c0:	ea000047 	b	3481f7e4 <TftpSend+0x150>
3481f6c4:	3481f6e0 	.word	0x3481f6e0
3481f6c8:	3481f778 	.word	0x3481f778
3481f6cc:	3481f79c 	.word	0x3481f79c
3481f6d0:	3481f7c0 	.word	0x3481f7c0
3481f6d4:	3481f778 	.word	0x3481f778
3481f6d8:	3481f778 	.word	0x3481f778
3481f6dc:	3481f6e0 	.word	0x3481f6e0
		s = (ushort *)pkt;
#ifdef CONFIG_CMD_TFTPPUT
		*s++ = htons(TftpState == STATE_SEND_RRQ ? TFTP_RRQ :
			TFTP_WRQ);
#else
		*s++ = htons(TFTP_RRQ);
3481f6e0:	e3a03c01 	mov	r3, #256	; 0x100
3481f6e4:	e18530b0 	strh	r3, [r5, r0]
3481f6e8:	e2845002 	add	r5, r4, #2
#endif
		pkt = (uchar *)s;
		strcpy((char *)pkt, tftp_filename);
3481f6ec:	e59f111c 	ldr	r1, [pc, #284]	; 3481f810 <TftpSend+0x17c>
3481f6f0:	e1a00005 	mov	r0, r5
3481f6f4:	ebffe4bc 	bl	348189ec <strcpy>
		pkt += strlen(tftp_filename) + 1;
3481f6f8:	e59f0110 	ldr	r0, [pc, #272]	; 3481f810 <TftpSend+0x17c>
3481f6fc:	ebffe51f 	bl	34818b80 <strlen>
3481f700:	e2800001 	add	r0, r0, #1
3481f704:	e0855000 	add	r5, r5, r0
		strcpy((char *)pkt, "octet");
3481f708:	e1a00005 	mov	r0, r5
3481f70c:	e59f1100 	ldr	r1, [pc, #256]	; 3481f814 <TftpSend+0x180>
		pkt += 5 /*strlen("octet")*/ + 1;
		strcpy((char *)pkt, "timeout");
		pkt += 7 /*strlen("timeout")*/ + 1;
		sprintf((char *)pkt, "%lu", TftpTimeoutMSecs / 1000);
3481f710:	e59f6100 	ldr	r6, [pc, #256]	; 3481f818 <TftpSend+0x184>
		*s++ = htons(TFTP_RRQ);
#endif
		pkt = (uchar *)s;
		strcpy((char *)pkt, tftp_filename);
		pkt += strlen(tftp_filename) + 1;
		strcpy((char *)pkt, "octet");
3481f714:	ebffe4b4 	bl	348189ec <strcpy>
		pkt += 5 /*strlen("octet")*/ + 1;
		strcpy((char *)pkt, "timeout");
3481f718:	e2850006 	add	r0, r5, #6
3481f71c:	e59f10f8 	ldr	r1, [pc, #248]	; 3481f81c <TftpSend+0x188>
3481f720:	ebffe4b1 	bl	348189ec <strcpy>
		pkt += 7 /*strlen("timeout")*/ + 1;
		sprintf((char *)pkt, "%lu", TftpTimeoutMSecs / 1000);
3481f724:	e5960000 	ldr	r0, [r6]
3481f728:	e3a01ffa 	mov	r1, #1000	; 0x3e8
3481f72c:	eb0001dc 	bl	3481fea4 <__udivsi3>
		strcpy((char *)pkt, tftp_filename);
		pkt += strlen(tftp_filename) + 1;
		strcpy((char *)pkt, "octet");
		pkt += 5 /*strlen("octet")*/ + 1;
		strcpy((char *)pkt, "timeout");
		pkt += 7 /*strlen("timeout")*/ + 1;
3481f730:	e285500e 	add	r5, r5, #14
		sprintf((char *)pkt, "%lu", TftpTimeoutMSecs / 1000);
3481f734:	e1a02000 	mov	r2, r0
3481f738:	e59f10e0 	ldr	r1, [pc, #224]	; 3481f820 <TftpSend+0x18c>
3481f73c:	e1a00005 	mov	r0, r5
3481f740:	ebffe9d2 	bl	34819e90 <sprintf>
		debug("send option \"timeout %s\"\n", (char *)pkt);
		pkt += strlen((char *)pkt) + 1;
3481f744:	e1a00005 	mov	r0, r5
3481f748:	ebffe50c 	bl	34818b80 <strlen>
3481f74c:	e2800001 	add	r0, r0, #1
3481f750:	e0855000 	add	r5, r5, r0
#ifdef CONFIG_TFTP_TSIZE
		pkt += sprintf((char *)pkt, "tsize%c%lu%c",
				0, NetBootFileXferSize, 0);
#endif
		/* try for more effic. blk size */
		pkt += sprintf((char *)pkt, "blksize%c%d%c",
3481f754:	e3a02000 	mov	r2, #0
3481f758:	e1a00005 	mov	r0, r5
3481f75c:	e1d630b4 	ldrh	r3, [r6, #4]
3481f760:	e59f10bc 	ldr	r1, [pc, #188]	; 3481f824 <TftpSend+0x190>
3481f764:	e58d2000 	str	r2, [sp]
3481f768:	ebffe9c8 	bl	34819e90 <sprintf>
3481f76c:	e0855000 	add	r5, r5, r0
				pkt += sprintf((char *)pkt, "multicast%c%c",
					0, 0);
			}
		}
#endif /* CONFIG_MCAST_TFTP */
		len = pkt - xp;
3481f770:	e0644005 	rsb	r4, r4, r5
		break;
3481f774:	ea00001b 	b	3481f7e8 <TftpSend+0x154>

	case STATE_RECV_WRQ:
	case STATE_DATA:
		xp = pkt;
		s = (ushort *)pkt;
		s[0] = htons(TFTP_ACK);
3481f778:	e3a03b01 	mov	r3, #1024	; 0x400
3481f77c:	e18530b0 	strh	r3, [r5, r0]
		s[1] = htons(TftpBlock);
3481f780:	e59f3084 	ldr	r3, [pc, #132]	; 3481f80c <TftpSend+0x178>
3481f784:	e1d338b4 	ldrh	r3, [r3, #132]	; 0x84
3481f788:	e1a02423 	lsr	r2, r3, #8
3481f78c:	e1823403 	orr	r3, r2, r3, lsl #8
3481f790:	e1c430b2 	strh	r3, [r4, #2]
			s[0] = htons(TFTP_DATA);
			pkt += loaded;
			TftpFinalBlock = (loaded < toload);
		}
#endif
		len = pkt - xp;
3481f794:	e3a04004 	mov	r4, #4
		break;
3481f798:	ea000012 	b	3481f7e8 <TftpSend+0x154>

	case STATE_TOO_LARGE:
		xp = pkt;
		s = (ushort *)pkt;
		*s++ = htons(TFTP_ERROR);
3481f79c:	e3a03c05 	mov	r3, #1280	; 0x500
3481f7a0:	e18530b0 	strh	r3, [r5, r0]
			*s++ = htons(3);
3481f7a4:	e3a03c03 	mov	r3, #768	; 0x300
3481f7a8:	e1c430b2 	strh	r3, [r4, #2]

		pkt = (uchar *)s;
		strcpy((char *)pkt, "File too large");
3481f7ac:	e2840004 	add	r0, r4, #4
3481f7b0:	e59f1070 	ldr	r1, [pc, #112]	; 3481f828 <TftpSend+0x194>
3481f7b4:	ebffe48c 	bl	348189ec <strcpy>
		pkt += 14 /*strlen("File too large")*/ + 1;
		len = pkt - xp;
3481f7b8:	e3a04013 	mov	r4, #19
		break;
3481f7bc:	ea000009 	b	3481f7e8 <TftpSend+0x154>

	case STATE_BAD_MAGIC:
		xp = pkt;
		s = (ushort *)pkt;
		*s++ = htons(TFTP_ERROR);
3481f7c0:	e3a03c05 	mov	r3, #1280	; 0x500
3481f7c4:	e18530b0 	strh	r3, [r5, r0]
		*s++ = htons(2);
3481f7c8:	e3a03c02 	mov	r3, #512	; 0x200
3481f7cc:	e1c430b2 	strh	r3, [r4, #2]
		pkt = (uchar *)s;
		strcpy((char *)pkt, "File has bad magic");
3481f7d0:	e2840004 	add	r0, r4, #4
3481f7d4:	e59f1050 	ldr	r1, [pc, #80]	; 3481f82c <TftpSend+0x198>
3481f7d8:	ebffe483 	bl	348189ec <strcpy>
		pkt += 18 /*strlen("File has bad magic")*/ + 1;
		len = pkt - xp;
3481f7dc:	e3a04017 	mov	r4, #23
		break;
3481f7e0:	ea000000 	b	3481f7e8 <TftpSend+0x154>
static void
TftpSend(void)
{
	uchar *pkt;
	uchar *xp;
	int len = 0;
3481f7e4:	e3a04000 	mov	r4, #0
		pkt += 18 /*strlen("File has bad magic")*/ + 1;
		len = pkt - xp;
		break;
	}

	NetSendUDPPacket(NetServerEther, TftpRemoteIP, TftpRemotePort,
3481f7e8:	e59f301c 	ldr	r3, [pc, #28]	; 3481f80c <TftpSend+0x178>
3481f7ec:	e58d4000 	str	r4, [sp]
3481f7f0:	e5931088 	ldr	r1, [r3, #136]	; 0x88
3481f7f4:	e593208c 	ldr	r2, [r3, #140]	; 0x8c
3481f7f8:	e59f0030 	ldr	r0, [pc, #48]	; 3481f830 <TftpSend+0x19c>
3481f7fc:	e5933090 	ldr	r3, [r3, #144]	; 0x90
3481f800:	ebfffa16 	bl	3481e060 <NetSendUDPPacket>
			 TftpOurPort, len);
}
3481f804:	e8bd807c 	pop	{r2, r3, r4, r5, r6, pc}
3481f808:	3482ba14 	.word	0x3482ba14
3481f80c:	3482e24c 	.word	0x3482e24c
3481f810:	3482e250 	.word	0x3482e250
3481f814:	34828026 	.word	0x34828026
3481f818:	34828bb4 	.word	0x34828bb4
3481f81c:	34828108 	.word	0x34828108
3481f820:	348276d5 	.word	0x348276d5
3481f824:	3482802c 	.word	0x3482802c
3481f828:	3482803a 	.word	0x3482803a
3481f82c:	34828049 	.word	0x34828049
3481f830:	3482d90c 	.word	0x3482d90c

3481f834 <TftpTimeout>:
}


static void
TftpTimeout(void)
{
3481f834:	e92d4070 	push	{r4, r5, r6, lr}
	if (++TftpTimeoutCount > TftpTimeoutCountMax) {
3481f838:	e59f4054 	ldr	r4, [pc, #84]	; 3481f894 <TftpTimeout+0x60>
3481f83c:	e59f5054 	ldr	r5, [pc, #84]	; 3481f898 <TftpTimeout+0x64>
3481f840:	e5943094 	ldr	r3, [r4, #148]	; 0x94
3481f844:	e5952008 	ldr	r2, [r5, #8]
3481f848:	e2833001 	add	r3, r3, #1
3481f84c:	e1530002 	cmp	r3, r2
3481f850:	e5843094 	str	r3, [r4, #148]	; 0x94
3481f854:	da000004 	ble	3481f86c <TftpTimeout+0x38>
 *
 * @param msg	Message to print for user
 */
static void restart(const char *msg)
{
	printf("\n%s; starting again\n", msg);
3481f858:	e59f103c 	ldr	r1, [pc, #60]	; 3481f89c <TftpTimeout+0x68>
3481f85c:	e59f003c 	ldr	r0, [pc, #60]	; 3481f8a0 <TftpTimeout+0x6c>
3481f860:	ebffa5b9 	bl	34808f4c <printf>
		puts("T ");
		NetSetTimeout(TftpTimeoutMSecs, TftpTimeout);
		if (TftpState != STATE_RECV_WRQ)
			TftpSend();
	}
}
3481f864:	e8bd4070 	pop	{r4, r5, r6, lr}
{
	printf("\n%s; starting again\n", msg);
#ifdef CONFIG_MCAST_TFTP
	mcast_cleanup();
#endif
	NetStartAgain();
3481f868:	eafff855 	b	3481d9c4 <NetStartAgain>
TftpTimeout(void)
{
	if (++TftpTimeoutCount > TftpTimeoutCountMax) {
		restart("Retry count exceeded");
	} else {
		puts("T ");
3481f86c:	e59f0030 	ldr	r0, [pc, #48]	; 3481f8a4 <TftpTimeout+0x70>
3481f870:	ebffa5ab 	bl	34808f24 <puts>
		NetSetTimeout(TftpTimeoutMSecs, TftpTimeout);
3481f874:	e5950000 	ldr	r0, [r5]
3481f878:	e59f1028 	ldr	r1, [pc, #40]	; 3481f8a8 <TftpTimeout+0x74>
3481f87c:	ebfff841 	bl	3481d988 <NetSetTimeout>
		if (TftpState != STATE_RECV_WRQ)
3481f880:	e5943000 	ldr	r3, [r4]
3481f884:	e3530006 	cmp	r3, #6
3481f888:	08bd8070 	popeq	{r4, r5, r6, pc}
			TftpSend();
	}
}
3481f88c:	e8bd4070 	pop	{r4, r5, r6, lr}
		restart("Retry count exceeded");
	} else {
		puts("T ");
		NetSetTimeout(TftpTimeoutMSecs, TftpTimeout);
		if (TftpState != STATE_RECV_WRQ)
			TftpSend();
3481f890:	eaffff7f 	b	3481f694 <TftpSend>
3481f894:	3482e24c 	.word	0x3482e24c
3481f898:	34828bb4 	.word	0x34828bb4
3481f89c:	34828071 	.word	0x34828071
3481f8a0:	3482805c 	.word	0x3482805c
3481f8a4:	34827ea9 	.word	0x34827ea9
3481f8a8:	3481f834 	.word	0x3481f834

3481f8ac <TftpHandler>:
#endif

static void
TftpHandler(uchar *pkt, unsigned dest, IPaddr_t sip, unsigned src,
	    unsigned len)
{
3481f8ac:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
3481f8b0:	e1a06003 	mov	r6, r3
	ushort proto;
	ushort *s;
	int i;

	if (dest != TftpOurPort) {
3481f8b4:	e59f32ac 	ldr	r3, [pc, #684]	; 3481fb68 <TftpHandler+0x2bc>
#endif

static void
TftpHandler(uchar *pkt, unsigned dest, IPaddr_t sip, unsigned src,
	    unsigned len)
{
3481f8b8:	e1a04000 	mov	r4, r0
	ushort proto;
	ushort *s;
	int i;

	if (dest != TftpOurPort) {
3481f8bc:	e5932090 	ldr	r2, [r3, #144]	; 0x90
#endif

static void
TftpHandler(uchar *pkt, unsigned dest, IPaddr_t sip, unsigned src,
	    unsigned len)
{
3481f8c0:	e59d5018 	ldr	r5, [sp, #24]
	ushort proto;
	ushort *s;
	int i;

	if (dest != TftpOurPort) {
3481f8c4:	e1510002 	cmp	r1, r2
3481f8c8:	18bd81f0 	popne	{r4, r5, r6, r7, r8, pc}
		if (Multicast
		 && (!Mcast_port || (dest != Mcast_port)))
#endif
			return;
	}
	if (TftpState != STATE_SEND_RRQ && src != TftpRemotePort &&
3481f8cc:	e5932000 	ldr	r2, [r3]
3481f8d0:	e3520001 	cmp	r2, #1
3481f8d4:	0a000006 	beq	3481f8f4 <TftpHandler+0x48>
3481f8d8:	e593308c 	ldr	r3, [r3, #140]	; 0x8c
3481f8dc:	e1560003 	cmp	r6, r3
3481f8e0:	0a000003 	beq	3481f8f4 <TftpHandler+0x48>
3481f8e4:	e3520006 	cmp	r2, #6
3481f8e8:	0a000001 	beq	3481f8f4 <TftpHandler+0x48>
	    TftpState != STATE_RECV_WRQ && TftpState != STATE_SEND_WRQ)
3481f8ec:	e3520007 	cmp	r2, #7
3481f8f0:	18bd81f0 	popne	{r4, r5, r6, r7, r8, pc}
		return;

	if (len < 2)
3481f8f4:	e3550001 	cmp	r5, #1
3481f8f8:	98bd81f0 	popls	{r4, r5, r6, r7, r8, pc}
		return;
	len -= 2;
	/* warning: don't use increment (++) in ntohs() macros!! */
	s = (ushort *)pkt;
	proto = *s++;
3481f8fc:	e1a07004 	mov	r7, r4
3481f900:	e0d730b2 	ldrh	r3, [r7], #2
	    TftpState != STATE_RECV_WRQ && TftpState != STATE_SEND_WRQ)
		return;

	if (len < 2)
		return;
	len -= 2;
3481f904:	e2455002 	sub	r5, r5, #2
3481f908:	e1a02423 	lsr	r2, r3, #8
3481f90c:	e1823403 	orr	r3, r2, r3, lsl #8
	/* warning: don't use increment (++) in ntohs() macros!! */
	s = (ushort *)pkt;
	proto = *s++;
	pkt = (uchar *)s;
	switch (ntohs(proto)) {
3481f910:	e6ff3073 	uxth	r3, r3
3481f914:	e3530005 	cmp	r3, #5
3481f918:	0a000079 	beq	3481fb04 <TftpHandler+0x258>
3481f91c:	e3530006 	cmp	r3, #6
3481f920:	0a000002 	beq	3481f930 <TftpHandler+0x84>
3481f924:	e3530003 	cmp	r3, #3
3481f928:	18bd81f0 	popne	{r4, r5, r6, r7, r8, pc}
3481f92c:	ea000016 	b	3481f98c <TftpHandler+0xe0>

	case TFTP_OACK:
		debug("Got OACK: %s %s\n",
			pkt,
			pkt + strlen((char *)pkt) + 1);
		TftpState = STATE_OACK;
3481f930:	e59f3230 	ldr	r3, [pc, #560]	; 3481fb68 <TftpHandler+0x2bc>
3481f934:	e3a02005 	mov	r2, #5
		TftpRemotePort = src;
3481f938:	e583608c 	str	r6, [r3, #140]	; 0x8c
	}
}
#endif

static void
TftpHandler(uchar *pkt, unsigned dest, IPaddr_t sip, unsigned src,
3481f93c:	e1a04007 	mov	r4, r7

	case TFTP_OACK:
		debug("Got OACK: %s %s\n",
			pkt,
			pkt + strlen((char *)pkt) + 1);
		TftpState = STATE_OACK;
3481f940:	e5832000 	str	r2, [r3]
		/*
		 * Check for 'blksize' option.
		 * Careful: "i" is signed, "len" is unsigned, thus
		 * something like "len-8" may give a *huge* number
		 */
		for (i = 0; i+8 < len; i++) {
3481f944:	e3a06008 	mov	r6, #8
			if (strcmp((char *)pkt+i, "blksize") == 0) {
				TftpBlkSize = (unsigned short)
3481f948:	e59f721c 	ldr	r7, [pc, #540]	; 3481fb6c <TftpHandler+0x2c0>
		/*
		 * Check for 'blksize' option.
		 * Careful: "i" is signed, "len" is unsigned, thus
		 * something like "len-8" may give a *huge* number
		 */
		for (i = 0; i+8 < len; i++) {
3481f94c:	ea00000a 	b	3481f97c <TftpHandler+0xd0>
			if (strcmp((char *)pkt+i, "blksize") == 0) {
3481f950:	e59f1218 	ldr	r1, [pc, #536]	; 3481fb70 <TftpHandler+0x2c4>
3481f954:	e1a00004 	mov	r0, r4
3481f958:	ebffe454 	bl	34818ab0 <strcmp>
3481f95c:	e2501000 	subs	r1, r0, #0
3481f960:	1a000003 	bne	3481f974 <TftpHandler+0xc8>
				TftpBlkSize = (unsigned short)
					simple_strtoul((char *)pkt+i+8, NULL,
3481f964:	e2840008 	add	r0, r4, #8
3481f968:	e3a0200a 	mov	r2, #10
3481f96c:	ebffe8a1 	bl	34819bf8 <simple_strtoul>
		 * Careful: "i" is signed, "len" is unsigned, thus
		 * something like "len-8" may give a *huge* number
		 */
		for (i = 0; i+8 < len; i++) {
			if (strcmp((char *)pkt+i, "blksize") == 0) {
				TftpBlkSize = (unsigned short)
3481f970:	e1c700bc 	strh	r0, [r7, #12]
3481f974:	e2866001 	add	r6, r6, #1
3481f978:	e2844001 	add	r4, r4, #1
		/*
		 * Check for 'blksize' option.
		 * Careful: "i" is signed, "len" is unsigned, thus
		 * something like "len-8" may give a *huge* number
		 */
		for (i = 0; i+8 < len; i++) {
3481f97c:	e1560005 	cmp	r6, r5
3481f980:	3afffff2 	bcc	3481f950 <TftpHandler+0xa4>
			NetStartAgain();
			break;
		}
		break;
	}
}
3481f984:	e8bd41f0 	pop	{r4, r5, r6, r7, r8, lr}
			/* Get ready to send the first block */
			TftpState = STATE_DATA;
			TftpBlock++;
		}
#endif
		TftpSend(); /* Send ACK or first data block */
3481f988:	eaffff41 	b	3481f694 <TftpSend>
		break;
	case TFTP_DATA:
		if (len < 2)
3481f98c:	e3550001 	cmp	r5, #1
3481f990:	98bd81f0 	popls	{r4, r5, r6, r7, r8, pc}
			return;
		len -= 2;
		TftpBlock = ntohs(*(ushort *)pkt);
3481f994:	e1d430b2 	ldrh	r3, [r4, #2]
3481f998:	e1a04423 	lsr	r4, r3, #8
3481f99c:	e1844403 	orr	r4, r4, r3, lsl #8
3481f9a0:	e6ff4074 	uxth	r4, r4
3481f9a4:	e59f31bc 	ldr	r3, [pc, #444]	; 3481fb68 <TftpHandler+0x2bc>
	 * RFC1350 specifies that the first data packet will
	 * have sequence number 1. If we receive a sequence
	 * number of 0 this means that there was a wrap
	 * around of the (16 bit) counter.
	 */
	if (TftpBlock == 0) {
3481f9a8:	e3540000 	cmp	r4, #0
		break;
	case TFTP_DATA:
		if (len < 2)
			return;
		len -= 2;
		TftpBlock = ntohs(*(ushort *)pkt);
3481f9ac:	e5834084 	str	r4, [r3, #132]	; 0x84
	 * RFC1350 specifies that the first data packet will
	 * have sequence number 1. If we receive a sequence
	 * number of 0 this means that there was a wrap
	 * around of the (16 bit) counter.
	 */
	if (TftpBlock == 0) {
3481f9b0:	1a000009 	bne	3481f9dc <TftpHandler+0x130>
		TftpBlockWrap++;
3481f9b4:	e5932098 	ldr	r2, [r3, #152]	; 0x98
		TftpBlockWrapOffset += TftpBlkSize * TFTP_SEQUENCE_SIZE;
		TftpTimeoutCount = 0; /* we've done well, reset thhe timeout */
3481f9b8:	e5834094 	str	r4, [r3, #148]	; 0x94
	 * have sequence number 1. If we receive a sequence
	 * number of 0 this means that there was a wrap
	 * around of the (16 bit) counter.
	 */
	if (TftpBlock == 0) {
		TftpBlockWrap++;
3481f9bc:	e2822001 	add	r2, r2, #1
3481f9c0:	e5832098 	str	r2, [r3, #152]	; 0x98
		TftpBlockWrapOffset += TftpBlkSize * TFTP_SEQUENCE_SIZE;
3481f9c4:	e59f21a0 	ldr	r2, [pc, #416]	; 3481fb6c <TftpHandler+0x2c0>
3481f9c8:	e1d210bc 	ldrh	r1, [r2, #12]
3481f9cc:	e593209c 	ldr	r2, [r3, #156]	; 0x9c
3481f9d0:	e0822801 	add	r2, r2, r1, lsl #16
3481f9d4:	e583209c 	str	r2, [r3, #156]	; 0x9c
3481f9d8:	ea00000e 	b	3481fa18 <TftpHandler+0x16c>
			TftpNumchars++;
		}
	} else
#endif
	{
		if (((TftpBlock - 1) % 10) == 0)
3481f9dc:	e2440001 	sub	r0, r4, #1
3481f9e0:	e3a0100a 	mov	r1, #10
3481f9e4:	eb0001a9 	bl	34820090 <__aeabi_uidivmod>
3481f9e8:	e3510000 	cmp	r1, #0
3481f9ec:	1a000002 	bne	3481f9fc <TftpHandler+0x150>
			putc('#');
3481f9f0:	e3a00023 	mov	r0, #35	; 0x23
3481f9f4:	ebffa540 	bl	34808efc <putc>
3481f9f8:	ea000006 	b	3481fa18 <TftpHandler+0x16c>
		else if ((TftpBlock % (10 * HASHES_PER_LINE)) == 0)
3481f9fc:	e1a00004 	mov	r0, r4
3481fa00:	e300128a 	movw	r1, #650	; 0x28a
3481fa04:	eb0001a1 	bl	34820090 <__aeabi_uidivmod>
3481fa08:	e3510000 	cmp	r1, #0
3481fa0c:	1a000001 	bne	3481fa18 <TftpHandler+0x16c>
			puts("\n\t ");
3481fa10:	e59f015c 	ldr	r0, [pc, #348]	; 3481fb74 <TftpHandler+0x2c8>
3481fa14:	ebffa542 	bl	34808f24 <puts>
		update_block_number();

		if (TftpState == STATE_SEND_RRQ)
			debug("Server did not acknowledge timeout option!\n");

		if (TftpState == STATE_SEND_RRQ || TftpState == STATE_OACK ||
3481fa18:	e59f3148 	ldr	r3, [pc, #328]	; 3481fb68 <TftpHandler+0x2bc>
3481fa1c:	e5933000 	ldr	r3, [r3]
3481fa20:	e3530001 	cmp	r3, #1
3481fa24:	13530005 	cmpne	r3, #5
3481fa28:	0a000001 	beq	3481fa34 <TftpHandler+0x188>
3481fa2c:	e3530006 	cmp	r3, #6
3481fa30:	1a00000d 	bne	3481fa6c <TftpHandler+0x1c0>
		    TftpState == STATE_RECV_WRQ) {
			/* first block received */
			TftpState = STATE_DATA;
3481fa34:	e59f312c 	ldr	r3, [pc, #300]	; 3481fb68 <TftpHandler+0x2bc>
3481fa38:	e3a02002 	mov	r2, #2
#ifdef CONFIG_MCAST_TFTP
			if (Multicast) { /* start!=1 common if mcast */
				TftpLastBlock = TftpBlock - 1;
			} else
#endif
			if (TftpBlock != 1) {	/* Assertion */
3481fa3c:	e5931084 	ldr	r1, [r3, #132]	; 0x84
			debug("Server did not acknowledge timeout option!\n");

		if (TftpState == STATE_SEND_RRQ || TftpState == STATE_OACK ||
		    TftpState == STATE_RECV_WRQ) {
			/* first block received */
			TftpState = STATE_DATA;
3481fa40:	e5832000 	str	r2, [r3]
#ifdef CONFIG_MCAST_TFTP
			if (Multicast) { /* start!=1 common if mcast */
				TftpLastBlock = TftpBlock - 1;
			} else
#endif
			if (TftpBlock != 1) {	/* Assertion */
3481fa44:	e3510001 	cmp	r1, #1
}

/* Clear our state ready for a new transfer */
static void new_transfer(void)
{
	TftpLastBlock = 0;
3481fa48:	e3a02000 	mov	r2, #0

		if (TftpState == STATE_SEND_RRQ || TftpState == STATE_OACK ||
		    TftpState == STATE_RECV_WRQ) {
			/* first block received */
			TftpState = STATE_DATA;
			TftpRemotePort = src;
3481fa4c:	e583608c 	str	r6, [r3, #140]	; 0x8c
}

/* Clear our state ready for a new transfer */
static void new_transfer(void)
{
	TftpLastBlock = 0;
3481fa50:	e58320a0 	str	r2, [r3, #160]	; 0xa0
	TftpBlockWrap = 0;
3481fa54:	e5832098 	str	r2, [r3, #152]	; 0x98
	TftpBlockWrapOffset = 0;
3481fa58:	e583209c 	str	r2, [r3, #156]	; 0x9c
#ifdef CONFIG_MCAST_TFTP
			if (Multicast) { /* start!=1 common if mcast */
				TftpLastBlock = TftpBlock - 1;
			} else
#endif
			if (TftpBlock != 1) {	/* Assertion */
3481fa5c:	0a000002 	beq	3481fa6c <TftpHandler+0x1c0>
				printf("\nTFTP error: "
3481fa60:	e59f0110 	ldr	r0, [pc, #272]	; 3481fb78 <TftpHandler+0x2cc>
3481fa64:	ebffa538 	bl	34808f4c <printf>
3481fa68:	ea00003c 	b	3481fb60 <TftpHandler+0x2b4>
				NetStartAgain();
				break;
			}
		}

		if (TftpBlock == TftpLastBlock) {
3481fa6c:	e59f40f4 	ldr	r4, [pc, #244]	; 3481fb68 <TftpHandler+0x2bc>
3481fa70:	e5943084 	ldr	r3, [r4, #132]	; 0x84
3481fa74:	e59420a0 	ldr	r2, [r4, #160]	; 0xa0
3481fa78:	e1530002 	cmp	r3, r2
3481fa7c:	08bd81f0 	popeq	{r4, r5, r6, r7, r8, pc}
			 */
			break;
		}

		TftpLastBlock = TftpBlock;
		TftpTimeoutCountMax = TIMEOUT_COUNT;
3481fa80:	e59f60e4 	ldr	r6, [pc, #228]	; 3481fb6c <TftpHandler+0x2c0>
			 *	Same block again; ignore it.
			 */
			break;
		}

		TftpLastBlock = TftpBlock;
3481fa84:	e58430a0 	str	r3, [r4, #160]	; 0xa0
		TftpTimeoutCountMax = TIMEOUT_COUNT;
3481fa88:	e3a0300a 	mov	r3, #10
3481fa8c:	e5863008 	str	r3, [r6, #8]
		NetSetTimeout(TftpTimeoutMSecs, TftpTimeout);
3481fa90:	e5960000 	ldr	r0, [r6]
3481fa94:	e59f10e0 	ldr	r1, [pc, #224]	; 3481fb7c <TftpHandler+0x2d0>
3481fa98:	ebfff7ba 	bl	3481d988 <NetSetTimeout>

		store_block(TftpBlock - 1, pkt + 2, len);
3481fa9c:	e5943084 	ldr	r3, [r4, #132]	; 0x84
#endif	/* CONFIG_MCAST_TFTP */

static inline void
store_block(int block, uchar *src, unsigned len)
{
	ulong offset = block * TftpBlkSize + TftpBlockWrapOffset;
3481faa0:	e1d610bc 	ldrh	r1, [r6, #12]
3481faa4:	e594209c 	ldr	r2, [r4, #156]	; 0x9c

		TftpLastBlock = TftpBlock;
		TftpTimeoutCountMax = TIMEOUT_COUNT;
		NetSetTimeout(TftpTimeoutMSecs, TftpTimeout);

		store_block(TftpBlock - 1, pkt + 2, len);
3481faa8:	e2433001 	sub	r3, r3, #1
#endif	/* CONFIG_MCAST_TFTP */

static inline void
store_block(int block, uchar *src, unsigned len)
{
	ulong offset = block * TftpBlkSize + TftpBlockWrapOffset;
3481faac:	e0232391 	mla	r3, r1, r3, r2
			return;
		}
	} else
#endif /* CONFIG_SYS_DIRECT_FLASH_TFTP */
	{
		(void)memcpy((void *)(load_addr + offset), src, len);
3481fab0:	e59f20c8 	ldr	r2, [pc, #200]	; 3481fb80 <TftpHandler+0x2d4>
		TftpSend(); /* Send ACK or first data block */
		break;
	case TFTP_DATA:
		if (len < 2)
			return;
		len -= 2;
3481fab4:	e2455002 	sub	r5, r5, #2
			return;
		}
	} else
#endif /* CONFIG_SYS_DIRECT_FLASH_TFTP */
	{
		(void)memcpy((void *)(load_addr + offset), src, len);
3481fab8:	e5920000 	ldr	r0, [r2]
3481fabc:	e2871002 	add	r1, r7, #2
3481fac0:	e0830000 	add	r0, r3, r0
3481fac4:	e1a02005 	mov	r2, r5

static inline void
store_block(int block, uchar *src, unsigned len)
{
	ulong offset = block * TftpBlkSize + TftpBlockWrapOffset;
	ulong newsize = offset + len;
3481fac8:	e0856003 	add	r6, r5, r3
			return;
		}
	} else
#endif /* CONFIG_SYS_DIRECT_FLASH_TFTP */
	{
		(void)memcpy((void *)(load_addr + offset), src, len);
3481facc:	ebffe4ef 	bl	34818e90 <memcpy>
#ifdef CONFIG_MCAST_TFTP
	if (Multicast)
		ext2_set_bit(block, Bitmap);
#endif

	if (NetBootFileXferSize < newsize)
3481fad0:	e59f30ac 	ldr	r3, [pc, #172]	; 3481fb84 <TftpHandler+0x2d8>
3481fad4:	e5932000 	ldr	r2, [r3]
3481fad8:	e1520006 	cmp	r2, r6
		NetBootFileXferSize = newsize;
3481fadc:	35836000 	strcc	r6, [r3]
				}
				TftpLastBlock = TftpBlock;
			}
		}
#endif
		TftpSend();
3481fae0:	ebfffeeb 	bl	3481f694 <TftpSend>
				mcast_cleanup();
				net_set_state(NETLOOP_SUCCESS);
			}
		} else
#endif
		if (len < TftpBlkSize)
3481fae4:	e59f3080 	ldr	r3, [pc, #128]	; 3481fb6c <TftpHandler+0x2c0>
3481fae8:	e1d330bc 	ldrh	r3, [r3, #12]
3481faec:	e1550003 	cmp	r5, r3
3481faf0:	28bd81f0 	popcs	{r4, r5, r6, r7, r8, pc}
	while (TftpTsize && TftpNumchars < 49) {
		putc('#');
		TftpNumchars++;
	}
#endif
	puts("\ndone\n");
3481faf4:	e59f008c 	ldr	r0, [pc, #140]	; 3481fb88 <TftpHandler+0x2dc>
3481faf8:	ebffa509 	bl	34808f24 <puts>
static inline void net_set_state(enum net_loop_state state)
{
	extern enum net_loop_state net_state;

	debug_cond(DEBUG_INT_STATE, "--- NetState set to %d\n", state);
	net_state = state;
3481fafc:	e3a02002 	mov	r2, #2
3481fb00:	ea000011 	b	3481fb4c <TftpHandler+0x2a0>
			tftp_complete();
		break;

	case TFTP_ERROR:
		printf("\nTFTP error: '%s' (%d)\n",
		       pkt + 2, ntohs(*(ushort *)pkt));
3481fb04:	e1d430b2 	ldrh	r3, [r4, #2]
		if (len < TftpBlkSize)
			tftp_complete();
		break;

	case TFTP_ERROR:
		printf("\nTFTP error: '%s' (%d)\n",
3481fb08:	e59f007c 	ldr	r0, [pc, #124]	; 3481fb8c <TftpHandler+0x2e0>
3481fb0c:	e1a02423 	lsr	r2, r3, #8
3481fb10:	e1822403 	orr	r2, r2, r3, lsl #8
3481fb14:	e6ff2072 	uxth	r2, r2
3481fb18:	e2871002 	add	r1, r7, #2
3481fb1c:	ebffa50a 	bl	34808f4c <printf>
		       pkt + 2, ntohs(*(ushort *)pkt));

		switch (ntohs(*(ushort *)pkt)) {
3481fb20:	e1d430b2 	ldrh	r3, [r4, #2]
3481fb24:	e1a02423 	lsr	r2, r3, #8
3481fb28:	e1823403 	orr	r3, r2, r3, lsl #8
3481fb2c:	e6ff3073 	uxth	r3, r3
3481fb30:	e2433001 	sub	r3, r3, #1
3481fb34:	e3530001 	cmp	r3, #1
3481fb38:	8a000006 	bhi	3481fb58 <TftpHandler+0x2ac>
		case TFTP_ERR_FILE_NOT_FOUND:
		case TFTP_ERR_ACCESS_DENIED:
			puts("Not retrying...\n");
3481fb3c:	e59f004c 	ldr	r0, [pc, #76]	; 3481fb90 <TftpHandler+0x2e4>
3481fb40:	ebffa4f7 	bl	34808f24 <puts>
			eth_halt();
3481fb44:	ebfff6b3 	bl	3481d618 <eth_halt>
3481fb48:	e3a02003 	mov	r2, #3
3481fb4c:	e59f3040 	ldr	r3, [pc, #64]	; 3481fb94 <TftpHandler+0x2e8>
3481fb50:	e5832000 	str	r2, [r3]
3481fb54:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
		case TFTP_ERR_DISK_FULL:
		case TFTP_ERR_UNEXPECTED_OPCODE:
		case TFTP_ERR_UNKNOWN_TRANSFER_ID:
		case TFTP_ERR_FILE_ALREADY_EXISTS:
		default:
			puts("Starting again\n\n");
3481fb58:	e59f0038 	ldr	r0, [pc, #56]	; 3481fb98 <TftpHandler+0x2ec>
3481fb5c:	ebffa4f0 	bl	34808f24 <puts>
			NetStartAgain();
			break;
		}
		break;
	}
}
3481fb60:	e8bd41f0 	pop	{r4, r5, r6, r7, r8, lr}
		default:
			puts("Starting again\n\n");
#ifdef CONFIG_MCAST_TFTP
			mcast_cleanup();
#endif
			NetStartAgain();
3481fb64:	eafff796 	b	3481d9c4 <NetStartAgain>
3481fb68:	3482e24c 	.word	0x3482e24c
3481fb6c:	34828bb4 	.word	0x34828bb4
3481fb70:	34828086 	.word	0x34828086
3481fb74:	34827f1e 	.word	0x34827f1e
3481fb78:	3482808e 	.word	0x3482808e
3481fb7c:	3481f834 	.word	0x3481f834
3481fb80:	348283c4 	.word	0x348283c4
3481fb84:	3482d880 	.word	0x3482d880
3481fb88:	34827ec5 	.word	0x34827ec5
3481fb8c:	348280cd 	.word	0x348280cd
3481fb90:	348280e5 	.word	0x348280e5
3481fb94:	3482b9d4 	.word	0x3482b9d4
3481fb98:	348280bc 	.word	0x348280bc

3481fb9c <TftpStart>:
	}
}


void TftpStart(enum proto_t protocol)
{
3481fb9c:	e92d4073 	push	{r0, r1, r4, r5, r6, lr}

	/*
	 * Allow the user to choose TFTP blocksize and timeout.
	 * TFTP protocol has a minimal timeout of 1 second.
	 */
	ep = getenv("tftpblocksize");
3481fba0:	e59f026c 	ldr	r0, [pc, #620]	; 3481fe14 <TftpStart+0x278>
3481fba4:	ebffa1a4 	bl	3480823c <getenv>
	if (ep != NULL)
3481fba8:	e3500000 	cmp	r0, #0
3481fbac:	0a000004 	beq	3481fbc4 <TftpStart+0x28>
		TftpBlkSizeOption = simple_strtol(ep, NULL, 10);
3481fbb0:	e3a01000 	mov	r1, #0
3481fbb4:	e3a0200a 	mov	r2, #10
3481fbb8:	ebffe857 	bl	34819d1c <simple_strtol>
3481fbbc:	e59f3254 	ldr	r3, [pc, #596]	; 3481fe18 <TftpStart+0x27c>
3481fbc0:	e1c300b4 	strh	r0, [r3, #4]

	ep = getenv("tftptimeout");
3481fbc4:	e59f0250 	ldr	r0, [pc, #592]	; 3481fe1c <TftpStart+0x280>
3481fbc8:	ebffa19b 	bl	3480823c <getenv>
	if (ep != NULL)
3481fbcc:	e3500000 	cmp	r0, #0
3481fbd0:	0a000004 	beq	3481fbe8 <TftpStart+0x4c>
		TftpTimeoutMSecs = simple_strtol(ep, NULL, 10);
3481fbd4:	e3a01000 	mov	r1, #0
3481fbd8:	e3a0200a 	mov	r2, #10
3481fbdc:	ebffe84e 	bl	34819d1c <simple_strtol>
3481fbe0:	e59f3230 	ldr	r3, [pc, #560]	; 3481fe18 <TftpStart+0x27c>
3481fbe4:	e5830000 	str	r0, [r3]

	if (TftpTimeoutMSecs < 1000) {
3481fbe8:	e59f4228 	ldr	r4, [pc, #552]	; 3481fe18 <TftpStart+0x27c>
3481fbec:	e5941000 	ldr	r1, [r4]
3481fbf0:	e3510ffa 	cmp	r1, #1000	; 0x3e8
3481fbf4:	2a000003 	bcs	3481fc08 <TftpStart+0x6c>
		printf("TFTP timeout (%ld ms) too low, "
3481fbf8:	e59f0220 	ldr	r0, [pc, #544]	; 3481fe20 <TftpStart+0x284>
3481fbfc:	ebffa4d2 	bl	34808f4c <printf>
			"set minimum = 1000 ms\n",
			TftpTimeoutMSecs);
		TftpTimeoutMSecs = 1000;
3481fc00:	e3a03ffa 	mov	r3, #1000	; 0x3e8
3481fc04:	e5843000 	str	r3, [r4]

	debug("TFTP blocksize = %i, timeout = %ld ms\n",
		TftpBlkSizeOption, TftpTimeoutMSecs);

	TftpRemoteIP = NetServerIP;
	if (BootFile[0] == '\0') {
3481fc08:	e59f6214 	ldr	r6, [pc, #532]	; 3481fe24 <TftpStart+0x288>
	}

	debug("TFTP blocksize = %i, timeout = %ld ms\n",
		TftpBlkSizeOption, TftpTimeoutMSecs);

	TftpRemoteIP = NetServerIP;
3481fc0c:	e59f3214 	ldr	r3, [pc, #532]	; 3481fe28 <TftpStart+0x28c>
	if (BootFile[0] == '\0') {
3481fc10:	e5d65000 	ldrb	r5, [r6]
	}

	debug("TFTP blocksize = %i, timeout = %ld ms\n",
		TftpBlkSizeOption, TftpTimeoutMSecs);

	TftpRemoteIP = NetServerIP;
3481fc14:	e59f4210 	ldr	r4, [pc, #528]	; 3481fe2c <TftpStart+0x290>
3481fc18:	e5933000 	ldr	r3, [r3]
	if (BootFile[0] == '\0') {
3481fc1c:	e3550000 	cmp	r5, #0
	}

	debug("TFTP blocksize = %i, timeout = %ld ms\n",
		TftpBlkSizeOption, TftpTimeoutMSecs);

	TftpRemoteIP = NetServerIP;
3481fc20:	e5843088 	str	r3, [r4, #136]	; 0x88
	if (BootFile[0] == '\0') {
3481fc24:	1a000013 	bne	3481fc78 <TftpStart+0xdc>
		sprintf(default_filename, "%02X%02X%02X%02X.img",
3481fc28:	e59f3200 	ldr	r3, [pc, #512]	; 3481fe30 <TftpStart+0x294>
3481fc2c:	e28400a4 	add	r0, r4, #164	; 0xa4
3481fc30:	e5933000 	ldr	r3, [r3]
3481fc34:	e59f11f8 	ldr	r1, [pc, #504]	; 3481fe34 <TftpStart+0x298>
3481fc38:	e7e72853 	ubfx	r2, r3, #16, #8
3481fc3c:	e58d2000 	str	r2, [sp]
3481fc40:	e1a02c23 	lsr	r2, r3, #24
3481fc44:	e58d2004 	str	r2, [sp, #4]
3481fc48:	e6ef2073 	uxtb	r2, r3
3481fc4c:	e7e73453 	ubfx	r3, r3, #8, #8
3481fc50:	ebffe88e 	bl	34819e90 <sprintf>
			NetOurIP & 0xFF,
			(NetOurIP >>  8) & 0xFF,
			(NetOurIP >> 16) & 0xFF,
			(NetOurIP >> 24) & 0xFF);

		strncpy(tftp_filename, default_filename, MAX_LEN);
3481fc54:	e28410a4 	add	r1, r4, #164	; 0xa4
3481fc58:	e2840004 	add	r0, r4, #4
3481fc5c:	e3a02080 	mov	r2, #128	; 0x80
3481fc60:	ebffe368 	bl	34818a08 <strncpy>
		tftp_filename[MAX_LEN-1] = 0;
3481fc64:	e5c45083 	strb	r5, [r4, #131]	; 0x83

		printf("*** Warning: no boot file name; using '%s'\n",
3481fc68:	e2841004 	add	r1, r4, #4
3481fc6c:	e59f01c4 	ldr	r0, [pc, #452]	; 3481fe38 <TftpStart+0x29c>
3481fc70:	ebffa4b5 	bl	34808f4c <printf>
3481fc74:	ea000013 	b	3481fcc8 <TftpStart+0x12c>
			tftp_filename);
	} else {
		char *p = strchr(BootFile, ':');
3481fc78:	e1a00006 	mov	r0, r6
3481fc7c:	e3a0103a 	mov	r1, #58	; 0x3a
3481fc80:	ebffe3a8 	bl	34818b28 <strchr>

		if (p == NULL) {
3481fc84:	e2505000 	subs	r5, r0, #0
3481fc88:	1a000005 	bne	3481fca4 <TftpStart+0x108>
			strncpy(tftp_filename, BootFile, MAX_LEN);
3481fc8c:	e2840004 	add	r0, r4, #4
3481fc90:	e1a01006 	mov	r1, r6
3481fc94:	e3a02080 	mov	r2, #128	; 0x80
3481fc98:	ebffe35a 	bl	34818a08 <strncpy>
			tftp_filename[MAX_LEN-1] = 0;
3481fc9c:	e5c45083 	strb	r5, [r4, #131]	; 0x83
3481fca0:	ea000008 	b	3481fcc8 <TftpStart+0x12c>
		} else {
			TftpRemoteIP = string_to_ip(BootFile);
3481fca4:	e1a00006 	mov	r0, r6
3481fca8:	ebffe2f7 	bl	3481888c <string_to_ip>
			strncpy(tftp_filename, p + 1, MAX_LEN);
3481fcac:	e2851001 	add	r1, r5, #1

		if (p == NULL) {
			strncpy(tftp_filename, BootFile, MAX_LEN);
			tftp_filename[MAX_LEN-1] = 0;
		} else {
			TftpRemoteIP = string_to_ip(BootFile);
3481fcb0:	e5840088 	str	r0, [r4, #136]	; 0x88
			strncpy(tftp_filename, p + 1, MAX_LEN);
3481fcb4:	e3a02080 	mov	r2, #128	; 0x80
3481fcb8:	e2840004 	add	r0, r4, #4
3481fcbc:	ebffe351 	bl	34818a08 <strncpy>
			tftp_filename[MAX_LEN-1] = 0;
3481fcc0:	e3a03000 	mov	r3, #0
3481fcc4:	e5c43083 	strb	r3, [r4, #131]	; 0x83
		}
	}

	printf("Using %s device\n", eth_get_name());
3481fcc8:	ebfff6ec 	bl	3481d880 <eth_get_name>
	printf("TFTP %s server %pI4; our IP address is %pI4",
3481fccc:	e59f4158 	ldr	r4, [pc, #344]	; 3481fe2c <TftpStart+0x290>
3481fcd0:	e59f5158 	ldr	r5, [pc, #344]	; 3481fe30 <TftpStart+0x294>
			strncpy(tftp_filename, p + 1, MAX_LEN);
			tftp_filename[MAX_LEN-1] = 0;
		}
	}

	printf("Using %s device\n", eth_get_name());
3481fcd4:	e1a01000 	mov	r1, r0
3481fcd8:	e59f015c 	ldr	r0, [pc, #348]	; 3481fe3c <TftpStart+0x2a0>
3481fcdc:	ebffa49a 	bl	34808f4c <printf>
	printf("TFTP %s server %pI4; our IP address is %pI4",
3481fce0:	e59f1158 	ldr	r1, [pc, #344]	; 3481fe40 <TftpStart+0x2a4>
3481fce4:	e1a03005 	mov	r3, r5
3481fce8:	e59f0154 	ldr	r0, [pc, #340]	; 3481fe44 <TftpStart+0x2a8>
3481fcec:	e2842088 	add	r2, r4, #136	; 0x88
3481fcf0:	ebffa495 	bl	34808f4c <printf>
		"from",
#endif
		&TftpRemoteIP, &NetOurIP);

	/* Check if we need to send across this subnet */
	if (NetOurGatewayIP && NetOurSubnetMask) {
3481fcf4:	e59f114c 	ldr	r1, [pc, #332]	; 3481fe48 <TftpStart+0x2ac>
3481fcf8:	e5913000 	ldr	r3, [r1]
3481fcfc:	e3530000 	cmp	r3, #0
3481fd00:	0a00000b 	beq	3481fd34 <TftpStart+0x198>
3481fd04:	e59f3140 	ldr	r3, [pc, #320]	; 3481fe4c <TftpStart+0x2b0>
3481fd08:	e5933000 	ldr	r3, [r3]
3481fd0c:	e3530000 	cmp	r3, #0
3481fd10:	0a000007 	beq	3481fd34 <TftpStart+0x198>
		IPaddr_t OurNet	= NetOurIP    & NetOurSubnetMask;
3481fd14:	e5952000 	ldr	r2, [r5]
		IPaddr_t RemoteNet	= TftpRemoteIP & NetOurSubnetMask;
3481fd18:	e5940088 	ldr	r0, [r4, #136]	; 0x88
#endif
		&TftpRemoteIP, &NetOurIP);

	/* Check if we need to send across this subnet */
	if (NetOurGatewayIP && NetOurSubnetMask) {
		IPaddr_t OurNet	= NetOurIP    & NetOurSubnetMask;
3481fd1c:	e0032002 	and	r2, r3, r2
		IPaddr_t RemoteNet	= TftpRemoteIP & NetOurSubnetMask;
3481fd20:	e0033000 	and	r3, r3, r0

		if (OurNet != RemoteNet)
3481fd24:	e1520003 	cmp	r2, r3
3481fd28:	0a000001 	beq	3481fd34 <TftpStart+0x198>
			printf("; sending through gateway %pI4",
3481fd2c:	e59f011c 	ldr	r0, [pc, #284]	; 3481fe50 <TftpStart+0x2b4>
3481fd30:	ebffa485 	bl	34808f4c <printf>
			       &NetOurGatewayIP);
	}
	putc('\n');
3481fd34:	e3a0000a 	mov	r0, #10

	printf("Filename '%s'.", tftp_filename);

	if (NetBootFileSize) {
3481fd38:	e59f4114 	ldr	r4, [pc, #276]	; 3481fe54 <TftpStart+0x2b8>

		if (OurNet != RemoteNet)
			printf("; sending through gateway %pI4",
			       &NetOurGatewayIP);
	}
	putc('\n');
3481fd3c:	ebffa46e 	bl	34808efc <putc>

	printf("Filename '%s'.", tftp_filename);
3481fd40:	e59f1110 	ldr	r1, [pc, #272]	; 3481fe58 <TftpStart+0x2bc>
3481fd44:	e59f0110 	ldr	r0, [pc, #272]	; 3481fe5c <TftpStart+0x2c0>
3481fd48:	ebffa47f 	bl	34808f4c <printf>

	if (NetBootFileSize) {
3481fd4c:	e1d410b0 	ldrh	r1, [r4]
3481fd50:	e3510000 	cmp	r1, #0
3481fd54:	0a000007 	beq	3481fd78 <TftpStart+0x1dc>
		printf(" Size is 0x%x Bytes = ", NetBootFileSize<<9);
3481fd58:	e1a01481 	lsl	r1, r1, #9
3481fd5c:	e59f00fc 	ldr	r0, [pc, #252]	; 3481fe60 <TftpStart+0x2c4>
3481fd60:	ebffa479 	bl	34808f4c <printf>
		print_size(NetBootFileSize<<9, "");
3481fd64:	e1d400b0 	ldrh	r0, [r4]
3481fd68:	e59f20f4 	ldr	r2, [pc, #244]	; 3481fe64 <TftpStart+0x2c8>
3481fd6c:	e1a00480 	lsl	r0, r0, #9
3481fd70:	e1a01fc0 	asr	r1, r0, #31
3481fd74:	ebffdcdb 	bl	348170e8 <print_size>
	}

	putc('\n');
3481fd78:	e3a0000a 	mov	r0, #10
3481fd7c:	ebffa45e 	bl	34808efc <putc>
		TftpState = STATE_SEND_WRQ;
		new_transfer();
	} else
#endif
	{
		printf("Load address: 0x%lx\n", load_addr);
3481fd80:	e59f30e0 	ldr	r3, [pc, #224]	; 3481fe68 <TftpStart+0x2cc>
3481fd84:	e59f00e0 	ldr	r0, [pc, #224]	; 3481fe6c <TftpStart+0x2d0>
3481fd88:	e5931000 	ldr	r1, [r3]
3481fd8c:	ebffa46e 	bl	34808f4c <printf>
		puts("Loading: *\b");
		TftpState = STATE_SEND_RRQ;
3481fd90:	e59f5094 	ldr	r5, [pc, #148]	; 3481fe2c <TftpStart+0x290>
	}

	TftpTimeoutCountMax = TftpRRQTimeoutCountMax;
3481fd94:	e59f407c 	ldr	r4, [pc, #124]	; 3481fe18 <TftpStart+0x27c>
		new_transfer();
	} else
#endif
	{
		printf("Load address: 0x%lx\n", load_addr);
		puts("Loading: *\b");
3481fd98:	e59f00d0 	ldr	r0, [pc, #208]	; 3481fe70 <TftpStart+0x2d4>
3481fd9c:	ebffa460 	bl	34808f24 <puts>
		TftpState = STATE_SEND_RRQ;
3481fda0:	e3a03001 	mov	r3, #1
3481fda4:	e5853000 	str	r3, [r5]
	}

	TftpTimeoutCountMax = TftpRRQTimeoutCountMax;
3481fda8:	e5943010 	ldr	r3, [r4, #16]

	NetSetTimeout(TftpTimeoutMSecs, TftpTimeout);
3481fdac:	e59f10c0 	ldr	r1, [pc, #192]	; 3481fe74 <TftpStart+0x2d8>
		printf("Load address: 0x%lx\n", load_addr);
		puts("Loading: *\b");
		TftpState = STATE_SEND_RRQ;
	}

	TftpTimeoutCountMax = TftpRRQTimeoutCountMax;
3481fdb0:	e5843008 	str	r3, [r4, #8]

	NetSetTimeout(TftpTimeoutMSecs, TftpTimeout);
3481fdb4:	e5940000 	ldr	r0, [r4]
3481fdb8:	ebfff6f2 	bl	3481d988 <NetSetTimeout>
	net_set_udp_handler(TftpHandler);
3481fdbc:	e59f00b4 	ldr	r0, [pc, #180]	; 3481fe78 <TftpStart+0x2dc>
3481fdc0:	ebfff6dc 	bl	3481d938 <net_set_udp_handler>
#ifdef CONFIG_CMD_TFTPPUT
	net_set_icmp_handler(icmp_handler);
#endif
	TftpRemotePort = WELL_KNOWN_PORT;
	TftpTimeoutCount = 0;
3481fdc4:	e3a06000 	mov	r6, #0
	NetSetTimeout(TftpTimeoutMSecs, TftpTimeout);
	net_set_udp_handler(TftpHandler);
#ifdef CONFIG_CMD_TFTPPUT
	net_set_icmp_handler(icmp_handler);
#endif
	TftpRemotePort = WELL_KNOWN_PORT;
3481fdc8:	e3a03045 	mov	r3, #69	; 0x45
3481fdcc:	e585308c 	str	r3, [r5, #140]	; 0x8c
	TftpTimeoutCount = 0;
3481fdd0:	e5856094 	str	r6, [r5, #148]	; 0x94
	/* Use a pseudo-random port unless a specific port is set */
	TftpOurPort = 1024 + (get_timer(0) % 3072);
3481fdd4:	e1a00006 	mov	r0, r6
3481fdd8:	ebff851d 	bl	34801254 <get_timer>
3481fddc:	e3a01b03 	mov	r1, #3072	; 0xc00
3481fde0:	eb0000aa 	bl	34820090 <__aeabi_uidivmod>
3481fde4:	e2811b01 	add	r1, r1, #1024	; 0x400
3481fde8:	e5851090 	str	r1, [r5, #144]	; 0x90
		TftpRemotePort = simple_strtol(ep, NULL, 10);
	ep = getenv("tftpsrcp");
	if (ep != NULL)
		TftpOurPort = simple_strtol(ep, NULL, 10);
#endif
	TftpBlock = 0;
3481fdec:	e5856084 	str	r6, [r5, #132]	; 0x84

	/* zero out server ether in case the server ip has changed */
	memset(NetServerEther, 0, 6);
3481fdf0:	e1a01006 	mov	r1, r6
3481fdf4:	e3a02006 	mov	r2, #6
3481fdf8:	e59f007c 	ldr	r0, [pc, #124]	; 3481fe7c <TftpStart+0x2e0>
3481fdfc:	ebffe3ff 	bl	34818e00 <memset>
	/* Revert TftpBlkSize to dflt */
	TftpBlkSize = TFTP_BLOCK_SIZE;
3481fe00:	e3a03c02 	mov	r3, #512	; 0x200
3481fe04:	e1c430bc 	strh	r3, [r4, #12]
	TftpTsize = 0;
	TftpNumchars = 0;
#endif

	TftpSend();
}
3481fe08:	e28dd008 	add	sp, sp, #8
3481fe0c:	e8bd4070 	pop	{r4, r5, r6, lr}
#ifdef CONFIG_TFTP_TSIZE
	TftpTsize = 0;
	TftpNumchars = 0;
#endif

	TftpSend();
3481fe10:	eafffe1f 	b	3481f694 <TftpSend>
3481fe14:	348280f6 	.word	0x348280f6
3481fe18:	34828bb4 	.word	0x34828bb4
3481fe1c:	34828104 	.word	0x34828104
3481fe20:	34828110 	.word	0x34828110
3481fe24:	3482d914 	.word	0x3482d914
3481fe28:	3482ba2c 	.word	0x3482ba2c
3481fe2c:	3482e24c 	.word	0x3482e24c
3481fe30:	3482ba04 	.word	0x3482ba04
3481fe34:	34827f2b 	.word	0x34827f2b
3481fe38:	34827f40 	.word	0x34827f40
3481fe3c:	34827f6c 	.word	0x34827f6c
3481fe40:	34828172 	.word	0x34828172
3481fe44:	34828146 	.word	0x34828146
3481fe48:	3482ba24 	.word	0x3482ba24
3481fe4c:	3482ba28 	.word	0x3482ba28
3481fe50:	34827fbc 	.word	0x34827fbc
3481fe54:	3482d908 	.word	0x3482d908
3481fe58:	3482e250 	.word	0x3482e250
3481fe5c:	34828177 	.word	0x34828177
3481fe60:	34827fee 	.word	0x34827fee
3481fe64:	34824054 	.word	0x34824054
3481fe68:	348283c4 	.word	0x348283c4
3481fe6c:	34828186 	.word	0x34828186
3481fe70:	3482801a 	.word	0x3482801a
3481fe74:	3481f834 	.word	0x3481f834
3481fe78:	3481f8ac 	.word	0x3481f8ac
3481fe7c:	3482d90c 	.word	0x3482d90c

3481fe80 <raise>:
 */

#include <common.h>

int raise (int signum)
{
3481fe80:	e1a01000 	mov	r1, r0
3481fe84:	e92d4008 	push	{r3, lr}
	/* Even if printf() is available, it's large. Punt it for SPL builds */
#if !defined(CONFIG_SPL_BUILD)
	printf("raise: Signal # %d caught\n", signum);
3481fe88:	e59f0008 	ldr	r0, [pc, #8]	; 3481fe98 <raise+0x18>
3481fe8c:	ebffa42e 	bl	34808f4c <printf>
#endif
	return 0;
}
3481fe90:	e3a00000 	mov	r0, #0
3481fe94:	e8bd8008 	pop	{r3, pc}
3481fe98:	3482819b 	.word	0x3482819b

3481fe9c <__aeabi_unwind_cpp_pr0>:

/* Dummy function to avoid linker complaints */
void __aeabi_unwind_cpp_pr0(void)
{
};
3481fe9c:	e12fff1e 	bx	lr

3481fea0 <__aeabi_unwind_cpp_pr1>:

void __aeabi_unwind_cpp_pr1(void)
{
};
3481fea0:	e12fff1e 	bx	lr

3481fea4 <__udivsi3>:
3481fea4:	e2512001 	subs	r2, r1, #1
3481fea8:	012fff1e 	bxeq	lr
3481feac:	3a000074 	bcc	34820084 <__udivsi3+0x1e0>
3481feb0:	e1500001 	cmp	r0, r1
3481feb4:	9a00006b 	bls	34820068 <__udivsi3+0x1c4>
3481feb8:	e1110002 	tst	r1, r2
3481febc:	0a00006c 	beq	34820074 <__udivsi3+0x1d0>
3481fec0:	e16f3f10 	clz	r3, r0
3481fec4:	e16f2f11 	clz	r2, r1
3481fec8:	e0423003 	sub	r3, r2, r3
3481fecc:	e273301f 	rsbs	r3, r3, #31
3481fed0:	10833083 	addne	r3, r3, r3, lsl #1
3481fed4:	e3a02000 	mov	r2, #0
3481fed8:	108ff103 	addne	pc, pc, r3, lsl #2
3481fedc:	e320f000 	nop	{0}
3481fee0:	e1500f81 	cmp	r0, r1, lsl #31
3481fee4:	e0a22002 	adc	r2, r2, r2
3481fee8:	20400f81 	subcs	r0, r0, r1, lsl #31
3481feec:	e1500f01 	cmp	r0, r1, lsl #30
3481fef0:	e0a22002 	adc	r2, r2, r2
3481fef4:	20400f01 	subcs	r0, r0, r1, lsl #30
3481fef8:	e1500e81 	cmp	r0, r1, lsl #29
3481fefc:	e0a22002 	adc	r2, r2, r2
3481ff00:	20400e81 	subcs	r0, r0, r1, lsl #29
3481ff04:	e1500e01 	cmp	r0, r1, lsl #28
3481ff08:	e0a22002 	adc	r2, r2, r2
3481ff0c:	20400e01 	subcs	r0, r0, r1, lsl #28
3481ff10:	e1500d81 	cmp	r0, r1, lsl #27
3481ff14:	e0a22002 	adc	r2, r2, r2
3481ff18:	20400d81 	subcs	r0, r0, r1, lsl #27
3481ff1c:	e1500d01 	cmp	r0, r1, lsl #26
3481ff20:	e0a22002 	adc	r2, r2, r2
3481ff24:	20400d01 	subcs	r0, r0, r1, lsl #26
3481ff28:	e1500c81 	cmp	r0, r1, lsl #25
3481ff2c:	e0a22002 	adc	r2, r2, r2
3481ff30:	20400c81 	subcs	r0, r0, r1, lsl #25
3481ff34:	e1500c01 	cmp	r0, r1, lsl #24
3481ff38:	e0a22002 	adc	r2, r2, r2
3481ff3c:	20400c01 	subcs	r0, r0, r1, lsl #24
3481ff40:	e1500b81 	cmp	r0, r1, lsl #23
3481ff44:	e0a22002 	adc	r2, r2, r2
3481ff48:	20400b81 	subcs	r0, r0, r1, lsl #23
3481ff4c:	e1500b01 	cmp	r0, r1, lsl #22
3481ff50:	e0a22002 	adc	r2, r2, r2
3481ff54:	20400b01 	subcs	r0, r0, r1, lsl #22
3481ff58:	e1500a81 	cmp	r0, r1, lsl #21
3481ff5c:	e0a22002 	adc	r2, r2, r2
3481ff60:	20400a81 	subcs	r0, r0, r1, lsl #21
3481ff64:	e1500a01 	cmp	r0, r1, lsl #20
3481ff68:	e0a22002 	adc	r2, r2, r2
3481ff6c:	20400a01 	subcs	r0, r0, r1, lsl #20
3481ff70:	e1500981 	cmp	r0, r1, lsl #19
3481ff74:	e0a22002 	adc	r2, r2, r2
3481ff78:	20400981 	subcs	r0, r0, r1, lsl #19
3481ff7c:	e1500901 	cmp	r0, r1, lsl #18
3481ff80:	e0a22002 	adc	r2, r2, r2
3481ff84:	20400901 	subcs	r0, r0, r1, lsl #18
3481ff88:	e1500881 	cmp	r0, r1, lsl #17
3481ff8c:	e0a22002 	adc	r2, r2, r2
3481ff90:	20400881 	subcs	r0, r0, r1, lsl #17
3481ff94:	e1500801 	cmp	r0, r1, lsl #16
3481ff98:	e0a22002 	adc	r2, r2, r2
3481ff9c:	20400801 	subcs	r0, r0, r1, lsl #16
3481ffa0:	e1500781 	cmp	r0, r1, lsl #15
3481ffa4:	e0a22002 	adc	r2, r2, r2
3481ffa8:	20400781 	subcs	r0, r0, r1, lsl #15
3481ffac:	e1500701 	cmp	r0, r1, lsl #14
3481ffb0:	e0a22002 	adc	r2, r2, r2
3481ffb4:	20400701 	subcs	r0, r0, r1, lsl #14
3481ffb8:	e1500681 	cmp	r0, r1, lsl #13
3481ffbc:	e0a22002 	adc	r2, r2, r2
3481ffc0:	20400681 	subcs	r0, r0, r1, lsl #13
3481ffc4:	e1500601 	cmp	r0, r1, lsl #12
3481ffc8:	e0a22002 	adc	r2, r2, r2
3481ffcc:	20400601 	subcs	r0, r0, r1, lsl #12
3481ffd0:	e1500581 	cmp	r0, r1, lsl #11
3481ffd4:	e0a22002 	adc	r2, r2, r2
3481ffd8:	20400581 	subcs	r0, r0, r1, lsl #11
3481ffdc:	e1500501 	cmp	r0, r1, lsl #10
3481ffe0:	e0a22002 	adc	r2, r2, r2
3481ffe4:	20400501 	subcs	r0, r0, r1, lsl #10
3481ffe8:	e1500481 	cmp	r0, r1, lsl #9
3481ffec:	e0a22002 	adc	r2, r2, r2
3481fff0:	20400481 	subcs	r0, r0, r1, lsl #9
3481fff4:	e1500401 	cmp	r0, r1, lsl #8
3481fff8:	e0a22002 	adc	r2, r2, r2
3481fffc:	20400401 	subcs	r0, r0, r1, lsl #8
34820000:	e1500381 	cmp	r0, r1, lsl #7
34820004:	e0a22002 	adc	r2, r2, r2
34820008:	20400381 	subcs	r0, r0, r1, lsl #7
3482000c:	e1500301 	cmp	r0, r1, lsl #6
34820010:	e0a22002 	adc	r2, r2, r2
34820014:	20400301 	subcs	r0, r0, r1, lsl #6
34820018:	e1500281 	cmp	r0, r1, lsl #5
3482001c:	e0a22002 	adc	r2, r2, r2
34820020:	20400281 	subcs	r0, r0, r1, lsl #5
34820024:	e1500201 	cmp	r0, r1, lsl #4
34820028:	e0a22002 	adc	r2, r2, r2
3482002c:	20400201 	subcs	r0, r0, r1, lsl #4
34820030:	e1500181 	cmp	r0, r1, lsl #3
34820034:	e0a22002 	adc	r2, r2, r2
34820038:	20400181 	subcs	r0, r0, r1, lsl #3
3482003c:	e1500101 	cmp	r0, r1, lsl #2
34820040:	e0a22002 	adc	r2, r2, r2
34820044:	20400101 	subcs	r0, r0, r1, lsl #2
34820048:	e1500081 	cmp	r0, r1, lsl #1
3482004c:	e0a22002 	adc	r2, r2, r2
34820050:	20400081 	subcs	r0, r0, r1, lsl #1
34820054:	e1500001 	cmp	r0, r1
34820058:	e0a22002 	adc	r2, r2, r2
3482005c:	20400001 	subcs	r0, r0, r1
34820060:	e1a00002 	mov	r0, r2
34820064:	e12fff1e 	bx	lr
34820068:	03a00001 	moveq	r0, #1
3482006c:	13a00000 	movne	r0, #0
34820070:	e12fff1e 	bx	lr
34820074:	e16f2f11 	clz	r2, r1
34820078:	e262201f 	rsb	r2, r2, #31
3482007c:	e1a00230 	lsr	r0, r0, r2
34820080:	e12fff1e 	bx	lr
34820084:	e3500000 	cmp	r0, #0
34820088:	13e00000 	mvnne	r0, #0
3482008c:	ea0000ac 	b	34820344 <__aeabi_ldiv0>

34820090 <__aeabi_uidivmod>:
34820090:	e3510000 	cmp	r1, #0
34820094:	0afffffa 	beq	34820084 <__udivsi3+0x1e0>
34820098:	e92d4003 	push	{r0, r1, lr}
3482009c:	ebffff80 	bl	3481fea4 <__udivsi3>
348200a0:	e8bd4006 	pop	{r1, r2, lr}
348200a4:	e0030092 	mul	r3, r2, r0
348200a8:	e0411003 	sub	r1, r1, r3
348200ac:	e12fff1e 	bx	lr

348200b0 <__divsi3>:
348200b0:	e3510000 	cmp	r1, #0
348200b4:	0a000081 	beq	348202c0 <.divsi3_skip_div0_test+0x208>

348200b8 <.divsi3_skip_div0_test>:
348200b8:	e020c001 	eor	ip, r0, r1
348200bc:	42611000 	rsbmi	r1, r1, #0
348200c0:	e2512001 	subs	r2, r1, #1
348200c4:	0a000070 	beq	3482028c <.divsi3_skip_div0_test+0x1d4>
348200c8:	e1b03000 	movs	r3, r0
348200cc:	42603000 	rsbmi	r3, r0, #0
348200d0:	e1530001 	cmp	r3, r1
348200d4:	9a00006f 	bls	34820298 <.divsi3_skip_div0_test+0x1e0>
348200d8:	e1110002 	tst	r1, r2
348200dc:	0a000071 	beq	348202a8 <.divsi3_skip_div0_test+0x1f0>
348200e0:	e16f2f13 	clz	r2, r3
348200e4:	e16f0f11 	clz	r0, r1
348200e8:	e0402002 	sub	r2, r0, r2
348200ec:	e272201f 	rsbs	r2, r2, #31
348200f0:	10822082 	addne	r2, r2, r2, lsl #1
348200f4:	e3a00000 	mov	r0, #0
348200f8:	108ff102 	addne	pc, pc, r2, lsl #2
348200fc:	e320f000 	nop	{0}
34820100:	e1530f81 	cmp	r3, r1, lsl #31
34820104:	e0a00000 	adc	r0, r0, r0
34820108:	20433f81 	subcs	r3, r3, r1, lsl #31
3482010c:	e1530f01 	cmp	r3, r1, lsl #30
34820110:	e0a00000 	adc	r0, r0, r0
34820114:	20433f01 	subcs	r3, r3, r1, lsl #30
34820118:	e1530e81 	cmp	r3, r1, lsl #29
3482011c:	e0a00000 	adc	r0, r0, r0
34820120:	20433e81 	subcs	r3, r3, r1, lsl #29
34820124:	e1530e01 	cmp	r3, r1, lsl #28
34820128:	e0a00000 	adc	r0, r0, r0
3482012c:	20433e01 	subcs	r3, r3, r1, lsl #28
34820130:	e1530d81 	cmp	r3, r1, lsl #27
34820134:	e0a00000 	adc	r0, r0, r0
34820138:	20433d81 	subcs	r3, r3, r1, lsl #27
3482013c:	e1530d01 	cmp	r3, r1, lsl #26
34820140:	e0a00000 	adc	r0, r0, r0
34820144:	20433d01 	subcs	r3, r3, r1, lsl #26
34820148:	e1530c81 	cmp	r3, r1, lsl #25
3482014c:	e0a00000 	adc	r0, r0, r0
34820150:	20433c81 	subcs	r3, r3, r1, lsl #25
34820154:	e1530c01 	cmp	r3, r1, lsl #24
34820158:	e0a00000 	adc	r0, r0, r0
3482015c:	20433c01 	subcs	r3, r3, r1, lsl #24
34820160:	e1530b81 	cmp	r3, r1, lsl #23
34820164:	e0a00000 	adc	r0, r0, r0
34820168:	20433b81 	subcs	r3, r3, r1, lsl #23
3482016c:	e1530b01 	cmp	r3, r1, lsl #22
34820170:	e0a00000 	adc	r0, r0, r0
34820174:	20433b01 	subcs	r3, r3, r1, lsl #22
34820178:	e1530a81 	cmp	r3, r1, lsl #21
3482017c:	e0a00000 	adc	r0, r0, r0
34820180:	20433a81 	subcs	r3, r3, r1, lsl #21
34820184:	e1530a01 	cmp	r3, r1, lsl #20
34820188:	e0a00000 	adc	r0, r0, r0
3482018c:	20433a01 	subcs	r3, r3, r1, lsl #20
34820190:	e1530981 	cmp	r3, r1, lsl #19
34820194:	e0a00000 	adc	r0, r0, r0
34820198:	20433981 	subcs	r3, r3, r1, lsl #19
3482019c:	e1530901 	cmp	r3, r1, lsl #18
348201a0:	e0a00000 	adc	r0, r0, r0
348201a4:	20433901 	subcs	r3, r3, r1, lsl #18
348201a8:	e1530881 	cmp	r3, r1, lsl #17
348201ac:	e0a00000 	adc	r0, r0, r0
348201b0:	20433881 	subcs	r3, r3, r1, lsl #17
348201b4:	e1530801 	cmp	r3, r1, lsl #16
348201b8:	e0a00000 	adc	r0, r0, r0
348201bc:	20433801 	subcs	r3, r3, r1, lsl #16
348201c0:	e1530781 	cmp	r3, r1, lsl #15
348201c4:	e0a00000 	adc	r0, r0, r0
348201c8:	20433781 	subcs	r3, r3, r1, lsl #15
348201cc:	e1530701 	cmp	r3, r1, lsl #14
348201d0:	e0a00000 	adc	r0, r0, r0
348201d4:	20433701 	subcs	r3, r3, r1, lsl #14
348201d8:	e1530681 	cmp	r3, r1, lsl #13
348201dc:	e0a00000 	adc	r0, r0, r0
348201e0:	20433681 	subcs	r3, r3, r1, lsl #13
348201e4:	e1530601 	cmp	r3, r1, lsl #12
348201e8:	e0a00000 	adc	r0, r0, r0
348201ec:	20433601 	subcs	r3, r3, r1, lsl #12
348201f0:	e1530581 	cmp	r3, r1, lsl #11
348201f4:	e0a00000 	adc	r0, r0, r0
348201f8:	20433581 	subcs	r3, r3, r1, lsl #11
348201fc:	e1530501 	cmp	r3, r1, lsl #10
34820200:	e0a00000 	adc	r0, r0, r0
34820204:	20433501 	subcs	r3, r3, r1, lsl #10
34820208:	e1530481 	cmp	r3, r1, lsl #9
3482020c:	e0a00000 	adc	r0, r0, r0
34820210:	20433481 	subcs	r3, r3, r1, lsl #9
34820214:	e1530401 	cmp	r3, r1, lsl #8
34820218:	e0a00000 	adc	r0, r0, r0
3482021c:	20433401 	subcs	r3, r3, r1, lsl #8
34820220:	e1530381 	cmp	r3, r1, lsl #7
34820224:	e0a00000 	adc	r0, r0, r0
34820228:	20433381 	subcs	r3, r3, r1, lsl #7
3482022c:	e1530301 	cmp	r3, r1, lsl #6
34820230:	e0a00000 	adc	r0, r0, r0
34820234:	20433301 	subcs	r3, r3, r1, lsl #6
34820238:	e1530281 	cmp	r3, r1, lsl #5
3482023c:	e0a00000 	adc	r0, r0, r0
34820240:	20433281 	subcs	r3, r3, r1, lsl #5
34820244:	e1530201 	cmp	r3, r1, lsl #4
34820248:	e0a00000 	adc	r0, r0, r0
3482024c:	20433201 	subcs	r3, r3, r1, lsl #4
34820250:	e1530181 	cmp	r3, r1, lsl #3
34820254:	e0a00000 	adc	r0, r0, r0
34820258:	20433181 	subcs	r3, r3, r1, lsl #3
3482025c:	e1530101 	cmp	r3, r1, lsl #2
34820260:	e0a00000 	adc	r0, r0, r0
34820264:	20433101 	subcs	r3, r3, r1, lsl #2
34820268:	e1530081 	cmp	r3, r1, lsl #1
3482026c:	e0a00000 	adc	r0, r0, r0
34820270:	20433081 	subcs	r3, r3, r1, lsl #1
34820274:	e1530001 	cmp	r3, r1
34820278:	e0a00000 	adc	r0, r0, r0
3482027c:	20433001 	subcs	r3, r3, r1
34820280:	e35c0000 	cmp	ip, #0
34820284:	42600000 	rsbmi	r0, r0, #0
34820288:	e12fff1e 	bx	lr
3482028c:	e13c0000 	teq	ip, r0
34820290:	42600000 	rsbmi	r0, r0, #0
34820294:	e12fff1e 	bx	lr
34820298:	33a00000 	movcc	r0, #0
3482029c:	01a00fcc 	asreq	r0, ip, #31
348202a0:	03800001 	orreq	r0, r0, #1
348202a4:	e12fff1e 	bx	lr
348202a8:	e16f2f11 	clz	r2, r1
348202ac:	e262201f 	rsb	r2, r2, #31
348202b0:	e35c0000 	cmp	ip, #0
348202b4:	e1a00233 	lsr	r0, r3, r2
348202b8:	42600000 	rsbmi	r0, r0, #0
348202bc:	e12fff1e 	bx	lr
348202c0:	e3500000 	cmp	r0, #0
348202c4:	c3e00102 	mvngt	r0, #-2147483648	; 0x80000000
348202c8:	b3a00102 	movlt	r0, #-2147483648	; 0x80000000
348202cc:	ea00001c 	b	34820344 <__aeabi_ldiv0>

348202d0 <__aeabi_idivmod>:
348202d0:	e3510000 	cmp	r1, #0
348202d4:	0afffff9 	beq	348202c0 <.divsi3_skip_div0_test+0x208>
348202d8:	e92d4003 	push	{r0, r1, lr}
348202dc:	ebffff75 	bl	348200b8 <.divsi3_skip_div0_test>
348202e0:	e8bd4006 	pop	{r1, r2, lr}
348202e4:	e0030092 	mul	r3, r2, r0
348202e8:	e0411003 	sub	r1, r1, r3
348202ec:	e12fff1e 	bx	lr

348202f0 <__lshrdi3>:
348202f0:	e2523020 	subs	r3, r2, #32
348202f4:	e262c020 	rsb	ip, r2, #32
348202f8:	41a00230 	lsrmi	r0, r0, r2
348202fc:	51a00331 	lsrpl	r0, r1, r3
34820300:	41800c11 	orrmi	r0, r0, r1, lsl ip
34820304:	e1a01231 	lsr	r1, r1, r2
34820308:	e12fff1e 	bx	lr

3482030c <__ashrdi3>:
3482030c:	e2523020 	subs	r3, r2, #32
34820310:	e262c020 	rsb	ip, r2, #32
34820314:	41a00230 	lsrmi	r0, r0, r2
34820318:	51a00351 	asrpl	r0, r1, r3
3482031c:	41800c11 	orrmi	r0, r0, r1, lsl ip
34820320:	e1a01251 	asr	r1, r1, r2
34820324:	e12fff1e 	bx	lr

34820328 <__ashldi3>:
34820328:	e2523020 	subs	r3, r2, #32
3482032c:	e262c020 	rsb	ip, r2, #32
34820330:	41a01211 	lslmi	r1, r1, r2
34820334:	51a01310 	lslpl	r1, r0, r3
34820338:	41811c30 	orrmi	r1, r1, r0, lsr ip
3482033c:	e1a00210 	lsl	r0, r0, r2
34820340:	e12fff1e 	bx	lr

34820344 <__aeabi_ldiv0>:
34820344:	e92d4002 	push	{r1, lr}
34820348:	e3a00008 	mov	r0, #8
3482034c:	ebfffecb 	bl	3481fe80 <raise>
34820350:	e8bd8002 	pop	{r1, pc}
